---
title: 정보처리기사) 실기 개념 정리
toc: true
toc_sticky: true
toc_label: 목차
published: true
categories:
    - Certificate
tags:
    - Certificate
    - study
---

* 최근 미뤄뒀던 정보처리기사 실기를 준비하며... 꼭 외워야 하는 내용 정리 🥲<br><br>

# 결합도(Coupling)
* 모듈과 모듈 사이의 관련성이 어느 정도인가를 나타내며, 관련성이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 작아진다. 자료 결합도가 제일 낮고 내용 결합도가 가장 높다.
* 자료 결합도의 품질이 가장 높고 내용 결합도의 품질이 가장 낮다.
* `자스제외공내`

* `자료 결합도(Data Coupling)` : 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 상호 작용이 일어난다.
* `스탬프 결합도(Stamp Coupling)` : 모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우
* `제어 결합도(Control Coupling)` : 단순 처리할 대상인 값만 전달하는 것이 아니라 어떻게 처리해야 한다는 제어요소가 전달되는 경우
* `외부 결합도(External Coupling)` : 모듈에서 외부로 선언한 데이터(변수)를 다른 모듈에서 참조할 때의 경우로 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 때 주로 발생
* `공통 결합도(Common Coupling)` : 파라미터가 아닌 모듈 밖에 선언되어 있는 전역변수를 참조하고 전역변수를 갱신하는 식으로 상호 작용하는 경우
* `내용 결합도(Content Coupling)` : 다른 모듈 내부에 있는 변수나 기능을 또 다른 모듈에서 사용하는 경우<br><br>

# 응집도(Cohension)
* 모듈 내부의 구성요소 간 관계의 밀접 정도로 평가되며, 응집도가 높을수록 필요한 요소들로 구성되고 낮을수록 요소들 간의 관련성이 적은 요소들로 구성된다.
* 기능적 응집도의 품질이 가장 높고 우연적 응집도의 품질이 가장 낮다.
* `기순통절시논우`

* `기능적 응집도(Functional Cohension)` : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행된다.
* `순차적 응집도(Sequential Cohension)` : 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용하는 경우
* `통신적 응집도(Communication Cohension)` : 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우
* `절차적 응집도(Procedural Cohension)` : 모듈이 다수의 관련 기능을 가질 때, 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행하는 경우
* `시간적 응집도(Temporal Cohension)` : 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리하는 경우
* `논리적 응집도(Logical Cohension)` : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
* `우연적 응집도(Coincidential Cohension)` : 모듈 내부의 각 구성 요소들이 연관이 없는 경우<br><br>
 
# 소프트웨어 아키텍처 패턴
* 소프트웨어 설계 시 참조 가능한 솔루션
* 일반적으로 발생하는 문제점들에 대해 일반화되고 재사용 가능한 솔루션<br><br>

# 요구공학
* 요구사항을 도출, 분석, 명세, 확인하는 구조화된 활동<br><br>

## 요구사항 분석 기법
* `자료 흐름 지향 분석` : 데이터 흐름도(DFD)와 자료 사전(DD)을 통해 분석
* `객체지향 분석` : 시스템 기능과 데이터를 함께 분석해 UML로 표준화

## 요구공학 프로세스
1. `개발 단계(CMM Level 3)` : 요구사항 분석
2. `관리 단계 (CMM Levle 2)` : 설계 - 개발 - 테스트를 거치는 동안 요구사항 잘 만족하는지 확인

## 요구공학 개발 단계 구성 (CMM Level 3)
1. `도출` : 이해관계자 식별, 고객 분석
2. `분석` : 분류 -> 개념 모델링 생성 -> 할당 -> 협상 -> 분석
3. `명세` : 정형화된 형태로 명세 작성
4. `확인` : 요구사항 이해를 확인하고 문서가 완전한지 검증

## 요구사항 도출 기법
* `인터뷰` : 직접 대화
* `브레인스토밍` : 말하기 쉬운 분위기 속에서 비판없이 의견을 수용
* `델파이 기법` : 전문가 경험 활용
* `롤 플레잉` : 각자 맡은 역을 연기
* `워크숍` : 단기간 집중하여 정보 획득 후 공유(사전 준비 필요)
* `설문 조사`

## 요구사항 분석 단계
1. `요구사항 분류` : 기능적 요구사항 (시스템이 제공해야 할 기능) vs 비기능적 요구사항(시스템이 준수해야 할 제약사항)
2. `개념 모델링 생성` : 주로 UML 사용. 요구사항을 쉽게 이해할 수 있도록 개념적 표현
3. `요구사항 할당` : 요구사항 만족을 위한 아키텍처 구성요소 식별
4. `요구사항 협상` : 충돌되는 경우 합의, 우선순위 부여
5. `정형 분석` : 정형화된 언어를 통해 수학적 기호로 표현

## 요구사항 명세 기법
1. `비정형 명세 기법` : 자연어 기반 서술
2. `정형 명세 기법` : 수학적 표기법으로 서술

## 요구사항 명세 원리 및 검증 항목
1. `명확성` : 각 명세 내용은 하나의 의미만 부여
2. `완전성` : 모든 요구사항이 포함되어야 함
3. `검증 가능성` : 달성 정도를 확인할 수 있어야 함
4. `일관성` : 모순이 없어야 함
5. `수정 용이성` : 쉽게 수정할 수 있어야 함
6. `개발 후 이용성` : 운영 및 유지보수에 이용이 가능해야 함
7. `추적 가능성` : 추적이 가능해야 함

## 요구사항 확인 기법
1. 정형 기술 검토(TCR)
2. 프로토타이핑 활용
3. 테스트 케이스를 통한 확인
4. CASE 도구 활용
5. 베이스라인 검증
6. 요구사항 추적표 (RTM : Requirement Tracebility Matrix) 통해 검증
    * 요구사항 정의서 기준으로 개발단계별 최종 산출물이 어떻게 변경되었는지 확인 가능한 문서

## 정형 기술 검토 (TCR) 기법
* `동료 검토 (Peer Review)` : 작성자가 설명하고, 이해 관계자들이 설명을 들으며 결함 발견
* `워크 스루 (Walk Through)` : 검토 자료 사전 배포 후, 짧은 시간 동안 회의 진행
* `인스펙션 (Inspection)` : 저작자가 아닌 다른 전문가가 검토
* 참가자 구성
    * `주재자(Moderator)` : 참가자를 선정하고 계획 및 주재
    * `작성자`
    * `낭독자`
    * `기록자`
    * `검토자`
* `관리 리뷰 (Management Review)` : 프로젝트 진행 상황을 전반적으로 검토
* `기술 리뷰 (Technical Review)` : 명세를 준수하고 있는지 검토
* `감사 (Audit)` : 제품이 표준이나 가이드라인을 준수하는지 검토. 제품 제공자, 소비자, 제 3기관이 수행

## 요구공학 관리 단계 구성(CMM Level 2)
1. `협상` : 구현 가능한 기능 협상
2. `기준선 설정` : 기준선(베이스라인) 설정
    * `베이스라인` : 개발 과정의 산출물의 변화를 통제하는 시점
3. `변경관리` : 형상통제 위원회를 운영하여 변경 관리
    * `CCB` : 형상 관리의 방침을 정하고 산출물을 검토하는 조직
4. `확인 및 검증` : 요구사항에 부합하는지 확인<br><br>

# 미들웨어
* 컴퓨터와 컴퓨터 간 연결 및 연결 관리를 돕는 소프트웨어
* Weblogic, Jeus, Tomcat 등<br><br>

# 네트워크
* 원하는 정보를 수신자에게 정확하게 전달하기 위한 인프라<br><br>

# OSI 7계층
* 네트워크 통신에서 충돌 문제를 최소화하고자, 국제표준화기구(ISO)에서 제시한 네트워크 통신 규약
* `물데네트세표응`!

## 물리 계층
* 데이터를 전기적인 신호로 변환시켜 통신
1. `단위` : 비트
2. `프로토콜` : RS-232C
3. `장비` : 허브, 리피터

### 물리 계층 장비
* `허브` : 여러 대의 컴퓨터를 연결해 네트워크로 보내거나, 하나의 네트워크로 수신된 정보를 여러 대의 컴퓨터로 보내는 장비
* `리피터` : 디지털 신호를 증폭시키는 장비<br><br>

## 데이터링크 계층
* 노드 간 오류 제어, 흐름 제어, 회선 제어
1. `단위` : 프레임
2. `장비` : L2 스위치, 브릿지, NIC, 스위칭 허브
3. `프로토콜` : HDLC, PPP, Frame Relay, ATM

### 데이터링크 계층 장비
* `L2 스위치` : 목적지 MAC 주소를 기반으로 빠르게 데이터를 전송하는 장비
    1. `Store and Forwarding` : 데이터를 전부 받은 후 처리
    2. `Cut Through` : 목적지 주소만 확인 후 바로 전송
    3. `Fragment Frame` : 앞 64비트만 읽어 에러 처리 후 전송
* `브릿지` : LAN과 LAN을 연결하는 장비
* `NIC` : 네트워크 인터페이스 카드. 외부 네트워크와 빠른 통신을 위해 컴퓨터 내에 설치되는 장비
* `스위칭 허브` : 스위치 기능을 가진 허브

### 데이터링크 계층 프로토콜
* `HDLC` : 점대점, 다중점 통신에 사용하는 프로토콜
* `PPP` : 통신 노드 간 연결을 위한 프로토콜
* `Frame Relay` : 프레임 간 중계기능, 다중화 기능을 통해 빠른 데이터 전송이 가능한 고속 전송 기술
* `ATM` : 고정 크기 단위로 전송하는 비동기식 전송 기술<br><br>

## 네트워크 계층
* 데이터 전송을 위한 최적의 경로 설정
1. `단위` : 패킷
2. `장비` : L3 스위치, 라우터, 게이트웨이, 인터넷 공유기, 망(백본) 스위칭 허브
3. `프로토콜` : IP, 라우팅 프로토콜, ARP, RARP, ICMP, IGMP

### 네트워크 계층 장비
* `L3 스위치` : 3계층에서 동작하는 스위치 (L2 스위치 기능 + L3 라우터 기능을 모두 갖춘 장비)
* `라우터` : 최적의 경로를 지정하고 경로에 따라 전송시키는 장비
* `게이트웨이` : 다른 통신망에 접속할 수 있게 해주는 장비
* `인터넷 공유기` : 하나의 인터넷 라인을 여러 컴퓨터가 공유할 수 있게 해주는 장비
* `망(백본) 스위칭 허브` : 광역 네트워크를 커버하는 스위칭 허브

### 네트워크 계층 프로토콜
* `IP` : 패킷 단위의 네트워크 통신 프로토콜
* `라우팅 프로토콜` : 최적의 데이터 전송 경로를 설정하는 프로토콜
* `ARP` : IP주소(3계층)를 MAC 주소(2계층)으로 변환하는 프로토콜
* `RARP` : MAC 주소는 알지만 IP 주소를 모를 때 사용하는 프로토콜
* `ICMP` : IP 패킷 처리 시의 문제를 알려주는 프로토콜
* `IGMP` : 멀티캐스트 실시간 전송을 위해 사용하는 프로토콜(화상회의 등)
* `IPSec` : 네트워크 계층에서 사용하는 보안 프로토콜. 인증 헤더 + 암호화를 이용. MAC + 암호화를 통해 인증 + 기밀성 제공<br><br>

## 전송계층(Transport)
* 종단 간 신뢰성있고 효율적으로 데이터 전송
1. `단위` : 세그먼트
2. `장비` : L4 스위치
3. `프로토콜` : TCP, UDP

### 전송계층 장비
* `L4 스위치` : OSI 4계층에서 네트워크 단위를 연결하는 장비. TCP/UDP 등 스위칭 수행

### 전송계층 프로토콜
* `TCP`
    1. `신뢰성 보장` : 패킷 손실, 중복이 없도록 보장 (IP 계층 보완)
    2. `연결지향적` : 연결 회선을 통해 통신이 이뤄짐
    3. `흐름제어` : 송신-수신 속도 일치시킴
    4. `혼잡제어` : 네트워크 혼잡도에 따라 송신율 제어
* `TCP 헤더 구조`
    1. `Source Port Number`
    2. `Destination Port Number`
    3. `Sequence Number` : 신뢰성과 흐름 담당
    4. `Acknowledgement Number` : 승인 번호(수신을 기대하는 다음 번호)
    5. `HLEN` : 헤더 길이
    6. `Flag Bit` : 값 유효 여부 등을 표시하는 플래그
    7. `Window Size`
    8. `Checksum` : 에러 확인
    9. `Urgent Pointer` : 시퀀스 번호로부터의 옵셋
    10. `Options and Padding`
* `UDP`
    1. `비신뢰성` : 메시지의 도착을 보장하지 않음
    2. `비순서화` : 수신된 메시지 순서 맞추지 않음
    3. 실시간 응용 및 멀티캐스팅 가능
    4. 단순 헤더 (고정 크기 헤더)
* `UDP 헤더 구조`
    1. `Source Port Number`
    2. `Destination Port Number`
    3. `UDP Length`
    4. `UDP Checksum`
    5. `Data`<br><br>
    
## 세션계층 (Session)
* 송수신간(단말기 사이) 연결을 제어
1. `단위` : 데이터
2. `프로토콜` : RPC, NetBIOS, SSH, SSL/TLS

### 세션계층 프로토콜
* `RPC` : 원격 프로시저 호출. 다른 주소 공간에 있는 프로세스 실행 가능
* `NetBIOS` : 응용계층의 애플리케이션에 API 제공
* `SSH` : 보안 쉘. 원격 호스트에 접근하기 위한 프로토콜
* `SSL/TLS` : 안전한 데이터 전송을 위한 보안 프로토콜 (4계층(응용) - 7계층(전송) 사이에서 안전한 데이터 전송을 보장)<br><br>

## 표현계층 (Presentaion)
* 응용프로그램의 데이터를 통신에 알맞은 형태로 만들거나, 하위 계층의 데이터를 사용자가 이해할 수 있는 형태로 만드는 계층
1. `단위` : 데이터
2. `프로토콜` : JPEG, MPEG

### 표현계층 프로토콜
* `JPEG` : 이미지를 위한 표준 규격
* `MPEG` : 멀티미디어를 위한 표준 규격<br><br>

## 응용계층 (Application)
* 사용자가 OSI 환경에 접근할 수 있도록 서비스(인터페이스)를 제공하는 계층
1. `단위` : 데이터
2. `프로토콜` : HTTP, FTP, SMTP, POP3, IMAP, Telnet

### 응용계층 프로토콜
* `HTTP` : 인터넷에서 데이터를 주고받기 위한 텍스트 기반의 프로토콜
* `FTP` : 서버-클라이언트 간 파일 전송을 위한 프로토콜
* `SMTP` : 이메일을 보내기 위한 프로토콜
* `POP3` : 이메일을 가져오기 위한 프로토콜 (로컬 PC에 저장 후 불러옴)
* `IMAP` : 이메일을 가져오기 위한 프로토콜 (메일 서버에서 불러옴)
* `Telnet` : 네트워크 연결에 사용하는 응용계층의 프로토콜<br><br>

# OS
* 컴퓨터의 하드웨어를 사용자가 쉽게 사용할 수 있도록 인터페이스를 담당하는 소프트웨어

## OS 현행 시스템 분석
1. `품질 측면` : 신뢰도, 성능
2. `지원 측면` : 기술 지원, 주변 기기, 구축 비용<br><br>

# 디자인 패턴
* 소프트웨어 설계 시 자주 쓰이는 방법을 정리한 패턴으로, 참고 시 개발 효율성이 높아진다.

## 디자인 패턴 구성요소
1. 패턴 이름
2. 문제 및 배경
3. 솔루션
4. 사례
5. 결과
6. 샘플코드
    * `라이브러리 구성` : 도움말, 설치파일, 샘플코드
    
## 디자인 패턴 유형
1. `생성(5)` : 객체의 생성방식을 결정하는 패턴
2. `구조(7)` : 객체를 조직화하는데 유용한 패턴
3. `행위(11)` : 객체의 행위를 조직, 관리, 연합하는데 사용하는 패턴

### 디자인 패턴 - 생성 패턴
1. `팩토리 메소드(Factory Method)` : 상위 클래스에서 인터페이스 정의, 서브 클래스가 실제 생성
2. `프로토타입(Prototype)` : 원형 객체를 복사하여 생성 (객체 생성 시 갖춰야 할 기본 형태가 있을 때 사용)
3. `빌더(Builder)` : 객체를 조립하여 생성. 생성 방법과 구현 방법을 구분하여, 동일한 객체 생성이여도 다른 결과가 나올 수 있음)
4. `싱글톤(Singletone)` : 클래스 내 객체가 하나 뿐임을 보장. 하나의 객체를 생성해 어디든 참조할 수 있으나 동시 참조 불가
5. `추상 팩토리(Abstract Factory)` : 구체적인 클래스에 의존하지 않고, 연관된 객체들의 그룹으로 생성 (객체 간 결합이 느슨해짐)

### 디자인 패턴 - 구조 패턴
1. `퍼싸드(Facade)` : 복잡한 시스템에 단순한 인터페이스를 제공해 접근성을 높인 패턴
2. `플라이웨이트(Flyweight)` : 객체가 필요할 때 생성하는 대신 공유하여 메모리 절약
3. `컴포지트(Composite)` : 객체 관계를 파일 트리 구조로 구성하여, 복합 객체와 단일 객체를 동일하게 취급
4. `프록시(Proxy)` : 실제 기능을 수행하는 객체(Real object) 대신 가상의 객체(Proxy object)를 사용해 로직의 흐름을 제어하는 디자인 패턴
5. `브리지(Bridge)` : 구현부에서 추상층을 분리하여 결합도를 낮춘 패턴
6. `어댑터(Adapter)` : 호환성 없는 클래스의 인터페이스를 이용할 수 있게 변환
7. `데코레이터(Decorator)` : 객체 결합을 통해 기능을 확장

### 디자인 패턴 - 행위 패턴
1. `중재자(Mediator)` : 객체 사이에 중재자를 두어 의존성을 줄이는 패턴
2. `인터프리터(Interpreter)` : 여러 언어 구문을 해석할 수 있게 해주는 패턴
3. `템플릿 메소드(Template Method)` : 상위 클래스에서 기능을 정의하고, 하위 클래스에서 세부 처리 방법을 구체화하는 패턴
4. `옵저버(Observer)` : 객체를 지켜보고 있다가, 객체의 상태가 변하면 그 객체에 의존하는 다른 객체들에게 변화된 상태를 전달
5. `커맨드(Command)` : 요청을 객체로 캡슐화하여, 각 요청(명령)이 들어오면 그에 맞는 서브 클래스 실행
6. `비지터(Visitor)` : 처리 기능을 별도로 분리한 패턴 (분리된 처리 기능은 클래스를 방문하여 수행)
7. `반복자(Iterator)` : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 (내부 노출 없이 순차적 접근 가능)
8. `상태(State)` : 객체의 상태를 캡슐화하고, 이를 참조해 동작을 다르게 처리
9. `전략(Strategy)` : 동일한 계열의 알고리즘을 캡슐화하고, 전략을 선택해 사용
10. `책임 연쇄(Chain of Responsibility)` : 한 객체가 요청을 처리하지 못하면, 연결된 객체로 넘어가 처리
11. `메멘토(Memento)` : 특정 시점의 객체 내부 상태를 객체화하여, 해당 시점으로 되돌리는 기능을 제공<br><br>

# 소프트웨어 아키텍처
* 소프트웨어 구성요소와, 구성요소의 특성, 구성요소 간 관계를 표현하는 구조

## 현행 시스템 파악
1. 구성 현황 / 기능 현황 / 인터페이스 파악
2. 아키텍처, 소프트웨어 구성 파악
3. 하드웨어, 네트워크 구성 파악

## 소프트웨어 4+1 뷰
* 요구사항을 4개의 관점에서 바라보는 방법. 4개 구조가 충돌되지 않는지, 요구사항을 충족하는지 증명하기 위해 유스케이스 사용
    * `프로세스 뷰` : 비기능적인 속성으로 자원 사용 등을 표현한 뷰
    * `유스케이스 뷰` : 유스케이스를 도출하고 다른 뷰를 검증하는 뷰
    * `배치 뷰` : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 보여주는 뷰
    * `논리 뷰` : 기능적인 요구사항이 어떻게 제공되는지 표현한 뷰
    * `구조 뷰` : 소프트웨어 모듈의 구성을 보여주는 뷰
    
## 소프트웨어 아키텍처 패턴 종류
1. `계층화 패턴` : 시스템을 계층으로 구분 (ex. `OSI 7계층` : 서로 마주보는 계층에서만 상호작용 발생)
2. `클라이언트-서버 패턴` : 하나의 서버 + 다수의 클라이언트 -> 사용자는 클라이언트와만 상호작용
3. `파이프-필터 패턴` : 데이터 스트림을 처리하는 시스템에서 사용 (ex. `Unix의 Shell` : 하나의 서브시스템이 데이터를 받아 처리하고, 결과를 다음 서브 시스템에게 넘겨줌)
4. `브로커 패턴` : 사용자가 요청하면, 브로커가 적합한 컴포넌트를 연결하는 방식. 원격 서비스 호출에 응답하는 컴포넌트가 여럿일 때 적합
5. `모델-뷰-컨트롤러 패턴` : 3개의 서브시스템으로 구조화한 패턴
    * `모델` : 핵심 기능과 데이터 보관
    * `뷰` : 사용자에게 정보 표시
    * `컨트롤러` : 사용자의 입력 처리 - 하나의 모델에 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합

## 소프트웨어 아키텍처 비용 평가 모델
1. `SAAM` : 변경 용이성과 기능성에 집중. 경험없어도 쉽게 사용 가능
2. `ATAM` : `SAAM`을 계승. 아키텍처 품질 속성을 만족하는지도 평가
3. `CBAM` : `ATAM`에 경제성 평가 보장
4. `ADR` : 아키텍처 구성요소 간 응집도 평가
5. `ARID` : `ATAM + ADR`. 전체가 아닌 특정 부분에 대한 비용 평가<br><br>

# SDLC (소프트웨어 생명주기)
* 시스템의 요구분석 ~ 유지보수까지 전 과정을 모델링한 것

## SDLC 모델 종류
1. `폭포수 모델(Waterfall model)` : 선형 순차적 모델. 고전적 생명주기 모델. 각 개발 단계를 마무리 지은 후 넘어가는 모델로 가장 오래됐고, 성공사례가 많으며, 단계별 산출물이 명확하고 요구사항 변경이 어려움
2. `프로토타이핑 모델(Prototyping model)` : 주요 기능을 프로토타입으로 구현하고, 피드백을 반영해 만들어나가는 모델
3. `나선형 모델(Spiral model)` : 위험을 최소화하기 위해 점진적으로 개발해나가는 모델
    * `절차` : 계획 및 정의 - 위험 분석 - 개발 - 고객 평가
4. `반복적 모델(Iteration model)` : 병렬적으로 개발 후 통합하거나, 반복적으로 개발해 점차 완성시켜나가는 모델

## SDLC 모델 프로세스
1. `요구사항 분석` : 요구사항을 분석하고, 제약조건, 목표 등을 정의
2. `설계` : 수행 방법을 논리적으로 결정 (ex. 시스템 구조 설계, 사용자 인터페이스 설계)
3. `구현` : 프로그래밍 언어를 사용해 실제로 코드를 작성 (ex. 인터페이스 개발, 자료 구조 개발, 오류 처리)
4. `테스트` (ex. 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트)
5. `유지보수`<br><br>

# 소프트웨어 개발 방법론
* 소프트웨어의 개발 시작부터 전 개발 과정을 형상화한 방법론

## 소프트웨어 개발 방법론 종류
1. `구조적 방법론` : 전체 시스템을 나눠 개발하고 통합하는 분할-정복 방식의 방법론. 나씨-슈나이더만 차트 사용
2. `정보공학 방법론` : 정보 시스템 개발에 필요한 절차를 체계화한 방법론 (대형 프로젝트)
3. `객체지향 방법론` : 객체라는 단위로 시스템을 설계하는 방법론
4. `컴포넌트 기반 방법론` : 컴포넌트를 조립해 작성하는 방법론
5. `애자일 방법론` : 절차보다 사람이 우선되는, 변화에 유연한 경량 개발 방법론
6. `제품 개발 방법론` : 제품에 적용할 공통 기능을 정의하여 개발하는 방법론 (임베디드 소프트웨어 작성에 유용)<br><br>

# XP
* 1-3주의 반복 주기를 갖는 애자일 방법론

## XP의 5가지 가치
1. `용기` : 용기를 갖고 빠르게 개발
2. `단순성` : 필요한 것만 하자
3. `의사소통` : 개발자-관리자-고객 간 원활하게 소통
4. `피드백` : 의사소통에 대한 빠른 피드백
5. `존중` : 팀원간 상호 존중

## XP의 12가지 기본 원리
1. `짝 프로그래밍 (Pair Programming)` : 다른 사람과 페어로 개발하여 공동 책임을 지님
2. `공동 코드 소유 (Collective Ownership)` : 시스템에 있는 코드는 누구나 언제든 수정 가능
3. `지속적인 통합 (CI ; Continuos Integration)` : 여러 번 소프트웨어를 통합하고 빌드해야 함
4. `계획 세우기 (Planning Process)` : 고객이 원하는 가치를 정의하고, 개발에 필요한 것은 무엇이며, 어떤 곳에서 지연이 될 수 있는지 알려줘야 함
5. `작은 릴리즈 (Small Release)` : 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트
6. `메타포어 (Metaphor)` : 공통 이름 체계를 통해 의사소통을 원활히
7. `간단한 디자인 (Simple Release)` : 요구사항에 적합한 단순한 시스템을 설계
8. `테스트 기반 개발 (TDD ; Test Drive Develop)` : 테스트를 먼저 수행하고, 통과할 수 있는 코드를 작성
9. `리팩토링 (Refactoring)` : 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 코드를 재구성
10. `40시간 작업 (40-Hour Work)` : 피곤으로 인한 실수가 없도록 주 40시간만 일하자
11. `고객 상주 (On Site Customer)` : 개발자들의 질문에 즉각 대답해줄 수 있는 고객이 풀타임 상주해야 함
12. `코드 표준 (Coding Standard)` : 코딩 표준을 두고 효과적으로 개발<br><br>

# 린
* 낭비 요소를 제거해 품질을 향상시키는 애자일 방법론

## 린의 7가지 원칙
1. 낭비제거
2. 품질 내재화
3. 지식 창출
4. 늦은 확정
5. 빠른 인도
6. 사람 존중
7. 전체 최적화<br><br>

# 스크럼
* 매일 정해진 시간 / 장소에서 짧은 시간의 개발을 위한 애자일 방법론

## 스크럼 용어
* `백로그` : 제품에 대한 요구사항
* `스프린트` : 짧은 기간 내 반복적으로 개발
* `데일리(스크럼) 미팅` : 매일 To-Do List 계획 수립. 번다운 차트 작성
* `스크럼 마스터` : 프로젝트 리더
* `스프린트 회고` : 각자 반성하고 개선점 확인
* `번 다운 차트` : 남아있는 백로그 대비 시간을 시각적으로 표현 (백로그를 수직, 시간을 수평)<br><br>

# 비용산정 모델
* 소프트웨어 개발 계획을 수립하기 위해 투입될 자원이나 시간을 산정하는 방식
    * `하향식` : 전문가가 산정 (ex. 델파이 기법)
    * `상향식` : 요구사항과 기능에 따라 산정 (ex. LoC, Man Month, COCOMO, 푸트남, FP)
    
## 비용산정 모델 종류
* `LoC(Lines of Codes) 모형` : 코드 라인 수의 예측치를 구하여 비용 산정
    * `산정방법` : (낙관치 + 중관치 x 4 + 비관치) / 6
* `COCOMO 모형` : 프로그램 규모에 따라 비용을 산정
    1. `조직형 / 단순형 (Organic)` : 소규모 5만 라인 (5KSDI) 이하
    2. `반 분리형 (Semi-Detached)` : 중간형 30만 라인 (30KSDI) 이하
    3. `임베디드형 (Embedded)` : 초대형
* `Man Month 모형` : 한 사람이 1개월 간 할 수 있는 일의 양을 기준으로 비용 산정
    * `Man Month = LoC / 개발자의 월간 생산성`
    * `프로젝트 기간 = Man Month / 프로젝트 인력`
* `푸트남(Putnam) 모형` : 생명주기 단계별 인력분포를 예측하는 방식 (시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선 분포도 기초)
* `FP(기능점수) 모형` : 요구 기능별로 가중치를 부여해 총 점수를 계산해 비용 산정<br><br>

# 일정 관리 모델
1. `CPM(주 공정법)` : 여러 작업의 수행 순서가 얽힌 프로젝트에서 일정을 계산하는 기법
    * `임계 경로(Critical Path) 계산법` : 가장 긴 경로 계산
2. `CCPM(중요 연쇄 공정법)` : 주 공정법의 연쇄법으로, 자원 제약사항을 고려해 계산
3. `PERT` : 낙관치, 중관치, 비관치의 3점 추정방식으로 일정 관리<br><br>

# UI
* 사용자와 시스템 사이의 매개체

## UI 유형
1. `CLI` : 텍스트(명령어) 기반
2. `GUI` : 그래픽 기반(마우스, 펜)
3. `NUI` : 신체 부위 이용(터치, 음성)
4. `OUI` : 유기적 상호작용 기반 인터페이스(모든 사물이 입출력장치로 변화)

## UI 설계 원칙
1. `직관성` : 누구나 쉽게 이해하고 쉽게 사용할 수 있어야 함
2. `유효성` : 사용자 목표가 달성될 수 있어야 함
3. `학습성` : 쉽게 배울 수 있어야 함
4. `유연성` : 인터렉션을 최대한 포용해야 함

## UI 설계 지침
1. `사용자 중심` : 사용자가 이해하기 쉽게 설계
2. `일관성` : 조작법을 빨리 이해할 수 있도록 일관적으로 설계해야 함
3. `단순성`
4. `결과 예측 가능`
5. `명확성` : 개념적으로 인지하기 쉬워야 함
6. `표준화` : 디자인 표준으로 선행학습 이후 쉽게 사용할 수 있어야 함
7. `오류 발생 해결` : 오류 상황을 인지할 수 있어야 함
8. `접근성` : 연령, 성별 등 다양한 계층을 수용해야 함
9. `가시성` : 주요 기능은 메인 화면에 노출해야 함

## UI 시나리오 문서 작성 요건
1. `완전성` : 누락 없이 최대한 상세하게 작성
2. `일관성` : 요구사항은 일관적이어야 함. UI도 일관적으로 작성
3. `이해성` : 이해하기 쉬워야 함
4. `가독성` : 쉽게 읽혀야 함
5. `추적 용이성` : 변경사항을 알아보기 쉬워야 함
6. `수정 용이성` : 쉽게 수정할 수 있어야 함

## UI 설계 도구
1. `화면 설계 도구` : 파워 목업, 발사믹 목업, 카카오 오븐
2. `프로토타이핑 도구` : UX핀, 액슈어(디스크립션까지 작성 가능), 네이버 프로토나우
3. `UI 디자인 산출물로 작업하는 프로토타이핑 도구` : 인비전, 픽사에이트, 프레이머

## UI 품질 요구사항 (ISO/IEC 9126 기반)
1. `이식성` : 다른 환경에도 잘 적응하는가?
    * `적용성` : 다른 환경에도 잘 적용되고
    * `설치성` : 잘 설치되며
    * `대체성` : 다른 SW를 대체할 수 있는지
2. `신뢰성` : 오류가 없거나 있더라도 괜찮은가?
    * `성숙성` : 오류가 없고
    * `고장허용성` : 오류가 있어도 성능을 유지할 수 있고
    * `회복성` : 오류를 금방 회복할 수 있는지
3. `사용성` : 쓰기 편한가?
    * `이해성` : 이해하기 쉽고
    * `학습성` : 배우기 쉽고
    * `운용성` : 다루기 쉬운지
4. `유지보수성` : 개선 및 확장이 쉬운가?
    * `분석성` : 결함이나 고장을 발견하기 쉽고
    * `변경성` : 수정하기 쉽고
    * `안정성` : 수정하더라도 안정적이고
    * `시험성` : 변경된 내용을 검증할 수 있는지
5. `효율성` : 한정된 자원을 효율적으로 쓰는가?
    * `시간반응성` : 처리 속도가 빠르고
    * `자원효율성` : 적절한 자원을 제공하는지
6. `기능성` : 요구사항을 정확하게 만족하며 기능하는가?
    * `적절성` : 적절하고
    * `정밀성` : 정확하고
    * `상호운용성` : 상호 운용되고
    * `보안성` : 보안성 있고
    * `호환성` : 표준 잘 지키는지
    
## UI 표준
1. UX 원칙 정의
2. 정책 및 철학 설정
3. 스타일 가이드 정의
4. UI 패턴 모델 정의
5. 조직 구성

## UI 개발을 위한 주요 기법
* `3C 분석` : Customer(고객), Company(자사), Competitor(경쟁사) 분석
* `SWOT 분석` : 강점, 약점, 기회, 위협 요인을 분석
* `시나리오 플래닝` : 다양한 시나리오를 설계해 불확실성 제거
* `사용성 테스트` : 사용자가 직접 제품을 사용하며 과제 수행
* `워크숍` : 집단이 모여 지식, 아이디어를 교환하고 검토하는 연구회

## UI 화면 설계 구분
* `와이어프레임` : 화면 단위의 레이아웃 설계
* `스토리보드` : 정책, 와이어프레임 등 구축하려는 서비스를 위한 정보가 수록된 문서
* `프로토타입` : 와이어프레임(or 스토리보드) + 동적 효과<br><br>

# 사용자 요구사항 도출 
1. 페르소나 정의
2. 콘셉트 모델 정의
3. 요구사항 정의
4. UI 컨셉션<br><br>

# UML
* 표준화된 범용 모델링 언어

## UML의 특징
1. `가시화 언어` : 원활한 의사소통을 위해 가시화
2. `구축 언어` : UML -> 소스코드 변환 가능
3. `명세화 언어`
4. `문서화 언어`

## UML의 구성요소
1. 사물
2. 관계
3. 다이어그램

## UML 다이어그램
* 정적(구조적) 다이어그램
    1. `클래스 다이어그램` : 클래스 간 관계 표현
    2. `객체 다이어그램` : 객체 간 관계 표현
    3. `컴포넌트 다이어그램` : 컴포넌트 간 관계를 표현. 구현 단계에서 사용
    4. `배치 다이어그램` : 물리적 요소의 위치 표현. 구현 단계에서 사용
    5. `복합체 구조 다이어그램` : 복합 구조인 경우 그 내부 표현
    6. `패키지 다이어그램` : 패키지 간 관계 표현
* 동적(행위적) 다이어그램
    1. `시퀀스 다이어그램` : `시간적 개념` 중심으로 메시지 표현
    2. `유스케이스 다이어그램` : 사용자 관점에서 표현
    3. `커뮤니케이션 다이어그램` : 객체들이 주고 받는 메시지와 상호작용(객체 간 연관)까지 표현
    4. `활동 다이어그램` : 시스템이 수행하는 활동을 표현
    5. `상태 다이어그램` : 객체의 상태와 상태 변화를 표현
    6. `타이밍 다이어그램` : 객체의 상태 변화와 시간 제약을 표현
    
## UML 스테레오 타입
* UML 기본 요소 + 새로운 요소를 더한 확장 매커니즘. << >>(길러멧) 기호 사용
* `<<include>>` : 어떤 시점에 반드시 다른 유스케이스를 실행함
* `<<extend>>` : 어떤 시점에 다른 유스케이스를 실행할 수도 있고 아닐 수도 있음
* `<<abstract>>` : 추상 클래스 (인스턴스 생성 하지 않고 공통 특징만 정의)
* `<<interface>>` : 모든 메서드와 상수가 추상인 클래스
* `<<entity>>` : 정보 또는 행위를 표현하는 클래스
* `<<boundary>>` : 상호작용을 담당하는 클래스
* `<<control>>` : 로직 및 제어를 담당하는 클래스

## 다이어그램 종류
### 클래스 다이어그램
* 클래스의 속성(변수), 연산(메서드), 클래스 간 관계를 표현한 다이어그램
* 속성 : 클래스의 구조적 특성 (인스턴스가 보유 가능한 값의 범위)
* 접근 제어자 : 접근 가능한 정도

#### 클래스 접근제어자
* `public` : 외부 모든 클래스에서 접근 가능
* `protected` : 동일 패키지(하위 클래스 포함)일 때 접근 가능
* `default` : 자바 전용. 접근 제어자 명시가 없을 때 동일 패키지(하위 클래스 포함) 또는 파생 클래스에서 접근 가능
* `private` : 같은 클래스 내에서만 접근 가능

#### 클래스 간 관계
1. `연관(Association)` : 관련되어 있음 < - - > (양방향은 화살표 생략)
2. `의존(Dependency)` : 클래스가 다른 클래스 사용 < . . . >
3. `집합(Aggeregation)` : 포함하지만 독립적 
4. `포함(Composition)` : 포함하고 생명주기를 함께 함
5. `일반화(Generalization)` : 일반적인지 구체적인지
6. `실체화(Realization)` : 기능으로 묶인 관계

### 컴포넌트 다이어그램
* 컴포넌트와 컴포넌트 간 관계를 표현한 다이어그램
    * 컴포넌트 : 탭 2개가 달린 직사각형 + 이름
    
### 패키지 다이어그램
* 패키지 관계를 표현한 다이어그램
    * 패키지 : 폴더 형태
    
### 시퀀스 다이어그램
* `시간적 개념` 중심으로 메시지 흐름을 표현한 다이어그램
    * 생명선 : - - - - -
    * 실행 : - - [ ] - - (함수 실행시간)
    
### 유스케이스 다이어그램
* 사용자 시점에서 표현한 다이어그램

### 커뮤니케이션 다이어그램
* 객체들이 주고받는 메시지와 상호작용(객체 간 연관)까지 표현한 다이어그램
    * 객체 : 사각형 (객체명:클래스명 으로 표현)
    * 메시지 : -> 표현
    
### 활동 다이어그램
* 시스템의 처리 활동을 순서대로 표현한 다이어그램
    * 종료점 : 조건 노드, 병합 노드, 포크 노드

### 상태 다이어그램
* 객체의 상태와 상태 변화를 표현한 다이어그램
    * 종료점 : 전이, 전이 조건, 이벤트<br><br>

# 데이터 모델
* 현실 세계의 정보를 컴퓨터가 이해할 수 있도록 표현한 모델

## 데이터 모델의 구성 요소
* 연구제!!!

1. 연산
2. 구조
3. 제약조건

## 데이터 모델의 절차
* 개논물
* 개념적 -> 논리적 -> 물리적 

### 개념적 데이터 모델
* 현실 세계의 정보를 `추상적`, `개념적`으로 표현
* DB 종류에 무관함
* 주요 산출물 : E-R 다이어그램
	* `E-R 다이어그램` : 현실의 정보를 사람이 이해할 수 있는 형태로 표현해 개체와 개체의 속성, 개체 간 관계를 도식화 한 다이어그램
	* `E-R 다이어그램 구성요소`
		* 개체 : □
		* 속성 : ○
		* 다중 값 속성 : ◎
		* 관계-속성 : ─
	* `개체 정의서` : 개념 데이터 모델링 단계에서 도출된 개체와 관련된 정보를 명세화한 문서

### 논리적 데이터 모델
* 논리적 데이터베이스 구조로 매핑
* 목표 DBMS 설정, `스키마 설계`
* 정규화 수행
* 모델링 종류
	1. 관계 데이터 모델
	2. 계층 데이터 모델
	3. 네트워크 데이터 모델

### 물리적 데이터 모델
* `객체 생성` (테이블, 뷰, 인덱스 등)
* 반 정규화 수행<br><br>

# 관계 데이터 모델
* 2차원 테이블 형태
* Codd 박사가 제안
* 1:1, 1:N, N:M 자유롭게 표현<br><br>

# 네트워크 데이터 모델
* 그래프 형태
* CODASYL DBTG 모델이라고도 함
* 상위-하위 레코드 간 N:M 관계<br><br>

# 계층 데이터 모델
* 트리 형태
* 상하 관계 존재
* 1:N 관계만 허용<br><br>

# 데이터베이스
* 다수의 인원과 시스템이 사용할 목적으로 관리하는 데이터 집합
1. 통합된 데이터
2. 저장된 데이터
3. 운영 데이터
4. 공용 데이터

## 데이터베이스 특성
1. `실시간 접근성` : 쿼리에 실시간으로 응답
2. `계속적인 변화` : 삽입/삭제/갱신으로 최신 데이터 유지
3. `동시 공용` : 다수 사용자가 이용
4. `내용 참조` : 사용자가 요구하는 내용으로 참조

## 데이터베이스의 종류
1. `파일 시스템 개념` : DB 전 단계의 데이터 관리 방식
2. `관계형 DBMS(= RDBMS)` : 관계형 데이터 모델을 기반으로 하는 DB 관리 시스템
3. `계층형 DBMS(= HDBMS)` : 데이터를 상하 종속 관계로 계층화한 모델
4. `네트워크형 DBMS(= NDBMS)` : 데이터를 망상 형태로 표현한 모델

## DBMS
* 데이터의 추가, 변경, 삭제 등의 관리 기능을 제공하는 소프트웨어

## DBMS의 유형
1. `Key-Value DBMS` : Unique한 키에 하나의 값을 갖는 형태 (ex. Redis, DynamoDB)
2. `Column Family Data Store DBMS` : Key 안에 (Column, Value) 조합의 필드를 갖는 DBMS. 구글의 Bigtable 기반 (ex.. HBase, Cassandra)
3. `Document Store DBMS` : 값의 데이터 타입이 문서 타입(XML, JSON)인 DBMS (ex. MongoDB, Couchbase)
4. `Graph DBMS` : 시멘틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현 (ex. Neo4j, AllegroGraph)
	* `온톨로지` : 실세계에 존재하는 개념 정보를 컴퓨터가 이해할 수 있도록 서술한 지식베이스

## DBMS의 특징
1. `데이터 일관성` : 조작 후에도 데이터는 변함없음
2. `데이터 회복성` : 장애 발생 시 복구되어야 함
3. `데이터 무결성` : 동일한 내용에 서로 다른 데이터가 저장되지 않아야 함
4. `데이터 효율성` : 응답시간, 저장공간 등을 최적화해야 함
5. `데이터 보안성` : 불법적인 노출, 변경으로부터 보호해야 함

## DBMS 분석 시 고려 사항
1. `성능 측면` : 가용성, 성능, 상호 호환성
2. `지원 측면` : 기술 지원, 구축 비용<br><br>

# 관계 대수
* 원하는 정보를 어떻게 유도하는가에 대한 절차적 정형 언어

## 일반 집합 연산자
1. `합집합(Union)` : 전체
2. `교집합(Intersection)` : 공통
3. `차집합(Difference)` : R에만 존재하고 S에는 없음
4. `카티션 프로덕트(CARTESIAN Product)` : R과 S에 속한 모든 튜플 연결

## 순수 관계 연산자
1. 셀렉트 `σ` : `σ 조건 (R)` R에서 조건을 만족하는 튜플 반환 -> 가로
2. 프로젝트 `π` : `π 속성리스트 (R)` R에서 주어진 속성들로만 구성된 튜플 반환 -> 세로
3. 조인 `▷◁` : `R ▷◁ S` 공통 속성으로 R과 S의 튜플 연결하여 반환
4. 디비전 `÷` : `R ÷ S` S의 모든 튜플과 관련된 R의 튜플 반환<br><br>

# 관계 해석
* 원하는 정보가 무엇인가에 대한 비절차적 언어 (프레디킷 해석 기반)<br><br>

# 정규화(Normalization)
* 데이터의 중복성을 제거하여 이상 현상을 방지하는 과정

## 이상 현상(Anomaly)
* 데이터 중복으로 인해 릴레이션 조작 시 발생하는 비합리적 현상
* `삽입, 삭제, 갱신 이상` (select, update, delete)

## 정규화 단계
1. `1NF (1차 정규화)` : 도메인은 원자값으로만 구성
2. `2NF (2차 정규화)` : 부분 함수 종속성 제거 (완전 함수적 종속 관계)
3. `3NF (3차 정규화)` : 이행 함수 종속성 제거 (A -> B, B -> C, A -> C일 때 이행 함수 종속 관계)
4. `보이스-코드(BC)NF` : 결정자는 모두 후보키여야 함
5. `4NF (4차 정규화)` : 다치(다중값) 종속 제거
6. `5NF (5차 정규화)` : 조인 종속 제거 (릴레이션의 모든 조인 종속이 후보키를 통해서만 설립)<br><br>

# 반 정규화(De-Normalization)
* 정규화된 개체/속성/관계를 단순화하는 기법
* 장점 : 성능 & 관리 효율성 증대
* 단점 : 일관성 & 무관성 하락

## 반 정규화 기법
1. 테이블 병합
2. 테이블 분할
3. 중복 테이블 추가 : 집계테이블, 진행테이블, 특정 부분만을 포함하는 테이블
4. 중복 컬럼 허용
5. 중복 관계 허용<br><br>

# NoSQL
* Not Only SQL
* 전통적인 RDBMS가 아닌 DBMS를 지칭
* 조인 연산 불가, 수평적으로 확장 가능

## NoSQL의 특징
1. `Basically Available` : 언제든지 접근 가능해야 함
2. `Soft-State` : 노드의 상태는 외부 정보로 결정됨
3. `Eventually Consistency` : 일정 시간이 지나면 데이터 일관성이 유지됨

## NoSQL의 유형
1. Key-Value
2. Column Family Data Store
3. Document Store
4. Graph<br><br>

# 데이터 마이닝
* 대규모 데이터 속에서 의미있는 정보를 파악해 의사결정에 활용하는 기법

## 데이터 마이닝 기법
1. `분류 규칙 (Classification)` : 과거 데이터로부터 분류 모델을 만들어 이를 토대로 새로운 결과 값을 예측
2. `연관 규칙 (Association)` : 데이터 항목 간 종속 관계를 찾아냄 (ex. 넥타이 구매자는 셔츠도 같이 구매함)
3. `연속 규칙 (Sequence)` : 연관 규칙에 '시간' 관련 정보가 포함된 기법
4. `데이터 군집화 (Clustering)` : 유사한 특성을 지닌 그룹으로 분류하되 정보가 없는 상태에서 분류

## 데이터 마이닝 종류
* `텍스트 마이닝` : 대량의 텍스트 속에서 의미있는 정보를 찾아내는 기법 (자연어, 문서 처리기술 적용)
* `웹 마이닝` : 웹으로부터 얻는 방대한 정보 속에서 의미있는 정보를 찾아내는 기법 (데이터 마이닝 기술 응용)<br><br>

# 빅데이터의 특성
1. `Volumn(양)` : PB 수준의 대규모 데이터
2. `Variety(다양성)` : 유형이 로그, 소셜, 위치 등 다양해짐
3. `Velocity(속도)` : 정보가 빠르게 증가하고 수집됨

## 빅데이터 수집 및 처리 기술
1. 비정형 데이터 수집 (ex. 척화(Chuckwa), 플럼(Flume), 스크라이브(Scribe)
2. 정형 데이터 수집 (ex. 스쿱(Squoop), 하이호(Hiho), ETL, FTP
3. 분산 데이터 저장/처리 (ex. HDFS(하둡 분산 파일 시스템), 맵리듀스(구글이 발표)
4. 분산 데이터 베이스 (ex. HBase)

## 빅데이터 분석 및 처리 기술
1. `빅데이터 분석`
	* 데이터 가공 : ex. 피그(Pig), 하이브(Hive), 
	* 데이터 마이닝 : ex. 머하웃(Mahout)
2. `빅데이터 실시간 처리`
	* 실시간 SQL 처리 : ex. 임팔라(Impala)
	* 요청 작업의 워크플로우 관리 : ex. 우지(Oozie)
3. `분산 코디네이션`
	* 분산 처리 기술 : ex. 주키퍼(Zookeeper)
4. `분석 및 시각화`
	* 시각화 기술 : ex. R<br><br>

# 인터페이스(연계) 명세서
* 연계에 필요한 항목을 명세화한 문서 구성요소
1. 인터페이스 ID
2. 최대 처리 횟수
3. 데이터 크기 (평균/최대)
4. 시스템 정보 (송수신 각각) : 시스템명, 업무명, 연계방식 등
5. 데이터 정보 (송수신 각각) : 번호, 필드, 데이터 타입 등

## 연계 요구사항 분석 시 참고 문서
1. 코드 정의서
2. 테이블 정의서
3. 응용 프로그램 구성도 (화면 설계서, 사용자 인터페이스 정의서 등)
4. 시스템 구성도 (소프트웨어 구성도, 하드웨어 구성도, 네트워크 구성도 등)

## 연계 시스템의 구성
1. 송신 시스템 : 연계할 데이터를 송신
2. 수신 시스템 : 수신한 데이터를 변환해 저장하고 활용하는 시스템
3. 중계 시스템 : 송신-수신 시스템 사이에서 송수신하고 모니터링하는 시스템

## 연계 데이터 표준화
1. 인터페이스 데이터 공통부 : 표준 항목
2. 인터페이스 데이터 개별부 : 개별 데이터
3. 인터페이스 데이터 종료부 : 전송데이터의 끝을 알림

## 연계 매커니즘 수행 절차
1. 연계 데이터 추출 및 생성
2. 코드 매핑 (데이터 변환)
3. 연계 테이블 또는 연계 파일 생성
4. 로그 기록
5. 연계 서버 또는 송수신 어댑터
6. 전송
7. 수신된 데이터 DB에 반영

## 연계 매커니즘 종류
### 직접 연계
* 장점 : 구현이 쉽고 개발 기간이 짧음
* 단점 : 결합도가 높음
* 종류
	* DB Link : 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 링크를 참조하는 방식
	* DB Connection : DB Connection Pool을 생성하고 해당 풀 명을 이용하여 연결하는 방식 
		* 커넥션 풀 : DB와 연결된 커넥션을 미리 만들어 풀 속에 저장하고, 필요할 때마다 쓰고 반환하는 기법
	* API : 데이터를 주고 받을 때 어떤 방식으로 요청하고 제공받을 수 있는지, 규격을 정해 놓은 인터페이스
	* JDBC : JDBC 드라이버를 이용해 송신 시스템의 DB와 연결하는 방식
		* JDBC : 자바에서 데이터베이스에 접속할 수 있게 해주는 API
		* JDBC 드라이버의 구성 : Java Application - JDBC API - JDBC Driver Manager - JDBC Driver
	* 하이퍼링크 : 현재 페이지에서 다른 부분 또는 다른 페이지로 이동하게 해주는 속성

### 간접 연계
* 장점 : 서로 상이한 네트워크, 프로토콜 연계 가능
* 단점 : 성능 저하, 개발 비용 높음
* 종류
	* EAI : 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간 `연계`를 돕는 솔루션
		* 구성요소
			* EAI 플랫폼
			* 어댑터 : EAI의 핵심장치. 애플리케이션을 연결하는 데이터 입출력 도구
			* 브로커 : 데이터 전송 시 포맷과 코드를 변환해 줌
			* 메시지 큐 : 비동기 메시지를 사용하는 프로그램 사이에서 송수신 해 주는 기술
			* 비즈니스 워크플로우 : 미리 정의된 워크플로우에 따라 업무 처리
		* 유형
			* Point-to-Point : 가장 기초적인 1:1 단순 통합방법
			* Hub & Spoke : 허브 시스템을 통한 중앙 집중 방식
			* Message Bus : 애플리케이션 사이에 미들웨어(버스)를 두어 연계
			* Hybrid : 그룹 내 = Hub & Spoke 그룹 간 = Message Bus
	* ESB : 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션을 하나의 시스템으로 관리할 수 있게 하는 아키텍처로, 미들웨어(버스)를 중심으로 애플리케이션 `통합`을 '느슨한 결합' 방식으로 지원
	* Socket : 프로세스 간 통신의 접속점(IP 주소 + 포트넘버) 클라이언트 요청을 서버와 연결해 줌
 
    * `EAI`는 연계! `ESB`는 통합!

## 인터페이스 기능 구현
1. 대상자 선택(대상이 될 데이터를 SQL로 선택)
2. 인터페이스 데이터 생성(JSON 등 형식에 맞게 가공)
3. 인터페이스 데이터 전송 요청
4. 인터페이스 데이터 전송
5. 인터페이스 데이터 수신
6. 인터페이스 데이터 파싱
7. 인터페이스 데이터 검증(포맷 및 제약조건 오류 검사)
8. 후속 기능 수행(수신 시스템에 정의된 후속 기능 진행)
9. 수신 결과 생성 및 전송<br>
10.수신 측의 처리 결과 반환 <br><br>

# 웹 서비스 방식
1. `SOAP` : HTTP, HTTPS 등을 사용해 XML 기반의 메시지를 교환하는 프로토콜
2. `WSDL` : Web Service Description Language. 웹 서비스명, 제공위치 등 웹 서비스의 정보가 기술된 XML 형식의 언어
3. `UDDI` : WSDL의 등록, 검색을 위한 저장소 (공개적으로 접근 가능한 레지스트리)

* XML 프로토콜이면 `SOAP`, 언어면 `WSDL`<br><br>

# JSON
* `키-값` 쌍으로 이루어진 데이터를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용한 포맷(AJAX에서 많이 사용)

## JSON의 표현 자료형
1. 숫자
2. 문자열(항상 "" 따옴표 사용)
3. 배열(대괄호 [] 표시)
4. 객체(중괄호 {} 로 표시하며, 이름은 문자열을 쓴다)<br><br>

# XML
* HTML의 단점을 보완하여, 특수한 목적을 갖는 마크업 언어

## XML의 특징
* 트리 구조이며 모든 태그에는 종료 태그가 필수
* 속성값은 큰 따옴표(")로 묶고 대소문자를 구분함<br><br>

# AJAX
* 서버-클라이언트 간 비동기적으로 데이터를 교환하기 위한 기술

## AJAX의 동작 원리
1. 요청 이벤트 발생
2. 자바스크립트 호출
3. 자바스크립트가 XMLHttpRequest 객체를 사용해 서버에 요청 (비동기이므로 그동안 다른 일 처리)
4. 서버는 XMLHttpRequest 객체를 가지고 AJAX 요청 처리
5. 전달받은 데이터를 사용해 웹 페이지 일부만을 갱신하는 자바스크립트 호출

## AJAX의 주요기술
* `XMLHttpRequest` : 비동기 통신을 담당하는 자바스크립트 객체
* `XML` : HTML의 단점을 보완하여, 특수한 목적을 갖는 마크업 언어
* `DOM` : XML 문서를 트리 구조 형태로 접근하게 해주는 API
* `XSLT(eXtensible Stylesheet Language Transformations)` : XML 문서를 다른 XML 문서로 변환하는 데 사용하는 언어
* `HTML` : 웹 문서를 표현하는 마크업 언어
* `CSS` : 마크업 언어가 표시되는 방법을 기술하는 언어<br><br>

# REST
* HTTP URI로 자원을 표시하고, HTTP 메서드를 통해 해당 자원에 대한 삽입, 삭제, 갱신 등의 명령을 적용하는 아키텍처

## REST 메서드의 종류
1. POST (Create)
2. GET (Read)
3. PUT (Update)
4. DELETE (Delete)

## REST의 구성
1. 리소스
2. 메서드
3. 메시지<br><br>

# DB 암호화 기법
1. `API 방식` : 애플리케이션 서버에 암호 모듈 적용(애플리케이션 서버에 부하 발생)
2. `플러그인 방식` : DB 서버에 암호 모듈 적용(DB 서버에 부하 발생)
3. `TDE 방식` : DBMS 커널이 자체적으로 암호화 기능 수행 (Transparent Data Encryption)
4. `하이브리드 방식` : API + 플러그인 (부하 분산)<br><br>

# 인터페이스 구현 검증 도구
1. `xUnit` : Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크
2. `STAF` : 각 테스트 대상 분산 환경에 '데몬'을 사용하여 테스트를 수행
3. `FitNesse` : 웹 기반 테스트 케이스를 지원
4. `NTAF` : STAF(재사용 및 확장성) + FitNesse(협업 기능) 장점을 통합한 NHN의 프레임워크
5. `Selenium` : 다양한 브라우저와 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
6. `Watir` : 루비 기반의 웹 애플리케이션 테스트 프레임워크

## 인터페이스 감시 도구
1. `스카우터` : 애플리케이션 및 DB 모니터링 가능한 감시 도구
2. `제니퍼` : 개발부터 운영에 이르기까지 전 생애주기 동안 모니터링 가능한 감시 도구

## 오류 처리 방법
1. 화면에서 오류를 인지하도록 구현
2. 오류 로그 생성
3. 관련 테이블에 오류 사항 기록<br><br>

# 프로그래밍 언어 분류(실행방식에 따라)
1. 명령형 언어(= 절차형 언어) : 명령들이 순차적으로 실행되는 방식
    * ex. FORTRAN, COBOL, PASCAL, C, ALGOL, BASIC
2. 객체지향 언어 : 객체 간 메시지 통신을 이용하는 방식
    * ex. 자바, C++
3. 함수형 언어 : 수학수식과 같은 함수들로 프로그램을 구성하여 호출하는 방식
    * ex. 리스프(LISP), 하스켈(Haskell)
4. 논리형 언어 : 논리 문장을 이용하여 표현하는 방식
    * ex. 프롤로그(Prolog)
5. 스크립트 언어 
    * PHP : 동적 웹페이지를 위한 언어
    * Perl : 실용성 모토, 인터프리터
    * Python, JavaScript
6. 선언형 언어
    * 함수형 언어
    * 논리형 언어
    * 특수분야 언어 : SQL(DBMS 관리를 위한 질의어)
    
## 프로그래밍 구현 기법
1. 컴파일 방식 : 고급 언어 -> 기계어로 번역
    * ex. FORTRAN, PASCAL, C, C++
2. 인터프리터 방식 : 명령문을 하나씩 번역하고 실행하는 방식
    * ex. BASIC, LISP, PHP, Perl, Prolog
3. 혼합형 방식 : 고급 언어를 컴파일하여 중간 언어로 변환 후 인터프리터가 번역을 실행하는 방식
    * ex. 자바
    
## 절차적 프로그래밍
1. FORTRAN : 과학 기술 전문 언어로, 고급 수학 함수들 사용 가능(컴파일 방식)
2. C : 유닉스 운영체제에서 사용하기 위한 언어(컴파일 방식)
3. 알골 : 알고리즘 연구개발 목적
4. 베이직 : 교육용으로 개발된 언어(인터프리터 방식)

## 객체지향 프로그래밍
1. C++ : C 언어에 객체지향 프로그래밍 개념 추가(컴파일 방식)
2. C# : MS에서 개발. 불안전 코드(Unsafe Code) 같은 기술을 통해 상호 운용성 확보
3. 자바 : 웹 애플리케이션 개발에 가장 많이 사용되는 언어
4. 델파이 : 파스칼 문법 + 여러 기능. Windows 아래에서 모든 부분 프로그래밍 가능

### 객체지향 프로그래밍의 구성요소
1. 객체 : 개체 + 속성 + 메서드로 이루어진 인스턴스
2. 클래스 : 객체를 표현하는 추상 데이터 타입
3. 메서드 : 객체 간 통신<br><br>

# 파이썬 자료형
* `List` : 순서 있는 배열
    * 값 맨 뒤에 삽입 : `append(value)`
    * 중간에 삽입 : `insert(index, value)`
    * 삭제 : `remove(value)`
* `Dictionary` : 키-값 쌍
    * 값 참조 : `딕셔너리이름[키] = 값`
    * 값 삭제 : `del 딕셔너리이름[키]`
* `Set` : 중복 허용 X, 순서 없음
    * 값 추가 : `add(value)`
    * 값 삭제 : `remove(value)`<br><br>
    
# 자바 자료형
* `HashMap` : 키-값 쌍
    * 값 추가 : `put(key, value)`
    * 값 삭제 : `remove(key)`
    * 값 얻기 : `get(key)`
* `ArrayList` : 순서 있는 배열
    * 값 맨 뒤에 추가 : `add(value)`
    * 값 중간에 삽입 : `add(index, value)`
    * 값 삭제 : `remove(index)`
    * 인덱스 값 참조 : `get(index)`
* `HashSet` : 중복 허용 X, 순서 없음
    * 값 추가 : `add(value)`
    * 값 제거 : `remove(value)`<br><br>
    
# 라이브러리
* 효율적인 개발을 위해 필요한 프로그램들을 모은 집합체(모듈과 패키지를 총칭)
    * `모듈` : 변수, 함수 등을 모아둔 파일
    * `패키지` : 모듈을 구조화한 라이브러리

## 라이브러리 구성
1. 도움말
2. 설치 파일
3. 샘플 코드<br><br>

# 클래스 관련 용어
## 인터페이스
* 자바에서 다향성을 극대화하기 위한 문법으로 추상 메서드와 상수만을 멤버로 갖는다.

## 추상 클래스
* 자식 클래스에서 상위 클래스의 미구현 추상 메서드를 구현하는 것  

## 추상 클래스 구현
* C++ : 메서드 뒤에 `= 0` 붙임
* 자바 : 클래스명과 메서드명 앞에 `abstract` 붙임
* 파이썬 : 메서드 내부에 `pass` 키워드 사용

## 상위 클래스 접근
* C++ : 부모클래스::메서드명()
* 자바 : super.메서드명()
* 파이썬 : super().메서드명()

## 오버로딩
* 같은 이름의 메서드를 매개변수만 다르게 하여 여러 개 정의하는 것

## 오버라이딩
* 하위 클래스에서 상위 클래스 메서드를 재정의하는 것. C++은 `virtual` 키워드 필요

## 상속
* 어떤 객체의 변수와 메서드를 다른 객체가 물려받는 것

### 상속 문법
* C++ : `class 자식클래스 : public 부모클래스 {}`
* 자바 : `class 자식클래스 extends 부모클래스 {}`
* 파이썬 : `class 자식클래스 (부모클래스):`

## 생성자
* 해달 클래스의 객체가 생성될 때 자동으로 호출되는 메서드
* C++, 자바 : 클래스명과 동일하면 생성자
* 파이썬 : `__int__` 메서드명 사용하면 생성자

## 소멸자
* 객체가 소멸될 때 호출되는 메서드. 할당된 메모리를 해제하는 용도로 사용됨
* C++ : 클래스명과 동일하나 클래스명 앞에 `~` 기호를 붙이면 소멸자
* 자바 : `finalize` 메서드명을 사용하면 소멸자
* 파이썬 : `__del__` 메서드면 사용하면 소멸자

## 자신 클래스 참조
* C++, 자바는 `this->`, `this.`
* 파이썬은 `self.`

## 구조체
* 기본 타입을 이용해 새롭게 정의하는 자료형
* C/C++ 한정 `struct`로 선언 후 사용

## 열거체
* 정수형 상수에 이름을 붙여 쓰기 편하게 만드는 것

## 포맷 스트링
* %c : 문자
* %s : 문자열
* %d : 10진수
* %x : 16진수
* %o : 8진수
* %f : 실수(6자리까지)

## 비트 연산자
* `&` : 같은 비트 값이 모두 1이면 1 - AND
* `|` : 같은 비트 중 하나라도 1이면 1 - OR
* `^` : 같은 비트값이 서로 다르면 1 - XOR
* `~` : 모든 비트값을 반대로 뒤집음 - NOT

## 시프트 연산자
* `<<` 왼쪽으로 비트 이동 : * 2 효과가 있다.
* `>>` 오른쪽으로 비트 이동 : / 2 효과 

## 식별자 표기법
* 헝가리안 표기법 : 식별자 앞에 자료형을 붙이는 표기법
* 스네이크 표기법 : 식별자에 여러 단어가 이어질 때 각 단어 사이에 언더바를 넣는 표기법
* 카멜 표기법 : 식별자에 여러 단어가 이어질 때 첫 단어의 시작만 소문자로, 각 단어의 첫 글자는 대문자로 쓰는 표기법
* 파스칼 표기법 : 식별자에 여러 단어가 이어질 때 각 단어의 첫 글자는 대문자로 쓰는 표기법

## 리스트 인덱스
* [0] [1] ... [n-2] [n-1] [-n] [-(n-1)] [-2] [-1]

## 리스트 슬라이싱
1. 시작 인덱스 : 생략 시 처음부터
2. 종료 인덱스 : `종료 인덱스 전` 까지만 슬라이싱하며 `생략 시 마지막까지`
3. 스텝 : 생략 시 1

```python
a = [7, 6, 3, 4, 0]
print(a[:4:2])
```

* 출력 : [7,3]

```python
a = "Hello Phython"
b = a[0:3]
c = a[-4:-1]
```

* 출력 : Heltho<br><br>

# 트랜잭션
* DB 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업 단위 (특성 : `ACID`)
* `원자성(Atomicity)` : All or Nothing. 연산 전체는 성공 또는 실패여야 하며, 하나라도 실패할 경우 전체가 취소되어야 하는 특성
* `일관성(Consistency)` : 트랜잭션이 성공적으로 실행되면, DB는 일관된 상태를 유지해야 하는 특성 (기법 : 병행(동시성) 제어)
* `격리성(Isolation)` : 트랜잭션 실행 중 중간 연산 결과에 다른 트랜잭션이 접근할 수 없다. (기법 : 고립화 수준)
* `영속성(Durability)` : 성공적으로 완료된 트랜잭션 결과는 DB에 영속적으로 저장되어야 한다. (기법 : 회복기법)

## 트랜잭션의 상태 변환
1. `활동상태(Active)` : 트랜잭션 실행 중
2. `부분 완료 상태(Partially Committed)` : 마지막 명령문 실행 상태
3. `완료 상태(Committed)` : 성공적으로 완료
4. `실패 상태(Failed)` : 정상적 실행 불가
5. `철회 상태(Aborted)` : 트랜잭션 취소

## TCL
* 트랜잭션 제어 언어
* 트랜잭션 결과를 허용하거나 취소하기 위한 제어 언어
* `COMMIT`, `ROLLBACK`, `CHECKPOINT`

## 병행제어
* 다수 사용자 환경에서 일관성 유지를 위해 제어하는 기법

### 병행제어 미보장 문제점
* 갱현모연
* 갱신손실(Lost Update)
* 현황파악오류(Dirty Read)
* 모순성(Inconsistency)
* 연쇄복귀(Cascading Rollback)

### 병행제어 기법
1. `로킹(Locking)` : 트랜잭션의 순차적 진행을 보장하는 기법
    * `로킹단위` : 한 번에 로킹할 수 있는 객체 크기
    * 로킹단위가 작을수록 DB 공유도는 증가하지만 로킹 오버헤드 증가
2. `낙관적 검증 기법(Validation)` : 일단 검증 없이 진행 후, 종료한 다음 검증을 수행해 반영
3. `타임 스탬프 순서(Time Stamp Ordering)` : 트랜잭션이나 데이터에 타임 스탬프를 부여하여, 그 시간에 따라 작업을 수행
4. `다중버전 동시성 제어(MVCC; Multi Version Concurrency Control)` : 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교해, 적절한 버전을 선택하여 접근하도록 하는 기법

## 고립화
* 무결성을 해치지 않기 위해 잠금을 설정하는 정도

### 고립화 수준 종류
1. `Read Uncommitted` : 연산 중인 데이터를 다른 트랜잭션이 읽는 것을 허용
2. `Read Committed` : 연산이 완료되기 전까지 다른 트랜잭션이 읽는 것을 제한
3. `Repetable Read` : 선행 트랜잭션이 특정 데이터를 읽을 때, 해당 데이터의 갱신/삭제를 제한
4. `Serializable Read` : 선행 트랜잭션이 특정 데이터 영역을 읽을 때, 해당 영역 전체의 접근을 제한

## 회복 기법
1. `로그 기반 회복 기법`
    * `지연 갱신 회복 기법` : 트랜잭션 완료 전에는 로그에만 기록. 장애 발생 시 로그를 폐기
    * `즉각 갱신 회복 기법` : 트랜잭션 갱신 결과를 바로 DB에 반영. 장애 발생 시 로그를 참고하여 되돌림
2. `체크포인트 회복 기법` : 체크포인트 이전으로 복원
3. `그림자 페이징 회복 기법` : 트랜잭션 수행 시 복제본을 생성해 이를 이용해 복구

## SQL 문법
1. DDL(정의어) : `Create, Alter, Drop, Truncate`
2. DML(조작어) : `Select, Insert, Update, Delete`
3. DCL(제어어) : `Grant, Revoke`

## 도메인
* 하나의 속성이 가질 수 있는 원자값의 집합

## 스키마
* DB의 구조, 제약조건 등의 정보를 담고 있는 구조

### 스키마 3계층
1. `외부 스키마` : 사용자(개발자) 관점에서의 구조. 사용자 뷰를 나타냄
2. `개념 스키마` : 제약조건, 권한, 보안 등 전체적인 논리 구조
3. `내부 스키마` : 물리적 저장장치 관점에서의 구조. 레코드 형식, 물리적 순서 등

## 테이블 관련 용어
* 테이블 : 데이터를 저장하는 공간 (=릴레이션, =엔터티)
* 튜플 : =Row. =레코드. 한 릴레이션에서 중복되는 튜플은 존재 불가
* 카디널리티 : 튜플의 개수
* 애트리뷰트 : =Column
* 디그리 : 애트리뷰트의 개수

## 뷰
* 데이터의 독립성을 보장하고 조작 연산을 간소화할 수 있는 논리 테이블
* ALTER로 변경 불가
* 자체 인덱스 불가

### 뷰 속성
* `REPLACE` : 기존 테이블 존재 시 재생성
* `FORCE` : 기본 테이블 관계 없이 뷰 생성
* `NO FORCE` : 기본 테이블이 있을 때만 뷰 생성
* `WITH CHECK OPTION` : 서브 쿼리 내 조건을 만족하는 행만 변경
* `WITH READ ONLY` : DML(조작어) 불가

## 인덱스
* DB 시스템에서 빠른 검색을 위한 데이터 구조
* 인덱스가 없으면 Table Full Scan을 하지만, 인덱스가 있으면 Index Range Scan을 하므로 검색 속도가 빠르다.

### 인덱스 종류
1. `비트맵 인덱스` : 컬럼 개수가 적고 수정이 적을수록 좋은 인덱스(생년월일, 상품번호 등)
2. `단일 인덱스` : 하나의 컬럼으로만 구성된 인덱스
3. `순서 인덱스` : 데이터가 정렬된 순서로 생성되는 인덱스
4. `함수기반 인덱스` : 함수를 적용해 만든 인덱스
5. `해시 인덱스` : 해시 함수를 통해 키 값으로 데이터에 접근하는 인덱스(튜플 양에 무관하게 접근 비용 동일함)
6. `결합 인덱스` : 두 개 이상의 컬럼으로 구성된 인덱스
7. `클러스터드 인덱스` : PK 기준으로 레코드를 묶어 데이터의 물리적 순서에 따라 생성된 인덱스

### 인덱스 컬럼 선정
* 적정 분포도 : 10-15%
    * 분포도 : 특정 컬럼 값이 테이블에 평균적으로 분포된 정도
* 수정이 빈번하지 않은 컬럼이 분포도가 좋은 컬럼 - 단일 인덱스
* 자주 결합되는 컬럼 - 결합 인덱스

### 인덱스 스캔 방식
1. `인덱스 범위 스캔` : ⬇️➡️ 루트 블록에서 리프 블록까지 수직 탐색 후, 리프 블록을 수평 탐색
2. `인덱스 전체 스캔` : ➡️➡️ 리프 블록을 처음부터 끝까지 수평 탐색
3. `인덱스 단일 스캔` : ⬇️⬇️ 수직 탐색으로만 스캔
4. `인덱스 생략 스캔` : 선두 컬럼이 조건 절에 없더라도 인덱스를 활용하는 스캔 (필요없는 부분은 과감히 스킵)

## 클러스터링
* 검색 속도 향상을 위해 물리적으로 저장하는 것
* 분포도가 넓을 수록(=좋지 않을 수록) 클러스터링이 적합

## 파티셔닝
* 테이블을 논리적 단위로 쪼개는 것

### 파티셔닝 유형
1. `레인지 파티셔닝` : 숫자나 날짜와 같은 범위 기준으로 파티셔닝
2. `해시 파티셔닝` : 해시 함수의 값을 기준으로 파티셔닝(균등 분할 가능)
3. `리스트 파티셔닝` : 값 목록을 기준으로 파티셔닝
4. `컴포지트 파티셔닝` : 2개 이상의 파티셔닝을 결합

### 파티셔닝 장점
1. `성능 향상` : 액세스 범위가 줄어드니까
2. `가용성 향상` : 데이터 훼손 가능성이 적으니까
3. `백업 기능`
4. `경합 감소`

## 테이블 명령어
* 테이블 생성 : CREATE TABLE 테이블명 (컬럼명 데이터타입 [제약조건]);
* 테이블 생성 제약조건
    * PRIMARY KEY
    * FOREIGN KEY REFERENCES 테이블(컬럼)
    * NOT NULL
    * UNIQUE
    * CHECK (조건 OR 조건)
    * DEFAULT
* 테이블 변경
    * ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];
    * ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];
    * ALTER TABLE 테이블명 DROP 컬럼명;
* 테이블 삭제
    * DROP TABLE 테이블명 [CASCADE | RESTRICT];
    * TRUNCATE TABLE 테이블명;
* 뷰 생성 : CREATE [OR REPLACE] VIEW 뷰이름 AS SELECT 이름 FROM 학생 WHERE 성별 = 'F';
* 뷰 삭제 : DROP VIEW 이름;
* 인덱스 생성 : CREATE INDEX 인덱스명 ON 테이블(컬럼);
* 인덱스 변경 : ALTER INDEX 인덱스명 ON 테이블(컬럼);
* 인덱스 삭제 : DROP INDEX 인덱스명;

## 참조 무결성
* 외래키 값은 항상 참조되는 테이블의 기본키여야 함

### 참조 무결성을 위한 옵션
1. `RESTRICT` : 참조 무결성 위배 시 연산 거절
2. `CASCADE` : 해당 투플을 참조하는 튜플도 함께 삭제
3. `SET NULL` : 해당 튜플을 참조하는 튜플의 외래키에 NULL 값 삽입(단, NOT NULL 제약조건 시 연산 거절)

## 조인
* 두 개 이상의 테이블을 연결해 데이터를 검색하는 방법

### 조인 명령어
* SELECT A.번호, B.가격 FROM 상품목록 A JOIN 가격목록 B ON A.번호 = B.번호 WHERE A.번호 IS NOT NULL

### 논리적 조인
1. `내부 조인` : 양 테이블의 공통 컬럼의 값이 같을 때 사용 `INNER JOIN`
2. `외부 조인`
    * `왼쪽 외부 조인` : 왼쪽 테이블 전체 + 오른쪽 테이블 동일 데이터 `LEFT OUTER JOIN`
    * `오른쪽 외부 조인` : 오른쪽 테이블 전체 + 왼쪽 테이블 동일 데이터 `RIGHT OUTER JOIN`
    * `완전 외부 조인` : 양쪽 모든 데이터 추출 `FULL OUTER JOIN`
3. `교차 조인` : 조인 조건이 없는 모든 데이터 조합 추출 `CROSS JOIN`
4. `셀프 조인` : 자기 자신에게 별칭을 지정한 후 조인

### 물리적 조인
1. Nested-Loop Join(중첩 반복 조인)
2. Sort-Merge Join(정렬 합병 조인)
3. Hash Join(해시 조인)

## 집합 연산자
* 2개 이상의 테이블의 질의의 결과를 합치는 연산자(검색을 위해 합치는 조인과 다름)
* `UNION 연산자` : 합집합. **중복을 제거**하고 모두 포함
* `UNION ALL 연산자` : 완전 합집합. 중복까지 포함
* `INSERT 연산자` : 교집합. 겹치는 데이터만 추출
* `MINUS 연산자` : 차집합. 첫 번째 쿼리에만 있고, 두 번째 쿼리에만 없는 결과만 추출

## DCL 명령어
* `권한 부여` : GRANT 권한 ON 테이블 TO 사용자 [WITH GRANT OPTION];
* `권한 회수` : REVOKE 권한 ON 테이블 FROM 사용자 [CASCADE CONSTRAINT];

## DBMS_OUTPUT
* 버퍼로부터 메시지를 읽어오는 인터페이스 패키지
```sql
DBMS_OUTPUT.PUT(문자열); // 문자열 출력하는 프로시저
```

## 절차형 SQL
* SQL 안에서도 절차 지향적인 프로그래밍이 가능하도록 하는 트랜잭션 언어

### 절차형 SQL의 종류
1. `프로시저` : 일련의 쿼리들을 하나의 함수처럼 실행하기 위한 쿼리의 집합
2. `사용자 정의 함수` : 일련의 SQL 처리 후, 그 결과를 단일값으로 반환
3. `트리거` : DB 시스템에서 삽입, 삭제, 갱신 등의 이벤트 발생 시 관련 작업이 자동으로 수행

## 튜닝(쿼리 성능 개선)
* SQL 실행 계획을 수정해 프로시저 성능을 개선하는 것

### 튜닝 개선 절차
1. 문제 있는 SQL 식별(APM 모니터링 도구 사용)
2. 옵티마이저 통계 확인
3. SQL문 재구성
4. 인덱스 재구성
5. 실행계획 유지관리

## 옵티마이저 
* SQL을 수행할 최적의 처리경로를 찾는 DBMS의 핵심엔진

### 옵티마이저 유형
1. RBO : 규칙 기반 옵티마이저. 사전에 등록된 규칙에 따라 실행 계획을 선택함
2. CBO : 비용 기반 옵티마이저. 모든 접근 경로를 고려해 실행 계획을 선택함
* 실행 계획(Execution Plan) : 옵티마이저가 생성한 처리경로

### 옵티마지어의 역할
1. 쿼리 변환 : SQL을 표준화된 형태로 변환
2. 비용 산정 : 카디널리티, 비용 등을 계산
3. 계획 생성
* `힌트`를 통해 옵티마이저의 실행 계획을 변경이 가능하다.<br><br>

# 개발 도구 분류
1. 빌드 도구
2. 구현 도구
3. 테스트 도구
4. 형상관리 도구<br><br>

# 형상관리(CM)
* 소프트웨어 개발 과정에서 발생하는 변경사항을 관리하는 것

## 형상관리 절차
1. 형상 식별(관리할 대상 식별 후 번호 부여)
2. 형상 통제(형상통제위원회 운영, 베이스라인 관리)
    * 베이스라인 : 개발 산출물 변화를 통제하는 시점 
3. 형상 감사(무결성 평가)
4. 형상 기록

## 형상관리 도구 유형
1. 공유 폴더 방식(개발이 완료된 파일을 공유 폴더에 복사)
2. 클라이언트/서버 방식(중앙에 버전관리 시스템이 동작)
3. 분산 저장소 방식(로컬 저장소/원격 저장소 분산)

## 형상관리 도구별 특징
1. `RCS` : 공유폴더 방식(잠금 처리 후 1명만 수정)
2. `CVS` : 클라이언트/서버 방식(동시 접근 가능)
3. `SVN` : 클라이언트/서버 방식
4. `Clear Case` : 복수 클라이언트/복수 서버(필요시 서버 증설 가능)
5. `Bitkeeper` : 분산 저장소 방식
6. `Git` : 분산 저장소 방식

## 형상관리 통제 위원회(CCB)
* 형상관리 방침을 정하고 관리하는 조직<br><br>

# 모듈
* 그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체
* 기능 단위로 분해, 추상화되어 재사용 가능한 단위

## 모듈화
* 성능 향상, 유지 관리 등을 위해 기능 단위 모듈로 분해하는 기법
* 모듈 단위로 설계하는 기법<br><br>

# 팬인 팬아웃
* `팬인(Fan-In)` : 어떤 모듈을 제어(호출)하는 모듈의 수
* `팬아웃(Fan-Out)` : 어떤 모듈에 의해 제어(호출)되는 모듈의 수<br><br>

# 루틴
* 특정 동작을 수행하는 일련의 코드
* 메인 루틴 : 전체의 개략적인 동작 절차를 표시하며 서브 루틴을 호출하는 루틴
* 서브 루틴 : 메인 루틴에 의해 호출되는 루틴<br><br>

# 웹서버
* 정적 콘텐츠를 처리하는 서버(ex. 아파치 웹 서버, 구글 웹 서버 등)<br><br>

# 웹 어플리케이션 서버(WAS)
* 동적 콘텐츠(JSP, 서블릿)를 처리하는 서버(ex. Tomcat, Weblogic 등)<br><br>

# 서버 프로그램 구현 방법
* DTO/VO -> SQL -> DAO -> Service Class -> Controller Class
    * `DTO` : Data Transfer Object. 화면에서 전달받은 데이터를 전송하는 객체
    * `VO` : Value Object. 간단한 객체
    * `DAO` : Data Access Object. 실질적으로 DB에 접근하는 객체<br><br>

# 배치 프로그램
* 사용자와 상호작용 없이 일련의 작업들을 묶어 일괄적으로 처리하는 방법

## 배치 프로그램 유형
1. `이벤트 배치` : 사전에 정의된 조건이 충족될 때 실행
2. `온디맨드 배치` : 사용자의 요구가 있을 때 실행
3. `정기 배치` : 정해진 시점에 실행

## 배치 스케줄러
* 배치(일괄 처리)를 위해 반복적인 작업을 지원하는 도구

## 배치 스케줄러 종류
1. 스프링 배치 : 스프링 프레임워크에서 사용하는 스케줄러
2. 쿼츠 스케줄러 : Job과 Trigger를 분리하는 오픈 소스 스케줄러

## 쿼츠 크론 표현식
* 스케줄러에서 배치 수행시간을 설정하기 위한 표현식<br><br>

# SW 개발 보안 3대 요소
1. `기밀성` : 인가되지 않은 접근에 정보 노출을 차단하는 특성
2. `무결성` : 정당한 방법으로만 데이터를 변경할 수 있으며, 데이터의 정확성을 보장하는 특성
3. `가용성` : 권한을 가지고 있으면 서비스를 지속해서 사용할 수 있도록 하는 특성

## SW 개발 보안 용어
1. 자산
2. 위협
3. 취약점
4. 위험<br><br> 

# 해킹 종류
* DRDos 공격 : 공격대상이 반사 서버로부터 다량의 응답을 받도록 하는 공격
* DDos 공격 : 여러 대의 공격자를 분산 배치 후 동시에 동작시키는 DoS 공격(대역폭 소진 공격 & 서비스 마비 공격)
* UDP 플러딩 : 대량의 UDP 패키지를 임의의 포트번호로 전송하지만 응답 메시지는 공격자에 정달되지 않아 자원을 고갈시키는 공격
* SYN 플러딩 : ACK를 발송하지 않고 SYN 패킷만 보내 점유하여 자원을 고갈시키는 공격
* 죽음의 핑 : ICMP 패킷(핑)을 아주 크게 만들어 과부하시키는 공격
* 스머프/스머핑 : 출발지 IP를 공격 대상의 IP로 변조하여 브로드캐스팅으로 ICMP Echo 패킷 요청을 보내 과부하시키는 공격
* 티어 드롭 : 조작된 IP 패킷 조각을 보내 재조립 과정에서 오류를 발생시키는 공격
* 랜드 어택 : 출발지 IP와 도착지 IP를 같은 주소로 만들어, 자기 자신에게 응답을 보내도록 하는 공격
* 봉크/보잉크 : IP 패킷의 재전송, 재조합 과정에서 오류를 발생시키는 공격(봉크 : 같은 시퀀스 번호 / 보잉크 : 시퀀스 번호에 빈 공간)
* Slow HTTP Read Dos : TCP 윈도 크기와 데이터 처리율을 감소시킨 뒤 다량의 HTTP 요청을 보내는 공격
* Slow HTTP Header Dos : =Slowloris. 헤더 정보를 조작하여 웹 서버가 온전한 헤더정보가 올 때까지 기다리게 하는 공격
* Slow HTTP Post Dos : =RUDY. 헤더의 Content-Length를 아주 크게 만들고 데이터를 아주 소량으로 보내 연결을 유지하게 하는 공격
* HTTP GET 플러딩 : 과도한 GET 메시지를 통해 과부하시키는 공격(캐싱서버가 아닌 웹 서버가 직접 처리하도록 유도)
* Hulk Dos : 공격자가 공격대상의 URL을 계속 변경하면서(=차단 정책 우회) 다량의 GET 요청을 보내는 공격
* Hash Dos : 웹 서버의 해시 테이블에 해시 충돌을 일으켜 자원을 소모시키는 공격
* Dos 공격 : 시스템의 자원을 고갈시켜 서비스 거부를 유발하는 공격
* 스니핑 : 공격대상에 직접 공격을 가하지 않고 몰래 정보를 들여다보는 수동적인 공격 기법
* 패스워드 크래킹
    1. 사전 크래킹 Dictionary Cracking : IP/PW가 될 가능성이 있는 단어를 대입하는 공격
    2. 무차별 크리킹 Brute Force Cracking : PW로 사용될 수 있는 문자를 무작위로 대입하는 공격
    3. 패스워드 하이브리드 공격 Password Hybrid Attack : 사전 + 무차별을 결합하여 공격
    4. 레인보우 테이블 공격 Rainbow Table Attack : 크래킹하려는 해시값을 테이블에서 검색하는 공격
* 네트워크 스캐너/스니퍼 : 공격자가 취약점을 탐색하는 도구
* ICMP Redirect 공격 : ICMP Redirect 메시지를 공격자가 원하는 형태로 위조해 패킷을 스니핑하는 공격
* IP 스푸핑 : IP를 위조하여 인증된 시스템인 것처럼 IP를 위조하여 목표 시스템의 정보를 빼내는 공격
* ARP 스푸핑 : MAC 주소를 위장하여 패킷을 스니핑하는 공격
* 트로이 목마 : 겉으로는 정상적이나 실행하면 악성코드가 실행되는 프로그램
* 버퍼 오버플로우 공격 : 메모리의 버퍼 크기를 초과하는 데이터를 입력해 프로세스 흐름을 변경시키는 공격 기법
    * 버퍼 오버플로우 공격 대응
        1. 스택가드 (활용 : 카나리(무결성 체크용 값)를 미리 삽입해 두고 버퍼 오버플로우 발생 시 카나리값을 체크해 변한 경우 복귀 주소를 호출하지 않음)
        2. 스택쉴드 (활용 : 함수 시작시 복귀주소를 특수 스택에 저장해 두고 함수 종료시 스택 값을 비교해 다를 경우 오버플로우로 간주하고 중단)
        3. ASLR (활용 : Address Space Layout Randomization; 주소 공간 배치 난수화. 주소 공간 배치를 난수화하여 실행 시마다 메모리 주소를 변경시키는 것)
        4. 안전한 함수 사용 : 버퍼오버플로우에 취약한 scanf() 대신 fscanf() 등을 사용
        5. 실행 제한 : 스택에서의 쓰기 권한 제한 등
* 스택 버퍼 오버플로우 공격 : 스택 영역(지역변수, 매개변수가 저장되는 영역)의 버퍼에 오버플로우를 일으켜서 복귀주소를 바꾸는 공격 기법
* 힙 퍼버 오버플로우 공격 : 힙 영역(사용자가 직접 관리 가능한 메모리 영역)의 버퍼에 오버플로우를 일으켜서 데이터를 오염시키는 공격 기법
* 포맷 스트링 공격 : 포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격
* 키로거 공격 : 키보드 움직임을 탐지해 주요정보를 빼가는 공격
* 루트킷 : 불법 해킹에 사용되는 기능을 제공하는 프로그램 모음
* 백도어 : 정상적인 인증절차를 우회하는 기법
* 레이스 컨디션 공격 : 프로세스가 임시 파일을 만들 때 실행 중에 끼어들어 임시파일을 심볼릭 링크하는 공격
* 스피어피싱 : 특정 대상 선정 후, 일반적인 메일로 위장한 메일을 발송해 개인정보를 탈취하는 공격
* 스미싱 : SMS + 피싱. 문자메시지를 통해 개인정보를 탈취하거나 소액결제를 유도하는 공격
* 공급망 공격 : SW 개발사의 코드를 수정하거나 배포 서버에 접근해 파일을 변경하는 공격
* 큐싱 : QR코드 + 피싱. QR을 이용한 피싱 공격
* APT 공격 : 특정 대상을 목표로 한 지능적/지속적인 공격
* 봇넷 : 악성 프로그램에 감염된 컴퓨터들이 네트워크로 연결된 형태
* 악성 봇 : 해커의 명령에 의해 원격으로 제어되는 프로그램(DDos 등에 악용)
* 웜 : 스스로를 복제하여 전파하는 악성 프로그램
* 제로데이 공격 : 보안 취약점이 공표되기 전 신속히 이뤄지는 공격
* 이블 트윈 공격 : 합법적인 Wifi 제공자처럼 행세하며 연결된 사용자 정보를 탈취하는 공격 
* 랜섬웨어 : 암호화 후 복호화를 위해 돈을 요구하는 악성 소프트웨어
* Tcpdump : 스니핑 도구(패킷 내용을 출력하는 프로그램)<br><br>

# 암호화 알고리즘 방식
1. 대칭 키 암호 방식
    * 블록 암호
        * DES
        * 3DES
        * AES
        * SEED
        * ARIA
        * IDEA
    * 스트림 암호
        * LFSR
        * RC4
2. 비대칭 키 암호 방식
    * 디피-헬만
    * RSA
    * ECC
    * Elgamel
3. 해시 암호 방식
