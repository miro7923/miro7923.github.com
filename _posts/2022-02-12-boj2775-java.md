---
title: Java) BOJ 2775. 부녀회장이 될테야
toc: true
toc_sticky: true
toc_label: 목차
published: true
categories:
    - BOJ
tags:
    - Algorithm
    - BOJ
    - No2775
    - Math
    - Java
---

# 문제 링크
* [https://www.acmicpc.net/problem/2775](https://www.acmicpc.net/problem/2775)<br><br>

# 문제
* 평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.
 * 이 아파트에 거주를 하려면 조건이 있는데, 
 * “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.
 * 아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 
 * 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 
 * 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.<br><br>
 
# 제한
* 시간 제한 : 1 초
* 메모리 제한 : 128 MB<br><br>

# 입력
* 첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다.<br><br>

# 출력
* 각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.  <br><br><br>

# 👀 풀이
* 문제 이해를 잘못 한건지 틀리게 구현한 거 같아서 긴가민가 하면서 냈는데 맞았다...
 * 문제를 다시 읽어보니까 k-1층까지의 누적합이 아니고 k-1층에서의 누적합만 구하면 되는 것이었네... 😅<br><br>
 
 * 기본적인 접근은 DP로 했다.
 * k층에 사는 사람들의 합계는 구할 필요가 없이 k-1층에 사는 사람들 중 n번째 집에 사는 사람들까지의 누적합계만 구하면 되기 때문에
 * [k][n]에 사는 사람들의 수는 [k-1][1] + [k-1][2] + [k-1][3] + ... [k-1][n]이 된다.
 * 그런데 층수가 올라가면서 이전 층의 데이터가 필요하기 때문에 이 데이터들을 저장할 장소가 필요하니까 2차원 배열을 만들어서 반복문으로 위의 식을 구현한 후 2차원 배열의 [k][n] 인덱스의 원소값을 출력했다.<br><br>
 
## ☑️ 결과
* 메모리 : 14208 kb
* 시간 : 132 ms<br><br>

# 코드

<script src="https://gist.github.com/miro7923/66534b8b1a9d1704a0721688ccb0aab9.js"></script>
