var store = [{
        "title": "컴퓨터 사이언스란",
        "excerpt":"컴퓨터 사이언스란?  컴퓨터 사이언스의 기원      컴퓨터 사이언스는 컴퓨터라고 하는 기기에 대한 연구라고 할 수 있다.    컴퓨터 사이언스의 현대적인 기원은 1940년대에 최초로 출현한 디지털 컴퓨터들의 등장과 1930년대에 이와는 별도로 형성된 계산기기들에 대한 적절한 수학적 모델에 있다고 할 수 있다. 컴퓨터는 그 전까지는 수작업으로 하던 덧셈과 뺄셈같은 계산들을 좀 더 빠르면서 정확하게 처리하고자 만든 장치에서 시작되었기 때문이다.      컴퓨터 사이언스의 정의      물리학은 에너지와 많은 관련성을 갖는 학문이다. 반면, 컴퓨터 사이언스는 정보의 표현, 저장, 조작 및 검색과 밀접한 관계를 갖는 학문이다.   물리학이 에너지 변환장치를 이용하는 것처럼, 컴퓨터 사이언스는 정보변환장치를 이용한다.         컴퓨터 사이언스에서는 정보가 중요하고 그것이 차지하는 비중이 크기 때문에 컴퓨터 사이언스를 정보과학(Information Science)이라고도 한다. 컴퓨터 사이언스는 여러 가지 서로 다른 측면에서 정의할 수 있다.      1. 기기 중심      문제를 해결하기 위한 도구로서의 정의. 컴퓨터 기기와 이를 둘러싼 질문들, 즉 컴퓨터를 어떻게 설계하고 분석하고 구축하고 사용할 것인가 하는 것에 초점이 모아진다.     2. 정보 중심      컴퓨터에게 정보(데이터)의 개념과 처리는 중요하다. 정보 중심 관점에서는 데이터의 표현, 저장, 구성, 전송 및 처리에 관한 질문으로 귀결된다.     3. 프로그램 중심      프로그램이란 어떤 문제를 풀기 위한 컴퓨터 명령어들의 집합이다. 프로그램 중심 관점에서 본다면 컴퓨터 사이언스는 프로그래밍에 관한 연구라고 할 수 있다. 그렇기 때문에 이 관점에서는 프로그램 표현을 위한 적절한 언어의 선택, 프로그램의 정확성과 효율성, 프로그램의 실행을 위한 기계, 그리고 프로그래밍 기술 등과 같은 프로그래밍에 관한 문제점들을 강조한다.     4. 알고리즘 중심      알고리즘이란 문제 해결을 위한 작업이 어떻게 수행되는지를 정의하는 단계들의 집합니다. 컴퓨터는 알고리즘을 구현하는 기계이고, 정보는 알고리즘이 만들어내는 대상이며, 프로그래밍은 알고리즘을 기술하는 수단이다. 알고리즘 중심 관점에서 본다면 컴퓨터 사이언스는 알고리즘에 관한 연구라고 할 수 있다.       👉 이와 같이 컴퓨터 사이언스는 컴퓨터의 설계, 컴퓨터 프로그래밍, 정보 처리, 알고리즘 문제 해결, 알고리즘 처리 자체 등과 같은 다양한 분야에 대한 과학적인 기초를 제공하는 학문이라 할 수 있다.     컴퓨터 사이언스의 주요분야      컴퓨터 구조    시스템 소프트웨어    프로그래밍 언어    데이터베이스    데이터통신    컴퓨터 네트워크    인공지능    소프트웨어 공학      컴퓨터 사이언스의 발전   1. 컴퓨터의 멀티미디어화      대용량의 사운드, 그래픽, 비디오 등을 지원하는 멀티미디어 PC가 보편화되면서 이에 따라 주변기기들의 성능도 멀티미디어를 잘 처리할 수 있는 수준으로 고성능화, 고용량화되고 있다.     2. 컴퓨터의 네트워크화      인터넷의 보급으로 클라이언트/서버 환경의 확대가 가속화되고 네트워크를 통한 정보의 교환이 급속히 늘어나면서 네트워크 환경에 알맞은 컴퓨터 기술과 더불어 더욱 고급화, 지능화되는 네트위크 기술의 개발과 연구가 가속화 되고 있다.     3. 모바일 컴퓨팅의 확산      노트북, PDA, 스마트폰 등 휴대할 수 있는 모바일 컴퓨터들이 확산되고 있는 것에 따라 무선 기술 및 관련 컴퓨팅 기술의 개발과 연구가 확대되고 있다.     4. 컴퓨터의 임베드화      컴퓨터 기술과 가전기기가 접합된 시스템을 임베디드(embedded) 시스템이라 한다. TV에 인터넷 접속 기능이 결합된 경우가 대표적이라 할 수 있다.    5. PC의 고성능화      클러스터링 기법을 활용한 병렬처리 컴퓨터 기술이 접합될 경우 지금의 서버 수준을 뛰어 넘는 고성능 PC가 개발될 것이다.    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-01/",
        "teaser": null
      },{
        "title": "컴퓨터는 무엇일까?",
        "excerpt":"컴퓨터는 무엇일까?  컴퓨터의 정의      컴퓨터(Computer)란 지금까지 사람이 해 왔던 기억과 계산 등의 일을 빠르고 정확하게 처리해 주는 기계이며, 사람의 지시에 따라 여러 가지 일을 자동적으로 처리해주는 전자 장치이다.    컴퓨터라는 명칭 자체가 계산하다 라는 뜻인 compute에서 확장된, 계산해주는 사람(혹은 장치)이라는 뜻의 computer에서 유래되었다.    초기의 컴퓨터는 단순 수치 계산을 목적으로 만들어졌지만 오늘날의 컴퓨터는 수치 계산 뿐만 아니라 기억, 분류, 비교하는 것과 같은 여러 가지 일들을 한꺼번에 처리할 수 있다.     외부로부터 입력된 자료를 정의된 방법에 따라 자료를 처리하여 정보를 생성하고, 사용자에게 생성된 정보를 출력해 주는 기능을 가지고 있다.     컴퓨터의 기능   1. 입력 기능      처리할 데이터와 처리 방법 그리고 절차를 지시하는 프로그램을 외부로부터 읽어들여 기억 장치로 전달해 주는 기능     2. 기억 기능      읽어 들인 데이터와 절차를 지시하는 프로그램들과 처리된 결과 등을 기억 장치에 기억시키는 기능     3. 연산 기능      데이터를 기억 장치에 기억된 프로그램을 통해서 산술 연산과 논리 연산을 하여 결과를 만들어 내는 기능     4. 제어 기능      기억된 프로그램들의 명령을 하나씩 읽고 해석하여 컴퓨터 각각의 기능이 유기적으로 동작하도록 장치들을 제어하고 지시하는 기능     5. 출력 기능      컴퓨터 내에 기억된 내용과 처리된 결과를 문자, 도형, 음성 등의 형태로 외부에 보여주는 기능    컴퓨터의 기능 중에서 기억과 제어 그리고 연산 기능은 가장 핵심적인 것으로서 주기억장치(Main Memory)와 중앙처리 장치(Central Processing Unit : CPU)에서 이루어진다.      컴퓨터의 특징   1. 신속성      자료를 주어진 시간 내에 빠르고 신속하게 처리한다.     2. 정확성      계산 시에 에러나 오차를 최소화하고 정확하게 계산하고 판단한다.     3. 자동성      입출력을 비롯한 전체 처리 과정을 자동적으로(프로그램 된 대로) 처리한다.     4. 대량성      대량 데이터의 처리가 가능하고 대량 데이터의 저장이 가능하다.      컴퓨터의 필요성      과학 기술의 발달과 산업 사회의 급격한 변화로 새로운 정보를 신속하게 수집, 분석, 활용할 필요성이 생겼다.    사회 현상이 복잡하고 다양해짐에 따라 처리할 데이터 양이 기하급수적으로 증가하였다.    가상 현실이나 모의 실험을 활용하여 위험 부담을 줄일 수 있기 때문이다.    편리한 생활을 위한 기계 및 전자 장치들을 제어하기 위해 컴퓨터가 필요하게 되었다.    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-02/",
        "teaser": null
      },{
        "title": "컴퓨터의 역사",
        "excerpt":"컴퓨터의 역사   1. 초창기 계산기      학교 다닐 때 배웠던 근대 문학에서 흔히 등장하는 주판이 있다. 주판은 지금 쓰는 전자식 계산기가 보급되기 전 계산을 할 때 쓰던 도구이다.    주판이 규칙에 따라 문제를 풀 수 있는 장치인 것을 알고 있는 중세와 근대의 유럽인들은 이러한 규칙을 기계 장치에 집어넣으면 계산을 자동화할 수 있지 않을까 하는 발상에서 톱니 계산기를 발명하게 된다.    최초의 기계식 계산기는 1642년에 파스칼이 고안한 장치였다. 이 장치는 손잡이와 이에 딸린 톱니바퀴가 일정한 비율로 배열되어 손잡이를 좌우로 돌리는데에 따라 덧셈과 뺄셈이 자동으로 수행되는 장치였다.     이후 라이프니츠가 만든 계산기는 덧셈과 뺄셈 이외에도 곱셈과 나눗셈, 간단한 제곱근까지도 계산이 가능했다고 한다.     2. 근대 계산기      초창기 계산기들은 손으로 수치를 일일이 입력해야 하는 것이 큰 단점이었다. 그래서 19세기 들어 입력 방식을 보완한 근대적 계산기가 탄생하게 된다.    구멍이 뚫려 있는 천공 카드(punched card)를 이용해서 카드에 뚫린 구멍의 순서에 따라 톱니가 물려 입력 순서를 정하게 되는 방식을 이용해 입력 방식을 보완한다.     찰스 바베지는 증기 기관으로 작동되는 수식 계산 기계인 차분 엔진(difference engine)과 업그레이드 판인 해석 엔진(analytical engine)을 설계한다. 하지만 완성하지는 못했다.    찰스 바베지와 함께 프로젝트를 진행했었던 에이다는 세계 최초의 여성 컴퓨터 과학자로 기록되었으며, 병렬 처리 프로그래밍 언어로 유명한 Ada는 그녀의 이름을 딴 것이다.     3. 현대식 컴퓨터      현대식 전자 컴퓨터는 국방 분야에서 자동화를 위해 많은 인력과 자본을 투입해 개발한 것에서 시작되었다.     최초의 전자식 계산기의 토대는 2차 세계대전 기간에 만들어져, 2차 세계대전이 끝나고 1950년대 말부터 일반 사무용으로 보급된다.      1) 0세대      최초의 컴퓨터라 할 수 있는 ENIAC(Electronic Nemerical Integrator And Computer)이 개발되었다.   초당 5번의 곱셈이 가능했지만 지금의 컴퓨터와는 다르게 설계에 따라 한 문제만 풀 수 있었고 다른 문제를 풀게 하려면 진공관 회로의 배치를 바꿔줘야 했다.   당시 컴퓨터는 덩치가 아주 크고 진공관 수는 약 2만여개였기 때문에 배치를 바꾸는 데에 몇 주가 소요되었다. 그리고 전력도 많이 들고 진공관 고장도 잦고 효율적이지 않았기 때문에 현대 컴퓨터의 아버지라 불리는 존 폰 노이만이 새로운 방식을 고안해 낸다.     이 방식이 지금 우리에게 익숙한 소프트웨어 방식이다. 저장 프로그램 개념으로 컴퓨터 프로그램을 처리해야 할 데이터의 일부로 규정하여 이를 기억 장치에 저장해 놓고 반복적으로 이용 가능하도록 한 방식이다.    이 시기에는 0과 1로 이루어진 기계어가 프로그래밍 언어로 사용되었다.     2) 1세대 컴퓨터(1950년대)      0세대 컴퓨터는 연구와 국방 목적으로 이용되었지만 이것을 상업적으로 판매할 수 있을거라 생각한 사람들에게서 1세대 컴퓨터가 시작된다.   최초의 1세대 컴퓨터는 UNIVAC(Universal Automatic Computer)으로 입력 장치로 천공 카드를 이용하고 내부 계산 장치로 진공관을 이용하도록 설계되었다.    하지만 진공관 컴퓨터는 전력을 많이 소모하면서 속도가 느리고 가격이 비쌌다. 그리고 작동시키려면 0과 1로 이루어진 이진법 기계어에 익숙한 전문가가 필요했기 때문에 여전히 대중화되지는 못했다.    이 시기에 들어서면서 기계어를 인간이 인식할 수 있는 문자로 대치해서 쓰는 어셈블리어가 개발되었다.     3) 2세대 컴퓨터(1959년대 말 ~ 1960년대 초)      진공관의 단점인 크기, 전력 소모, 열 발생의 문제들이 해결된 트랜지스터가 개발된다.   트랜지스터를 이용해서 진공관 컴퓨터와 같은 원리로 동작하는 컴퓨터를 만드는 것이 가능했기 때문에 트랜지스터 컴퓨터가 개발되면서 컴퓨터의 처리 속도가 획기적으로 빨라지게 된다. 하지만 여전히 입력 수단으로는 천공 카드를 사용하고 있었는데 천공 카드의 입력 속도가 처리 속도에 비해 느려서 컴퓨터가 벌써 일을 다 끝내고 입력을 하염없이 기다리고 있게 된다.    이를 해결하기 위해            **병렬 처리(parallel processing) 기법** : 여러 개의 프로세서가 입력과 출력 및 연산을 독자적으로 수행하는 것        **멀티프로그래밍(multi-programming) 기법** : 한 개의 프로세서가 서로 다른 여러 개의 프로그램을 번갈아 가면서 처리하는 것    들이 개발되었다.            이 시기에 들어서서 인간이 인식하기 쉬운 언어로 작성한 프로그램을 기계어나 어셈블리어로 번역하는 컴파일러(compiler) 기술이 개발된다. 이에 따라 프로그램을 보다 체계적으로 구성할 필요가 생기면서 구조적 프로그래밍 언어 기법이 도입되었다. 이를 이용해서 우리가 코딩할 때 쓰는 라이브러리 개념이 생긴다.     4) 3세대 컴퓨터(1960년대 중반 ~ 1960년대 말)      3세대 컴퓨터 시기에 들어오면서 트랜지스터와 동일한 원리로 작동되지만 하나의 작은 실리콘 조각 위에 여러 개의 트랜지스터와 전자회로를 포함한 **집적회로(IC : Integrated Circuit) **가 개발된다.   집적회로는 비용을 크게 줄였기 때문에 보다 저렴하면서 강력한 성능을 가진 컴퓨터의 제작이 가능해졌다.    다중 처리와 다중 프로그래밍이 중요해졌으며 시분할 처리 시스템(Time Sharing System)이 생겨난다.     5) 4세대 컴퓨터(1970년대 초 ~ 1980년대 말)      집적회로가 더욱 발전되어 하나의 집적회로에서 연산, 제어, 기억 등의 프로세서의 모든 기능을 단순하게나마 수행할 수 있는 **마이크로프로세서**가 개발된다.   마이크로프로세서를 이용해 만든 개인용 마이크로 컴퓨터가 폭발적인 인기를 끌면서 컴퓨터의 설계는 마이크로프로세서 중심으로 개편된다.    이 시기부터 GUI(Graphical User Interface)가 개발되어 컴퓨터에 대한 지식이 없어도 쉽게 사용할 수 있게 된다.     6) 5세대 컴퓨터(1990년 ~ 현재)      데스크톱 말고도 랩탑과 팜탑 컴퓨터의 출현과 보조 기억 장치(CD-ROM, DVD 등)의 개선과 멀티미디어의 사용, 가상현실 등이 주요 특징이다.    객체지향언어와 프로그래밍이 각광받기 시작했으며 인터넷이 등장했다.     7) 미래의 컴퓨터 기술      병렬 처리 기술이 더욱 두드러지고 대용량의 주변기기들과의 접목을 통해 컴퓨터의 멀티미디어화가 더욱 가속화 될 것이다.    착용식 컴퓨터, 광 컴퓨터, 양자 컴퓨터, 바이오 컴퓨터 등과 같은 새로운 형태의 컴퓨터들이 출현할 것으로 기대된다.    인공지능(AI)이 더욱 발전되어 사람처럼 생각하고 행동하는 소프트웨어가 개발될 것으로 예상된다.    유비쿼터스 컴퓨팅이 보편화 되어 사용자가 네트워크나 컴퓨터를 의식하지 않고 장소에 상관없이 자유롭게 네트워크에 접속할 수 있는 정보통신 환경이 형성됨으로써 컴퓨팅의 사용성을 극대화한 사용자 중심의 중단없는 컴퓨팅 환경이 제공될 것으로 예상된다.   ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-03/",
        "teaser": null
      },{
        "title": "컴퓨터의 분류",
        "excerpt":"컴퓨터의 분류    1. 사용 목적에 따른 분류   1) 특수용 컴퓨터      한 가지 작업만을 처리할 수 있도록 설계되고 만들어진 컴퓨터     2) 범용 컴퓨터      여러 분야에서 다양한 일을 할 수 있도록 설계된 컴퓨터    일반적인 자료 처리는 물론이고 프로그램을 교체하여 다른 작업에 이용할 수 있다.    연구, 기업업무용으로 주로 사용되어 우리가 흔히 아는 개인용 컴퓨터와는 약간 다르다.     3) 개인용 컴퓨터      개인의 업무를 처리하도록 설계된 컴퓨터    우리가 흔히 볼 수 있는 컴퓨터로 교육용, 가정용, 기업용 등으로 널리 보급되어 있다.      2. 데이터 표현 방식에 따른 분류   1) 디지털 컴퓨터      일반적으로 생각하는 컴퓨터    이산적(discrete, 연속적이지 않다)인 형태로 이용한다.    시간에 따른 연속적인 변화량을 정해진 시간에 측정된 수치로 기억한다. 연결된 것처럼 보일만큼 작은 단위로 쪼개서 기억한다고 볼 수 있다.     2) 아날로그 컴퓨터      연속적인 자료를 이용하여 물리적인 유사성으로 변수나 양을 표현하고 이를 수학적으로 분석한 물리적 상태를 흉내 내는 방식으로 작동한다.    거리, 속도, 가속도, 온도, 압력 등의 물리량을 전압이나 전류의 양으로 대치하고 기계적 또는 전자적으로 동등한 회로에서 작동시킨 결과를 이용하는 방식이다.     3) 하이브리드 컴퓨터      변환기를 통해 아날로그 형태로 입력된 데이터를 디지털 형태로 변환하여 처리한 후 결과를 디지털 형태나 다시 아날로그 형태로 변환하여 출력할 수 있다.      3. 처리 용량에 따른 분류      현재는 크기와는 별도로 컴퓨터의 처리 속도에 따른 분류를 주로 사용한다.     1) 슈퍼 컴퓨터      가장 빠르고 가장 가격이 비싼 컴퓨터를 총칭하는 용어이다.    항공 우주, 입자물리와 화학, 전자, 자동차 및 석유 탐사 분야와 기상 예측, 지진 분석, 유전자 분석 등 시간이 오래 걸리는 복잡한 수학 공식을 반복적으로 방대한 분량을 계산하는 과학 기술 분야에서 주로 사용된다.    10기가 플롭스 이상의 속도를 가지고 있는 컴퓨터가 슈퍼 컴퓨터의 범주에 포함된다.     2) 메인프레임 컴퓨터      대규모 회사에서 주로 사용하는 컴퓨터    계산의 양보다는 입력과 출력되는 데이터의 양이 많은 경우에서 주로 사용된다.    다중 사용자(multi-user) 시스템     3) 미니 컴퓨터      메인프레임 컴퓨터보다 저렴하면서 메인프레임 컴퓨터와 유사한 기능을 이용할 수 있는 컴퓨터    약 200명 정도의 동시 사용자를 지원해주는 시스템을 가지고 있다.    메인프레임 컴퓨터의 하위 호완버전이라고 생각하면 된다.    다중 사용자(multi-user) 시스템     4) 워크스테이션과 마이크로 컴퓨터      단일 사용자(single-user) 시스템     4-1) 워크스테이션      * 강력한 계산, 고성능의 그래픽 디스플레이를 필요로 하는 공학자와 건축가, 그 외의 여러 분야의 전문가들의 작업에 적합하도록 설계된 데스크탑 컴퓨터     4-2) 마이크로 컴퓨터      * 우리가 흔히 볼 수 있는 데스크탑 컴퓨터      * 현재 많은 사람들이 사용하는 개인용 컴퓨터(PC)는 마이크로프로세서를 이용한 마이크로 컴퓨터를 뜻한다.     5) 휴대형 컴퓨터   5-1) 랩탑 컴퓨터      * 3~4kg 정도의 무게에 무릎 위에 올려놓고 사용할 수 있는 컴퓨터     5-2) 노트북 컴퓨터      * 우리가 흔히 사용하는 노트북     5-3) 팜탑 컴퓨터      * 처리해야 할 작업의 종류가 다양하지 않고 노트북을 휴대하는 것조차 부담스러운 이용자들을 위해 개발된 컴퓨터      * 대표적인 것이 PDA로 약속 시간 관리 및 전화 번호부, 메모장 등의 용도로 한정되어 있다. 최근에는 무선 및 유선 통신 기능을 추가하여 근로용 단말기로도 이용되고 있다.     5-4) 스마트폰      * 우리가 흔히 사용하는 스마트폰      * 다양한 기능 수용을 위해서 iOS, 안드로이드와 같은 표준화된 전용 운영체제를 갖추고 있다.     5-5) 태플릿 PC      * 아이패드와 같은 태블릿      * 일반 업무용과 개인 멀티미디어 기기로 활용하며, 프레젠테이션, 교육, 모바일 네트워크 기기로 활용    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-04/",
        "teaser": null
      },{
        "title": "데이터의 표현과 연산",
        "excerpt":"데이터의 표현과 연산    1. 컴퓨터의 수 체계      우리는 10진수를 사용하지만 컴퓨터는 0과 1로 모든 것을 판단하기 때문에 2진수를 사용한다.    컴퓨터의 연산과 제어의 기본은 부울대수이며, 컴퓨터가 다루는 데이터를 2진 숫자(Binary digIT)라고 하며 약자로 비트(BIT)라고 한다.    8개의 비트를 한 단위로 하여 1바이트(byte)로 사용한다.    2진수의 최상위 비트를 MSB(most significant bit)라 하고 최하위 비트를 LSB(least significant bit)라 한다.     2. 데이터의 표현   1) BCD 코드      Binary Coded Decimal의 약자로 8421 코드라고도 한다.    BCD 코드는 각 비트 자리가 자리값을 갖는데 1010이라는 4자리 비트가 있다고 했을 때 왼쪽(10진수로 생각할 때 1000의 자리)부터     2^3 = 8    2^2 = 4    2^1 = 2    2^0 = 1    의 값을 가지므로 8421코드라 부른다.     일반적으로 10진수를 2진수로 표현하는 것과 비슷하지만 10이 넘어가면 2진수는 1010이라고 표현하지만 BCD 코드는 0001 0000, 11은 0001 0001 … 와 같은 방식으로 표현한다.     2) 문자 데이터      문자 데이터는 1바이트의 데이터이다. 아스키코드의 문자 ABC를 2진법과 16진법으로 나타낸다면 다음과 같이 된다.                   문자       2진법       16진법                               A       0100 0001       41H                         B       0100 0010       42H                         C       0100 0011       43H                    3) 존(Zone) 형식      언팩(unpack) 형식이라고도 하며, 1바이트에 한 개의 10진수가 저장된다. 1바이트의 왼쪽 4비트를 존(zone) 비트라고 하며 항상 F(16진수)가 들어 있다.                   2진수       1111       0111       1111       0001       1100       0010                               16진수       F       7       F       1       C(양수)       2                      10진수를 712로 표현한다면 위와 같이 표현되는데 마지막 바이트의 왼쪽 4비트를 이용해서 부호를 나타낸다. 위와 같은 경우처럼 마지막 바이트의 왼쪽 4비트가 C라면 양수고                   2진수       1111       0111       1111       0001       1101       0010                               16진수       F       7       F       1       D(음수)       2                      위처럼 D라면 음수로 -712가 된다.     4) 팩(Pack) 형식      수치를 표현하는 4비트의 BCD를 1바이트에 2개를 나타내며 10진수 숫자 2개를 표시한다. 존 형식이 절반으로 줄어든 형태라고 보면 된다.                   2진수       0111       0001       0010       1100                               16진수       7       1       2       C(양수)                                  2진수       0111       0001       0010       1101                               16진수       7       1       2       D(음수)                    5) 고정 소수점 형식      고정 소수점 형식은 소수점 위치가 가장 오른쪽 끝에 고정되어 있다고 가정하는 것으로 전체의 수를 정수로 표현한다. 가장 왼쪽의 비트는 부호를 표시하며 0이면 +양수, 1이면 -음수를 나타낸다. 데이터 길이를 n이라고 했을 때 -(2^n-1 - 1) ~ (2^n-1 - 1)의 범위를 나타낼 수 있다.    고정 소수점은 BCD 코드에 비해서 명령 속도가 빠르다.     6) 부동 소수점 표현      아주 큰 수나 아주 작은 수를 표현한다든지 아니면 높은 정도(precision)로 취급할 때 많이 쓰인다. 유효숫자만을 나타내는 소수부(fraction part)와 소수점의 위치를 나타내는 지수부(exponent part)로 구분한다. 10^-78 ~ 10^74의 범위까지를 나타낼 수 있다.      3. 보수 연산      보수(complement)란 어떤 기준이 되는 수를 설정했을 때 그 수에 모자라는 수를 말한다. x에 대한 9의 보수는 9로부터 x를 뺀 것인데, 6에 대한 9의 보수는 3이고 2에 대한 10의 보수는 8이다.    보수 연산은 뺄셈을 할 때 9의 보수를 사용하는 방법과 1의 보수와 2의 보수를 사용하는 방법 등이 있다.      4. 정보 교환용 코드      정보 교환용 코드는 국제표준화기구(ISO)에 의해 정해지고 이것에 준해서 각국에서 정하여 사용하고 있다. 컴퓨터 대 컴퓨터시스템간의 통신을 단순화하고 표준화하기 위해 만들어졌다.     대표적인 것으로 프로그래밍을 할 때 자주 쓰는 아스키(ASCII)코드가 있다.   산업 표준으로 전세계 모든 문자들을 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 유니코드(Unicode)가 제정되어 사용되고 있다.     ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-05/",
        "teaser": null
      },{
        "title": "부울대수",
        "excerpt":"부울대수    1. 부울대수의 개요      부울대수(Boolean algebra)는 논리적 관계의 문제를 다룰 때 대수 형식으로 표시하며, 여러가지 논리회로를 설계하거나 같은 기능을 갖는 논리 회로를 간략화하는 데 사용된다.   인간의 지식이나 사고를 참, 거짓으로 공식화하고 이를 수학적으로 해석하기 위한 것으로 논리대수라고도 한다.    주로 컴퓨터의 회로 설계 등에 이용되고 있으며 “0”과 “1”의 두 개의 수치만을 사용하여, 연산의 결과는 언제나 0 또는 1로 표한된다.      2. 논리회로      논리회로는 2가지 상태를 다루는 방법으로 컴퓨터에서 사용되는 방법이다. NOT, AND, OR 3가지의 기본논리회로의 조합으로 구성된다.      1) NOT 회로      인버터(inverter)라고도 한다. 입력이 1개로 구성된 것으로 입력신호와 반대되는 출력을 내놓는다.    입력신호가 1이면 출력은 0, 입력신호가 0이면 출력은 1     2) AND 게이트      두 입력이 모두 1일 때 출력이 1이 되고 그 외에는 모두 0이 출력된다.     3) OR 게이트      입력신호 중 어느 하나 또는 두 개가 모두 1일 때 1이 출력된다.     4) 부정논리곱      AND와 NOT 회로를 결합한 것으로 AND의 결과를 반전한 결과를 얻는다.    두 입력이 모두 1일 때에만 0을 출력하고 나머지는 모두 1 출력     5) 부정논리합      OR와 NOT 회로를 결합한 것으로 OR의 출력이 반전된 결과를 얻는다.     두 입력이 모두 0이면 1을 출력하고 나머지는 모두 0 출력     6) 베타논리합(XOR : exclusive-OR)      두 개의 입력조건이 서로 다르면 1이고, 조건이 같으면 0이 된다.     3. 조합 논리 회로      입력 논리치가 정해지면 출력 논리치가 결정되는 논리회로, AND, OR, XOR 등의 논리가 해당된다.     1) 반 가산기(half adder)      1비트의 2진수 2개를 합하여 그 결과를 한 비트의 합과 한 비트의 올림수로 발생시키는 논리회로     2) 전 가산기(full adder)      반 가산기는 자리 올림수를 더해줄 수 없기 때문에 이것을 보완하여 만든 회로    두 개의 입력과 전 단계에서 발생한 자리 올림수를 더할 수 있도록 구성된 회로    여러 자리의 2진수 덧셈을 위해서는 첫 자리의 덧셈은 반 가산기를 이용하고, 다음 단계부터는 자리 올림수를 더해줘야 하기 때문에 전 가산기를 사용한다.     3) 인코더(encoder)      1게의 입력을 다수의 신호로 변환하여 출력을 얻는 회로로 부호기라고도 한다.    0, 1, 2, … 와 같은 하나의 십진수를 4개의 비트를 이용한 2진수 코드로 변환할 때 사용할 수 있다.     4) 디코더(decoder)      인코더와 반대로 다수의 입력신호로서 1개의 출력신호를 얻는 회로이다.    2진수 코드의 정보를 다른 부호로 바꾸어야 할 때 사용하는 회로로 해독기라고도 한다.     5) 멀티플렉서(multiplexer)      n개의 선택입력에 따라 2^n 개의 입력 중 하나를 선택하여 출력하는 회로로 다중기라고도 한다.    데이터통신 장치에 많이 사용된다.      4. 순서 논리 회로      조합 논리 회로가 입력신호의 조합에 따라 출력값이 결정되었다면 순서 논리 회로는 입력신호의 조합뿐만 아니라 논리회로의 내부 상태에 따라 다르게 출력이 나타난다.     입력 신호에 의하여 상태를 바꾸도록 지시할 때까지 계속적으로 컴퓨터 내부에서 0, 1의 값을 가지는 bit을 기억하고 유지하기 위하여 사용된다.    이런 소자를 플립플롭(Flip-Flop)이라 하며, 정보를 기억하는 레지스터 및 카운터 등의 구성소자에서 사용된다.    @레지스터(register)      CPU의 연산장치와 기억장치 중에서 기억장치에서 읽어내는 정보와 연산결과 등을 일시 기억하는 데 사용된다.    1개의 플립플롭은 1비트의 정보가 기억되기 때문에 n개의 플립플롭을 사용하면 n비트의 정보를 기억하는 레지스터가 된다.    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-06/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 구성",
        "excerpt":"컴퓨터 하드웨어 구성      컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다.    하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다.    중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다.    소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.     컴퓨터 하드웨어의 구성   1) 입력 장치      자료를 컴퓨터에 읽어 들이는 기능을 가지고 있다.    디스크 장치, 테이프 장치, 단말기, 카드 판독기 등이 있다.     2) 기억 장치      주기억 장치와 보조 기억 장치로 나누며, 입력된 자료가 처리될 때까지 일시적으로 기억하거나 연산 결과와 출력할 내용 등을 기억한다.     3) 연산 장치      산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)라고도 한다.    제어 장치의 지시에 따라 전송된 자료를 처리하기 위하여 사칙 연산, 논리 연산, 자리 이동 등의 연산을 수행하는 장치이다.     4) 제어 장치      자료를 처리하는 순서를 저장한 프로그램의 명령어를 해독하여 입력 장치, 기억 장치, 연산 장치, 출력 장치 등을 제어한다.     5) 출력 장치      CPU로부터 출력 결과를 받아서 사람이 알 수 있는 형태로 변환하거나 다른 기억 장치(자기 테이프, 자기 디스크 장치 등)로 전송한다.                   중앙 처리 장치(CPU)       주변 장치                       제어 장치       보조 기억 장치                 주기억 장치       입력 장치                 연산 장치       출력 장치          ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-07/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 기억장치",
        "excerpt":"컴퓨터 하드웨어 기억장치    기억 장치      입력 장치에서 읽어 들인 숫자, 문자, 각종 기호 등의 자료들을 저장하는 장치로 주기억 장치와 보조 기억 장치로 나누어진다.     1) 주기억 장치(main memory unit)      컴퓨터 중앙 처리 장치(CPU)에 위치하며 실행하고자 하는 프로그램이나 자료를 기억시키는 장치     2) 보조 기억 장치(auxiliary storage unit)      주변 장치로서(CPU에 속하지 않음!) 주기억 장치에 필요한 프로그램이나 자료를 보낼 수 있고, 처리된 자료 또는 개발된 프로그램 등을 저장할 수 있다.     3) 기억 장치에서 사용되는 단위      최소 단위는 비트(bit : binary digit)이다.     8개의 비트가 모이면 1바이트가 된다.    1바이트는 영문자 1개를 기억하며 한글 1문자를 저장하는 데엔 2바이트가 필요하다.         1킬로 바이트(KB)는 1,024바이트로 구성되며, 1메가 바이트(MB)는 1,024킬로 바이트이고, 1기가 바이트(GB)는 1,024메가 바이트가 된다.         메모리 셀(memory cell)             **한 소자나 전기회로가 하나의 비트를 저장**하는 데 사용된다.        (0 또는 1) 플립플롭, 충전된 커패시터, 자기테이프 또는 디스크 등을 예로 들 수 있다.             메모리 워드(memory word)             메모리에 있는 비트는 몇 가지 형태의 명령이나 데이터로 표현된다.        예를 들면, 8개의 플립플롭으로 구성된 레지스터는 8비트 워드로 저장되는 메모리로 생각할 수 있다.        워드의 용량은 보통 4~8바이트 사이이다.             바이트(byte)             8비트 워드에 대해 사용되는 용어이다.        항상 8비트로 구성된다.        마이크로컴퓨터에서 가장 일반적인 워드 크기이다.             용량(capacity)             비트들을 저장할 수 있는 공간        메모리에 있어 워드수는 대개 1024의 곱이다.        우리가 흔히 보는 하드 용량 몇 GB는 2^10(1,024), 2^20(1,048), … 와 같이 딱 나눠 떨어지는 10의 배수가 아닌 2의 거듭제곱들이다.             주기억 장치   1) 주기억 장치의 구성      주기억 장치는 수많은 바이트로 구성된다.   입력 장치를 통하여 읽어 들은 자료는 1과 0의 상태가 모아져 바이트 단위로 구성되며 순서에 따라 특정한 장소에 저장된다.         자료를 저장하거나 저장된 자료를 읽기 위하여 각 기억 장소는 고유한 주소를 갖는다.          기억부             주어진 프로그램이나 데이터를 기억해 두는 2진 기억 소자(memory cell)들이 2차원 행렬(matrix)로 구성되어 있다.             메모리 주소 레지스터(MAR : Memory Address Register)             프로그램이나 데이터를 입출력하기 위한 번지를 가지고 있다.             메모리 버퍼 레지스터(MBR : Memory Buffer Register)             입출력하고자 하는 프로그램이나 데이터를 임시 보관하는 레지스터             번지 선택 회로             MAR(메모리 주소 레지스터)에 의하여 기억 장소를 선택하는 회로             제어 회로             기억 장치에 저장하라는 Write 신호와 기억 장치로부터 읽어내리는 Read 신호를 발생시키는 회로        칩이나 모듈 개념으로 여러개로 나누어 구성될 경우 칩 선택 신호나 메모리 모듈 선택 신호가 필요하다.             2) 기억 장치에 저장하는 외부 동작의 순서      기억 장치의 위치(번지)를 MAR(메모리 주소 레지스터)에 넣는다.    프로그램이나 데이터의 비트를 MBR(메모리 버퍼 레지스터)에 넣는다.    입력 신호로 MBR(메모리 버퍼 레지스터)의 내용이 메모리에 저장된다.     3) 기억 장치로부터 읽어낼 때 외부 동작 순서      읽어내려는 프로그램이나 데이터 번지를 MAR에 넣은 후 출력신호를 준다.    메모리의 해당 내용이 MBR로 옮겨져 외부로 출력하게 된다.     4) 어드레스(Address)      메모리에서 한 워드의 위치를 식별하는 주소(숫자)    메모리소자 또는 시스템에 저장된 각 워드는 고유의 주소를 갖는다.    주소는 보통 2진수, 8진수, 16진수로 표현되고, 편의를 위해 10진수로 표현되기도 한다.    메모리에 있는 특정 워드의 위치를 언급할 때마다 그것을 식별하기 위해서 그 위치의 주소코드를 사용한다.    !모든 프로그램은 주기억 장치에서만 실행된다!     그래서 주기억 장치(RAM)의 용량이 클수록 더 많은 정보를 기억하고 실행할 수 있기 때문에 비싸다.     ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-08/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 주기억 장치의 종류",
        "excerpt":"주기억 장치의 종류      컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다.     1. 과거의 주기억 장치     초기        처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다.         1960년대 초반 ~ 1970년대 중반        자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.         기억 원리            코어의 링을 통과하는 도선에 전류를 흘려 ‘플레밍의 오른손 법칙’에 따라 자화의 방향을 바꾸어 준다.       자기 코어는 한 번 1 또는 0의 상태가 되면 어떠한 변화를 주지 않는 한 계속 자화 상태를 유지하여 정보를 기억하게 되고, 여러 개의 코어를 코어판(core plane)의 형태로 묶어서 사용하게 된다.             자화(magnetization)            물질을 자기장 속에 놓았을 때 그 물질 전체가 갖는 거시적인 자기(磁氣)모멘트       물질의 자기적 성질은 주로 전자의 자기모멘트에 연유하는데, 전자가 가진 극히 작은 미시적인 자기모멘트가 많이 모여, 그 총합으로 거시적으로 물질이 나타내는 자기모멘트를 자화라고 한다.             플레밍의 오른손 법칙                N극에서 S극 방향으로 자기장이 형성되었을 때 그림처럼 자기장의 방향과 수직으로 도체(금속 막대 등)가 움직이고 있다면 전류는 가운데 손가락 방향으로 흐른다.       엄지손가락 방향 : 도체를 움직이는 힘(속도)의 방향       두번째 손가락 방향 : 자기장의 방향       가운데 손가락 방향 : 전류가 흐르는 방향           2. 현재의 주기억 장치     1960년대 후반부터 반도체 집적 회로(IC : Integrated Circuit) 기술의 개발과 함께 기억 소자로의 적용이 추진된 후, 1968년에는 주기억 장치의 버퍼 메모리로 사용되기 시작했다.   집적 회로는 집적도, 소비 전력, 소형성, 경제성 등으로 코어 메모리를 대체하여 널리 이용되고 있다.     3. 미래의 주기억 장치     현재보다 크기가 작고, 대용량, 고속의 기억 소자가 사용될 것이라 예상된다.   그 중 하나가 조셉슨 소자(Josephson device)인데, 현재의 기억 소자보다 10배 이상 빠르게 나타나고 있으며 대량 생산과 가격 등의 문제점을 해결하고 있다.   ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-09/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 - 반도체 메모리",
        "excerpt":"반도체 메모리     현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.     메모리의 제조기술적인 분류에 따른 특성   1) 밀도(chip당 bit 용량)  2) 속도  3) 소비전력(bit당 mW)  4) bit당 cost(반도체 제조가격 측면)  5) Noise 면역성     읽기동작(read operation)과 쓰기동작     특별한 메모리위치(주소)에 저장되어 있는 2진 워드가 감지되어 다른 소자에 전달되는 동작   만약 100번 주소에 있는 메모리에서 워드 4를 사용하려 한다면 주소 100번에서 읽기동작을 실행해야 한다.   한 워드를 메모리부터 가져오기 때문에 패치(fetch)동작이라고도 한다.     접근 시간(access time)     기억 장치가 출력 신호를 받은 시간부터 데이터가 출력된 때까지의 시간   자기 코어 기억 장치에서는 접근 시간과 복원 시간을 합해서 사이클(cycle) 시간이라 하며, IC 메모리에서는 사이클 시간이 접근 시간과 같다.   메모리소자 동작속도의 측정치로 읽기동작하는 데 필요한 시간이라고도 할 수 있으며, 이는 주소입력 순간으로부터 메모리 내용의 출력순간까지의 시간이다.     랜덤 액세스메모리(RAM)     한 메모리 워드의 실제 물리적 위치가 그 위치로부터 읽거나 쓰는 데 걸리는 시간이 얼마나 걸리는가에는 영향을 받지 않는 메모리이다. 즉 액세스시간이 메모리의 모든 주소에 대해서 같은 메모리이다.   대부분의 반도체메모리와 코어메모리는 RAM이다.            사용 예 : CDP(컴팩트 디스크 플레이어)는 적당한 코드를 입력함으로써 어떤 한 노래를 선택하든간에 같은 시간을 갖는다.              순차 액세스 메모리(SAM)     액세스시간이 일정하지 않고 주소위치에 따라 변하는 메모리의 한 형태이다.   원하는 주소에 도달할 때까지 모든 주소위치를 통하여 저장된 워드를 순차적으로 찾기 때문에 랜덤 액세스메모리보다 더 긴 액세스시간을 갖는다.            사용 예 : 자기테이프, 디스크, 자기버블메모리             읽기전용메모리(ROM)     읽기동작이 쓰기동작보다 매우 많은 응용분야를 위해 설계된 반도체메모리의 종류   기술적으로 (주로 제작자에 의해)단 한 번만 프로그래밍되어 쓸 수 있으며, 이후로는 내용을 수정할 수 없으며 읽기만 가능하다.   모든 ROM은 비휘발성이며 전원이 제거되어도 데이터는 그대로 저장된다.   한 번 이상 쓰기동작을 할 수 있는 메모리 RMM(Read Mostly Memory)도 있는데 읽기동작보다 쓰기동작이 훨씬 복잡하기 때문에 자주 사용되지는 않는다.                ROM의 구성도             ROM은 읽어내기만 하기 때문에 기억부와 번지 해독기, 출력 버퍼만으로 구성된다.     프로그램이나 자료 저장 방법에 따른 ROM 분류     마스크(Mask) ROM : 사용자의 요구에 따라 제작사가 자료를 넣기 때문에 내용을 바꿀 수는 없지만 대량 생산에 적합   PROM(Programmable ROM) : 제작시에 아무런 내용을 넣지 않은 상태로 만들어져서 사용자가 원하는 내용을 저장할 수 있다. 하지만 한 번 기억되면 그 내용을 변경할 수 없다.   EPROM(Erasable ROM) : ROM의 내용을 자외선 삭제 장치로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능   EEPROM(Electrically Erasable PROM) : ROM의 내용을 전기신호로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능     정적 램(static RAM device, SRAM)     전원이 인가되는 동안은 저장된 데이터가 영원히 저장되고, 주기적으로 데이터를 다시 쓸 필요가 없는 반도체 메모리장치   플립플롭 조합으로 구성되어 있다.     동적 램(dynamic RAM device, DRAM)     전원이 인가되어도 저장된 데이터가 영원히 유지되지 못하며, 데이터가 메모리에 주기적으로 다시 쓰여져야 저장된 데이터가 계속 저장되는 반도체메모리   이러한 주기적 동작을 리플레시(refresh)동작이라 한다.     휘발성 메모리(volatile memory)     전원이 제거되면 메모리에 있는 모든 정보가 소실된다.   반도체메모리가 휘발성 메모리에 해당한다.     캐시 메모리(cache memory)     SRAM과 구성이 동일하다.   기억 용량은 작으나 속도가 매우 빠른 버퍼(buffer) 메모리로 주기억 장치와 CPU와의 속도 차이를 줄여서 처리의 효율을 높이기 위해서 사용된다.   캐시 기억 장치의 호출 시간은 주기억 장치의 호출 시간보다 5~10배 정도 빠르다.   전체 기억 장치 시스템의 총 소요 시간을 최소화하면서 가능한 하 높은 평균 액세스 속도를 얻기 위해서 사용한다.      메모리의 연결     컴퓨터 내부메모리는 어드레스(Address) 버스, 데이터(Data) 버스, 제어(Control) 버스라는 세 종류의 버스로 CPU에 연결되는 신호선이 구성된다.     버스   1) 어드레스 버스 : CPU에서 메모리 IC까지 2진 어드레스 출력을 전달하는 단방향 버스  2) 데이터 버스 : CPU와 메모리 IC 사이에 데이터를 옮기는 양방향 버스  3) 제어 버스 : CPU에서 메모리 IC까지 제어신호들 전달     CPU의 쓰기동작 순서   1) CPU가 데이터가 저장될 메모리 위치에 2진 어드레스 공급. 어드레스 버스선에서 이 어드레스를 인가한다.  2) CPU가 데이터 버스선에 저장될 데이터 인가  3) CPU가 메모리 쓰기 동작을 위해 제어신호선 동작시킴  4) 메모리 IC들은 저장될 위치를 선택하기 위해 2진 어드레스 해독  5) 데이터 버스에 있는 데이터가 선택된 메모리 위치로 전송됨     CPU의 읽기동작 순서   1) 어드레스 버스선에 이 어드레스 인가. CPU가 데이터의 메모리 위치의 2진 어드레스 공급  2) CPU가 메모리 읽기동작을 위해 제어신호선 활성화 시킴  3) 메모리 IC중에서 읽기동작이 실행되는 위치를 선택하기 위해, 2진 어드레스를 해독한다.  4) 메모리 IC들은 선택된 메모리 위치로부터 데이터 버스에 데이터 인가. 데이터가 전송되는 곳으로부터 CPU로 데이터 인가     메모리 맵(Memory Map)     원하는 용량 및 워드사이즈에 알맞게 응용하기 위해 메모리칩을 조합하거나 큰 용량을 나누어 쓰는 것     ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-10/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 - 보조 기억 장치",
        "excerpt":"보조 기억 장치     주기억 장치는 적은 자료를 기억하여 고속으로 처리한다.   **그에 반해 많은 양의 자료를 기억시켜 관리하기 위한 장치**를 보조 기억 장치 또는 2차 기억 장치(secondary memory)라 한다.   보조 기억 장치의 자료를 액세스하는 방법에 따라 **순차 액세스**와 **임의 액세스**로 분류할 수 있다.     순차 액세스(sequential access)     물리적으로 저장된 순서에 따라 자료를 검색해 나가기 때문에 일괄 처리(batch processiong)에 적합하다.   그렇기 때문에 빠른 액세스가 요구되는 실시간 처리에는 잘 사용되지 않는다.            사용 예 : 자기 테이프             임의 액세스(random access)     원하는 레코드에 직접 액세스할 수 있는 방식   레코드를 순차적으로 읽지 않기 때문에 원하는 데이터를 빠르게 검색할 수 있다.   주로 실시간 처리 시스템에서 사용된다.            사용 예 : 자기 디스크              보조 기억 장치의 종류  자기 테이프(magnetic tape)     플라스틱 테이프의 표면에 자성 도료를 입혀 제작된 것     1) 특성      녹음 테이프와 비슷하게 생겼는데 폭이 1/2~3/4인지 정도로 넓고 기록 밀도가 높다.       대량의 자료를 반영구적으로 보관할 수 있고 가격이 저렴하다는 장점을 가지고 있다.   하지만 테이프가 릴에 순차적으로 감겨 있기 때문에 자료의 순차적 처리만 가능하다.     2) 기록 밀도      자기 테이프 1릴(reel)의 길이는 보통 800, 1,200, 1,600, 2,400 피트(feet) 등이며, 테이프의 기록 밀도는 테이프 1인치 당 저장될 수 있는 문자(character)의 수 혹은 바이트(byte)의 수로 계산 되고 있다.   이 기록 밀도의 단위를 BPI(Byte Per Inch)라고 하며 800, 1,600, 3,200, 6,250, 20,000BPI 등의 기록 밀도가 있다.   자기 테이프는 최초로부터 4~5m 지점에 BOT(Beginning of Tape) 마커가 있고 끝의 6~7m 앞지점에 EOT(End of Tape) 마커가 있는데, 이 부분에는 자료를 수록할 수 없다.   자기 테이프는 7개 또는 9개의 트랙(track)으로 구성되어 데이터를 표현한다.   자료의 저장은 ASCII 코드나 EBCDIC 코드로 표현된다.   파일의 갱신과 보수를 쉽게 하기 위하여 레이블을 사용하는데 레이블에는 표준 레이블, 비표준 레이블, 레이블이 없는 것 세 가지 종류가 있다.     3) 저장 방법      레코드는 자기 테이프에 순차적으로 기록되고 읽혀진다.   이 때 테이프가 레코드를 읽거나 기록하는 과정에서 테이프를 출발시키거나 멈추게 하는데는 물리적인 가속 및 감속 구간이 필요한데, 이를 IRG(Inter Record Gap)로 나타낸다.   IRG의 길이는 약 0.3~0.75인치로 각 레코드마다 IRG를 두게 되면 그만큼 저장할 수 있는 공간이 줄어들기 때문에 비효율적이다.   따라서 효율성을 위해 몇 개의 레코드를 묶어서 한 개의 물리적 레코드로 만들어 준다.   이것을 블록화라고 하며 하나의 블록에 포함된 논리 레코드의 수를 블록화 인수, 각 블록 사이의 간격을 IBG(Inter Block Gap)라 한다.     4) 자기 테이프의 레코드 형식      고정 길이 비블록 레코드(fixed unblock record)            블록화되지 않은 고정 길이 레코드       물리 레코드와 논리 레코드의 길이가 같다.           고정 길이 블록 레코드(fixed block record)            블록화된 고정 길이 레코드       레코드의 길이가 일정하며 하나의 물리 레코드 내에 2개 이상의 논리 레코드가 존재한다.           가변 길이 비블록 레코드(variable unblock record)            블록화되지 않은 가변 길이 레코드       각 논리 레코드의 길이가 일정하지 않다.           가변 길이 블록 레코드(variable block record)            블록화된 가변 길이 레코드       길이가 일정하지 않은 논리 레코드가 블록화되어 있는 형식이다.           부정 형식 레코드(undefined record)            길이를 나타내는 필드가 없는 가변 길이 레코드       비블록 레코드이다.             자기 디스크 장치         대용량을 저장할 수 있고 임의로 호출이 가능하기 때문에 은행 업무, 좌석 예약 업무 등 실시간 처리가 요구되는 자료 처리에 효율적이다.   처리 속도는 1,200 ~ 3,600 회전/분이며, 기록 밀도는 한 트랙당 3,000 ~ 13,000바이트, 즉 60만 ~ 520만 바이트가 수록된다.   자기 디스크 장치는 여러 디스크가 하나의 축에 연결되어 있는데 이것을 디스크 팩(pack)이라 한다.   그리고 각 면의 트랙을 수직으로 연결한 트랙군을 실린더(cylinder)라 한다.   트랙과 실린더에는 고유 번호인 트랙 번호와 실린더 번호가 있어서 기억 매체상의 주소(address)가 할당되어 있기 때문에 데이터에 직접 액세스 하는 것이 가능하다.     자기 드럼 장치(magnetic drum)         초기에 사용되던 주기억 장치   새로운 기억 장치가 개발되면서 보조 기억 장치로 사용되기 시작했지만 현재는 그마저도 잘 안 쓴다.   직경 20~30cm인 금속 원통의 표면에 자성 물질을 입힌 드럼으로 드럼을 회전시킬 때 표면에 헤드를 접근시켜 기억된 내용을 읽거나 새로운 내용을 기억시킨다.     플로피 디스크 장치(floppy disk)         자기 디스크와 같이 데이터를 직접 액세스하며 가볍고 취급이 간편한 반면, 먼지, 햇볕, 열 또는 자성 물질에 가까이 두지 않는 등 관리상 주의가 필요하다.   기록 방법에 따라 단밀도, 배밀도, 고밀도 등이 있으며, 2D는 양면 배밀도를 뜻하고 2HD는 양면 고밀도를 뜻한다.     하드 디스크(hard disk)         개인용 컴퓨터의 보조 기억 장치로 널리 사용되고 있다.   동작 속도는 ms로 나타내며, 보통 평균 액세스 속도와 트랙간 이동 속도, 최대 이동 거리 속도 등을 표시한다.   평균 속도가 빠를수록 전체적으로 동작이 빠르며 가격도 높아진다.   하드 디스크는 본체에 내장되어 사용되는 것이 보통이나 기억 용량의 증가, 편의성 등으로 외장형 하드 디스크도 사용되고 있다.     광학 디스크(optical disk)      레이저를 이용해서 자료를 기록한다.   레이저가 필요한 표면에 도착하면 표면을 태워서 비트 형태의 데이터를 저장한다.   광학 디스크는 데이터가 잘 지워지지 않는 백업 파일, 역사적 기록 등의 분야에 이용된다.     광 디스크의 종류   1) CD-ROM(Compact Disk-Read Only Memory)         지름이 12cm인 소형 디스크 위에 정보를 기록, 저장 및 검색할 수 있는 형식의 시스템으로 광학 드라이브를 이용해서 읽을 수 있다.   원본에 정보를 기록하기 위해서는 WORM 장치가 사용된다.   오디오 디스크, 비디오 디스크, 각종 상품화된 소프트웨어의 저장에 이용된다.     2) WORM(Write Once Read Memory)      디스크에 단 한 번만 정보를 기록할 수 있고 기록한 후에 지울 수 없고 판독만 할 수 있는데, 그 후에는 드라이브에 있는 데이터가 삭제되지 않도록 보호하는 데이터 저장기술이다.   문서용 파일, 비디오용 파일 등에 이용된다.     3) MO DISK(Magneto Optical Disk)         자기광학 디스크라고도 하며 자기박막의 광자기 효과를 이용하여 자료를 기록하고 읽어낼 수 있는 CD-ROM 형태의 외부 기억 매체   자료를 기록할 때엔 레이저광을 사용하여 자화시키는데 이 자화가 유지되어 정보가 기록된다.   판독시엔 피트(pit : 광자기 디스크 표면의 미세한 홈)에 반사되는 빛의 유무로 데이터를 판독한다.   광자기 디스크는 3.5인치 디스켓보다는 빠르지만 하드 디스크보다는 느리다.   광자기 디스크는 자료 백업용 기억매체로 사용하기 좋으며 이동이 간편하고 신뢰성이 높은 것이 장점이다.   오디오용, 비디오용, 컴퓨터 데이터 파일 등에 이용된다.     4) DVD      CD에서 더 발전한 광학 디스크 기술을 이용하는 저장매체이다.   외형은 CD와 같지만 다른 포맷으로 저장되며 높은 용량을 가지고 있다.   DVD는 MPEG-2 파일과 압축 표준을 사용한다.   MPEG-2 이미지들은 MPEG-1 이미지의 4배 해상도를 가지며, 2개의 필드가 하나의 이미지 프레임을 구성하는 상황에서 초당 60개의 인터레이스드 필드(Interlaced Field)를 전송할 수 있다. (MPEG-1은 초당 30개의 인터레이스되지 않은 프레임을 전송한다)           메모리 계층 구조    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-11/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 - 산술 논리 연산 장치",
        "excerpt":"산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)     제어 장치의 지시에 따라 실제 자료 처리가 이루어지는 곳   사칙연산, 논리연산, 비교연산, 자리 이동(shift) 등을 수행한다.     산술 논리 연산 장치의 구성     가산기(adder), 레지스터(register), 보수기(complementary) 등으로 구성된다.        1) 누산기(ACC : accumulator)     연산 장치의 중심이 되는 레지스터   초기에는 연산될 데이터의 보관 장소로 사용되며, 연산 후에는 산술 및 논리 연산 결과를 일시적으로 보관한다.            =&gt; 연산 결과값을 일시적으로 기억             2) 데이터 레지스터(data register)     연산에 필요한 데이터가 두 개인 경우, 하나의 데이터를 일시적으로 보관하고 있다가 필요할 때 제공하는 역할을 수행한다.   기억 레지스터(storage register)라고도 한다.            =&gt; 연산에 필요한 데이터를 일시적으로 보관             3) 가산기(adder)     누산기와 데이터 레지스터에 보관된 두 값을 더하여 그 계산 결과를 다시 누산기에 보관한다.     4) 상태 레지스터(status register)     연산 결과가 양(0)인지 음(1)인지, 또는 자리 올림(carry)이나 오버플로우가 발생했는지 등의 연산에 관계되는 상태와 인터럽트(interrupt) 신호를 기억한다.     5) 보수기(complementary)     어떤 수를 보수로 바꾸어 주는 회로로서 뺄셈을 수행할 때 빼는 수를 보수로 바꾸어 가산기에 입력함으로써 감산의 결과를 얻을 수 있다.   보수에는 1의 보수와 2의 보수가 있는데 주로 2의 보수를 많이 사용한다.      산술 연산  1) 10진수 연산     부호가 있는 10진수 수치 자료의 연산을 수행하는 것   가감승제는 팩형 10진수(packed decimal) 형태의 데이터가 사용된다.     2) 2진수 연산     고정 소수점 연산과 부동 소수점 연산으로 나누어진다.   고정 소수점 연산은 일정한 길이의 바이트에 표시된 고정 소수점 수를 연산하는 것으로 10진수 연산보다 처리 속도가 빠르다.   부동 소수점 연산은 부호 비트, 지수부, 소수부로 구성되어 있으며, 부동 소수점 연산을 위해서는 특수 목적을 가진 레지스터가 필요하다.   부동 소수점 연산은 매우 큰 수나 작은 수를 다룰 수 있으며 연산 처리 속도가 고속이다.      논리 연산     사칙연산을 제외한 문자 처리   로드(load), 스토어(store), 분기(branch), NOT, AND, OR 등의 논리 연산과 자리이동(shift), 순환이동(rotate) 등이 있다.   이러한 데이터 처리는 비트나 바이트로 처리된다.            로드 : 기억 장치에서 CPU의 레지스터로 이동하는 것       스토어 : 레지스터에서 기억 장치로 이동하는 것       분기 : 명령의 실행 순서를 변경하는 것. 무조건 분기와 조건 분기가 있다.           ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-12/",
        "teaser": null
      },{
        "title": "적재와 프로그램과 프로세스",
        "excerpt":"🔸 적재(로드 load)     보조기억장치(HDD 등) -&gt; 주기억장치(RAM)로 이동   🔸 프로그램(Program)     하드디스크에 들어있는 상태 (아직 실행은 되지 않은 상태임)   🔸 프로세스(Process)     주기억장치에 로드된 상태의 프로그램(실행되고 있는 프로그램)   ☑️ 실행(load)되면 비로소 프로세스가 된다.     그러므로 인터넷 브라우저를 켜서 쓰고 있다면 인터넷 브라우저 프로세스를 사용하고 있다고 할 수 있다.(인터넷 브라우저 프로그램 사용중이라고 하는거 아님!!)   ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-13/",
        "teaser": null
      },{
        "title": "깃허브 블로그(Github Blog)를 만들기 위한 여정",
        "excerpt":"🎬 시작   개발 공부를 시작하고 기존에 쓰던 티스토리 블로그가 있긴 했는데 뭔가 깃헙을 이용해서 블로그를 꾸미고 여기에 공부한 내용을 올리고 싶어졌습니다. 다른 개발자 분들이 쓰시는 걸 보니까 되게 있어보이기도 하고 만들어져 있는 큰 회사(?)의 블로그를 쓰는 것 보다는 내가 직접 만들어 보면 뭔가 더 공부가 되지 않을까… 하는 생각으로 깃헙 블로그 만들기에 호기롭게 도전하게 되었습니다.    그리고 그것은 엄청난 고생길의 시작이었습니다….ㅎ     0. 시작 전에… Ruby   깃헙 블로그는 보통 jekyll(지킬)이라는 것을 사용해서 꾸미더라고요. 근데 저건 ruby 기반으로 만들어져 있어서 깃헙 블로그를 시작하려면 ruby를 깔아야 합니다. 전 처음에 이것도 모르고 시작했기 때문에 블로그 글을 똑같이 따라해도 안 되었던 것들이 참 많았기 때문에…ㅎ 이 글을 보시는 분들은 시작 전에 꼭 ruby를 깔고 시작하세요!   ruby 설치 관련글은 아래 글과 같이 구글에 검색하시면 많이 보실 수 있을 것입니다.  https://ogaeng.com/jekyll-blog-install/   부디 고통받지 마시고 사전에 루비 설치하고 진행하세요…     +) 그리고…   시작 전에 깃헙 블로그는 터미널에서 명령어를 입력하는 것을 이용해서 만들 것인데 처음 하면 이것도 뭔가 싶으실 수 있습니다.  모든 블로그 글들을 따라하다 보면 터미널에서 무슨 명령어를 입력해라고 할텐데 그냥 터미널을 켜고 명령어를 입력하면 전혀 작동하지 않고 명령어로 실행하고자 하는 파일이 들어있는 위치로 이동한 다음에 해당 명령어를 입력해야 합니다.        그렇기 때문에 블로그 repository가 있는 폴더에서 마우스 우클릭해서 나오는 메뉴에서 ‘폴더에서 새로운 터미널 열기’ 를 선택해서 터미널을 실행하거나    cd /폴더경로  cd 명령어를 이용해 해당 파일이 있는 폴더로 이동해 모든 명령어를 입력해 주어야 합니다.     1. 참고했던 글   https://zeddios.tistory.com/1222   맨 처음에는 이 블로그 글을 참고해서 만들었었습니다.   그런데 똑같이 따라하고 심지어 테마도 똑같은 걸로 받아 썼지만 안 되더라고요… 제 repo에 push도 잘 되는데 정작 제 블로그 페이지에 들어가보면 맨 처음에 기본으로 주는 테마에서 변경이 안 되었습니다. .gitignore 설정이 잘못 되어있나 싶어서 아예 지워도보고 기타등등 별 짓을 다 해봤지만 되질 않아서… 이 글을 따라하며 만들었던 repo를 삭제하고 다시 만들기로 다짐하면서 다른 블로그 글을 찾아 떠나게 됩니다.   만약 이 글대로 하셔서 잘 되시면 거기서 스톱하고 나만의 블로그를 꾸미시면 됩니다. 전 되질 않아서 더 많은 시간을 소비해야만 했거든요…ㅠ    ! 그리고 테마를 설치하다 보면 거의 99% 확률로   `require’: cannot load such file – webrick (LoadError)   이런 메세지를 보게 됩니다. 근데 다른 블로거분들은 이런걸 보신 적이 없는지 이것에 대한 언급이 아무도 없으심 ㅠ.ㅠ  https://junho85.pe.kr/1850   만약 저런 오류 메세지를 보시면 이 글을 참고하여 해결하시면 됩니다.   bundle add webrick  무엇보다도 중요한 명령어… 전 테마를 설치할 때마다 webric을 꼭 추가해 주어야 했습니다.     https://honbabzone.com/jekyll/start-gitHubBlog/   그리고 두번째로 찾은 글  새로운 마음으로 다시 repo를 만들고 테마도 똑같은 걸로 다운받아서 진행했습니다.   이번엔 다행히 잘 되었습니다. 😄👏👏👏   하지만 댓글 기능을 추가하려고 disqus에 들어가 보니까       기본적으로 유료 서비스더라고요… 무료 서비스도 있긴 한데 무겁고 광고가 붙는다고 해서 disqus는 쓰지 않고 오픈소스에다 가벼운 utterances를 쓰기로 했습니다.     2. utterances로 댓글 기능 만들기   사실 영어를 그닥 좋아하지 않아서(^^;) 최대한 한국인이 쓴 글을 구글링 해서 찾는 편이지만 제가 쓰는 테마는 영어를 쓰는 사람이 만들었기 때문에 영어로 된 설명서를 봐야만 했습니다.   https://github.com/apps/utterances   일단 여기로 이동하셔서 utterances를 repo에 설치합니다.         인스톨 버튼을 누르시면         이런 화면을 보실 수 있는데 제가 가진 모든 repo에 댓글 기능을 추가할 필요는 없기 때문에 블로그용으로 쓰는 repo만 선택했습니다. 여기까지 하셨으면 Install을 눌러서 다음으로 진행하시면 됩니다.        다음으로 넘어가면 이런 화면을 보실 수 있는데 configuration 아래 repo를 설정하는 란에 나의 깃헙 블로그 파일들을 저장하는 repository의 경로를 적어주시면 됩니다. 깃헙아이디/깃헙아이디.github.com 혹은 깃헙아이디/깃헙아이디.githun.io 이런 식으로 보통 적으실 것입니다.        밑으로 내려보시면 이런 선택란이 있을텐데 댓글이 작성되는 루트를 어디로 설정해주느냐 선택하는 것이라고 합니다. pathname은 블로그에 올릴 포스트의 파일명으로 깃헙 블로그에 올릴 포스트의 파일 이름 형식은 정해져 있어서(ex. 2022-01-30-title.md) 바꿀 일이 거의 없다고 봐도 되기 때문에 맨 첫번째 것으로 선택했습니다. 다른 분들도 많이 선택하시는 옵션이었습니다.        그리고 또 밑으로 내려보시면 이런 태그를 보실 수 있는데 본인이 쓰시는 테마의 레이아웃에 이걸 설정하는 란이 따로 있다면 저 태그를 복사해서 넣어주시면 되는데 제가 쓰는 테마엔 따로 없어서 저 태그는 필요가 없었습니다.   Theme 아래 화살표가 있는 박스를 눌러보시면 댓글창의 테마를 선택할 수 있으니 맘에 드는 것을 고르시면 되겠습니다.         대신 위 설명처럼 _config.yml 파일에서만 설정해주면 되었습니다.        이런 식으로 provider 이름만 설정해주고 아래 utterances 정보 입력란에서 입력만 해 주니까        짜잔! 댓글창이 생겼습니다!! 😘👏👏  아 행복해… 이거 만든다고 또 한시간 썼었거든요…ㅠ   댓글창 색이 테마랑 좀 안맞는 감이 있지만 이건 천천히 수정하기로 하고.. 여기까지 해서 제 첫 깃헙 블로그를 만들기 위한 여정이 마무리 되었습니다.    혹시 제 블로그 설정 파일이 궁금하시면    https://github.com/miro7923/miro7923.github.com   여기를 참고하세요.    https://github.com/miro7923/miro7923.github.com/blob/main/_config.yml  그 중에서도 _config.yml 파일 내용이 궁금하시면 여기를 참고하시면 됩니다.      3. 그런데.. 열심히 쓴 글이 포스팅 되지 않는다.   드디어 블로그 세팅을 완료하고 설레는 마음으로 첫 글을 썼는데 로컬 서버로 띄워 보면 잘 보이는데 암만 push를 해도 실제 제 블로그에서는 보이질 않는 것이었습니다…! 머선일이고 이게 ㅠㅠ   약 한시간동안 헤멘 끝에   https://devyuseon.github.io//github%20blog/githubblog-post-not-shown/  이 글을 보고 해결할 수 있었습니다.        저는 _config.yml에 future: true 추가하고 게시글 마크다운 파일의 상단 타이틀 쓰는 란에 published: true 를 추가해 주었더니 해결되었습니다.   그리고 네이버나 티스토리처럼 큰 회사 블로그처럼 push 하자마자 블로그가 업데이트 되는 것은 아니고 몇 분 정도 기다려야 변경내용이 완전히 반영이 되더라고요. 외국 회사라 그런가?   하지만 네이버랑 티스토리에 비해서는 손이 가는게 많아서 그런지 포스트 하나를 쓰고 나면 뭔가 엄청 뿌듯하고 그렇습니다.😄 열심히 해야지!     그럼 오늘은 여기까지… 다음 글에서 만나요!!   ","categories": ["Story"],
        "tags": ["story"],
        "url": "/story/making-github-blog-01/",
        "teaser": null
      },{
        "title": "DB 구동 및 접속",
        "excerpt":"🎬 DB 구동 및 접속    1. Linux 부팅 및 터미널 실행     Windows에서 가상 PC를 실행한 뒤 Linux 부팅 후 로그인한다.   Linux 부팅이 완료되면 마우스 우클릭 - 터미널 열기   2. Listener 시작  $ lsnrctl start     Listener를 시작한다.   Listener는 네트워크를 이용하여 클라이언트에서 오라클 서버로 연결하기 위한 오라클 네트워크 관리자이다.   리스너를 시작하지 않아도 DB 구동엔 문제가 없지만 네트워크를 통한 연결은 모두 리스너가 담당하기 때문에 리스너를 시작하지 않으면 DB에 접속하고자 하는 클라이언트들이 접속할 수 없다.   따라서 터미널이 실행되면 가장 먼저 리스너를 시작한 후 다음 프로세스를 진행한다.     3. SqlPlus 실행  $ sqlplus /nolog   4. Database 접속  $ conn 아이디/비밀번호 as sysdba(권한)  🔸 DB User     sysdba : dba + DB 생성 + DB 시작/종료 권한   system : dba 권한   hr : Object(테이블, 뷰, 시퀀스 등) 생성 및 운영 권한     5. Database 시작  SQL&gt; startup   6. HR 사용자로 DB Login  SQL&gt; conn 아이디/비밀번호   7. 사용자 확인  SQL&gt; show user     HR 사용자로 최종 로그인 되었는지 확인한다.   🔸 User 비밀번호 변경 방법  SQL&gt; alter user 아이디      identified by 새 비밀번호;  ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/DB-start-conn/",
        "teaser": null
      },{
        "title": "DB 기초",
        "excerpt":"🎬 DB란?    🔸 DB를 쓰는 이유     데이터를 오프라인으로 캐비넷에 저장하자니 물리적 저장 공간은 한정되어 있다.   그렇다면 엑셀 파일을 만들어 암호를 걸어 쓰는 방법이 있는데 만약 암호가 유출된다면 그 엑셀 파일 안에 저장된 정보도 모두 유출된다. 따라서 이것도 안전한 방법은 아니다.   그래서 서버에 데이터베이스를 구축하고 거기에 고객 정보를 저정하고 관리하는 것이다.            데이터베이스엔 애초에 허가받은 사용자만 접근할 수 있고 허가받은 권한 만큼만 데이터에 접근할 수 있다.             🔸 DBMS     데이터베이스 관리 시스템   DB에서 필요한 데이터를 검색하거나 삽입, 수정, 삭제하기 위한 프로그램   ORACLE, MySQL등이 있으며 이것들이 DB 자체를 의미하는 것은 아니다.            DB를 다루기 위한 수단으로서 MySQL을 사용하면 MySQL을 사용한 DB 프로그램인 것이다.             🔸 RDBMS     관계형 DBMS   시중에 나와있는 대부분의 DBMS라고 보면 된다.     🔸 SQL     데이터 액세스를 위해 ORACLE server와 통신하는 언어로 DB와 소통하기 위한 언어   모든 DBMS에서 사용하는 공용언어     🔸 TABLE     DB에서 사용하는 대표 객체(오브젝트)   테이블을 사용해서 데이터를 분류한다.        세로는 열(column), 가로는 행(row)!!   column과 row가 만나는 곳은 Field(Record)값이라고 부른다.   ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/DB-start/",
        "teaser": null
      },{
        "title": "HTTP 프로토콜(HyperText Transfer Protocol)",
        "excerpt":"🎬 HTTP 프로토콜이란?     실제 사용자와 연결된 최상위 계층의 프로토콜로 가장 대표적인 웹브라우저의 통신에 관한 프로토콜     🔸 프로토콜(Protocol)     네트워크상에서 데이터를 주고 받는 규칙   컴퓨터 상호간의 대화에 필요한 통신 규약      1. HTTP 프로토콜의 구조     요청(Request)과 응답(Response) 형태로 이루어졌다.   사용자가 웹 페이지의 링크를 클릭하면 브라우저는 HTTP 프로토콜의 요청 형태로 HTTP 메시지를 작성하여 웹 서버에 전송한다.   웹 서버에서는 지금 받은 HTTP 메시지가 요청(Request) 메시지임을 판단하고 그 데이터를 분석해서 HTTP 프로토콜의 응답(Response) 형태로 메시지를 작성하여 브라우저로 보내게 되면 브라우저는 메시지를 받아서 사용자의 화면에 표시하게 된다.        각 HTTP 메시지는 지금 작성 된 메시지가 요청인지, 응답인지와 요청 URL 등 기본적인 정보가 담겨있는 시작 라인과 수행 날짜, 서버 정보, 브라우저 버전 등 부가적인 정보를 담는 헤더 그리고 요청이나 응답에 필요한 내용을 담고 있는 본문(Body)으로 구성된다.      2. HTTP 요청(Request) 메시지     기본적으로 HTTP 메소드(Method)와 접근할 주소(URL) 정보 그리고 서버에 전달할 데이터인 폼 파라미터로 구성된다.   HTTP 메소드(Method)는 클라이언트가 웹 서버가 해야 할 행동을 정해주는 정보로 GET 메소드와 POST 메소드가 있다.   GET 메소드를 사용하는 요청 메시지를 GET 방식의 요청, POST 메소드를 사용하는 요청 메시지를 POST 방식의 요청이라고 한다.     🔸 GET 방식     전송할 파라미터 값들을 시작 라인의 URL 정보에 붙여서 같이 전송한다.   파라미터의 길이는 256바이트를 넘을 수 없다.   본문(Body)이 필요없기 때문에 전송 속도가 POST 방식에 비해 빠르다.   전송해야 할 데이터가 적을 때 유용하다.   파라미터가 URL뒤에 붙어서 전송되므로 사용자가 브라우저의 주소 창에서 전송되는 파라미터를 실제로 확인할 수 있다.     🔸 POST 방식     전송할 파라미터 값들을 요청 메시지 본문(Body)에 담아서 전송한다.   따라서 전송할 수 있는 데이터의 양에 제한이 없으며 주소창에서 전송되는 파라미터 확인이 불가능하다.   GET 방식에 비해 보안상 더 유용하다.           3. HTTP 응답(Response) 메시지     요쳥에 대한 서버의 처리 성공 여부를 표시하는 상태 코드(HTTP 404, 500 등) 번호와 웹 서버가 응답해주는 콘텐츠의 타입 정보(텍스트/HTML, 이미지 등), 콘텐츠의 내용으로 구성된다.   실제적으로 서블릿 클래스가 요청을 처리해 생성하는 페이지는 웹 서버에서 응답 메시지의 형태로 작성되어 사용자의 브라우저에 전송된다.  ","categories": ["JSP"],
        "tags": ["WEB","JSP","HTTP"],
        "url": "/jsp/JSP-http-protocol/",
        "teaser": null
      },{
        "title": "서블릿의 동작 원리",
        "excerpt":"1. 사용자의 URL 요청     웹 서버가 배포 서술자를 통해 지금 받은 요청이 서블릿 요청이라는 것을 알게 되면 서블릿을 담당하는 웹 컨테이너로 그 요청을 전달한다.     🔸 배포 서술자(Deployment Descriptor)       사전에 웹 서버측에 URL과 서블릿 클래스를 미리 매핑시켜놓은 것     2. request, response 객체 생성     웹 컨테이너는 받은 요청을 처리하기 위해 HTTP 요청을 처리하기 위한 request 객체와 HTTP 응답을 위한 response 객체를 생성한다.     3. 서블릿 인스턴스와 스레드 생성     request, response 객체가 생성된 뒤 사용자의 URL 요청이 어떤 서블릿 클래스를 필요로 하는지 배포 서술자를 통해 알아낸다.   그 클래스가 한 번도 실행된 적이 없거나 현재 메모리에 인스턴스(프로세스)가 없으면 새로 생성한 뒤 스레드를 하나 생성하고 이미 인스턴스가 존재한다면 기존의 인스턴스에 스레드만 하나 새로 생성한다.   각 서블릿 클래스는 웹 컨테이너당 하나만 존재한다.     4. service() 메소드 호출과 서블릿 클래스 실행     스레드가 생성되면 각 스레드에서 service() 메소드가 호출된다.   service() 메소드가 호출되면 HTTP 요청 방식이 GET 방식이면 doGet() 메소드가, POST 방식이면 doPost() 메소드가 request, response 객체를 인자로 자동으로 호출된다.   개발자가 실제로 동적인 웹 페이지 생성을 할 수 있는 코드를 만들어야 하는 부분이 doGet()과 doPost() 메소드 부분이다.     5. 응답과 스레드의 소멸     사용자의 요청에 따른 동적인 웹 페이지를 생성한 결과물이 담긴 response 객체를 웹 컨테이너가 HTTP 응답 형태로 바꾸어 웹 서버로 전송한다.   사용이 끝난 request와 response 객체를 소멸시키고 스레드를 종료한다.   웹 서버는 전송 받은 HTTP 응답 메시지를 사용자의 브라우저로 전송하게 되고 사용자는 브라우저를 통해 동적으로 생성된 페이지를 받아보게 된다.     ","categories": ["JSP"],
        "tags": ["WEB","JSP","HTTP","Servlet"],
        "url": "/jsp/JSP-servlet-process/",
        "teaser": null
      },{
        "title": "웹페이지 기초",
        "excerpt":"🔸 웹페이지에는 정적데이터와 동적데이터가 있다.      네이버 홈페이지에 접속하면 보이는 이미지 데이터들은 정적데이터        HTML, CSS, JavaScript, … =&gt; WEB 서버에서 처리         신문 기사, 날씨, 코스피 지수 등 변하는 값들은 동적데이터   DB에 저장되어 있는 데이터 =&gt; WAS(Web Application Server - web에 application이 추가된 것)서버에서 처리            예) 톰캣이라는 서버에서 자바 애플리케이션이 실행되고 있는 것             🔸 웹페이지 동작     [클라이언트/사용자]가 naver에 요청 ➡️ [naver - WEB서버]가 판단해서 요청한 데이터가 정적데이터만 있다면 바로 실행하게 만듦 ➡️ [클라이언트/사용자]에게 naver가 응답(정적데이터)        👉 이 결과로 사용자는 naver 페이지를 볼 수 있게 된다.         하지만 동적데이터도 있다면…   naver가 [naver서버 - WAS서버]에 동적데이터를 요청한다.        그러면 [Database서버]에 데이터를 요청해서 사용자에게 보여준다.            +) .com, .co.kr 과 같은 도메인은 비싸다.   .ar 같은 도메인들은 무료   🔸 DNS     도메인 네임서버   IP주소를 도메인 주소로 바꾼 것   숫자로 된 IP주소는 외우기 힘드니까 좀 더 읽기 쉬운 문자형 주소로 바꾸는 것  ","categories": ["JSP"],
        "tags": ["WEB","JSP"],
        "url": "/jsp/JSP-web-beginning/",
        "teaser": null
      },{
        "title": "웹 컨테이너",
        "excerpt":"🎬 웹 컨테이너란?     JSP와 서블릿을 사용한 웹 서버는 크게 URL 주소의 해석을 담당하는 HTTP 서버와 서블릿 클래스 또는 JSP 파일의 실행 요청을 처리해주는 웹 컨테이너(Web Container)로 구성된다.   HTTP 서버는 단순히 어떤 주소(URL) 요청이 들어왔을 경우 그 주소에 미리 매핑되어 있는 콘텐츠(HTML 파일이나 이미지 등)를 사용자의 브라우저에 응답 형태로 전송하는 역할을 한다.   이 때 요청된 URL이 서블릿 클래스 또는 JSP 파일일 경우 HTTP 서버는 이를 웹 컨테이너에서 처리하도록 클라이언트의 요청을 넘겨준다.   웹 컨테이너에서는 요청된 URL에 맞는(미리 설정된) 서블릿 클래스 또는 JSP 파일을 실행하여 결과를 HTTP 서버에 넘겨주게 되고 이는 응답 메시지의 형태로 사용자의 브라우저에 전송된다.     👉 즉 웹 컨테이너란 웹 서버 내부에서 서블릿 클래스 또는 JSP 파일을 실행하기 위한 실행 환경을 제공하는 역할을 한다.       서블릿 클래스에 대한 웹 컨테이너를 서블릿 컨테이너   JSP 파일에 대한 웹 컨테이너를 JSP 컨테이너     대표적으로 아파치 톰캣, 웹로직, Resin 등이 있다.  ","categories": ["JSP"],
        "tags": ["WEB","JSP","HTTP"],
        "url": "/jsp/JSP-web-container/",
        "teaser": null
      },{
        "title": "웹 프로그래밍 언어 종류",
        "excerpt":"1. CGI(Common Gateway Interface)     응용 프로그램과 웹 서버 사이의 정보를 주고받는 방식이나 규약들을 정해 놓은 것   단순한 HTML 방식으로는 동적인 웹 페이지를 만들기가 어렵기 때문에 서버측에서 동적인 데이터를 처리해 클라이언트에 HTML 문서로 전송해 줄 수 있는 응용 프로그램(웹 프로그램)이 필요해져서 만들어졌다.   현재 웹 프로그래밍은 대부분 ASP, PHP, JSP를 이용한 것이 대부분인데, DBMS와의 간편한 연동, 객체 지향적인 특성, 편한 개발 환경 등 강력한 기능을 갖추었기 때문이다.     🔸 DBMS(Database Management System)     데이터베이스 관리자라고도 불리며 다수의 컴퓨터 사용자들이 데이터베이스 안에 데이터를 기록하거나 접근할 수 있게 해주는 프로그램   DBMS는 데이터베이스 내의 정보를 검색하거나, 데이터베이스에 정보를 저장하기 편리하고 효율적인 환경을 제공하며, 응용 소프트웨어별로 흩어져 있는 자료들을 통합하고 통합된 자료들을 각 응용 소프트웨어가 공유하여 정보의 체계적인 활용을 가능하게 한다.   일반적인 형태의 DBMS는 관계형 데이터베이스 관리 시스템(RDBMS)인데, RDBMS의 표준화된 사용자 및 프로그램 인터페이스를 SQL(Strutured Query Language)이라고 한다.   RDBMS로는 오라클(Oracle), 사이베이스(Sybase), 인포믹스(Infomix)등이 쓰인다.     🔸 인터페이스(Interface)     사물과 사물간의 소통이 가능하도록 만들어진 매개체 또는 규약   웹 프로그래밍에서는 서버와 응용 프로그램 간의 원활한 통신이 가능하도록 만들어진 규약을 말한다.     🔸 스크립트 언어(Script Language)     C와 같은 일반적인 프로그래밍 언어는 컴파일러에 의해 컴파일 되어 2진수로 되어있는 기계어로 변환되어야지만 컴퓨터 상에서 실행될 수 있다.   이와는 달리 컴파일이 필요 없이 해석기(인터프리터)에 의해 즉시 실행될 수 있는 프로그램 언어를 스크립트 언어라고 한다.   대표적으로 브라우저에 의해 해석되어 실행되는 JavaScript가 있으며, Unix의 쉘 스크립트, 윈도우의 Batch 파일도 스크립트 언어라 할 수 있다.      2. ASP(Active Server Page)     C#(.Net)과 유사하다.   동적인 웹 페이지의 구현을 위해 Visual Basic 언어를 기반으로 만들어진 VBScript라는 스크립트 언어를 사용해서 구성된 웹 프로그래밍 기술   쉬운 문법을 가지고 있어 빠르고 쉽게 개발할 수 있고 Active-X 및 DDL 컴포넌트를 사용하여 어느 정도의 확장성도 갖추었지만 웹 서버로 오직 Windows 기반의 IIS(Internet Information Server)만을 사용할 수 있기 때문에 플랫폼에 비독립적이라는 큰 단점을 가디고 있다.   또한 Java 기반의 JSP에 비해 시스템 자원의 효율성과 확장성이 떨어진다.      3. PHP(Personal Hypertext Preprocessor)     ASP와 유사한 스크립트 기반의 언어이지만 C를 기반으로 만들어져서 빠른 속도를 가지고 있다.   다양한 플랫폼에서 사용 가능하며 100% 무료로 사용할 수 있다.   하지만 서버측의 지원 인프라가 매우 부족하여 확장성이 떨어지고, 기업형의 복잡한 시스템 구조에 적용하기가 힘들고 보안상의 약점을 가지고 있다.      4. JSP     Java를 기반으로 만들어진 서블릿(Servlet)이라는 동적 웹 구현 기술이 개발된다.   서블릿은 객체지향적이며 플랫폼 독립적인 자바의 장점을 그대로 웹에서 구현할 수 있었으며 스레드(Thread) 기반의 요청 처리 방식을 채택했기에 사용자가 많을수록 효율적으로 동작하는 기술이었다.   하지만 익히기가 쉽지 않은 편이었기 때문에 유저인터페이스의 구현이 쉬운 ASP의 장점을 수용하여 JSP가 개발된다.   JSP 또한 스크립트 기반으로 개발되어 훨씬 쉽게 작성할 수 있었고 서블릿과 함께 구동함으로써 서블릿의 기능을 그대로 사용할 수 있고 자바빈즈(JavaBeans), EJB같은 기술로 보다 강력한 객체지향적 지원이 가능해졌다.   또한 JSTL을 지원하게 되면서 웹 프로그램의 가독성이 좋아지고 유지 및 보수가 훨씬 쉬워지는 장점을 가지게 되었다.   이러한 장점들은 대규모 프로젝트에서 유용하기 때문에 최근에는 일정 규모 이상의 웹사이트를 개발할 때에는 주로 JSP를 사용한다.     🔸 프로세스(Process)     실행 중인 프로그램을 나타내는 말로 태스크(Task)라고도 한다.   윈도우와 같이 멀티태스킹을 지원하는 운영체제에서는 동시에 실행되고 있는 여러 개의 프로세스에 대하여 CPU와 메모리 자원을 안정되게 분배해 주어야 하며 이러한 역할은 그 운영체제의 성능을 결정하는 데 있어 아주 중요한 요소이다.   그런데 운영체제는 똑같은 프로그램이 두 개 이상 실행되면 같은 프로그램이라 하더라도 서로 다른 자원을 할당해 두 개 이상의 프로세스를 만든다.   이는 실행되는 프로그램의 수가 늘어날수록 할당해야 하는 자원이 늘어나게 되어 굉장히 비효율적이고 성능의 하락을 가져올 것이다.   이러한 단점을 극복하기 위해 개발된 것이 스레드(Thread)이다.     🔸 스레드(Thread)     하나의 프로세스 내에서 해당 프로세스가 할당받은 자원을 공유하며 실행되는 독립적인 작업단위   프로세스의 자원을 참조할 뿐 새로 할당받을 필요가 없기 때문에 프로세스를 생성하는 것보다 훨씬 빠른 생성 속도를 가진다.   ","categories": ["JSP"],
        "tags": ["WEB","JSP"],
        "url": "/jsp/JSP-web-programming-languages/",
        "teaser": null
      },{
        "title": "SELECT 구문을 사용한 데이터 검색",
        "excerpt":"🎬 SQL 문법은 기본적으로 대소문자를 구분하지 않는다.     ☑️ 문법  SELECT * | {[DISTINCT] column | expression [alias], ...} FROM   table;   1. 테이블 구조 조회  DESCRIBE employees       2. 테이블로부터 데이터 검색  1) SELECT 구문  SELECT * FROM   department;     ‘*‘은 모든 것을 보여달라고 할 때 사용한다.   SQL 구문 또한 세미콜론(;)을 사용해서 문장이 끝났다는 것을 표시하기 때문에 명령어를 실행하려면 마지막에 세미콜론을 꼭 찍어줘야 한다.    SELECT department_id, location_id FORM   departments;     SELECT 뒤에 컬럼명을 지정하면 해당 컬럼에 해당하는 내용들만 보여달라는 뜻이 된다.    SELECT last_name, salary, 12*salary+100 FROM   employees;     12*salary+100 처럼 내가 원하는 계산을 한 결과를 출력하게 할 수도 있다.     🔸 입력한 명령어 수정 (마지막으로 쓴 명령어와 비슷한 명령어를 또 써야 할 때 유용하다)     SQL에서는 가장 마지막에 입력한 구문 하나만 버퍼에 저장되어서 이것을 수정할 수 있다.     ed           위 명령어를 입력하고 엔터를 치면 버퍼를 수정할 수 있는 모드에 들어갈 수 있다.     i           를 누르면 하단에 –INTSERT–가 표시되며 버퍼에 저장된 명령어를 수정할 수 있다.   이 때 구문의 마지막에 세미콜론을 입력하면 안 된다!!!   모든 수정이 끝나면 ESC를 눌러 수정을 종료한 뒤     :wq           위 명령어를 입력하면 버퍼 수정 모드를 빠져나온다.     / + ENTER           ’/’를 입력하고 엔터를 누르면 버퍼에 저장된 명령어를 실행하는 동작이다. 모든 수정을 마치고 나와서 ‘/’ + 엔터를 실행해주면 아까 수정했던 명령어가 실행되는 것을 볼 수 있다.     2) null값이란?     사용할 수 없는 값, 알려지지 않은 값, 할당받지 못한 값, 모르는 값, 아직 정의되지 않은 값 등…   null은 0(zero)이나 공백과는 다른 특수한 값으로 모든 데이터타입에 사용 가능하다.     3) Column Alias     컬럼명에 별명을 붙이는 것   원래 정해져 있는 컬럼명을 사용자가 보기에 좀 더 알아보기 쉽게 표시하고 싶을 때 사용한다.     1️⃣  컬럼명 AS alias      2️⃣  컬럼명 alias      3️⃣  컬럼명 [AS] “Alias” =&gt; 대소문자 구분, 공백 포함, 특수문자 포함을 원하는 경우      SELECT last_name AS name, commission_pct comm FORM   employees;                  SELECT last_name \"Name\", salary*12 \"Annual Salary\" FROM   employees;                   4) 연결 연산자 (||)  SELECT last_name || job_id AS \"Employees\" FROM   employees;                                                 로 연결된 컬럼들을 묶어서 한 컬럼에 표시해 준다. 이것 또한 Alias 지정이 가능하다.                             5) 리터럴 문자     리터럴 문자란 쿼리 구문에 포함된 일반 문자, 숫자, 날짜 값   문자나 날짜 리터럴은 작은 따옴표로 묶어서 작성해야 함     SELECT last_name || ' is a ' || job_id      AS \"Employee Details\" FROM   employees;           Alias를 지정하지 않았다면 ‘last_name is a job_id’ 라는 컬럼명으로 표시된다.     6) DISTINCT 키워드     중복된 값을 자동으로 제거해 주는 키워드     SELECT DISTINCT department_id FROM   employees;               ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-SELECT/",
        "teaser": null
      },{
        "title": "WHERE(조건문)절과 ORDER BY(정렬)절",
        "excerpt":"☑️ 문법  SELECT * | {[DISTINCT] column | expression [alias], ...} FROM   table [WHERE condition(s)] [ORDER BY {column, expr, alias} [ASC | DESC]];   1) 1. WHERE절     WHERE절을 사용해서 특정 칼럼에서 어떤 값을 가진 필드값만 찾아달라고 할 수 있다.     SELECT employee_id, last_name, job_id, department_id FROM   employees WHERE  department_id = 90;           employee_id, last_name, job_id, department_id 컬럼을 출력하는데 department_id가 90인 필드만 출력해라       SELECT last_name, job_id, department_id FROM   employees WHERE  last_name = 'Whalen';           last_name, job_id, department_id 컬럼을 출력하는데 last_name이 ‘Whalen’인 필드만 출력해라       SELECT last_name FROM   employees WHERE  hire_date = '17-FEB-96';           last_name 컬럼을 출력하는데 hire_date가 96년 2월 17일인 필드를 출력해라   날짜를 쓸 때엔 ‘DD-MM-YY’형식으로 쓴다.     SELECT last_name, salary FROM   employees WHERE  salary &lt;= 3000;     last_name, salary 컬럼을 출력하는데 salary가 3000 이하인 필드를 출력해라       SELECT last_name, salary FROM   employees WHERE  salary BETWEEN 2500 AND 3500;           last_name, salary 컬럼을 출력하는데 salary가 2500 ~ 3500 사이인 필드를 출력해라       SELECT employee_id, last_name, salary, manager_id FROM   employees WHERE  manager_id IN (100, 101, 201);           employee_id, last_name, salary, manager_id 컬럼을 출력하는데 manager_id가 100이거나 101이거나 201인 필드를 출력해라(or과 같은 역할)       SELECT last_name FROM   employees WHERE  last_name LIKE '_O%';           last_name 컬럼을 출력하는데 last_name의 두번째 문자가 o인 필드를 출력해라     🔸 LIKE 비교연산자       % : 0 char 또는 여러개 char   _ : 반드시 1 char            a로 시작되는 문자열 : ‘a%’       a가 포함된 문자열 : ‘%a%’       a로 끝나는 문자열 : ‘%a’       두번째 문자가 a인 문자열 : ‘_a%’       끝에서 세번째 문자가 a인 문자열 : ‘%a__‘             SELECT last_name, manager_id FROM   employees WHERE  manager_id IS NULL;     last_name, manager_id 컬럼을 출력하는데 manager_id가 null인 필드를 출력해라     SELECT employee_id, last_name, job_id, salary FROM   employees WHERE  salary &gt;= 10000 AND    job_id LIKE '%MAN%';     employee_id, last_name, job_id, salary 컬럼을 출력하는데 salary가 10000 이상이고 job_id에 MAN이 포함되는 필드를 출력해라     SELECT employee_id, last_name, job_id, salary FROM   employees WHERE  salary &gt;= 10000 OR     job_id LIKE '%MAN%';     employee_id, last_name, job_id, salary 컬럼을 출력하는데 salary가 10000 이상이거나 job_id에 MAN이 포함되는 필드를 출력해라     🔸 비교연산자에 NOT(논리연산자)이 조합으로 사용된 경우       2. ORDER BY절     ORDER BY절을 사용해서 특정 조건에 따라 필드값을 정렬해서 볼 수 있다.   ASC : Ascending order, default 오름차순   DESC : Descending order 내림차순     SELECT last_name, job_id, department_id, hire_date FROM   employees ORDER BY hire_date DESC;           last_name, job_id, department_id, hire_date 컬럼을 출력하는데 hire_date의 내림차순으로 정렬해라     SELECT employee_id, last_name, salary*12 annsal FROM   employees ORDER BY annsal;     employee_id, last_name, salary12 annsal 컬럼을 출력하는데 salary12은 annsal이라는 Alias로 출력하고 annsal의 오름차순으로 정렬해라     SELECT last_name, job_id, department_id, hire_date FROM   employees ORDER BY 3;     last_name, job_id, department_id, hire_date 컬럼을 출력하는데 3번째 컬럼(department_id)의 오름차순으로 정렬해라   하지만 숫자로 표시하면 알아보기 힘들어서 추천하는 방법은 아니다.     SELECT last_name, department_id, salary FROM   employees ORDER BY department_id, salary DESC;     last_name, department_id, salary 컬럼을 출력하는데 department_id, salary 컬럼의 내림차순으로 정렬해라    ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-WHERE-ORDER-BY/",
        "teaser": null
      },{
        "title": "단일 행 함수",
        "excerpt":"1. 함수란?       2. SQL 함수의 두가지 유형       3. 단일 행 함수       1) 문자함수     문자 입력을 받아 들이며 문자 및 숫자값을 모두 반환할 수 있다.        1️⃣ 대소문자 변환 함수                      함수       결과       기능                               LOWER(‘SQL Course’)       sql course       모두 소문자로 변환                         UPPER(‘SQL Course’)       SQL COURSE       모두 대문자로 변환                         INITCAP(‘SQL Course’)       sql Course       단어의 첫 글자만 대문자로 변환                   SELECT employee_id, last_name, department_id FROM   employees WHERE  LOWER(last_name) = 'higgins';       2️⃣ 문자 조작 함수                  함수       결과       기능                               CONCAT(‘Hello’, ‘World’)       HelloWorld       파라미터 두개를 연결(사용 가능 파라미터는 두개로 제한)                         SUBSTR(‘HelloWorld’, 1, 5)       Hello       지정된 범위의 문자열 추출                         LENGTH(‘HelloWorld’)       10       문자열 길이 리턴                         INSTR(‘HelloWorld’, ‘W’)       6       문자열에서 지정된 문자의 숫자 위치를 찾음                         LPAD(salary, 10, ‘@’)       @@@@@24000       길이가 n이 되도록 왼쪽부터 문자식으로 채운 표현식 리턴                         RPAD(salary, 10, ‘@’)       24000@@@@@       길이가 n이 되도록 오른쪽부터 문자식으로 채운 표현식 리턴                         REPLACE(‘JACK and JUE’, ‘J’, ‘BL’)       BLACK and BLUE       1번 파라미터에서 2번 파리미터로 입력한 값을 3번 파라미터로 변경                         TRIM(‘H’ FROM ‘HelloWorld’)       elloWorld       문자열에서 선행문자나 후행문자를 자름                   SELECT employee_id, CONCAT(first_name, last_name) NAME,        job_id, LENGTH(last_name),        INSTR(last_name, 'a') \"Contains 'a'\" FROM   employees WHERE  SUBSTR(job_id, 4) = 'REP';        2) 숫자함수     숫자 입력을 받아 들이고 숫자값을 반환한다.                   함수       결과       기능                               ROUND(45.926, 2)       45.93       지정된 소수점 자릿수로 반올림                         TRUNC(45.926, 2)       45.92       지정된 소수점 자릿수로 버림                         MOD(1600, 300)       100       나눈 나머지 반환                   🔸 DUAL 테이블     SYS 소유   함수 및 계산 결과를 볼 때 사용하는 공용 테이블   DUMMY라는 하나의 열과 값이 X인 하나의 행을 포함            이걸 쓰는 이유는 컬럼을 출력할 필요가 없이 어떤 값을 계산한 결과만 보고 싶어도 FROM절에 테이블명을 꼭 써야 함       이 때 employees 처럼 실제 데이터가 들은 테이블을 호출하면 비효율적이니까 아무것도 없는 빈 테이블을 DUAL 테이블이라 지정하고 계산 결과만 볼 때에 호출하는 것         SELECT ROUND(45.923, 2), ROUND(45.923, 0), ROUND(45.923, -1) FROM   DUAL;                                       3) 날짜함수     DATE 데이터 유형의 값에 대해 실행된다.   1️⃣ SYSDATE 함수     현재 데이터베이스 서버 날짜 및 시간을 반환하는 함수     SELECT sysdate FROM   dual;                   2️⃣ 날짜를 사용한 산술 연산                   연산       결과       설명                               날짜 + 숫자       날짜       날짜에 일 수를 더한다.                         날짜 - 숫자       날짜       날짜에서 일 수를 뺀다.                         날짜 - 날짜       일 수       한 날짜를 다른 날짜에서 뺀다.                         날짜 + 숫자 / 24       날짜       날짜에 시간 수를 더한다.                   SELECT last_name, (SYSDATE - hire_date) / 7 AS WEEKS FROM   employees WHERE  department_id = 90;  3️⃣ 날짜 조작 함수                   함수       결과                               MONTHS_BETWEEN       두 날짜 간의 월 수                         ADD_MONTHS       날짜에 월 추가                         NEXT_DAY       지정된 날짜의 다음 날                         LAST_DAY       월의 마지막 날                         ROUND       날짜 반올림                         TRUNC       날짜 버림                                  함수       결과                               MONTHS_BETWEEN(‘01-SEP-95’, ‘11-JAN-94’)       19.6774194                         ADD_MONTHS(‘31-JAN-96’, 1)       ‘29-FEB-96’                         NEXT_DAY(‘01-SEP-95’, ‘FRIDAY’)       ‘08-SEP-95’                         LAST_DAY(‘01-FEB-95’)       ‘28-FEB-95’                   🔸 ROUND와 TRUNC의 활용                   함수       결과                               ROUND(SYSDATE, ‘MONTH’)       01-AUG-03                         ROUND(SYSDATE, ‘YEAR’)       01-JAN-04                         TRUNC(SYSDATE, ‘MONTH’)       01-JUL-03                         TRUNC(SYSDATE, ‘YEAR’)       01-JAN-03                   4) 변환함수         값의 데이터유형을 변환한다.     1️⃣ TO_CHAR 함수(DATE ➡️ CHAR)      🔸 문법      TO_CHAR(date, 'format_model')           🔸 날짜 형식 요소                  요소       결과                               YYYY       숫자로 된 전체 연도                         YEAR       영어 철자로 표기된 연도                         MM       월의 2자리 값                         MONTH       전체 월 이름                         MON       월의 3자 약어                         DY       3문자로 된 요일 약어                         DAY       요일의 전체 이름                         DD       숫자 형식의 월간 일                           시간 요소는 날짜에서 시간 부분의 형식을 지정한다.  HH24:MI:SS AM ➡️ 15:45:32 PM            문자열은 큰 따옴표로 묶어 추가한다.  DD “of” MONTH ➡️ 12 of OCTOBER       숫자 접미어는 숫자를 영어 철자로 표기한다.  ddspth ➡️ fourtheenth   sp라 쓰면 약간 잘라서 약자로 표현함     2️⃣ TO_CHAR 함수(NUMBER ➡️ CHAR)  🔸 문법  TO_CHAR(number, 'format_model')      🔸 숫자 형식 요소                  요소       결과                               9       숫자를 나타냄(0 ~ 9)                         0       0이 표시되도록 강제 적용(0만 표시됨)                         $       부동 달러 기호 배치                         L       부동 로컬 통화 기호 사용                         .       소수점 출력                         ,       천단위 표시자로 쉼표 출력                   SELECT TO_CHAR(salary, '$99,999.00') SALARY FROM   employees WHERE  last_name = 'Ernst';     TO_CHAR(salary, ‘$99,999.00’) 에서 ‘$99,999.00’를 통해 출력할 수 있는 자리수는 최대 6자리이다.   만약 자리수를 초과하면 ####으로 출력되고 숫자 자체가 출력되지 않는다. =&gt; 그러니까 자리수를 넉넉히 쓰자     3️⃣ TO_NUMBER 함수(CHAR ➡️ NUMBER)  🔸 문법  TO_NUMBER(char[, 'format_model'])     문자를 숫자로 바꿔주는 함수인데 쓸 일이 거의 없다.   salary 같은 컬럼을 $3,000이라 저장하면 조회할 때 보기에는 편하지만 필드값을 계산에 사용하려고 하면 $가 없는 숫자로 바꿔줘야 해서 번거롭다.   그래서 보통 3000 숫자 자체만 저장해놓기 때문에 TO_NUMBER 함수를 쓸 일이 없다.     4️⃣ TO_DATE 함수(CHAR ➡️ DATE)  🔸 문법  TO_DATE(char[, 'format_model'])     내가 원하는대로 날짜값을 출력해주는 함수     SELECT employee_id, last_name, salary, hire_date FROM   employees WHERE  hire_date &lt; to_date('2004/08/09', 'YYYY/MM/DD');                   5) 일반함수     모든 데이터타입에 사용가능하다.                   함수                               NVL(expr1, expr2)                         NVL2(expr1, expr2, expr3)                         NULLIF(expr1, expr2)                         COALESCE(expr1, expr2, …, exprn)                   1️⃣ NVL 함수     null 값을 실제 값으로 변환   사용할 수 있는 데이터 유형은 날짜, 문자 및 숫자   데이터 유형이 일치해야 함            NVL(commission_pct, 0)       NVL(hire_date, ‘01-JAN-97’)       NVL(job_id, ‘No Job Yet’)           산술식에 null이 들어가면 결과값은 null이다.     SELECT last_name, salary, NVL(commission_pct, 0),       (salary*12) + (salary*12*NVL(commission_pct, 0)) AN_SAL FROM   employees;                   2️⃣ NVL2 함수     첫번째 표현식을 검사해서 null이 아니면 두번째 표현식을 반환하고 또 null이면 세번째 반환     SELECT last_name, salary, commission_pct,       NVL2(commission_pct, 'SAL+COMM', 'SAL') income FROM   employees WHERE  department_id IN (50, 80);                   3️⃣ NULLIF 함수     expr1과 expr2를 비교해서 두 표현식이 같으면 null을 반환하고 두 표현식이 다르면 expr1 반환     SELECT first_name, LENGTH(first_name) \"expr1\",      last_name, LENGTH(last_name) \"expr2\",      NULLIF(LENGTH(first_name), LENGTH(last_name)) result FROM   employees;                   4️⃣ COALESCE 함수     NVL 함수보다 여러 대체값을 가질 수 있음   null이 아닌 첫번째 표현식 반환   파라미터들의 자료형이 모두 같아야 한다.     SELECT last_name, employee_id,       COALESCE(TO_CHAR(commission_pct), TO_CHAR(manager_id),       'No commission and no manager') FROM   employees;           ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-single-func/",
        "teaser": null
      },{
        "title": "쿼리구문에 큰 따옴표 사용 문법",
        "excerpt":"쿼리구문에 큰 따옴표(“ “)가 사용되는 경우     컬럼명 [AS] “Alias”            대소문자 구분       특수문자 포함       공백 포함하는 경우              TO_CHAR(sysdate, 'YYYY-MM-DD \"Time\" HH24:MI')            사용자 형식 내 문자열 포함 시           =&gt; 긴가민가하면 작은 따옴표를 쓰자  ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-use-quotes-in-query/",
        "teaser": null
      },{
        "title": "깃허브 프로필(Github Profile) 꾸미기",
        "excerpt":"🎬 시작   드디어 깃헙 블로그를 만들고… 다른 깃헙들을 구경하다 보니까 깃헙 메인 화면 자체를 예쁘게 꾸며놓으신 분들이 많더라고요!      이렇게요!   되게 좋아 보이잖아요?ㅎㅎㅎ 그래서 저도 꾸며보기로 했습니다.     1. New Repository 만들기      먼저 내 아이디와 같은 이름으로 새로운 레포지토리를 만들어 줍니다.  처음 깃헙 블로그를 만들 때 봤을 때엔 깃헙 프로필 페이지 자체를 꾸밀 수 있다는 것을 몰라서 뭔 소린가 했는데 이런 뜻이었네요…        만들 때엔 add a readme에 꼭 체크해 주세요! readme로 프로필 페이지를 꾸며야 하거든요.     2. README.md 편집하기      새로 만든 레포로 들어오면 아무것도 없어서 휑한 모습을 볼 수 있습니다. 전 까먹고 스샷을 좀 늦게 찍었더니 어느정도 꾸미기를 진행한 상태였네요 😅   여기서 리드미 파일 상단의 연필 그림을 누르거나 오른쪽에 보이는 초록색 edit readme 버튼을 눌러서 웹상에서 바로 편집을 진행하셔도 되고 로컬로 다운받아서 편집한 다음에 푸시하셔도 됩니다.     🔸 markdown 미리보기   혹은 https://dillinger.io/     라는 사이트가 있는데 여기에서는 마크다운으로 작성하는 파일을 실시간으로 미리볼 수 있는 서비스를 제공하고 있습니다.  보통 마크다운 파일을 편집할 땐 미리보기가 가능하지 않으니까 여러번 커밋과 푸시를 하게 되어서 좀 귀찮은데 이 사이트에서는 실시간으로 확인하면서 작성한 다음에 복붙해서 한 번에 커밋할 수 있어서 꽤 편합니다.   하지만 전 쓸 게 그렇게 많지는 않아서 여기 쓰려다가 안 쓰고 그냥 레포에서 바로 수정했습니다…😅     🔸 배지 만들기      다른 분들 보니까 이런식으로 c++같은 프로그래밍 언어들을 그냥 텍스트로 쓰지 않고 배지 그림으로 달아 놓으셨더라고요. 저도 좋아보이는 건 다 해보고 싶어서 배지 이미지를 만들어 주는 사이트에서 만들었습니다.     ▪️ 배지 : https://shields.io/  ▪️ 언어 로고 : https://simpleicons.org/   위 사이트들에 가면 저런 폼나는 아이콘들을 얻을 수 있습니다.     배지를 만드시려면      이런식으로 넣고 싶은 문구를 입력하고 세번째 칸의 화살표를 눌러서 색상을 선택하거나 직접 입력하시고 나서 오른쪽의 Make Badge 버튼을 누르시면       이렇게 배지를 만들어 줍니다. 여기서 주소를 복사하세요.    &lt;img src=\"https://img.shields.io/badge/-TechBlog-brightgreen\"&gt;  위 태그를 리드미에 입력하시면 우리가 만든 배지를 불러옵니다. 하지만 이렇게만 작성하면 단순히 그림만 불러오고 이 그림을 눌렀을 때 어디로 이동할지는 정해주지 않았기 때문에 그냥 새 창에서 그림이 호출될 것이어요…     &lt;a href=\"https://miro7923.github.io/\"&gt; &lt;img src=\"https://img.shields.io/badge/-TechBlog-brightgreen\"&gt;  그렇기 때문에 이런식으로 a 태그를 이용해 하이퍼링크를 걸어주시면 우리가 만든 배지 그림을 눌렀을 때 나의 블로그로 이동하게 됩니다.     일반화한다면    &lt;img src=\"https://img.shields.io/badge/라벨-메세지-색상\"&gt;  이렇게 작성하시면 됩니다.     만약 이메일 주소도 추가하고 싶으시면    &lt;a href=\"mailto:miro7923@gmail.com\"&gt;  mailto를 이용해 메일주소를 적어주세요!     🔸 프로그래밍 언어 로고 만들기   &lt;img src=\"https://img.shields.io/badge/C++-00599C?style=flat-square&amp;logo=C%2B%2B&amp;logoColor=white\"/&gt;&lt;/a&gt;&amp;nbsp   프로그래밍 언어 로고는 위와 같이 태그를 입력하면 되는데 이것을 일반화하면   &lt;img src=\"https://img.shields.io/badge/언어-색상?style=flat-square&amp;logo=simpleicons에서 로고 이름&amp;logoColor=white\"/&gt;&lt;/a&gt;&amp;nbsp   위와 같은 형태로 만들 수 있습니다.      simpleicons 사이트에서 원하는 언어를 검색해서 그 언어의 이름과 색상을 넣어준 다음 simpleicons 사이트에서 표시되어 있는 언어의 이름을 넣어주시면 됩니다.      단, c++을 쓸 때에만 좀 주의하면 되는데 simpleicons 사이트에는 단순히 C++이라 나와있지만 이걸 그대로 쓰면 적용이 안 되고 C%2B%2B라고 적어주어야 적용이 된다고 합니다. %2B가 +에 대응된다고 합니다.   c#은 C Sharp 이라는 이름으로 등록되어 있었습니다.        대략 이렇게 태그들을 쓴 다음에         커밋 버튼 눌러서 마무리!     3. 최종 완성      짠 👏 커밋 버튼을 눌러서 나오면 이렇게 완성된 리드미를 볼 수 있습니다.        그리고 제 깃헙 프로필 메인 페이지를 확인해보면 이렇게 있어보이게 바꼈습니다! 😄 뿌듯~~!!   이렇게 보니까 할 줄 아는거 되게 많네요! ㅎㅎ 더 뿌듯하다…     앞으로 공부 더 열심히 해야겠습니다. 그럼 다음 글에서 만나요! 👋   ","categories": ["Story"],
        "tags": ["story"],
        "url": "/story/decorate-github-profile/",
        "teaser": null
      },{
        "title": "CSS 기초",
        "excerpt":"👀 CSS란?     Cascading Style Sheets의 약자로 HTML로 만든 웹 문서 뼈대에 디자인을 적용하기 위한 것   🔸 적용 방법     태그에 바로 스타일 적용 - 잘 안씀    head 안에서 스타일 적용    외부파일로 스타일 적용      👀 기본 문법  태그 대상 {     속성: 값;     속성: 값; ... }  * {     HTML 내용 전체 선택 }  h2 {     color: blue;     background-color: skyblue;     모든 h2 태그에 적용 }   #p1 {     id=\"p1\" 인 id 모두 선택 }  .p2 {     class=\"p2\" 인 class 모두 선택 }  #footer p {     footer 안에 있는 p 태그에만 적용 }  /* 하이퍼링크 태그에만 부분적으로 적용하는 것도 가능하다 */ a:link, a:visited { \t/* 하이퍼링크색, 방문한 하이퍼링크색 변경 */ \tcolor: black; }  a:hover { \t/* 하이퍼링크에 마우스를 올리면 */ \tcolor: white; \tbackground-color: black; }      &lt;p id=\"p1\"&gt;, &lt;span class=\"p2\"&gt; 와 같이 지정하며 id는 넓은 영역을 지정할 때 주로 사용하고 class는 좁은 영역을 지정할 때 주로 사용한다고 한다.      👀 CSS 꾸미기 속성들   p { \t/* 배치 */ \tdisplay: block; 전체영역(문단영역) : 블록레벨 \tdisplay: inline; 요소영역 : 인라인 레벨(가로로 붙음) \tdisplay: inline-block; 메뉴 만들땐 인라인 블록이 편하다 \tdisplay: inline-block;      \t/* 박스크기 계산 box-sizing */     /* 웹 페이지의 내용물들을 배치할 때 박스크기 계산한 것을 바탕으로 배치하는 것이 좋다 */ \tbox-sizing: border-box; 내용 안여백 테두리선 포함해서 크기 계산 \tbox-sizing: content-box; 내용(기본값)물만 포함해서 크기 계산      \t/* 너비 */ \twidth: 600px; \t \t/* 높이 */ \theight: 50%;       /* 안 여백 10px */ \tpadding: 10px; \t \t/* 밖 여백 */ \tmargin: 50px;      \t/* 배경색 */ \tbackground-color: silver; \tbackground-color: #0000ff; \tbackground-color: rgb(255, 0, 0);          color: rgba(255, 0, 0, 0.5);     color: #ff0000;          font-family: \"바탕\";          font-size: 20px;     font-size: 3em;     /* 절대크기(지정된 크기) : 상대크기(상대적인 글자크기) */     /* 포인트 pt, 픽셀 px, em 대문자를 기준으로 비율값 적용, rem 1em 비율값 적용, ex 소문자를 기준으로 적용 */          font-style: italic;          font-weight: bold;          /* 글자 가운데 정렬 */     text-align: center;          line-height: 100%;          text-decoration: overline;          /* 그림자 효과 */     text-shadow: 5px 5px 3px black;           /* 글자 하나사이 간격*/     letter-spacing: 0.5em;           /* 단어 사이 간격 */     word-spacing: 50px;           /* 목록 들여쓰기 내어쓰기 inside/outside */     list-style-position: outside;          /* 목록 점(불릿) 대신 이미지 사용 */     list-style-image: url(\"1.jpeg\");          /* 표 제목 위치 지정 caption-side: top/bottom; */ \tcaption-side: top;      \t/* 표 테두리선 그려주기 border: 테두리선 두께 테두리선 모양 테두리선 색 */ \tborder: 1px solid black;     border-style: dotted; \tborder-color: blue;      \t/* 셀(칸) 사이에 여백 */ \tborder-spacing: 10px; \t \t/* 표와 셀 테두리 합치기 */ \tborder-collapse: collapse;          /* 모서리 둥글게 */ \tborder-radius: 50%;          /* 박스 그림자 (12시부터 시계방향으로) 색상 */ \tbox-shadow: 5px 5px 15px 5px green;   \t/* 어울림 배치하는 법 */ \tfloat: left; /* 이미지를 왼쪽으로 기준으로 글자 어울림 배치 */ \tfloat: right; /* 이미지 오른쪽으로 기준으로 글자 어울림 배치 */   \t/* 어울림 배치 해제 */ \t/* 아까 설정한 방향 중 해제하고 싶은 방향을 입력해줌 */ \tclear: left; \tclear: right; \tclear: both;            /* 배경 이미지 삽입 */ \t/* 이미지 태그에서 안보이면 스타일시트에서 이미지를 넣은 것이다. */ \tbackground-image: url(\"dot.png\"); \tbackground-repeat: repeat; /* 이미지 바둑판 모양으로 반복 */ \tbackground-repeat: repeat-x; /* x축만 반복 */ \tbackground-repeat: repeat-y; /* y축만 반복 */ \tbackground-repeat: no-repeat; /* 반복 안함 */  \tbackground-position: center; /* 문단 가운데로 정렬 */ \tbackground-position: bottom right; /* 두개 넣으면 오른쪽 아래와 같이 정렬됨 */ \tbackground-position: top left; \tbackground-size: 50px 50px; }      ☑️ CSS 꾸미기 시작은  * { \t/* body 영역엔 기본적인 여백이 조금씩 있는데 이걸 다 0으로 만들고 시작한다. */ \tmargin: 0px; \tpadding: 0px; \t \t/* 테두리포함 너비 계산하기 */ \tbox-sizing: border-box; }      위와 같이 초기화하고 시작하는 것이 좋다.  ","categories": ["HTML"],
        "tags": ["HTML","Front-end","CSS"],
        "url": "/html/CSS-beginning/",
        "teaser": null
      },{
        "title": "HTML 문법",
        "excerpt":"👀 시작 전에     HTML 문서는 크게 &lt;head&gt; 부분과 &lt;body&gt; 부분으로 나누어져 있다.   크롬 탭에서 보이는 제목을 지정하고 싶으면 &lt;head&gt; 부분에 &lt;title&gt; 태그를 이용해 제목을 적어준다.   &lt;body&gt; 부분에 본격적인 웹 페이지 내용을 작성한다.     🔸 HTML 주석문   &lt;!-- 주석 --&gt;      HTML에서의 주석문은 다른 프로그래밍 언어와는 다르게 위와 같이 쓴다.   🔸 제목 태그   &lt;h1&gt;제목&lt;/h1&gt; &lt;h2&gt;제목2&lt;/h2&gt; &lt;h3&gt;제목3&lt;/h3&gt; &lt;h4&gt;제목4&lt;/h4&gt; &lt;h5&gt;제목5&lt;/h5&gt; &lt;h6&gt;제목6&lt;/h6&gt;      제목 태그에는 6가지가 있다.   1번이 글씨 크기가 가장 크고 숫자가 커질수록 글씨 크기가 작아진다.   🔸 문단 태그   &lt;p&gt;문단 내용&lt;/p&gt;      아래위로 공백이 약간 생기면서 한 문단을 만드는 것과 같은 효과를 줄 수 있다.   🔸 글씨 꾸미기 태그   &lt;b&gt;진하게&lt;/b&gt; &lt;strong&gt;진하게&lt;/strong&gt; &lt;i&gt;기울이기(이탤릭체)&lt;/i&gt; &lt;em&gt;기울이기&lt;/em&gt; &lt;small&gt;작게&lt;/small&gt; &lt;u&gt;밑줄&lt;/u&gt; &lt;sup&gt;위 첨자&lt;/sup&gt; &lt;sub&gt;아래 첨자&lt;/sub&gt; &lt;del&gt;취소선 긋기&lt;/del&gt;  &lt;blockquote&gt;인용문 들여쓰기 효과&lt;/blockquote&gt;  &lt;hr&gt; &lt;!-- 수평선 긋는 태그 --&gt;  &lt;pre&gt;     원하는  \t\t모양대로 \t\t\t\t출력 \t\t\t이 가능한 태그 &lt;/pre&gt;      &lt;b&gt; 태그를 쓰면 글씨를 진하게 표현할 수 있고 &lt;i&gt; 태그를 쓰면 글씨를 옆으로 기울일 수 있다.   🔸 줄바꿈 태그  안녕하세요!&lt;br&gt; Hello!      HTML에서는 단순히 엔터를 치는 것으로는 줄을 바꿀 수 없다.   줄을 바꾸고 싶은 곳에서 &lt;br&gt; 태그를 적어줘야 줄바꿈이 적용된다.   🔸 하이퍼링크 태그  &lt;a href=\"http://www.naver.com\"&gt; 네이버 하이퍼링크 &lt;/a&gt;&lt;br&gt; &lt;a href=\"test1.html\"&gt; test1.html 문서 하이퍼링크 &lt;/a&gt;&lt;br&gt; &lt;a href=\"4.jpeg\" download=\"\"&gt; 이미지 다운로드 &lt;/a&gt;&lt;br&gt; &lt;a href=\"ex4.html\" target=\"_blank\"&gt;새 창에서 연결&lt;/a&gt;&lt;br&gt;      웹 페이지 링크를 걸 수도 있고 내가 만든 HTML 페이지를 링크로 걸 수도 있다.   웹 페이지 링크를 작성할 땐 http://도 꼭 써주어야 제대로 동작한다.   ☑️ 문서 내에서 하이퍼링크  &lt;a href=\"#content1\" id=\"menu\"&gt;메뉴1&lt;/a&gt; &lt;a href=\"#content2\"&gt;메뉴2&lt;/a&gt; &lt;a href=\"#content3\"&gt;메뉴3&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;  &lt;a id=\"content1\"&gt;메뉴1 문서&lt;/a&gt; &lt;a href=\"#menu\"&gt;메뉴 위로 이동&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;  &lt;a id=\"content2\"&gt;메뉴2 문서&lt;/a&gt; &lt;a href=\"#menu\"&gt;메뉴 위로 이동&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;  &lt;a id=\"content3\"&gt;메뉴3 문서&lt;/a&gt; &lt;a href=\"#menu\"&gt;메뉴 위로 이동&lt;/a&gt;   🔸 이미지 삽입 태그  &lt;img src=\"1.jpeg\"&gt;&lt;br&gt; &lt;img src=\"2.gif\"&gt;&lt;br&gt; &lt;img alt=\"3번이미지\" src=\"./3.png\" width=\"50%\" height=\"50%\" border=\"5\"&gt;      이미지를 삽입할 때엔 닫는 태그가 없어도 된다.   이미지 파일은 삽입하고자 하는 HTML 파일과 동일한 위치에 있어야 경로지정 없이 삽입할 수 있다.   같은 위치에 없다면 경로지정을 해 주어야 하는데            . : 현재폴더(생략가능)       .. : 상위폴더       상대참조 : 현재 페이지를 기준으로 상대적 파일을 찾는 방법       절대참조 : /(root) 기준으로 파일 경로를 찾아가는 방법           ☑️ img 태그 속성     src : 원본(그림) 파일   alt : 원본이 안 보일 때 표시할 그림 설명   width : 이미지 너비(픽셀) 지정            px : 이미지 크기를 픽셀 단위로 지정. 고정값       % : 이미지 크기가 브라우저 크기에 따라 변동됨           ☑️ 픽셀(Pixel)     화면을 이루는 빛(하나의 점)   ☑️ 해상도     화면을 이루는 점(빛)의 개수   ☑️ 웹에서 사용하는 이미지 형식     .jpg : 사진형태. 색상과 명암을 다양하게 표현   .gif : 256색상 사용. 작은 아이콘, 작은 이미지 사용. 움직이는 이미지   .png : 색상 다양하게 표현. 투명한 배경색 가능. 웹에서 많이 사용   🔸 목록 만드는 태그  순서 있는 목록  &lt;ol&gt;   &lt;li&gt; 항목1 &lt;/li&gt;   &lt;li&gt; 항목2 &lt;/li&gt; &lt;/ol&gt;      1부터 차례대로 순서가 매겨지면서 목록이 만들어진다.   &lt;ol type=\"i\"&gt;   &lt;li&gt;항목1&lt;/li&gt;   &lt;li&gt;항목2&lt;/li&gt; &lt;/ol&gt;      type에 1, a, A, i, I(이탤릭)들을 사용해 순서를 매길 포맷을 지정해 줄 수 있다.   순서 없는 목록  &lt;ul&gt;   &lt;li&gt;항목1&lt;/li&gt;   &lt;li&gt;항목2&lt;/li&gt; &lt;/ul&gt;      순서가 없이 점만 찍히는 목록이 만들어진다.   &lt;ul type=\"circle\"&gt;   &lt;li&gt;항목1&lt;/li&gt;   &lt;li&gt;항목2&lt;/li&gt; &lt;/ul&gt;      마찬가지로 disc, square, circle 점 모양 속성을 지정해 줄 수 있다.   🔸 표 만드는 태그  &lt;table border=\"1\"&gt;   &lt;caption&gt;표제목&lt;/caption&gt;   &lt;tr&gt;&lt;td&gt;1행1열&lt;/td&gt;&lt;td&gt;1행2열&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td&gt;2행1열&lt;/td&gt;&lt;td&gt;2행2열&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;      &lt;table&gt; 태그를 이용해 틀을 만든 다음 &lt;tr&gt;을 사용해 가로로 줄을 그어 칸을 만들고 &lt;td&gt; 태그로 세로로 줄을 그어 칸을 만들 수 있다.   &lt;thead&gt; &lt;!-- 코드 상에서 영역 나눠서 작업할 때 사용 --&gt; &lt;tr&gt;&lt;th&gt;제목1&lt;/th&gt;&lt;th&gt;제목2&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt;  &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;내용1&lt;/td&gt;&lt;td&gt;내용2&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;  &lt;tfoot&gt; &lt;tr&gt;&lt;td&gt;내용3&lt;/td&gt;&lt;td&gt;내용4&lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt;   표 합치기  &lt;table border=\"1\" width=\"500\" height=\"300\"&gt;   &lt;tr&gt;&lt;td&gt;용도&lt;/td&gt;&lt;td&gt;중량&lt;/td&gt;  &lt;td colspan=\"2\"&gt;개수가격&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td rowspan=\"2\"&gt;선물용&lt;/td&gt;&lt;td&gt;3kg&lt;/td&gt;&lt;td&gt;11-16과&lt;/td&gt;&lt;td&gt;35000원&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;                         &lt;td&gt;5kg&lt;/td&gt;&lt;td&gt;18-26과&lt;/td&gt;&lt;td&gt;52000원&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td rowspan=\"2\"&gt;가정용&lt;/td&gt;&lt;td&gt;3kg&lt;/td&gt;&lt;td&gt;11-16과&lt;/td&gt;&lt;td&gt;30000원&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;                         &lt;td&gt;5kg&lt;/td&gt;&lt;td&gt;18-26과&lt;/td&gt;&lt;td&gt;47000원&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;      colspan으로 가로로 나란히 위치한 칸들을 합치고 rowspan으로 세로로 나란히 위치한 칸들을 합칠 수 있다.   🔸 폼(양식) 태그     기능과 데이터들을 묶어주는 것   submit 버튼을 클릭하면 폼태그에 있는 내용(데이터, 이름 =&gt; 값)을 서버(백엔드)로 전송하는 기능을 폼태그를 사용해 만들 수 있다.   전송 방식에는 Get 방식과 Post 방식이 있다.   &lt;fieldset&gt; &lt;!-- 테두리를 그려서 그룹으로 묶어주는 태그 --&gt; \t&lt;legend&gt;그룹이름1&lt;/legend&gt; \t&lt;label&gt;아이디 :&lt;/label&gt; \t&lt;input type=\"text\" name=\"id\" value=\"아이디\" size=\"30\" maxlength=\"5\" readonly=\"readonly\"&gt;&lt;br&gt; \t&lt;!-- size=\"30\" 30자를 적을 수 있는 크기 maxlength=\"5\" 입력학 글자개수 readonly=\"readonly\" 읽기전용 --&gt; \t&lt;label&gt;비밀번호 : &lt;/label&gt; \t&lt;input type=\"password\" name=\"pass\" required autofocus&gt;&lt;br&gt; \t&lt;!-- 비밀번호 필수요소로 입력제어 \tautofocus : 입력상자에 커서 깜박이게 하기  --&gt; \t&lt;label&gt;자기소개 : &lt;/label&gt; \t&lt;textarea rows=\"5\" cols=\"10\"&gt;&lt;/textarea&gt;&lt;br&gt; \t&lt;label&gt;이메일 :&lt;/label&gt; \t&lt;input type=\"email\" name=\"email\" placeholder=\"이메일 형식\"&gt;&lt;br&gt; \t&lt;!-- placeholer : 배경이미지 형태로 설명글 --&gt; \t&lt;label&gt;날짜 : &lt;/label&gt; \t&lt;input type=\"date, name=\"date\" min=\"2022-01-01\" max=\"22022-01-14\"&gt; \t&lt;label&gt;날짜(월) : &lt;/label&gt; \t&lt;input type=\"week\" name=\"week\"&gt; \t&lt;label&gt;시간 : &lt;/label&gt; \t&lt;input type=\"time\" name=\"time\"&gt;&lt;br&gt; \t&lt;label&gt;날짜 시간 : &lt;/label&gt; \t&lt;input type=\"datetime-local\" name=\"datetime\"&gt;&lt;br&gt; &lt;/fieldset&gt;```  * `type`의 `text`는 입력하는 글자를 보여주는 것이고 `password`는 입력하는 글자를 보여주지 않는 것이다.  ```html &lt;textarea rows=\"5\" cols=\"30\" placeholder=\"본사 지원 동기를 간략히 적어주세요.\"&gt;&lt;/textarea&gt;&lt;br&gt;      &lt;textarea&gt;를 사용하면 긴 텍스트를 입력할 수 있는 텍스트박스를 만들 수 있다.   placeholder=\"\" 속성은 회색 글씨로 안내 사항을 입력해 놓는 것. 입력을 시작하면 사라진다.   &lt;fieldset&gt; \t&lt;legend&gt;그룹이름2&lt;/legend&gt; \t&lt;label&gt;검색 : &lt;/label&gt; \t&lt;input type=\"search\" name=\"search\"&gt;&lt;br&gt; \t&lt;label&gt;웹주소 : &lt;/label&gt; \t&lt;input type=\"url\" name=\"url\"&gt;&lt;br&gt; \t&lt;label&gt;연락처(모바일) : &lt;/label&gt; \t&lt;input type=\"tel\" name=\"tel\"&gt;&lt;br&gt; &lt;!-- 모바일 환경에서는 숫자 키패드 나옴 --&gt; \t&lt;label&gt;숫자 : &lt;/label&gt; \t&lt;input type=\"number\" name=\"number\"&gt;&lt;br&gt; \t&lt;label&gt;슬라이드 밸류값 설정 : &lt;/label&gt; \t&lt;input type=\"range\" name=\"range\"&gt;&lt;br&gt;  &lt;/fieldset&gt;   🔸 라디오 버튼(radio)과 체크박스(checkbox)   성별 : &lt;input type=\"radio\" name=\"gender\" value=\"남\"&gt;남성        &lt;input type=\"radio\" name=\"gender\" value=\"여\"&gt;여성&lt;br&gt; 취미 : &lt;input type=\"checkbox\" name=\"hobby\" value=\"여행\"&gt;여행 \t  &lt;input type=\"checkbox\" name=\"hobby\" value=\"게임\"&gt;게임       &lt;input type=\"checkbox\" name=\"hobby\" value=\"독서\"&gt;독서&lt;br&gt; 목록상자 : &lt;select name=\"sel\" size=\"5\" multiple=\"multiple\"&gt; \t\t&lt;option value=\"목1\"&gt;목록1&lt;/option&gt; \t\t&lt;option value=\"목2\"&gt;목록2&lt;/option&gt; \t\t&lt;option value=\"목3\"&gt;목록3&lt;/option&gt;         &lt;/select&gt;      radio는 하나만 선택 가능할 때 사용하고 checkbox는 여러개를 선택할 수 있을 때 사용한다.   이 때 name을 동일하게 해야 같은 그룹으로 취합되고 그 안에서 선택하는 것이 가능하다.   &lt;form action=\"test1.html\" method=\"get\"&gt;  파일업로드 : &lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; 히든값 : &lt;input type=\"hidden\" name=\"hi\" value=\"값\"&gt; &lt;!-- 사용자에게는 보이지 않는 숨겨진 입력 필드 정의 --&gt; &lt;input type=\"button\" value=\"버튼\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"전송\"&gt;&lt;br&gt; &lt;!-- action=\"test1.html\"으로 작성 내용들을 전달함. 폼태그 밖에서 쓰면 작동 안됨  --&gt;  &lt;input type=\"image\" scr=\"5.jpeg\" width=\"100\" height=\"100\"&gt; &lt;input type=\"reset\" value=\"초기화\"&gt;&lt;br&gt; &lt;/form&gt;   🔸 영역 지정 태그  &lt;div&gt;   큰 영역을 지정할 때 사용(웹 블록 지정) &lt;/div&gt;  &lt;span&gt; 인라인(작은 영역) 블록 지정 &lt;/span&gt;   🔸 특수 문자 입력 태그  &amp;nbsp;  공백 표시 &amp;lt;    꺽쇄(&lt; &gt;) 표시 &amp;copy;  ©  &amp;amp;   &amp;  &amp;quot;  \"  &amp;clubs; ♣  ","categories": ["HTML"],
        "tags": ["HTML","Front-end"],
        "url": "/html/HTML-language01/",
        "teaser": null
      },{
        "title": "프론트엔드와 백엔드",
        "excerpt":"👀 프론트엔드란?     웹 화면에 보여지는 모든 것들을 프론트엔드라 칭한다.     👀 백엔드란?     웹 화면에 보여지지 않지만 화면에 표시하기 위해 서버로부터 보내는 데이터, 데이터베이스에 있는 고객의 정보 등 화면에 보여지지 않지만 웹 화면 구성을 위해서 필요한 것들     👀 HTML이란?     Hyper Text Markup Language의 약자로 웹 문서를 작성하는 마크업 언어(Markup Language)이다.   Hyper Text : 문서를 서로 연결해주는 링크   Markup : 표시한다(텍스트, 이미지, 영상, …) 웹 문서를 만드는 기본 언어   HTML은 태그로 구성되어 있으며, 태그를 이용해 인터넷에 문자와 그림을 표현하거나 하이퍼링크로 서로 다른 문서들을 연결한다.   학습에 참고하면 좋은 사이트 : http://www.w3schools.com  ","categories": ["HTML"],
        "tags": ["HTML","Front-end","Back-end"],
        "url": "/html/HTML/",
        "teaser": null
      },{
        "title": "JSP 액션 태그",
        "excerpt":"👀 액션 태그란?   &lt;jsp:~ 형태로 시작하는 태그&gt;      JSP 페이지에서 HTML 태그 형태로 JSP 코드의 역할을 수행하는 것   스크립틀릿 등의 스크립트 요소(자바 코드)를 사용하지 않기 때문에 JSP 페이지의 내부적인 프로그램 로직을 사용자로부터 감출 수 있다.   즉, 사용자에게 보여지는 프레젠테이션 부분과 사용자의 요청을 처리하는 비즈니스 로직 부분(프로그램 부분)을 분리하는 것이 가능하다.   프로그램 재사용성을 높여주고 코드의 간결성을 향상시킨다.   🔸 &lt; jsp:forward &gt;   &lt;jsp:forward page=\"이동할 페이지(ex. forward.jsp)\" /&gt; &lt;jsp:forward page=\"이동할 페이지\"&gt;&lt;/jsp:forward&gt;      액션 태그는 XML 문법을 이용하여 구현된 기능이므로 태그의 종료 끝에 반드시 종료 태그가 있어야 한다.   forward 액션은 현재 페이지의 요청과 응답에 관한 처리권을 page 속성에 지정된 이동할 페이지로 영구적으로 넘기는 기능을 한다.   🔸 &lt; jsp:include &gt;   &lt;jsp:include page=\"이동할 페이지(ex. forward.jsp)\" flush=\"false\" /&gt; &lt;jsp:include page=\"이동할 페이지(ex. forward.jsp)\" flush=\"false\"&gt;&lt;/jsp:include&gt;      특정 페이지를 include 한다.   각각의 페이지를 컴파일 후 해당 파일을 include 한다.   top, bottom과 같은 동일 사용 페이지를 추가할 때 사용한다.   🔸 &lt; jsp:param &gt;   &lt;jsp:param name=\"파라미터 이름1\" value=\"파라미터 값1\" /&gt; &lt;jsp:param name=\"파라미터 이름2\" value=\"파라미터 값2\" /&gt;      forward와 include 태그를 사용하여 이동할 페이지에 추가적으로 넘겨줄 파라미터가 있으면 &lt;jsp:param/&gt; 태그를 사용할 수 있다.  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-action-tag/",
        "teaser": null
      },{
        "title": "JSP 지시어(Directive)",
        "excerpt":"👀 JSP 지시어란?(Directive)   &lt;%@ ... %&gt;      JSP 파일 내에서 JSP를 실행할 컨테이너에서 해당 페이지를 어떻게 처리할 것인가에 대한 설정 정보들을 지정해주는 데 사용   page 지시어, include 지시어, taglib 지시어 3가지로 나누어진다.   1. page 지시어   &lt;%@ page 속성1=\"값1\" 속성2=\"값2\" 속성3=\"값3\"... %&gt;      JSP 페이지에 대한 속성을 지정하는 지시어   속성에는 스크립트 언어, import할 패키지/클래스, 세션 사용 여부, 에러 페이지 등 12개의 설정 정보를 지정해 사용할 수 있다.                  속성       사용법       기본값       설명                               language       language=”java”       java       스크립트 요소에서 사용할 언어 설정                         extends       extends=”클래스명”       없음       상속받을 클래스를 설정                         import       import=”패키지.클래스명”       없음       import할 패키지.클래스 설정                         session       session=”true”       true       HttpSession 사용 여부를 설정                         buffer       buffer=”16kb”       8kb       JSP 페이지의 출력 버퍼 크기를 설정                         autoFlush       autoFlush=”true”       true       출력 버퍼가 다 찼을 경우 처리 방법을 설정                         isThreadSafe       isThreadSafe=”true”       true       다중 스레드의 동시 실행 여부를 설정                         info       info=”페이지 설명”       없음       페이지 설명                         errorPage       errorPage=”에러 페이지.jsp”       없음       에러 페이지로 사용할 페이지를 지정                         contentType       contentType=”text/html”       text/html;charset=ISO-8859-1       JSP 페이지가 생성할 문서의 타입을 지정                         isErrorPage       isErrorPage=”false”       false       현재 페이지를 에러 페이지로 지정                         pageEncoding       pageEncoding=”euc-kr”       ISO-8859-1       현재 페이지의 문자 인코딩 타입 설정                      각각의 속성을 하나의 page 지시어에 한 번에 지정할 수도 있으며 여러 개의 page 지시어에 나누어 지정할 수도 있다.   하지만 import 속성을 제외한 나머지 속성은 하나의 페이지에서 오직 한 번씩만 지정할 수 있다.     2. include 지시어   &lt;%@ include file=\"header.jsp\" %&gt;      특정한 JSP 파일 또는 HTML 파일을 해당 JSP 페이지에 삽입할 수 있도록 하는 기능을 제공한다.   include되는 JSP 코드 자체가 해당 JSP 페이지에 복사되어 더해지므로 서블릿 컴파일 과정은 include 되는 페이지의 수가 아무리 많아도 단 한 번만 이루어지게 된다.   사용되는 공통 변수값들을 추가할 때 주로 사용한다.   include 지시어는 중첩 사용이 가능하기 때문에 include되는 파일 안에서 또 다른 파일을 include하여도 문제없이 동작한다.     3. taglib 지시어   &lt;%@ taglib url=\"http://taglib.com/sampleURI\" prefix=\"samplePrefix\" %&gt;      JSTL(JSP Standard Tag Library)이나 커스텀 태그 등 태그 라이브러리를 JSP`에서 사용할 때 접두사를 지정하기 위해 사용된다.   uri 속성과 prefix 속성으로 이루어진다.   🔸 uri 속성     태그 라이브러리에서 정의한 태그와 속성 저보를 저장한 TLD(Tag Library Descriptor) 파일이 존재하는 위치 지정   🔸 prefix 속성     사용할 커스텀 태그의 네임 스페이스(Name Space)를 지정  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-directive/",
        "teaser": null
      },{
        "title": "JSP 내장 객체",
        "excerpt":"👀 내장 객체란?     JSP 페이지가 웹 컨테이너에 의해서 서블릿으로 변환할 때 웹 컨테이너가 자동으로 생성해 주는 객체(클래스, import 구분없이 사용 가능)     javax.servlet 패키지 - 8개                   내장 객체 변수명       설명                               request       클라이언트의 HTTP 요청 정보를 저장한 객체(HTTP헤더 정보, 파라미터 등)                         response       클라이언트 요청에 대한(HTTP) 응답 정보를 저장한 객체                         session       클라이언트의 세션 정보를 저장한 객체                         pageContext       페이지 실행에 필요한 컨텍스트 정보를 저장한 객체                         out       응답 페이지 정보를 전송하기 위한 출력 스트림 객체                         application       동일한 애플리케이션의 컨텍스트 정보를 저장한 객체                         config       해당 페이지의 서블릿 설정 정보(초기화 정보)를 저장한 객체                         page       해당 페이지 서블릿 객체(인스턴스)                    java.lang 패키지 - 1개      exception : 예외 처리를 위한 객체   1. request 객체          사용자의 요청에 관한 정보를 얻기 위한 객체         서버 도메인명 : request.getServerName();   서버 포트번호 : request.getServerPort();   URL : request.getRequestURL();   URI : request.getRequestURI();   클라이언트 호스트명 : request.getRemoteHost();   클라이언트 IP주소 : request.getRemoteAddr();   프로토콜 : request.getProtocol();   페이지 요청(전송)방식 : request.getMethod();   프로젝트 경로 : request.getContextPath();   물리적 경로 : request.getRealPath(\"/\");   http헤더 (user-agent): request.getHeader(\"user-agent\");   http헤더 (accept-language) : request.getHeader(\"accept-language\");   http헤더 (host) : request.getHeader(\"host\");        http헤더 (connection) : request.getHeader(\"connection\");       전송을 통해 다른 페이지에서 전달받은 (이름 등의)정보를 얻을 때   String name = request.getParameter(\"name\");         정보들을 배열로 얻을 때   String hobbies[] = request.getParameterValues(\"hobby\");   🔸 URI     URI는 특정 리소스를 식별하는 통합 자원 식별자(Uniform Resource Identifier)를 의미한다.   웹 기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스다.   🔸 URL     URL은 흔히 웹 주소라고도 하며, 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약이다. URI의 서브셋이다.   한마디로 URI가 자원 자체에 대한 고유 식별자라면 URL은 자원이 실제로 존재하는 위치를 가리킨다.         2. response 객체          클라이언트의 요청에 대한 HTTP 응답(HTTP Response)을 나타내는 객체              response.setHeader(“헤더이름”, 값);       response.addHeader(\"Refresh\", \"3\"); // 3초에 한번씩 새로고침 response.addHeader(\"Refresh\", \"3;url=http://www.naver.co.kr\"); // 3초 후에 다음 페이지로 이동      response.sendRedirect(“주소”); // “주소”로 요청 재전송   response.sendRedirect(\"http://www.naver.co.kr\"); // 해당 페이지로 바로 이동      response.setContentType(\"속성값\"); 컨텐츠 타입 지정   response.addCookie(\"쿠키값\"); 쿠키 추가   3. session 객체          클라이언트의 정보가 유지되어야 할 필요가 있는 경우를 위해 가상 연결을 구현해주는 세션         세션ID값 : session.getId();   세션생성시간 정보(ms) : session.getCreationTime();   최종 접속 시간(ms) : session.getLastAccessedTime();   세션 유지시간(기본)(1800s,30m) : session.getMaxInactiveInterval();    4. application 객체          해당 웹 애플리케이션의 실행 환경을 제공하는 서버의 정보와 서버측 자원에 대한 정보를 얻어내거나 해당 애플리케이션의 이벤트 로그를 다루는 메소드들을 제공         서버정보 : application.getServerInfo();   서버의 물리적 경로 : application.getRealPath(\"/\");   5. out 객체     서블릿/JSP 컨테이너가 응답 페이지를 만들기 위해 사용하는 출력 스트림 객체        하지만 표현식을 사용해서 자바 코드의 변수 값들과 메소드의 리턴 값들을 출력할 수 있기 때문에 잘 사용되지 않는다.         출력 : out.print(\"Hello\");   버퍼 사이즈 : &lt;%=out.getBufferSize() %&gt;byte&lt;br&gt;   버퍼 사용후 : &lt;%=out.getRemaining() %&gt;byte&lt;br&gt;  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-implicit-object/",
        "teaser": null
      },{
        "title": "JSP 영역 객체와 속성",
        "excerpt":"👀 영역 객체(Scope)와 속성(Attribute)     jsp 내장객체 중에서 특정 공간(Scope)에 정보를 저장하고, 저장된 정보(Attribute)를 공유할 수 있는 객체   JSP에서는 page, request, session, application 4가지 영역으로 정의한다.       ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-scope-attribute/",
        "teaser": null
      },{
        "title": "JSP 스크립트 요소",
        "excerpt":"👀 JSP 스크립트 요소  1. 선언문   &lt;%!     // 멤버변수와 메서드 선언 %&gt;      멤버변수와 메서드를 선언하기 위한 영역   클래스에서 멤버변수와 메서드를 선언한 것과 동일한 결과로 같은 JSP 페이지 어느 위치에서든 참조가 가능하다.   2. 스크립틀릿(Scriptlet)   &lt;% 문장1; %&gt; &lt;%     문장2; 문장3; 문장4; ... %&gt;      JSP 코드를 작성하는 영역   서블릿 코드의 작성법이 다소 어려워서 이것을 보완하기 위해 만들어진 방식   스크립틀릿 영역에서 선언되는 변수들은 지역변수로 인식된다.   JSP 파일이 실행되면 웹 컨테이너에 의해 JSP 파일이 파싱되어 서블릿 클래스로 변환된 자바 소스 파일과 클래스 자바 파일이 서버에 저장된다.   3. 표현식(Expression)   &lt;%=변수 %&gt; &lt;%=리턴값이 있는 메소드 %&gt; &lt;%=수식(변수 또는 리턴값이 있는 메소드를 포함할 수 있음) %&gt;      선언문, 스크립틀릿에 생성한 변수, 메소드의 리턴값을 스크립틀릿 태그 외부에서 출력하기 위해 사용   하나의 표현식 태그 내의 구문 전체가 print() 메소드의 괄호 안에 통채로 들어가기 때문에 표현식 태그 내부에서는 세미콜론(;)을 사용해서는 안된다.  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-script-elements/",
        "teaser": null
      },{
        "title": "세션(Session)과 쿠키(Cookie)",
        "excerpt":"👀 세션(Session)이란?  ☑️ 서버랑 클라이언트와의 관계(상태)를 유지하기 위해서 사용하는 값     HTTP 프로토콜은 상태가 유지되지 않기 때문에 요청에 대한 응답이 한 번씩 이뤄지고 나면 그 관계가 소멸된다.   하지만 이런 방식으로는 사용자가 회원 사이트에 로그인 했을 때 지속적으로 업무를 볼 수 없게 된다.   그래서 사용자가 지속적으로 업무를 볼 수 있도록 서버와 클라이언트간의 관계를 일정 시간동안 유지해주기 위해 쓰는 것이 세션이다.   세션객체(영역)는 브라우저당 1개씩 생성된다.   🔸 세션 메소드     세션값 생성 : session.setAttribute(\"이름\", 값);   세션값 사용 : session.getAttribute(\"이름\");   세션값 제거 : session.removeAttribute(\"이름\");   세션값 초기화 : session.invalidate();            ❗️ 세션값 제거 메소드를 통한 부분제거보다는 세션값 초기화를 시켜야 한다.       일부만 제거하면 사용자가 로그아웃 했는데 로그인 했을 때와 같은 행동이 일부 가능할 수 있다.               👀 쿠키(Cookie)란?     클라이언트 측에서 관리되는 정보   사용 가능한 기간동안 하드디스크에 저장되기 때문에 웹 브라우저가 사라져도 사용이 가능하다.   하지만 그만큼 보안적으로 취약하다. (그래서 보안이 필요한 정보는 세션 사용)   🔸 쿠키 생성 절차  1. 쿠키 생성  2. 쿠키가 필요로 하는 설정값 저장(유효기간, 설명, 도메인, …)  3. 웹 브라우저에 생성된 쿠키 정보 전달  4. 웹 브라우저 요청에서 쿠키를 얻어온다.  5. 쿠키 정보는 이름, 값의 데이터 쌍으로 형성된다.  6. 쿠키 이름을 사용해서 해당 값을 사용한다.   🔸 쿠키 사용 방법  1) HTTP 헤더 정보 사용 - 안씀 XX  2) 서블릿 API 사용 - 현재 쓰는 방식      쿠키 생성하는 예제 코드   &lt;%     // 쿠키값 생성 - 서블릿 API 사용     Cookie cookie = new Cookie(\"name\", \"CookieValue\"); // HDD 저장X, 메모리에만 있는 상태 \t\t     // 쿠키값 설정 - 유효기간 설정     cookie.setMaxAge(600); // 초 단위 - 10분 \t\t     // 쿠키값을 저장(응답정보(response)에 저장)     response.addCookie(cookie);     System.out.println(\"쿠키정보가 전달 완료시 사용자의 HDD에 저장\"); %&gt;           먼저 쿠키를 생성한 다음 클라이언트에게 전송한다.            쿠키값 가져오는 예제 코드       &lt;%     // 쿠키값 가져오기(request - 요청정보로부터 꺼내오기)     Cookie[] cookies = request.getCookies(); \t\t\t     if (null != cookies) // !!배열을 반복문 돌리기 전에 예외처리 꼭 하기!!     {         for (int i = 0; cookies.length &gt; i; i++)         {             //System.out.println(cookies[i]);             if (cookies[i].getName().equals(\"name\"))             {                 // Cookie cookie = new Cookie(\"name\", \"CookieValue\"); // HDD 저장X, 메모리O                 // ⬆️ 얘를 가져올 것임                 // 이름이 같다면 내가 직접 생성한 쿠키임                 System.out.println(cookies[i].getValue()); \t\t\t\t\t\t                 out.print(\"쿠키명: \" + cookies[i].getName() + \"\\n\");                 out.print(\"쿠키값 : \" + cookies[i].getValue());             }         }     } %&gt;      그 다음 클라이언트 측에서 쿠키를 가져온다.   쿠키값을 가져올 때엔 꼭 예외처리를 해서 null값이 아닐 때에만 가져오는 동작을 수행하도록 해야한다.  ","categories": ["JSP"],
        "tags": ["JSP","WEB","Session","Cookie"],
        "url": "/jsp/JSP-session-cookie/",
        "teaser": null
      },{
        "title": "JavaScript 기본 문법",
        "excerpt":"자바스크립트란?     웹 페이지에 방문했을 때 사용자의 동작(이벤트)에 따른 처리를 하는 언어   인터프리터 언어로 작성된 코드를 위에서 아래로 순차적으로 실행한다.   컴파일 언어와 다른 점은 일단 실행을 하고 에러가 발생하기 전 까지의 코드만 실행한다.   객체 기반 언어이다.   오픈소스 언어   다양한 라이브러리(API) 사용 가능            Jquery 주로 사용 - Ajax, Json           HTML5(웹표준) API 기반의 언어      변수 선언     var 키워드를 이용해 선언한다.   var num = 1;      일반적인 프로그래밍 언어와 다르게 자료형별로 구분해서 선언하지 않는다. 변수 선언과 동시에 초기화하는 내용물에 따라서 자바스트립트가 알아서 자료형을 지정한다.   편한 듯 하면서도 원래 하던 언어가 있어서 그런지 무의식적으로 int num … 과 같이 타이핑하게 될 때가 많다.   🔸 var     var 키워드는 같은 이름으로 중복해서 선언하고 값을 넣는 것이 가능하다.   var name = \"james\"; console.log(name); // james  var name = \"lily\"; console.log(name); // lily      컴파일 언어를 하다 온 입장에서는 다소 이해가 되지 않지만 자바스크립트에서의 var 키워드는 이런 흐름이 가능하다.   변수가 많아지면 중간에 꼬일 가능성이 아주 많아 보이는 속성이다. 그래서 이것을 보완하기 위해 나온 것이 let 키워드이다.   🔸 let     let 키워드도 var처럼 변수를 선언하는 키워드지만 약간 속성이 다르다.   let name = \"james\"; console.log(name); // james  let name = \"lily\"; console.log(name);  // Uncaught SyntaxError: Identifier 'name' has already been declared      let 키워드를 사용하니까 컴파일 언어와 같은 흐름을 보인다.   🔸 const     컴파일 언어에서와 마찬가지로 상수 선언 키워드이다.   const 다음에 자료형은 쓸 필요 없이 바로 변수 이름을 선언하고 초기화하면 된다.   const name = \"james\";       연산자     연산자의 사용은 동일하지만 자바스크립트에는 ===과 !==이라는 연산자가 있다.   데이터값과 자료형이 모두 동일한지 확인하는 연산자이다.   ==, != 연산자들은 단순히 값만 확인하고 자료형이 같은지는 확인하지 않는다.            그래서 문자 100과 숫자 100을 ==을 이용해서 값이 같은지 비교하면 true를 리턴한다.       === 연산자 사용시 false 리턴           🔸 연산자 우선순위      ()    단항연산자(++, –, !)    산술연산자(+, -, *, /, %)    비교연산자(&gt;, &lt;, &gt;=, &lt;=, ==, !=, ===, !==)                                    논리연산자(&amp;&amp;,                       )                            복합대입연산자(=, +=, -=, *=, /=, %=)     함수     함수 또한 자료형을 구분하지 않고 function 키워드 하나만 쓴다.   function 함수명() {     실행문; } 호출법 : 함수명();          익명함수도 사용 가능하다.     변수 = function () {   실행문; } 호출법 : 참조 변수명();                   객체     내 눈앞에 보이는 모든 대상   🔸 객체 생성은 new 키워드를 이용해서 생성한다.  var 참조변수(레퍼런스) = new Object();       1) 내장객체     자바스크립트 안에 포함된 객체            문자(String), 날짜(Date), 수학(Math), 숫자(Number), 배열(Array), …           🔸 날짜(Date)객체   var day = new Date(2022,0,1); // 2022년 1월 1일      자바스크립트에서의 날짜객체에서 좀 희안한 점이라면 월(Month)이 실제 숫자보다 1 적은 형태로 표현된다는 것이다. new Date(2022,1,1); 이라 쓰면 2022년 2월 1일이다.   🔸 배열(Array)객체   var arr1 = new Array(); var arr2 = new Array('a', 'b', 'c'); // 다 가능 let arr3 = [1, 2, 3];       자바스크립트에서 배열은 배열객체를 통해 생성 할 수도 있고 컴파일 언어와 비슷하게 []를 사용해서 초기화 하는 형태로 선언할 수도 있다.   또 특이한 점이라면 하나의 배열에 서로 다른 자료형을 가진 값을 담을 수 있다는 것이다.   2) 브라우저 객체 모델(BOM)     웹 브라우저에 포함되어 브라우저를 표현하는 객체   계층형 구조로 되어 있다.            / document, screen, ... window -   location, history          \\ navigator      알림창을 출력할 때     window.alert(\"메시지 출력 메서드\");           를 많이 쓴다.   &lt;script type=\"text/javascript\"&gt; function myOpen() {     window.open(\"test1.html\", \"test1\", \"width=300, height=200, top=150, left=500\"); } &lt;/script&gt;  &lt;input type=\"button\" value=\"팝업창 열기\" onclick=\"myOpen();\"&gt;      위 처럼 HTML 태그와 함께 쓸 수 있다.   🔸 location 객체   location.href = 'test1.html'; // test1.html로 이동 location.reload(); // 페이지 새로고침 location.replace('test2.html'); // 현재 페이지를 test2.html로 변경      주소창과 관련된 기능을 가지고 있다.   특정 페이지로 이동하거나 현재 페이지를 다시 로드하는 등의 동작을 수행할 수 있다.   🔸 history 객체   history.back(); // 뒤로 가기 history.forward(); // 앞으로 가기 history.go(-숫자); // 숫자만큼 뒤로 가기 history.go(숫자); // 숫자만큼 앞으로 가기      페이지의 방문기록에 따른 동작을 수행할 수 있다.   🔸 navigator 객체     방문자(클라이언트)의 브라우저 정보 및 운영체제정보 확인 가능   &lt;script type=\"text/javascript\"&gt;     alert(navigator.userAgent); &lt;/script&gt;      위와 같이 쓰면 팝업창에서 사용자의 브라우저 정보와 운영체제정보를 볼 수 있다.   3) 문서 객체 모델(DOM)     HTML문서 구조(객체)   document.images[0].src; // 현재 페이지에 있는 이미지들 중 첫번째 소스에 접근   document.폼태그명.속성      HTML의 폼태그와 결합해 사용할 수 있다.   🔸 폼태그 form     사용자의 정보를 입력받아서 특정 페이지(action)로 정보를 전달하는(submit) 태그   전달 방식에서는 Get방식과 Post방식이 있다.   &lt;fieldset&gt;     &lt;legend&gt;회원정보 가입하기&lt;/legend&gt;     &lt;form action=\"itwill.jsp\" name=\"fr2\" method=\"get\" onsubmit=\"return fun8();\"&gt;         &lt;label&gt;아이디 : &lt;/label&gt;&lt;input type=\"text\" name=\"id\" value=\"\"&gt; &lt;br&gt;         비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt; &lt;br&gt;          주민번호 : &lt;input type=\"text\" name=\"ju1\" onkeyup=\"check1();\" maxlength=\"6\"&gt; - &lt;input type=\"text\" name=\"ju2\" maxlength=\"7\" onkeyup=\"check2();\"&gt;         &lt;br&gt; 메세지 :         &lt;textarea rows=\"5\" cols=\"10\" name=\"msg\"&gt;&lt;/textarea&gt;         &lt;br&gt; &lt;input type=\"submit\" value=\"회원 가입하기\" onsubmit=\"return fun8();\"&gt;          &lt;hr&gt;         &lt;input type=\"button\" value=\"속성 확인 버튼\" onclick=\"fun5()\"&gt;          &lt;input type=\"button\" value=\"속성 변경 버튼\" onclick=\"fun6()\"&gt;          &lt;input type=\"button\" value=\"데이터 확인 버튼\" onclick=\"fun7()\"&gt;     &lt;/form&gt; &lt;/fieldset&gt;      위와 같이 사용 가능하다.  ","categories": ["JavaScript"],
        "tags": ["JSP","JavaScript"],
        "url": "/javascript/JavaScript/",
        "teaser": null
      },{
        "title": "JSP란?",
        "excerpt":"👀 JSP(Java Server Page)란?     Java를 이용하여 동적인 웹 페이지를 만들기 위해 Sun Microsystems사가 개발한 기술     JSP의 특징  1. 강력한 이식성     자바기반의 언어로 어떤 JSP 컨테이너에서도 사용이 가능하므로 한 번 작성한 코드를 별다른 수정 없이 다른 플랫폼으로 이식이 가능하다.   모듈화와 모듈의 재사용성이 좋다.   2. 서버 자원의 효율적인 사용     스레드(Thread) 기반의 아키텍처 사용으로 불필요한 자원 낭비를 감소시켰다.   3. 간편한 MVC 패턴(디자인 패턴)     MVC 패턴을 JSP(View)와 자바빈즈(Model), 서블릿(Controller)을 이용해 쉽게 구현할 수 있다.   🔸 MVC 패턴     사용자에게 보여지는 화면인 View 부분과 실제 비즈니스 로직이 들어가는 Model 부분 그리고 View와 Model을 연결시켜주는 Controller 부분으로 구성   최근에 중대형 프로젝트에서 효과적이라 평가되어 많이 사용되고 있다.   🔸 디자인 패턴     프로젝트를 개발함에 있어서 특정한 문제가 주어졌을 때 그 문제를 해결하기 위한 방법을 설명해 놓은 일종의 지침   ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/What-is-JSP/",
        "teaser": null
      },{
        "title": "JSP 사용",
        "excerpt":"👀 JSP 사용     HTML 태그와 Java 코드를 함께 사용한다.   &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;%       // 스크립틀릿   %&gt; &lt;/body&gt; &lt;/html&gt;      HTML body 태그 안에서 스크립틀릿을 쓴 다음에 스크립틀릿의 범위 내에 코드를 작성한다.   &lt;h2&gt;자바코드로 테이블 생성&lt;/h2&gt;   &lt;table border=\"1\"&gt;     &lt;tr&gt;         &lt;td&gt;번호&lt;/td&gt;&lt;td&gt;이름&lt;/td&gt;     &lt;/tr&gt;     &lt;%         for (int i = 1; 6 &gt; i; i++)         {             %&gt;             &lt;tr&gt;                 &lt;td&gt;&lt;%=i %&gt;&lt;/td&gt;&lt;td&gt;학생&lt;%=i %&gt;&lt;/td&gt;             &lt;/tr&gt;             &lt;%         }     %&gt;   &lt;/table&gt;      위와 같이 자바 코드 사이에 스크립틀릿이 끝나는 표시(%&gt;)를 하고 HTML 태그를 쓴 다음에 &lt;%= %&gt;를 이용해 자바 코드의 지역 변수를 출력하는 것이 가능하다.(신기…)   🔸 JSP 주석   &lt;%-- --%&gt; (웹페이지 개발자 도구창에서 나타나지 않기 때문에 보안상 이것을 쓰는 것이 더 좋다) // 자바 스타일도 사용 가능  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/use-JSP/",
        "teaser": null
      },{
        "title": "운영체제",
        "excerpt":"👀 운영체제란?     Operating System, OS        컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층            좁은 의미의 운영체제(커널)            운영체제의 핵심 부분으로 메모리에 상주하는 부분       전공자 입장에서는 운영체제 하면 커널만을 이야기한다.           넓은 의미의 운영체제            커널 뿐 아니라 메모리에 상주하지 않는 각종 주변 시스템 유틸리티를 포함한 개념             🔸 운영체제의 목적      컴퓨터 시스템을 편라하게 사용할 수 있는 환경 제공   컴퓨터 시스템의 자원을 효율적으로 관리            하드웨어 자원인 프로세서, 기억장치, 입출력 장치들의 관리와       소프트웨어 자원인 프로세스, 파일, 메시지 등 모든 것을 관리한다.       사용자간의 형평성 있는 자원 분배가 가능해야 하고 주어진 자원으로 최대한의 성능을 낼 수 있어야 한다.       실행 중인 프로그램들은 CPU를 번갈아가며 차지하며 동작을 하게 되는데 이 때 운영체제는 한 프로그램이 CPU를 너무 오랫동안 쓰지 않고 짧은 시간동안 번갈아 쓰도록 할당해 주어야 한다.       또한 실행 중인 프로그램들에게 메모리 공간을 적절히 분배해 주어야 한다.             🔸 운영체제의 분류     동시 작업 가능 여부   사용자의 수   처리 방식     위 세 가지에 따라 분류할 수 있는데 현대 운영체제는 동시 작업이 가능하고 다중 사용자를 지원하며 시분할이 가능하다고 정리할 수 있다.   ☑️ 동시 작업 가능 여부  단일 작업(single tasking)     한 번에 하나의 작업만을 처리한다.   예) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음   과거에 MS-DOS에서 주로 사용되던 방식으로 현대 컴퓨터에선 쓰이지 않지만 엘리베이터처럼 기능이 단순하거나 특수 목적을 수행하는 기계에는 지금도 사용되고 있다.   다중 작업(multi tasking)     동시에 두 개 이상의 작업 처리   예) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음   스마트폰을 포함한 현대의 대부분의 하드웨어에서 사용되는 운영체제이다.     ☑️ 사용자의 수  단일 사용자(single user)     예) MS-DOS, MS Windows   다중 사용자(multi user)     예) UNIX, NT server   사용자가 많아지면 파일에 대한 접근 권한이나 사용자간 자원 분배를 형평성 있게 해 줄 수 있어야 한다.     ☑️ 처리 방식  일괄 처리(batch processing)     Interactive 하지 않은 방식   작업 요청을 일정량 모아서 한꺼번에 처리   작업이 완전 종료될 때까지 기다려야 함(하루 이상 걸림)   에) 초기 Punch Card 처리 시스템   시분할(time sharing)     Interactive한 방식   현대에 주로 사용하는 운영체제로 일반적인 범용 컴퓨터에서 사용   여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할해서 사용   일괄 처리 시스템에 비해 짧은 응답 시간을 가짐(UNIX)   하지만 응답 시간이 항상 고정된 것은 아니며 사용자가 많아지면 느려질 수 있다.   사람이 빠르다고 느끼면서 주어진 자원과 시간을 최대한 활용하는 것이 목적이다.   실시간(Realtime OS)     정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간시스템을 위한 OS   원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어 등 특수 목적을 가진 시스템에서 사용된다.   ▪️ 실시간 시스템의 개념 확장     Hard realtime system(경성 실시간 시스템)            데드라인을 지키지 않으면 큰일나는 시스템       예) 반도체, 미사일 등           Soft realtime system(연성 실시간 시스템)            데드라인을 좀 못 지켜도 괜찮은 시스템       예) OTT             🔸 비슷한 의미로 사용되지만 약간 다른 용어들     Multitasking : 하나의 프로그램이 끝나기 전에 다른 프로그램 작업이 가능한 것   Multiprogramming : 여러 프로그램이 메모리에 올라가 있는 것을 강조   Time sharing : CPU의 시간을 분할하여 나누어 쓴다는 것을 강조   Multiprocess : 여러 프로그램이 동시에 실행된다.   =&gt; 모두 컴퓨터에서 여러 작업을 동시에 수행한다는 것을 뜻하지만 어디에 더 초점을 맞추느냐에 따라 다르게 사용된다.   ☑️ Multiprocessor     하나의 컴퓨터에 CPU(processor)가 여러 개 붙어 있음을 의미   CPU가 하나임을 전제로 하는 위의 네 가지 용어들과는 하드웨어적으로 다르다.     🔸 운영체제의 예  ☑️ 유닉스(UNIX)     멀티태스킹 가능   다중 사용자용   대형 서버용   코드의 대부분을 C언어로 작성 - 기계어 사용에 어려움이 많아서 유닉스 개발용으로 C언어를 만들었다.   높은 이식성 - 다른 기계어 집합을 사용하는 컴퓨터에 이식이 쉽다.   최소한의 커널 구조   복잡한 시스템에 맞게 확장 용이   소스 코드 공개 - 학술적으로 사용하기 좋다.   프로그램 개발에 용이   다양한 버전            System V, FeeBSD, SunOS, Solaris - 유로. 소스 코드 비공개       Linux - 무료. 소스 코드 공개. 유닉스보다는 규모가 작은 환경이나 개인용 컴퓨터에 사용된다.           ☑️ DOS(Disk Operating System)     MS사에서 1981년 IBM-PC를 위해 개발   단일 사용자용 운영체제   싱글태스크   메모리 관리 능력의 한계(주 기억 장치 최대 용량 : 640KB)   ☑️ MS Windows     MS사의 다중 작업용 GUI 기반 운영체제   Plug and Play, 네트워크 환경 강화   DOS용 응용 프로그램과 호환성 제공   불안정성(초창기 윈도우즈)   풍부한 지원 소프트웨어   ☑️ Handheld device를 위한 OS     PalmOS, Pocket PC(WinCE), Tiny OS     🔸 운영체제의 구조     크게 CPU - memory - Disk - I/O device 구조   ☑️ CPU     CPU 스케줄링을 통해 실행중인 프로그램들에게 CPU를 효율적으로 할당해야 함   CPU에게는 선착순 처리가 효율적이지 않기 때문에 프로그램마다 걸리는 작업 시간에 따라 처리하도록 스케줄링한다.   ☑️ memory     프로그램을 실행하려면 memory에 올려야 하는데 memory는 한정되어 있기 때문에 적당히 잘 쪼개어 써야 한다.   최근에 많이 사용된 데이터는 오래 보관하고 그렇지 않으면 쫓아내는 방식으로 관리   ☑️ Disk     Disk에는 헤드가 있고 그 헤드를 움직이면서 일정 위치에 파일을 기록하기 때문에 I/O 요청이 들어왔을 때 헤드를 최대한 적게 움직이면서 최대한 빠르게 많이 처리할 수 있도록 처리 순서를 스케줄링 해야 한다.   ☑️ I/O device     지금까지 나온 장치들 중에선 가장 느리다.   때문에 인터럽트 기반으로 관리되며 CPU는 평소에는 자기 할 일을 하고 있다가 I/O 장치에서 인터럽트 요청이 들어오면 입출력을 수행하는 방식으로 진행된다.   ☑️ 프로세스 관리     프로세스의 생성과 삭제   자원 할당 및 반환   프로세스 간 협력   ☑️ 그 외     보호 시스템   네트워킹   명령어 해석기(command line interpreter)  ","categories": ["Operating System"],
        "tags": ["CS","OS"],
        "url": "/operating%20system/OS-01/",
        "teaser": null
      },{
        "title": "시스템 구조와 프로그램 실행",
        "excerpt":"👀 컴퓨터 시스템 구조            CPU는 매 시간마다 Memory에서 기계어 Instruction을 읽어서 실행하게 된다.   따라서 Memory는 CPU의 작업공간이라 할 수 있다.        Disk가 I/O 장치인 이유는 데이터를 Memory에서 읽어들이기도 하고 처리된 데이터를 가져와서 저장하기도 하기 때문이다.         device controller는 각 I/O device를 전담하는 작은 CPU 역할을 한다.   I/O device가 CPU에 비해 많이 느려서 CPU가 I/O 작업 처리가 끝나는 것을 마냥 기다릴 수는 없기 때문에 중간에 controller를 둬서 I/O 작업이 끝나면 CPU에게 알려준다.   local buffer는 각 I/O device controller의 작업공간이다.   입력받은 내용이나 출력할 내용을 여기에 저장해뒀다가 device controller가 사용자 프로그램으로 전달하거나 화면에 출력하는 등의 작업을 한다.     Mode bit     사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요해서 사용한다.   현재 수행중인 Instruction이 운영체제인지 사용자 프로그램인지 구분하기 위한 것   0과 1이라는 두 가지 operation을 사용해 모니터 모드와 사용자 모드를 구분한다.            1 사용자 모드 : 사용자 프로그램 수행       0 모니터 모드(= 커널 모드, 시스템 모드) : OS 코드 수행           보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 특권명령으로 규정한다.   Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꾼다.   사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅     Timer     CPU를 특정 프로그램이 독점하는 것으로부터 보호하기 위해서 사용한다.            정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 Interrupt를 발생시킨다.       Timer는 매 클럭 틱 때마다 1씩 감소한다.       Timer 값이 0이 되면 Timer Interrupt 발생             time sharing을 구현하기 위해 널리 이용된다.   현재 시간을 계산하기 위해서도 사용된다.     Device Controller     해당 I/O 장치유형을 관리하는 일종의 작은 CPU   제어 정보를 위해 control register, status register를 가진다.            CPU는 device controller를 통해 일을 시키는데 이 때 control register와 status register를 사용한다.                local buffer를 가진다.(일종의 data register)         I/O는 실제 device와 local buffer 사이에서 일어난다.   device controller는 I/O가 끝났을 경우 Interrupt로 CPU에 그 사실을 알린다.     ☑️ device driver(장치구동기)     OS 코드 중 각 장치별 처리루틴 ➡️ software            ex) 새 프린터를 사면 설치하는 프린터용 드라이버           ☑️ device controller(장치제어기)     각 장치를 통제하는 일종의 작은 CPU ➡️ hardware     입출력(I/O)의 수행     모든 입출력 명령은 특권명령이다.   ☑️ 사용자 프로그램의 I/O 방법     시스템콜(system call)            사용자 프로그램은 운영체제에게 I/O 요청           trap을 사용하여 인터럽트 벡터의 특정 위치로 이동   제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동   올바른 I/O 요청인지 확인 후 I/O 수행   I/O 완료 시 제어권을 system call 다음 명령으로 옮김     인터럽트(Interrupt)     인터럽트 당한 시점의 레지스터와 program counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.   ☑️ 넓은 의미의 인터럽트     Interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트로 일반적인 의미의 인터럽트   Trap (소프트웨어 인터럽트)            Exception : 프로그램이 오류를 범한 경우(프로그램 강제종료 등으로 대응)       System call : 프로그램이 커널 함수를 호출하는 경우           일반적으로 인터럽트 하면 하드웨어적인 인터럽트를 의미하고 소프트웨어적인 인터럽트는 Trap이라고 따로 지칭한다.   ☑️ 인터럽트 관련 용어     인터럽트 벡터            해당 인터럽트의 처리 루틴 주소(처리 위치)를 가지고 있다.           인터럽트 처리 루틴(= Interrupt Service Routine, 인터럽트 핸들러)            해당 인터럽트를 처리하는 커널 함수           🔸 현대의 운영체제는 인터럽트에 의해 구동된다.     만약 인터럽트가 없으면 CPU는 항상 사용자 프로그램이 쓰고 있게 될 것이다.     시스템콜(System Call)     사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것   사용자 프로그램이 I/O 등의 작업을 수행해야 할 때 시스템콜을 통해 운영체제에게 CPU를 넘겨줌으로서 필요한 서비스를 받을 수 있게 된다.     동기식 입출력과 비동기식 입출력  ☑️ 동기식 입출력 (Synchronous I/O)          I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에게 넘어간다.         구현 방법 1 (잘 안 씀)            하나의 I/O가 끝날 때까지 그거 하나만 한다.       I/O가 끝날 때까지 CPU를 낭비시킴       매시점 하나의 I/O만 일어날 수 있음             구현 방법 2 (보통 이렇게 구현함)            I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음       I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움       다른 프로그램에게 CPU를 줌       이 프로그램의 I/O 작업이 끝나면 다시 CPU를 준다.           ☑️ 비동기식 입출력 (Asynchronous I/O)     I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 즉시 넘어간다.   🔸 두 경우 모두 I/O의 완료는 인터럽트로 알려준다.   DMA(Direct Memory Access)     입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다.   CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송   byte 단위가 아니라 block 단위로 인터럽트를 발생시킴     서로 다른 입출력 명령어            일반적인 I/O 방식은 메모리를 관리하는 주소와 디바이스를 관리하는 주소를 따로 관리한다.   Memory Mapped 방식은 디바이스를 관리하는 주소도 메모리 영역에서 함께 관리한다.     저장장치 계층 구조            위로 갈수록 Speed ⬆️  Cost ⬆️(단위공간당 용량이 적어진다)  Volatility ⭕️ (휘발성 - 전원을 끄면 데이터가 사라진다)            CPU에서 직접 접근 가능(byte 단위 접근 가능)           아래로 갈수록 Speed ⬇️  Cost ⬇️(단위공간당 용량이 커진다)  Volatility ❌ (비휘발성 - 전원을 꺼도 데이터가 사라지지 않는다)            CPU 직접 접근 불가(byte 단위 접근이 불가능하며 섹터 단위 접근 가능)           ☑️ Caching     메인 메모리에 있는 내용 중 당장 필요한 것만 캐시 메모리에 올려 쓰는 것으로 재사용을 빠르게 하기 위한 목적     프로그램의 실행(메모리 load)         커널 주소 공간의 내용         사용자 프로그램이 사용하는 함수          모든 프로그램은 함수 구조로 짜여 있다. (기계어 레벨에서도 함수의 시작과 끝이 표시됨)         사용자 정의 함수            자신의 프로그램에서 정의한 함수             라이브러리 함수            자신의 프로그램에서 정의하지 않고 만들어져 있는 것을 가져다 쓴 함수       자신의 프로그램의 실행 파일에 포함되어 있다.           ☑️ 이 두 가지는 자신의 프로그램의 코드 영역에 포함되어 있어서 가상 메모리 안에서 자유롭게 점프가 가능하다.        커널 함수            운영체제 프로그램의 함수       커널 함수의 호출 = 시스템 콜           ☑️ 커널 함수는 커널의 코드 영역에 포함되어 있기 때문에 사용자 프로그램에서 자유로운 점프를 할 수 없다. ➡️ System call을 통해 운영체제에게 CPU 제어권을 넘기게 된다.     프로그램의 실행      ","categories": ["Operating System"],
        "tags": ["CS","OS","System Structure","Program Execurion"],
        "url": "/operating%20system/OS-02-System-structure-Program-excution/",
        "teaser": null
      },{
        "title": "MySQL 시작하기",
        "excerpt":"👀 MySql 시작하기     맥 기준으로 MySql을 설치하는 방법에는 2가지가 있는데   homebrew를 통해 설치하는 방법과        MySql 홈페이지에서 dmg 파일을 다운받아 설치하는 방법이 있다.          나는 여기서 homebrew를 통해 설치하는 방법을 택했다.   homebrew는 맥에서 쓸 수 있는 터미널 버전 앱스토어 같은 느낌으로 개발에 필요한 각종 소프트웨어들을 명령어 한 줄로 간편하게 설치할 수 있다.   MySql 설치     homebrew가 설치되어 있다는 전제하에 homebrew 터미널을 열어 명령어 입력을 통한 설치를 진행할 것인데, 먼저 홈 브루를 최신 버전으로 업데이트 시켜주고 시작하자.     brew update           업데이트가 완료되면 아래 명령어를 입력하면 MySql이 설치된다.     brew install mysql           설치가 완료된 후     brew list           를 입력하면 홈 브루를 통해 설치된 프로그램들이 나열되는데 그 중에 mysql이 있으면 설치가 잘 된 것임   MySql 실행     아까 설치할 때 썼던 터미널창에서 명령어 입력을 통해 MySql을 실행할 수 있는데 역시 2가지 방법이 있다.     brew services start mysql 혹은 mysql.server start           둘 중 하나를 입력해서 MySql서버를 시작할 수 있다.   네트워크 연결 허용하겠냐는 창이 뜨면 허용하겠다고 하면 된다.   MySql 초기 설정     서버가 시작되었다고 바로 쓸 수 있는 것은 아니고 간단한 설정을 해 주어야 한다.     mysql_secure_installation                위 명령어를 입력하면 MySql 초기 세팅을 시작할 수 있다.                                         “Would you like to setup VALIDATE PASSWORD component? (Press y           Y for Yes, any other key for No)”                           비밀번호를 복잡하게 설정하겠느냐는 것인데 아직 초보 단계니까 No를 입력해서 ‘1234’와 같은 쉬운 비밀번호를 설정한다. (Yes를 입력하면 복잡한 비밀번호 설정)        새 비밀번호를 입력하라는 메시지가 나오면 입력하고 엔터 누르면 된다.                                         “Remove anonymous users? (Press y           Y for Yes. any other key for No)”                           사용자 설정을 묻는 것인데 Yes를 선택했다.   Yes - 접속하는 경우 “mysql -uroot”처럼 -u 옵션 필요        No - 접속하는 경우 “mysql”처럼 -u 옵션 불필요                                         “Disallow root login remotely? (Press y           Y for Yes, any other key for No)”                           다른 IP에서 root 아이디로 원격 접속이 가능한지 묻는 것인데 Yes는 불가능, No는 가능        나는 Yes로 선택했다.                                         “Remove test database and access to it? (Press y           Y for Yes, any other key for No)”                                테스트 데이터베이스를 삭제할건지 말건지 묻는 것인데 나는 Yes로 선택했다.                                         “Reload privilege tables now? (Press y           Y for Yes, any other key for No)”                                변경된 권한을 테이블에 적용하는 설정에 대한 질문인데 이 질문은 무조건 Yes로 선택하는 것이 좋다고 한다.         여기까지 하면 모든 초기 설정이 완료된다.   MySql 접속  mysql -u root -p     위 명령어를 입력하면 root 아이디로 로그인할 수 있다.   비밀번호 입력창이 나오면 비밀번호를 입력 후(보이지 않지만 그냥 치면 됨) 엔터를 누르면 로그인이 완료된다.   정상적으로 로그인 되면 쉘이 mysql&gt;로 바뀐다.   mysql&gt; status;     위 명령어를 입력하면 현재 설정을 확인할 수 있다.   MySql 종료  mysql&gt; exit     위 명령어를 입력하면 Bye라는 메시지와 함께 mysql에서 빠져나올 수 있다.   brew services stop mysql 혹은 mysql.server stop     둘 중 하나를 입력하면 MySql 서버가 종료된다.  ","categories": ["MySQL"],
        "tags": ["MySQL","Database","JSP"],
        "url": "/mysql/mysql-beginning/",
        "teaser": null
      },{
        "title": "Java) BOJ 2908. 상수",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2908     문제          상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.            상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.            두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.         입력     첫째 줄에 상근이가 칠판에 적은 두 수 A와 B가 주어진다. 두 수는 같지 않은 세 자리 수이며, 0이 포함되어 있지 않다.     출력     첫째 줄에 상수의 대답을 출력한다.      👀 풀이     입력으로 주어지는 숫자들을 % 연산을 이용해 뒤집은 다음 뒤집은 수들을 비교한 뒤 큰 값을 출력한다.   버퍼입출력을 이용해 출력할 때 주의점은 정수형은 string으로 타입캐스팅을 해 주어야 제대로 출력된다.(처음에 이걸 모르고 정수형 그대로 넣어서 이상한 값이 출력되어서 헤멨다…)       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2908","String","Java"],
        "url": "/boj/boj2908/",
        "teaser": null
      },{
        "title": "Java) BOJ 5622. 다이얼",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/5622     문제          상근이의 할머니는 아래 그림과 같이 오래된 다이얼 전화기를 사용한다.             전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.            숫자 1을 걸려면 총 2초가 필요하다. 1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.            상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.            할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 최소 시간을 구하는 프로그램을 작성하시오.         입력     첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 단어의 길이는 2보다 크거나 같고, 15보다 작거나 같다.     출력     첫째 줄에 다이얼을 걸기 위해서 필요한 최소 시간을 출력한다.      👀 풀이     다소 하드코딩으로 풀었는데… 1~9까지 돌리는데 걸리는 최소 시간을 배열에 저장한 다음에 각 문자의 범위별로 인덱스값을 정해주어 시간을 저장한 배열에서 시간을 가져와서 더해주었다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No5622","String","Java"],
        "url": "/boj/boj5622/",
        "teaser": null
      },{
        "title": "MySQL Workbench 시작하기",
        "excerpt":"👀 MySQL Workbench란?     터미널을 통한 데이터베이스 관리를 좀 더 편하게 할 수 있게 해주는 도구   IDE를 이용해서 프로그래밍 하는 것처럼 자동완성도 되고 테이블도 시각적으로 좀 더 편하게 볼 수 있고 터미널보다 훨씬 편하다.   최신버전에는 버그가 있어서 8.0.19 버전으로 수업을 진행할 예정   윈도우라면 MySQL 인스톨러에서 Remove 버튼을 눌러 개별 프로그램만 간편히 제거한 후 Add 버튼을 눌러 원하는 버전으로 선택해서 설치할 수 있다.   하지만 난 맥을 써서 homebrew로 MySQL만 따로 깔았기 때문에 Workbench는 홈페이지에서 dmg 파일을 따로 받아서 설치했다.       MySQL 주석문  # 주석문 -- 주석문 /* 주석문 */      셋 다 사용가능하다.       DB 조회  select * from jspdb.tbl_member;      Workbench에서 테이블을 조회하려면 테이블 앞에 DB명을 꼭 붙여줘야 한다.   그런데 매번 이렇게 쓰려면 좀 귀찮다…   use jspdb;  select * from tbl_member;      C++에서 using을 쓰듯 use를 써서 DB명을 선언해주면 그 다음부터는 DB명 없이 테이블을 부를 수 있다.   쿼리문 실행  Windows) ctrl + enter Mac) command + enter      일정 쿼리 구문들만 실행하고 싶으면 해당 쿼리문들을 블록으로 선택한 후 위 명령어를 입력하면 해당 쿼리문들만 실행된다.   Windows) ctrl + shift + enter Mac) command + shift + enter      전체 쿼리 실행은 위 명령어를 입력한다.  ","categories": ["MySQL"],
        "tags": ["MySQL","Workbench","Database","JSP"],
        "url": "/mysql/mysql-workbench-beginning/",
        "teaser": null
      },{
        "title": "Java) BOJ 1259. 팰린드롬수",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1259     문제            어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. ‘radar’, ‘sees’는 팰린드롬이다.         수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다.   123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다.   또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만,   특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.      입력       입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다.   입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.       출력       각 줄마다 주어진 수가 팰린드롬수면 ‘yes’, 아니면 ‘no’를 출력한다.       👀 풀이       예제의 팰린드롬수를 보면 수의 개수가 짝수개일 땐 절반으로 나눈 앞뒤가 같아야 하고        홀수개일 땐 가운데 숫자를 제외한 나머지 앞뒤가 같아야 한다.         그래서 반복문으로 반복자는 문자열 길이의 절반까지만 반복하며   첫 글자와 맨 뒤 글자를 비교하면서 첫 글자를 가리키는 반복자는 증가시키고 끝 글자를 가리키는 반복자는 감소시켜가면서   두 반복자간의 거리를 좁히면서 검사하면 해당 수가 팰린드롬인지 아닌지 쉽게 확인할 수 있다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1259","String","Java"],
        "url": "/boj/boj1259/",
        "teaser": null
      },{
        "title": "Java) BOJ 1316. 그룹 단어 체커",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/1316     문제     그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다.   예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만,   aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.   단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.     입력     첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다.   단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.      출력     첫째 줄에 그룹 단어의 개수를 출력한다.      👀 풀이          문제 이해가 잘 되지 않아서 질문게시판의 문제 해설을 참고했다.                     현재 문자가 이미 나온 적이 있고                       바로 이전 문자가 아니면                -&gt; 그 단어는 그룹 단어가 아니다.         이 흐름에 따라 알파벳이 등장했는지 확인할 boolean 배열을 만들어 알파벳이 이전에 나왔는지 확인한 후   나온 적이 없고 바로 앞 문자와 같으면 그룹단어로 카운트하였고   나온 적이 있는데 바로 앞 문자와 같지 않으면 더 이상 확인을 중단하고 다음 문자를 확인하는 방식으로 코드를 짰다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1316","String","Java"],
        "url": "/boj/boj1316/",
        "teaser": null
      },{
        "title": "Java) BOJ 2941. 크로아티아 알파벳",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2941     문제     예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.   예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다.   단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.   dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.     입력     첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 ‘-‘, ‘=’로만 이루어져 있다.   단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.      출력     입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.      👀 풀이     특정 크로아티아 문자들 (“c=”, “c-“, “dz=”, “d-“, “lj”, “nj”, “s=”, “z=”)의 첫글자가 나오면 다음에 연속되는 문자를 검사해서 지정된 크로아티아 문자이면 그 길이만큼 반복문의 반복자를 증가시키고 아니면 반복자를 1씩 증가시키면서 글자수를 셌다.   이러한 조건문을 작성할 때 처음에는 반복자의 범위에 대한 예외처리를 해주지 않아서 제출하니까 string index out of bounds가 떴다.   배열을 다룰 때엔 항상 인덱스 범위를 잘 지키는 것에 유의하자.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2941","String","Java"],
        "url": "/boj/boj2941/",
        "teaser": null
      },{
        "title": "Java) BOJ 4949. 균형잡힌 세상",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/4949     문제            세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.              정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.              문자열에 포함되는 괄호는 소괄호(“()”) 와 대괄호(“[]”)로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.         모든 왼쪽 소괄호(“(“)는 오른쪽 소괄호(“)”)와만 짝을 이뤄야 한다.   모든 왼쪽 대괄호(“[“)는 오른쪽 대괄호(“]”)와만 짝을 이뤄야 한다.   모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.   모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.        짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.         정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.      입력       하나 또는 여러줄에 걸쳐서 문자열이 주어진다.        각 문자열은 영문 알파벳, 공백, 소괄호(“( )”) 대괄호(“[ ]”)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다.         입력의 종료조건으로 맨 마지막에 점 하나(“.”)가 들어온다.       출력       각 줄마다 해당 문자열이 균형을 이루고 있으면 “yes”를, 아니면 “no”를 출력한다.       👀 풀이            ’(‘, ‘[’ 괄호가 나오면 스택에 넣고 ‘)’, ‘]’ 괄호가 나오면 스택에서 마지막 값을 pop해서 매치되는 괄호면 넘어가고 매치되지 않으면 오답처리하고 탐색을 중단하고 “no”를 출력하는 방식으로 짰는데…         문제를 제대로 안 읽어서 소문자 “yes”, “no”로 출력해야 할 것을 대문자 “YES”, “NO”로 출력해서 20%에서 계속 틀렸다 ㅠ.ㅠ   문제를 제대로 읽자………….. 한시간 버렸다…….       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No4949","String","Java"],
        "url": "/boj/boj4949/",
        "teaser": null
      },{
        "title": "Java) BOJ 5430. AC",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/5430     문제       선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다.        이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.              함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.         함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, “AB”는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다.        예를 들어, “RDD”는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.         배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.      입력            첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.              각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.              다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)              다음 줄에는 [x1,…,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)              전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.         출력       각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.       👀 풀이       처음엔 스택과 큐를 이용해서        큐에 원래 순서대로 숫자를 집어넣고 뒤집어야 하면 스택에 push했다가 다시 큐로 pop 하는 방식을 썼는데 수의 최대 개수가 10만개라 예상대로 시간초과가 발생했다.              그래서 질문게시판을 찾아보다 덱을 사용하는 것을 보고 컨테이너를 덱으로 바꿨다.         그리고 R 연산이 짝수번이면 뒤집었다 다시 뒤집는 것이기 때문에 결국 뒤집지 않은 것이랑 같다.   그래서 연속된 R의 개수를 세어서 홀수번이면 덱의 맨 뒤에서 D 연산을 수행하고        연속된 R이 짝수번이면 맨 앞에서 D 연산을 수행하도록 하였다.              그 후 뒤집힌 상태라면 덱의 맨 뒤에서부터 pop연산을 수행하고 뒤집히지 않았다면 덱의 맨 앞에서부터 pop연산을 수행했다.              하지만 덱에 들어있는 숫자들을 정답 형태로 만들 때 단순 string에 더하는 형태로 만들었더니 가비지 컬렉션이 많이 발생해서… 거기서 최적화가 되지 않아서 또 시간초과를 받았다.         그래서 StringBuilder로 바꾼 뒤 정답 형태의 문자열로 만드는 부분을 좀 더 최적화 해 주었더니 932ms에 통과할 수 있었다…       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No5430","String","Java"],
        "url": "/boj/boj5430/",
        "teaser": null
      },{
        "title": "Java) BOJ 9012. 괄호",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/9012     문제     괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다.   그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다.   한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다.   그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다.   예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.   여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.      입력     입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다.   각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.      출력     출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.       👀 풀이          처음엔 왼쪽 오른쪽 괄호 개수를 세서 같으면 정답처리하는 방식으로 짰는데 2번 테케에서 틀렸다.              그래서 왼쪽 오른쪽 괄호가 나왔는지 확인하는 boolean 배열을 만들어서 확인하는 방식으로 수정했는데 사실상 1번이랑 다를 바 없었기 때문에 또 틀렸다.         그 다음엔 괄호의 개수를 세는데 왼쪽 괄호가 나오면 1을 더해주고 오른쪽 괄호가 나오면 1을 빼주는 방식으로 코드를 짰다.   그러면 양쪽 괄호가 맞게 나오면 최종 결과값은 0일 것이고,   왼쪽 괄호가 더 많다면 결과값이 양수일 것이다.   오른쪽 괄호가 더 많다면 음수가 나오게 되는데 처음으로 음수가 나오는 시점부터 이 테스트케이스는 매치되지 않는다고 판단하고 탐색을 중단하고 오답처리하면 된다.        왜냐면 )( 같은 경우에는 끝까지 카운트하면 0이 나오게 되는데 숫자상으로 보면 정답이지만 사실 매치되지 않는 괄호쌍이기 때문에 )이 처음 나와서 음수가 되는 순간부터 이 문장에 있는 괄호들은 매치되지 않는다.         따라서 한 문장에 대한 탐색이 끝나고 난 후 결과값이 0일 때에만 \"YES\"를 출력하고 나머지 경우엔 \"NO\"를 출력하면 된다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No9012","String","Java"],
        "url": "/boj/boj9012/",
        "teaser": null
      },{
        "title": "Java) BOJ 1712. 손익분기점",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/1712     문제     월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며,        한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.              예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.         노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.        최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.         A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.      입력     첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.       출력     첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.       👀 풀이          반복문으로 수익이 날 때까지 개수를 늘려가면서 계산했더니 시간초과가 나서 질문게시판을 검색했다..         반복문이 아닌 수학적으로 접근해야 하는 문제였으며 이 문제를 풀기 위해서는 순이익이 얼마인지 알아야 한다.   순이익은 (순이익 = 판매금액 C - 생산비용 B)로 구할 수 있다.        그런데 순이익이 0이거나 음수면 평생 팔아도 절대 수익이 나지 않는다. 그래서 이 경우엔 -1을 출력한다.         순이익이 양수라면 언젠가는 수익이 난다는 뜻이므로 정답을 구할 수 있다.   순이익은 판매비용에서 생산비용을 뺀 값이므로 순이익을 계산하는 과정에서 판매비용에 대한 계산은 끝나게 된다.   그럼 남은 것은 건설비용 A인데 물건을 판매할 때마다 순이익으로 건설비용 A를 갚다보면 언젠가는 남은 건설비용이 -가 될 것이다.   그러므로 건설비용을 순이익으로 나눈 몫이 손해가 나지 않을 최소 금액이라는 것을 알 수 있다.   그런데 문제에서 요구하는 손익분기점은 마이너스에서 최초로 이익이 발생하는 지점이므로 (건설비용 / 순이익)에다 1을 더해줘야 최초로 수익이 나는 지점이 된다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1712","Math","Java"],
        "url": "/boj/boj1712/",
        "teaser": null
      },{
        "title": "Java) BOJ 2292. 벌집",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2292     문제         위의 그림과 같이 육각형으로 이루어진 벌집이 있다.   그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다.   숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오.   예를 들면, 13까지는 3개, 58까지는 5개를 지난다.      입력     첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.       출력     입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.       👀 풀이     중심에서부터 벌집 테두리가 하나씩 늘어날 때 마다 6, 12, 18, … 6의 배수로 늘어난다.   즉 중심에서부터 벌집까지의 거리가 2인 테두리(첫번째 테두리)의 벌집 개수는 6개이고 거리가 3인 테두리는 12개, … 식으로 늘어난다.   그리고 벌집의 방 번호는 1부터 시작하기 때문에 N번째 방 번호는 1 + (61) + (62) + (63) + … (6N)이라는 것을 알 수 있다.        여기서 N을 구하는 것을 기본 아이디어로 잡고 시작했다.         문제의 조건은 1번에서 N번까지의 거리를 구하는 것이기 때문에   첫번째 테두리의 가장 큰 수인 7번방까지의 거리를 구한다면 (6*1) + 1 = 7이다. 이 때 N은 1이다.   그런데 처음 위치도 카운트해야 하기 때문에 1을 더해줘서 최종 정답은 2가 된다.        첫번째 테두리에 있는 가장 큰 수 까지의 거리가 2니까 같은 테두리에 있는 더 작은 숫자들까지의 거리도 2가 된다.          두번째 테두리의 가장 큰 수인 19까지의 거리를 구하면 (61) + (62) + 1 = 19이고 이 때의 N은 2이고 1을 더해주면 총 거리는 3이 된다.        마찬가지로 두번째 테두리의 가장 큰 수 까지의 거리가 3이니까 같은 테두리에 있는 더 작은 숫자들까지의 거리도 3이다.               이 아이디어를 N번째 숫자가 될 때까지 확장시켜가면 정답을 구할 수 있다.          위에서 더했던 과정을 반대로 생각하면 i=1부터 1씩 증가할 때 N에서 6*i을 빼고 남은 나머지가 1보다 작거나 같다면 N은 i번째 테두리에 있다고 할 수 있다.   그러면 N=i가 되는 것이고 이렇게 구한 N에다 첫 시작지점인 1을 더해주면 정답을 구할 수 있다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2292","Math","Java"],
        "url": "/boj/boj2292/",
        "teaser": null
      },{
        "title": "2/8 CSS 수업 내용",
        "excerpt":"👀 오늘 수업 내용            HTML 페이지를 CSS로 이렇게 꾸미는 것을 했다.      소스코드 - CSS        &lt;style type=\"text/css\"&gt;         * { /*             기본적인 여백 없앰 - 0px */             margin: 0px; padding: 0px;         }                  body {             background-color: #ccc;             padding: 20px;         }                  form { /*            배경색 흰색, 테두리 1실선, #222, 테두리 둥글게 5px,              안여백 20px, 너비 400px 밖여백 위아래 30px 왼쪽오른쪽 가운데정렬 */             background-color: white;             border: 1px solid #222;             border-radius: 5px;             padding: 20px;             width: 400px;             margin: 30px auto;         }                  fieldset { /*            테두리 1px 실선 #ccc, 밖 아래여백 30px */             border: 1px solid #ccc;             margin-bottom: 30px;         }                  legend { /*            폰트크기 16px, 폰트굵게 bold, 안 왼쪽여백 5px, 안 아래여백 10px */             font-size: 16px;             font-weight: bold;             padding-left: 5px;             padding-bottom: 10px;         }                  li { /*            줄간격 30px, 리스트 스타일 none, 안여백 5px 10px, 밖아래여백 2px */             line-height: 30px;             list-style: none;             padding: 5px 10px;             margin-bottom: 2px;         }                  label { /*            왼쪽으로 배치, 폰트크기 13px, 너비 110px */             float: left;             font-size: 13px;             width: 110px;         }                  .btn { /*            테두리 1px 실선 #222, 테두리 둥글게 20px, 글자크기 16px,              글자간격 1px, 밖여백 자동 가운데정렬, 안여백 7px 25px */             display: block;             border: 1px solid #222;             border-radius: 20px;             font-size: 16px;             letter-spacing: 1px;             margin: 0px auto;             padding: 7px 25px;         }          /*        input type=\"submit\" 제외하는 법 */         input:not([type=submit]) { /*            테두리선 1px 실선 #ccc, 테두리선 둥글게 3px, 글자크기 13px, 안여백 5px,              너비 200px */             border: 1px solid #ccc;             border-radius: 3px;             font-size: 13px;             padding: 5px;             width: 200px;         }          /*        여러 필드셋 중 마지막 필드셋만 스타일 지정 */         fieldset:last-of-type {             border: none;             margin-bottom: 0px;         }          /*        태그 중 조건을 걸어줄 땐 대괄호 [] */         input[required] {             border: 1px solid red;         }                  input[readonly] {             border: none;         }     &lt;/style&gt;       소스코드 - HTML    &lt;body&gt; &lt;form action=\"a.jsp\" method=\"get\"&gt; \t&lt;fieldset&gt; \t\t&lt;legend&gt;로그인 정보&lt;/legend&gt; \t\t&lt;ul&gt; \t\t\t&lt;li&gt;&lt;label&gt;아이디&lt;/label&gt; \t\t\t    &lt;input type=\"text\" name=\"id\" autofocus required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;비밀번호&lt;/label&gt; \t\t\t    &lt;input type=\"password\" name=\"pwd1\"  required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;비밀번호 확인&lt;/label&gt; \t\t\t    &lt;input type=\"password\" name=\"pwd2\"  required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;회원 등급&lt;/label&gt; \t\t\t    &lt;input type=\"text\" name=\"level\" value=\"준회원\" readonly&gt;&lt;/li&gt; \t\t&lt;/ul&gt; \t&lt;/fieldset&gt; \t&lt;fieldset&gt; \t\t&lt;legend&gt;개인정보&lt;/legend&gt; \t\t&lt;ul&gt; \t\t\t&lt;li&gt;&lt;label&gt;이름&lt;/label&gt; \t\t\t    &lt;input type=\"text\" name=\"name\" placeholder=\"5자미만 공백없이\" required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;메일 주소&lt;/label&gt; \t\t\t    &lt;input type=\"email\" name=\"email\" placeholder=\"abcd@domain.com\" required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;연락처&lt;/label&gt; \t\t\t    &lt;input type=\"tel\" name=\"tel\"&gt;&lt;/li&gt; \t\t&lt;/ul&gt; \t&lt;/fieldset&gt; \t&lt;fieldset class=\"btnFieldset\"&gt; \t\t&lt;input type=\"submit\" value=\"제출\" class=\"btn\"&gt; \t&lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;  ","categories": ["HTML"],
        "tags": ["HTML","Front-end","CSS"],
        "url": "/html/CSS/",
        "teaser": null
      },{
        "title": "Java) BOJ 1193. 분수찾기",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/1193     문제          무한히 큰 배열에 다음과 같이 분수들이 적혀있다.         1/1\t1/2\t1/3\t1/4\t1/5\t…   2/1\t2/2\t2/3\t2/4\t…\t…   3/1\t3/2\t3/3\t…\t…\t…   4/1\t4/2\t…\t…\t…\t…   5/1\t…\t…\t…\t…\t…        …\t…\t…\t…\t…\t…         이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.    X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.     제한     시간 제한 : 0.5초   메모리 제한 : 256MB     입력     첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.      출력     첫째 줄에 분수를 출력한다.       👀 풀이          ❗️ 1시간 고민했지만 풀이를 찾지 못해서 질문 게시판 참고함         x/y 라고 해볼께요. 일단 x=1일때를 봅시다. 왼쪽아래, 또는 오른쪽 으로 이동하죠? 이 때 x+y를 봅시다.   x+y가 짝수일때 오른쪽으로 이동하고, 홀수일 때 왼쪽아래로 이동하죠. 이와 마찬가지로 y=1일 때를 봅시다.   x+y가 짝수일 때 오른쪽 위로 이동하고, 홀수일 때 아래로 이동합니다.   다음과 같이 생각하시면 쉽게 풀 수 있을겁니다.   if x==1 or y==1 : (x+y)가 홀수일 때와 짝수일 때로 나눠서 시행하기        else : 바로 이전에 한 이동과 같은 방향으로 이동         위의 글에서 아이디어를 얻어서 다음과 같은 문제 해결법을 생각해 봄             필요한 것 : 현재 번호, 현재 분자와 분모를 저장할 변수, 이동 방향을 저장할 변수              x==1 or y==1 이라면 (x+y)가 홀수일 때 이동 방향을 왼쪽으로 설정한다.     \t- 왼쪽으로 이동한다는 것은 x가 증가한다.   2-1. (x+y)가 짝수면 이동 방향을 오른쪽으로 설정한다.    \t- 오른쪽으로 이동한다는 것은 y가 증가한다.              1번 경우에 들어가지 않는 경우에는 1번 경우에서 정해진 이동방향에 따라 이동한다.   3-1. 왼쪽 이동이면 x++, y--   3-2. 오른쪽 이동이면 x--, y++              위의 두 경우 모두 현재 번호가 증가하니까 현재 번호를 저장한 변수도 증가시킨다.              그런데 x==1 or y==1일 때에도 증가시키지 않는 쪽을 감소시켜야 하는데 최소값은 1이어야 하는데 그냥 감소시키면 0이 되어버리니까 1보다 클 때에만 감소시키도록 한다.              위의 과정을 코드로 구현하면 정답!!         ☑️ 결과 : 메모리) 16184kb, 시간) 176ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1193","Math","Java"],
        "url": "/boj/boj1193/",
        "teaser": null
      },{
        "title": "Process",
        "excerpt":"👀 프로세스란?     프로세스란 실행 중인 프로그램을 말한다.   앞으로 얘기할 것은 모두 사용자 프로그램의 관점에서 보는 것이다.(운영체제 아님❗️)     프로세스의 문맥(context)          현대 프로세스는 멀티태스킹 환경이기 때문에 이 작업 저 작업 왔다갔다 하면서 실행하려면 프로세스가 어디까지 실행했었는지를 알 수 있는 문맥 정보가 필요하다.         CPU 수행 상태를 나타내는 하드웨어 문맥            Program Counter       각종 register             프로세스의 주소 공간            code, data, stack             프로세스 관련 커널 자료 구조            PCB (Process Control Block) : 프로세스가 실행될 때마다 하나씩 만들어서 프로세스에 CPU, 메모리를 얼마나 줘야 할 지, 어디까지 실행했는지 이상 행동을 하지는 않는지 관리하기 위한 자료구조       Kernal stack : 프로세스마다 별도로 둔다.           프로세스의 상태 (Process State)     CPU가 하나라고 가정했을 때 프로세스는 상태가 변경되며 수행된다.   Running     CPU를 잡고 instruction을 수행중인 상태   Time interrupt, System call이 생기게 되면 CPU를 다시 내어주게 된다.   Ready     CPU를 기다리는 상태(메모리 등 CPU를 얻기 위한 다른 조건을 모두 만족하고)   CPU를 얻기 위한 Ready queue에서 기다리고 있다.   Blocked (wait, sleep)     CPU를 주어도 당장 instruction을 수행할 수 없는 상태   Process 자신이 요청한 event(ex. I/O)가 즉시 만족되지 않아 이를 기다리는 상태            예) 디스크에서 파일을 읽어와야 하는 경우           New     프로세스가 생성중인 상태   Terminated     수행(execution)이 끝난 상태인데 작업이 완전히 끝난 것은 아니고 정리할 것이 남아있는 상태이다.     PCB (Process Control Block)     운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보   다음의 구성 요소를 가진다(구조체로 유지). 1) OS가 관리상 사용하는 정보   Process state, Process ID   scheduling information, priority     2) CPU 수행 관련 하드웨어 값     Program counter, registers     3) 메모리 관련     Code, data, stack의 위치 정보     4) 파일 관련     Open file descriptors…     문맥 교환 (Context Switch)     CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정   CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.            CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장       CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴             ❗️ System call이나 Interrupt 발생시 반드시 Context switch가 일어나는 것은 아니다.  System call이나 Interrupt 발생 후 다른 프로세스에게 CPU를 넘겨줬을 때 Context switch가 일어나는 것이지 같은 프로세스에게 다시 CPU를 줬을 때엔 Context switch가 일어난 것이 아니다.        Context switch가 일어나면 cache memory를 비워야 하는데 이거 자체가 상당한 오버헤드를 일으킨다.     프로세스를 스케줄링하기 위한 큐  Job queue     현재 시스템 내에 있는 모든 프로세스의 집합   Ready queue     현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합   Device queues     I/O device의 처리를 기다리는 프로세스의 집합     🔸 프로세스들은 각 큐들을 오가며 수행된다.     👀 스케줄러 (Scheduler)  Long-term scheduler (장기 스케줄러 or job scheduler)     시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정   프로세스에 memory(및 각종 자원)을 주는 문제 결정   degree of Multiprogramming(메모리에 올라가 있는 프로세스의 수) 제어   하지만 time sharing system에는 보통 장기 스케줄러가 없다(무조건 ready)   Short-term scheduler (단기 스케줄러 or CPU scheduler)     어떤 프로세스를 다음번에 running 시킬지 결정   프로세스에 CPU를 주는 문제 결정   충분히 빨라야 함 (millisecond 단위)   Medium-term scheduler (중기 스케줄러 or Swapper)     time sharing system에서는 중기 스케줄러를 사용한다.   여유 공간 마련을 위해 일부 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.   프로세스에게서 memory를 뺏는 문제 결정   degree of Multiprogramming 제어   중기 스케줄러를 사용하면서 바뀌는 프로세스의 상태  Running     CPU를 잡고 instruction을 수행중인 상태   Time interrupt, System call이 생기게 되면 CPU를 다시 내어주게 된다.   Ready     CPU를 기다리는 상태(메모리 등 CPU를 얻기 위한 다른 조건을 모두 만족하고)   CPU를 얻기 위한 Ready queue에서 기다리고 있다.   Blocked (wait, sleep)     I/O등의 event를 (스스로) 기다리는 상태            예) 디스크에서 파일을 읽어와야 하는 경우           자신이 요청한 event가 만족되면 Ready 상태가 된다.   Suspended (stopped)     외부적인 이유로 프로세스의 수행이 정지된 상태   프로세스는 통째로 디스크에 swap out 된다.            예) 사용자가 프로그램을 일시 정지시킨 경우 (break key)       시스템이 여러 이유로 프로그램을 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)           외부에서 resume 해 주어야 Active 상태가 된다.     👀 스레드 (Thread)     프로세스 하나에 CPU 수행단위(Program Counter)만 여러개 두고 있는 것   스레드를 사용하는 이유는 메모리 절약과 수행속도를 높이기 위해서라고 볼 수 있다.   만약 같은 프로세스를 여러개 실행시키고 싶을 때 프로세스를 여러개 만들면 그만큼 메모리 공간을 할당해야 하니까 메모리 낭비가 커진다. 그리고 그 프로세스들 간에 문맥 교환이 일어난다면 오버헤드도 클 것이다.   하지만 프로세스의 주소공간(메모리)은 함께 쓰면서 각 프로그램마다 PCB에 코드를 어디까지 실행했는지만 저장해 놓고 코드 영역에서 각자 다른 부분의 코드만 실행하면 메모리를 아낄 수 있다(그 프로그램에 저장된 데이터와 코드가 바뀌는 것이 아니니까). 즉, 프로세스의 Code와 Data 영역만 함께 쓰는 것이다.   하지만 각 스레드별로 함수를 어디까지 실행했는지 등의 정보는 각자 알고 있어야 하기 때문에 함수 실행과 관련된 정보를 저장하는 Stack영역은 따로 사용해야 한다.   그래서 하나의 프로세스를 만들고 스레드를 생성하면 code와 data 영역은 공유하고 각 스레드의 stack 영역이 여러개 만들어진다.     스레드 사용의 장점  응답성 - 사용자 입장에서 빠르게 느껴진다     만약 웹페이지를 로드한다고 했을 때 이미지와 텍스트를 불러오는 작업은 상당히 시간이 걸리는 작업인데 스레드를 하나만 써서 웹페이지가 완전히 완성될 때까지 기다렸다가 사용자에게 보여주면 웹페이지를 표시하기 위한 작업이 끝날 때까지 사용자는 빈 화면만 보고 있을 것이다. 이것은 굉장히 답답하게 느껴진다.   이 때 멀티 스레드를 사용해 작업을 하면 한 스레드가 이미지를 불러오는 동안 다른 스레드는 일찍 로드된 텍스트를 사용자에게 먼저 보여주고 있는다든지 하는 일을 수행할 수 있게 된다. 그러면 답답함을 많이 줄일 수 있다.   자원 공유     위에서 서술했듯이 프로세스는 하나만 두고 PC랑 register만 따로 사용해서 프로세스를 실행하면 자원을 효율적으로 쓸 수 있다.   경제성     실행 속도 측면에서도 프로세스를 추가하는 것 보다는 스레드를 추가하는 것이 훨씬 빠르다.   문맥 교환이 일어났을 때에도 스레드 간에 하는 것이 오버헤드가 훨씬 적다.   병렬성     CPU가 여러개인 환경에서 각각의 스레드가 병렬적으로 작업을 할 수 있어 동시에 처리할 수 있는 작업이 늘어난다.     스레드의 구현 스타일     스레드를 구현하는 스타일이 다 같지 않다.   Kernel Threads     운영체제의 지원을 받아 관리되는 스레드   그래서 OS가 스레드의 존재를 알고 있다.   예) Windows 95/98/NT, Solaris, Digital UNIX, Mach   User Threads     사용자 레벨에서 라이브러리의 지원을 받아 관리되는 스레드   그래서 OS는 스레드의 존재를 알 수 없다. OS 입장에서 보면 프로세스 하나가 실행되고 있는 것이다.   사용자 프로세스 스스로가 스레드를 관리한다.   예) POSIX Pthreads, Mach C-threads, Solaris threads     그리고 real-time으로 관리되는 스레드가 있는데 그냥 이런게 있구나 정도로 알고 있으면 된다고 한다.  ","categories": ["Operating System"],
        "tags": ["CS","OS","Process"],
        "url": "/operating%20system/OS-03-Process/",
        "teaser": null
      },{
        "title": "SQL) GROUP BY절과 HAVING절",
        "excerpt":"   그룹함수와 함께 사용하며 조건에 맞는 그룹으로 묶어서 보여준다.   ☑️ 문법  SELECT    column, group_function FROM      table [WHERE    contition] [GROUP BY group_by_expression] [HAVING   group_condition] [ORDER BY column];       그룹함수     AVG : 평균을 구해주는 함수   COUNT : 개수를 세어주는 함수   MAX : 최대값을 구해주는 함수   MIN : 최소값을 구해주는 함수            날짜와 문자의 최대값과 최소값도 구할 수 있는데       날짜에서의 최대값은 가장 최근 날짜, 최소값은 가장 과거 날짜       문자에서는 알파벳/가나다 오름차순으로 보여준다.           STDDEV : 표준편차를 구해주는 함수(쓸 일이 많지는 않다)   SUM : 합계를 구해주는 함수   VARIANCE : 분산을 구해주는 함수(쓸 일이 많지는 않다)   SELECT AVG(salary), MAX(salary),        MIN(salary), SUM(salary) FROM   employees WHERE  job_id LIKE '%REP%';  SELECT COUNT(commission_pct) FROM   employess WHERE  department_id = 80;   GROUP BY절  SELECT   department_id, AVG(salary) FROM     employees GROUP BY department_id;  SELECT   department_id, job_id, SUM(salary) FROM     employees WHERE    department_id &gt; 40 GROUP BY department_id, job_id ORDER BY department_id;     select절에 있는 컬럼 리스트 중에서 그룹함수에 포함되어 있지 않은 컬럼은 반드시 group by절에 포함되어 있어야 문법 오류가 안 난다.     HAVING절  SELECT   job_id, SUM(salary) PAYROLL FROM     employees WHERE    job_id NOT LIKE '%REP%' GROUP BY job_id HAVING   SUM(salary) &gt; 13000 ORDER BY SUM(salary);     GROUP BY절과 HAVING절 사이에 순서는 없으나 ORDER BY절은 맨 마지막에 쓰는 것이 좋다.   왜냐면 최종 결과를 가지고 정렬하는 것이 가장 정확하니까.  ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-having-groupby/",
        "teaser": null
      },{
        "title": "Java) BOJ 10250. ACM 호텔",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/10250     문제     ACM 호텔 매니저 지우는 손님이 도착하는 대로 빈 방을 배정하고 있다.   고객 설문조사에 따르면 손님들은 호텔 정문으로부터 걸어서 가장 짧은 거리에 있는 방을 선호한다고 한다.   여러분은 지우를 도와 줄 프로그램을 작성하고자 한다.   즉 설문조사 결과 대로 호텔 정문으로부터 걷는 거리가 가장 짧도록 방을 배정하는 프로그램을 작성하고자 한다.   문제를 단순화하기 위해서 호텔은 직사각형 모양이라고 가정하자.   각 층에 W 개의 방이 있는 H 층 건물이라고 가정하자 (1 ≤ H, W ≤ 99).   그리고 엘리베이터는 가장 왼쪽에 있다고 가정하자(그림 1 참고). 이런 형태의 호텔을 H × W 형태 호텔이라고 부른다.   호텔 정문은 일층 엘리베이터 바로 앞에 있는데, 정문에서 엘리베이터까지의 거리는 무시한다.   또 모든 인접한 두 방 사이의 거리는 같은 거리(거리 1)라고 가정하고 호텔의 정면 쪽에만 방이 있다고 가정한다.   방 번호는 YXX 나 YYXX 형태인데 여기서 Y 나 YY 는 층 수를 나타내고 XX 는 엘리베이터에서부터 세었을 때의 번호를 나타낸다.   즉, 그림 1 에서 빗금으로 표시한 방은 305 호가 된다.   손님은 엘리베이터를 타고 이동하는 거리는 신경 쓰지 않는다. 다만 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다.   예를 들면 102 호 방보다는 301 호 방을 더 선호하는데, 102 호는 거리 2 만큼 걸어야 하지만 301 호는 거리 1 만큼만 걸으면 되기 때문이다.   같은 이유로 102 호보다 2101 호를 더 선호한다.   여러분이 작성할 프로그램은 초기에 모든 방이 비어있다고 가정하에 이 정책에 따라 N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램이다.   첫 번째 손님은 101 호, 두 번째 손님은 201 호 등과 같이 배정한다. 그림 1 의 경우를 예로 들면, H = 6이므로 10 번째 손님은 402 호에 배정해야 한다.     제한     시간 제한 : 1 초   메모리 제한 : 256 MB     입력     프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T 개의 테스트 데이터로 이루어져 있는데 T 는 입력의 맨 첫 줄에 주어진다.   각 테스트 데이터는 한 행으로서 H, W, N, 세 정수를 포함하고 있으며 각각 호텔의 층 수, 각 층의 방 수, 몇 번째 손님인지를 나타낸다(1 ≤ H, W ≤ 99, 1 ≤ N ≤ H × W).     출력     프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행을 출력하는데, 내용은 N 번째 손님에게 배정되어야 하는 방 번호를 출력한다.       👀 풀이          N을 H로 나눈 몫 + 1이 방 번호의 맨 뒷자리가 되고 N을 H로 나눈 나머지만큼 앞자리 층수를 올려주면 되기 때문에 정답을 구하기 위한 계산식은 (N % H) * 100 + (N / H + 1) * 100 이 된다.         그런데 처음엔 N == H 인 경우를 생각하지 않아서 틀렸다.   N == H 일 경우 N을 H로 나눈 몫이 1이 되고 나머지는 0이기 때문에 처음에 생각했던 경우의 계산식만 적용하면 (N % H) * 100 = 0 이 된다.        거기다 1을 더하면 2가 나온다. 항상 오답됨         그래서 N == H 경우에는 층수는 H로 항상 고정되기 때문에 H * 100 + (N / H) 로 계산했다.      ☑️ 결과     메모리 : 14372 kb   시간 : 136 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10250","Math","Java"],
        "url": "/boj/boj10250-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 2775. 부녀회장이 될테야",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2775     문제     평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.   이 아파트에 거주를 하려면 조건이 있는데,   “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.   아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때,   주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라.   단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.     제한     시간 제한 : 1 초   메모리 제한 : 128 MB     입력     첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다.     출력     각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.        👀 풀이     문제 이해를 잘못 한건지 틀리게 구현한 거 같아서 긴가민가 하면서 냈는데 맞았다…        문제를 다시 읽어보니까 k-1층까지의 누적합이 아니고 k-1층에서의 누적합만 구하면 되는 것이었네… 😅         기본적인 접근은 DP로 했다.   k층에 사는 사람들의 합계는 구할 필요가 없이 k-1층에 사는 사람들 중 n번째 집에 사는 사람들까지의 누적합계만 구하면 되기 때문에   [k][n]에 사는 사람들의 수는 [k-1][1] + [k-1][2] + [k-1][3] + … [k-1][n]이 된다.   그런데 층수가 올라가면서 이전 층의 데이터가 필요하기 때문에 이 데이터들을 저장할 장소가 필요하니까 2차원 배열을 만들어서 반복문으로 위의 식을 구현한 후 2차원 배열의 [k][n] 인덱스의 원소값을 출력했다.     ☑️ 결과     메모리 : 14208 kb   시간 : 132 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2775","Math","Java"],
        "url": "/boj/boj2775-java/",
        "teaser": null
      },{
        "title": "C++) BOJ 2869. 달팽이는 올라가고 싶다",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2869     문제     땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.   달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.   달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.     제한     시간 제한 : 0.15초   메모리 제한 : 128 MB     입력     첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B &lt; A ≤ V ≤ 1,000,000,000)     출력     첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.      👀 풀이     Java로 풀었는데 C++ 실행속도가 궁금해서 한 번 더 풀어보았다.        확실히 엄청 빠름         아주 오랜만에 스스로 풀이과정을 생각해 낸 수학문제… 그만큼 쉬운 문제였다.        입력의 최대 크기가 10억이기 때문에 반복문을 돌리면 안 되고 사칙연산을 이용해서 풀었다.         달팽이가 하루에 갈 수 있는 거리는 (총 이동거리 A - 자는동안 미끄러지는 거리 B) 이다.   그런데 정상에 도착하면 미끄러지지 않는다고 했으므로 A 거리만큼 이동해서 정상에 도착할 수 있는 날이면 B를 뺄 필요 없이 A만큼만 이동하면 된다.   그러면 (총 이동거리 A - 자는동안 미끄러지는 거리 B)만큼 이동하는 날수는 정상에서 A 거리만큼을 뺀 길이까지이다.   그래서 (정상 V - A) / (총 이동거리 A - 자는동안 미끄러지는 거리 B) 연산을 통해 마지막 날이 되기 전까지 며칠이 걸리는지 구할 수 있는데   나누기 연산을 하고 나서 나머지(짜투리 길이)가 생길 수 있다.   짜투리 길이만큼을 이동하는데에도 하루를 소모해야 하기 때문에 나누기 연산 후 나머지가 생기면 하루를 더해줘야 한다.   그 다음 마지막날을 더해주면 된다.     ☑️ 결과 : 메모리) 2020 kb, 시간) 0 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2869","Math","C++"],
        "url": "/boj/boj2869-cpp/",
        "teaser": null
      },{
        "title": "Java) BOJ 2869. 달팽이는 올라가고 싶다",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2869     문제     땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.   달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.   달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.     제한     시간 제한 : 0.15초   메모리 제한 : 128 MB     입력     첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B &lt; A ≤ V ≤ 1,000,000,000)     출력     첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.      👀 풀이     아주 오랜만에 스스로 풀이과정을 생각해 낸 수학문제… 그만큼 쉬운 문제였다.        입력의 최대 크기가 10억이기 때문에 반복문을 돌리면 안 되고 사칙연산을 이용해서 풀었다.         달팽이가 하루에 갈 수 있는 거리는 (총 이동거리 A - 자는동안 미끄러지는 거리 B) 이다.   그런데 정상에 도착하면 미끄러지지 않는다고 했으므로 A 거리만큼 이동해서 정상에 도착할 수 있는 날이면 B를 뺄 필요 없이 A만큼만 이동하면 된다.   그러면 (총 이동거리 A - 자는동안 미끄러지는 거리 B)만큼 이동하는 날수는 정상에서 A 거리만큼을 뺀 길이까지이다.   그래서 (정상 V - A) / (총 이동거리 A - 자는동안 미끄러지는 거리 B) 연산을 통해 마지막 날이 되기 전까지 며칠이 걸리는지 구할 수 있는데   나누기 연산을 하고 나서 나머지(짜투리 길이)가 생길 수 있다.   짜투리 길이만큼을 이동하는데에도 하루를 소모해야 하기 때문에 나누기 연산 후 나머지가 생기면 하루를 더해줘야 한다.   그 다음 마지막날을 더해주면 된다.     ☑️ 결과 : 메모리) 2020 kb, 시간) 0 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2869","Math","Java"],
        "url": "/boj/boj2869-java/",
        "teaser": null
      },{
        "title": "회원관리 서비스 요구사항",
        "excerpt":"👀 회원관리 서비스 요구사항     모든 웹페이지의 기본 서비스라고 할 수 있는 회원관리 서비스! 아래와 같은 사항들이 가능해야 한다.     1) 회원가입 페이지 - 아이디는 이메일을 사용하거나 전화번호를 입력받는 등 회원가입에 필요한 정보 입력  2) 로그인  3) 메인페이지  4) 회원정보 조회  5) 회원정보 수정  6) 회원정보 삭제  7) 관리자 - 회원 전체 목록 조회        이렇게 작성하는 것을 요구사항 확인 혹은 요구사항 명세라고 한다.   이 과정을 진행하기 전에 DB 테이블 생성을 먼저 진행한다.  ","categories": ["JSP"],
        "tags": ["Database","JSP","JDBC"],
        "url": "/jsp/customer-management/",
        "teaser": null
      },{
        "title": "JDBC",
        "excerpt":"👀 JDBC(Java Database Connectivity)란?     Java랑 DBMS를 연결시켜주는 API   즉 자바랑 DB를 연결시켜서 사용할 수 있게 해주는 기능들이 모여있는 라이브러리라 할 수 있다.   데이터베이스에 데이터를 삽입, 수정, 삭제할 때 SQL 프롬프트에서 SQL문을 사용하지 않아도 자바 프로그램에서 SQL문을 사용하여 데이터베이스에 데이터를 추가하고 삭제하는 작업을 할 수 있게 하는 API이다.   JDBC는 DBMS 종류에 상관없이 독립적으로 사용 가능하다.            여러 언어에서 작동하는 방법이 전반적으로 같다고 할 수 있다.              JDBC 드라이버 설치     mysql 홈페이지에서 Connect J를 다운받는다.(현재 최신버전인 8.0.28)   윈도우라면 .zip 파일을 받으면 되고 맥이라면 .tar 파일을 받는다.   압축을 풀면 mysql-connector-java-8.0.28.jar란 파일이 있다.   저걸 JDBC를 사용하고자 하는 (이클립스)프로젝트의 WEB-INF/lib 폴더에 넣는다.(경로 다르면 안 됨!! 무조건 저기에 넣어야 함)   그러면 설치 끝!      JDBC 연동  1. 드라이버 로드(하드디스크에 있는 프로그램을 메모리로 불러오기)     아까 설치한 JDBC 드라이버를 불러올 것이다.     Class.forName(\"com.mysql.cj.jdbc.Driver\"); // static method라서 객체 생성 없이 바로 호출할 수 있음           이렇게 입력하면 드라이버를 로드할 수 있다.   MySQL 홈페이지 가서 Documentation 페이지 - Connector/J 8.0 Developer Guide - 6. ConnectJ reference - 6.1 Driver/Datasource Class Name 가면 드라이버를 로드할 때 무슨 클래스명을 입력해야 하는지 찾을 수 있다.            그 외에도 레퍼런스가 필요하면 참고하자.           만약 설치를 안 했다면 실행시 참고할 드라이버가 없어서 HTTP500 에러가 뜬다.     2. DB 연결     DriverManager.getConnection(\"디비주소\", \"디비아이디\", \"디비비밀번호\");   DriverManager 객체를 이용해 DB와 드라이버를 연결한다.   Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jspdb\", \"root\", \"1234\");      이런 식으로 DB의 주소와 아이디, 비밀번호를 입력한 뒤 연결 객체 정보를 Connection에 저장한다.   이러면 mysql과 연결된 것이다. 이제 jsp 파일에서 SQL문을 작성해 데이터베이스를 관리할 수 있다.   JDBC 사용 예제 1) 사용자가 홈페이지에 회원가입 하는 상황   1. insertForm.jsp라는 이름으로 간단한 회원가입 페이지를 만든다.  &lt;form action=\"insertPro.jsp\" method=\"post\"&gt;     아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;     비밀번호 : &lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;     이름 : &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt;     &lt;input type=\"submit\" value=\"전송하기\"&gt;   &lt;/form&gt;      여기서 사용자가 정보를 입력하고 submit버튼을 클릭하면 insertPro.jsp 페이지로 전달된다.     2. insertPro.jsp라는 이름으로 회원가입 정보를 받아서 DB에 사용자 정보를 추가하는 페이지를 만든다.    &lt;% // 스크립틀릿 사용     // 0단계 : 드라이버 설치 - 완료됐으니 로드 단계로 넘어간다.     // 1단계 : 드라이버 로드     Class.forName(\"com.mysql.cj.jdbc.Driver\");        System.out.println(\"드라이버 로드 성공!\");          // 2단계 : 디비 연결 (디비 바꾸려면 jdbc:mysql://localhost:3306/뒤에 디비 이름만 바꿔주면 됨)     Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jspdb\", \"root\", \"1234\");          System.out.println(\"디비 연결 성공!\");     System.out.println(\"연결정보 : \" + con);          // 3단계 : SQL 구문 생성 &amp; stmt(statement) 객체 생성     // String sql = \"insert into itwill_member (id, pass, name) values('id', 'pw', 'name')\";          // secure 코딩 예시) values에 담을 데이터의 개수만큼 ?를 넣는다.     String sql = \"insert into itwill_member (id, pass, name) values(?, ?, ?)\";          // stmt 객체 만들기 : sql 구문을 실행하는 객체 \t        // Statement stmt = con.createStatement(); // 하지만 이렇게 쓰려면 valuse 괄호 안에 따옴표를 넘 많이 써야해서 안 쓸 예정                             // 그리고 따옴표 안에 정보를 노출해서 써야해서 보안적으로 좋지 않다.     // Statement랑 PreparedStatement 객체 둘 중 하나만 쓸 수 있음          // pstmt 객체 : sql 구문을 실행하는 객체     PreparedStatement pstmt = con.prepareStatement(sql); // 객체를 만들 때 쿼리 정보를 가져가서 사전준비함          // ??? 값 sql 구문에 채워넣기     // pstmt.setXXXXXX(물음표의 위치, 실제 들어갈 값);     // =&gt; XXXXX : 컬럼의 데이터타입(int, double, string, ...)에 따라 변경     // * ? 개수와 동일한 구문을 수행해야 함 - ?가 3개면 채우는 구문 3개 있어야 함     // null 넣고 싶으면 쿼리문(String sql) 안에 직접 넣으면 됨     pstmt.setString(1, id); // 뜻 : 1번 물음표에 id에 해당하는 값을 넣는다.     pstmt.setString(2, pass);     pstmt.setString(3, name);          // 4단계 : SQL 구문 실행     // stmt.executeUpdate(sql); // 얘는 미리 준비 안해서 파라미터로 넣어줌     pstmt.executeUpdate(); // 그리고 바로 실행          System.out.println(\"insert 동작 완료!\");   %&gt;      위 과정을 완료하면 터미널이나 워크벤치에서 직접 SQL문을 작성하지 않았는데도 DB에 데이터가 삽입된다!     ❗️ 페이지를 실행할 땐 ~Form.jsp 페이지에서 한다.     사용자가 보는 페이지는 Form 페이지이지 처리를 하는 Pro 페이지를 사용자가 볼 수 없고 그럴 필요도 없기 때문이다.   Pro 페이지는 개발과정에서 개발자만 보는 페이지이다.   JDBC 사용 예제 2) 회원 정보를 수정하는 상황  1. updateForm.jsp라는 이름으로 수정할 정보를 입력받을 간단한 페이지를 하나 만든다.    &lt;form action=\"updatePro.jsp\" method=\"post\"&gt;     아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;     비밀번호 : &lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;     수정할 이름 : &lt;input type=\"text\" name=\"update_name\"&gt;&lt;br&gt;     &lt;input type=\"submit\" value=\"전송하기\"&gt;   &lt;/form&gt;   2. updatePro.jsp라는 이름으로 전송받은 정보를 DB에 삽입할 페이지를 만든다.    &lt;%     // 그냥 받으면 한글이 깨지기 때문에 꼭 한글처리 후 데이터 받기를 시작한다.     request.setCharacterEncoding(\"UTF-8\");          // 전달된 파라미터 저장     String id = request.getParameter(\"id\");     String pass = request.getParameter(\"pass\");     String uName = request.getParameter(\"update_name\");   %&gt;      아이디 : &lt;%=id %&gt;&lt;br&gt;   비밀번호 : &lt;%=pass %&gt;&lt;br&gt;   수정할 이름 : &lt;%=uName %&gt;&lt;br&gt;   &lt;hr&gt;      &lt;%     final String DRIVER = \"com.mysql.cj.jdbc.Driver\";     final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";     final String DBID = \"root\";     final String DBPASS = \"1234\";   %&gt;      &lt;h2&gt; 1. 드라이버 로드 &lt;/h2&gt;   &lt;%     Class.forName(DRIVER); // Class는 java.lang 패키지에 들어서 임포트 없이 쓸 수 있음.          System.out.println(\"드라이버 로드 성공!\");   %&gt;      &lt;h2&gt; 2. 디비 연결 &lt;/h2&gt;   &lt;%     Connection con = DriverManager.getConnection(DBURL, DBID, DBPASS);          System.out.println(\"디비연결 성공!\");   %&gt;      &lt;h2&gt; 3. sql 작성 &amp; pstmt 생성 &lt;/h2&gt;   &lt;%     String sql = \"update itwill_member set name=? where id=? and pass=?\"; // ?는 mysql 문법이 아니고 jsp 코드에서만 쓸 수 있는 문법          PreparedStatement pstmt = con.prepareStatement(sql); // 인터페이스를 통해 객체를 생성하지 않고 만들어진 정보를 전달          // ? 채우기     pstmt.setString(1, uName);     pstmt.setString(2, id);     pstmt.setString(3, pass);   %&gt;      &lt;h2&gt; 4. sql 실행 &lt;/h2&gt;   &lt;%     pstmt.executeUpdate();     System.out.println(\"회원정보 수정 완료!\");   %&gt;   JDBC 사용 예제 3) 사용자 정보를 삭제하는 상황  1. deleteForm.jsp라는 이름으로 삭제할 사용자의 정보를 입력받는 페이지를 만든다.    &lt;form action=\"deletePro.jsp\" method=\"post\"&gt;     아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;     비밀번호 : &lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;     &lt;input type=\"submit\" value=\"전송하기\"&gt;   &lt;/form&gt;   2. deletePro.jsp라는 이름으로 DB에서 전달받은 정보를 삭제하는 작업을 하는 페이지를 만든다.    &lt;%     request.setCharacterEncoding(\"UTF-8\");        String id = request.getParameter(\"id\");     String pass = request.getParameter(\"pass\");   %&gt;      &lt;%     final String DRIVER = \"com.mysql.cj.jdbc.Driver\";     final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";     final String DBID = \"root\";     final String DBPASS = \"1234\";   %&gt;      &lt;h2&gt; 1. 드라이버 로드 &lt;/h2&gt;   &lt;%     Class.forName(DRIVER);   %&gt;      &lt;h2&gt; 2. 디비 연결 &lt;/h2&gt;   &lt;%     Connection con = DriverManager.getConnection(DBURL, DBID, DBPASS);   %&gt;      &lt;h2&gt; 3. sql 작성 &amp; pstmt 생성 &lt;/h2&gt;   &lt;%     String sql = \"delete from itwill_member where id=? and pass=?\";          PreparedStatement pstmt = con.prepareStatement(sql);     pstmt.setString(1, id);     pstmt.setString(2, pass);   %&gt;      &lt;h2&gt; 4. sql 실행 &lt;/h2&gt;   &lt;%     pstmt.executeUpdate();        System.out.println(\"회원정보 삭제 완료!\");   %&gt;  ","categories": ["JSP"],
        "tags": ["Database","JSP","JDBC"],
        "url": "/jsp/jdbc/",
        "teaser": null
      },{
        "title": "Java) BOJ 1011. Fly me to the Alpha Centauri",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1011     제한     시간 제한 : 2 초   메모리 제한 : 512 MB     문제       우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다.   그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.   그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에,   그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다.   하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서,   이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다.   예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나   사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며,        그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. )           김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다.   하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.   김우현을 위해 x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.     입력       입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다.   각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x &lt; y &lt; 231)     출력       각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.      👀 풀이       https://www.acmicpc.net/board/view/75491        참고 해설         30분 고민해 봤으나 k1 = 1, kn = 1이어야 한다까지만 알겠고 나머지 풀이는 영 감이 안 와서 질문게시판을 검색했다.   내가 처음에 했던 생각에서 아주 구체화 된 풀이를 찾을 수 있었는데   121 12321 123421 123454321 … 이런식으로 이동해야 한다. (각 자리수마다 장치를 작동하는 것임)   저 수들에서 찾을 수 있는 규칙은 각 자리수의 합은 2의 제곱, 3의 제곱, 4의 제곱, … 과 같다.        그리고 수의 길이는 2의 제곱-1, 3의 제곱-1, 4의 제곱-1, … 과 같다. =&gt; 이건 장치의 작동 회수가 된다.         이제 도착지 y와 출발지 x 사이의 거리를 구한다.   그리고 거리보다 작거나 같으면서 가장 가까운 제곱수의 제곱근을 구한다. (제곱근 구해주는 함수는 Math.sqrt() 쓰면 됨)   그 다음 거리에서 제곱수를 뺀다.        이 때 뺀 수가 0이면 아까 구했던 수의 길이를 그대로 출력하면 되고         예) 이동해야 하는 거리가 25일 때   25        123454321 &lt;- 5*2-1 = 9 번만에 이동할 수 있다.         0보다 크면서 제곱근보다 작거나 같으면 위에서 구했던 수의 길이에다 1을 더해주면 된다.   26        1234543211 &lt;- 9번 이동한 다음 1번 더 이동해야 각 자리수를 더한 합이 26이 된다.         27        1234543221 &lt;- 마찬가지로 9번 이동하고 1번 더 이동해야 한다.         28        1234543321         29        1234544321         30        1234554321              왜냐면 위의 예시와 같이 중간에 이동할 수 있기 때문이다.          하지만 뺀 수가 0보다 크면서 제곱근보다 크면 수의 길이에다 2를 더해줘야 한다.   31 (여기서 한자리 숫자가 더 늘어나죠?)   12345543211 &lt;- 31보다 작으면서 가장 가까운 제곱수는 55=25이기 때문에 (66=36은 초과해서 안됨) 31-25를 해야 한다.   …   35        12345554321 &lt;- 여기까지는 (5*2-1) + 2 = 11          36(여기는 6의 제곱)        12345654321 &lt;- 6*2-1 = 11         이 과정을 코드로 구현하면 통과할 수 있다.   수학 문제는 규칙을 찾는 것이 중요하다는 것을 알 수 있었다.     결과       시간 : 128 ms   메모리 : 14084 KB   코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1011","Math","Java"],
        "url": "/boj/boj1011-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 10757. 큰 수 A+B",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/10757     문제     두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.     제한     시간 제한 : 1 초   메모리 제한 : 256 MB     입력     첫째 줄에 A와 B가 주어진다. (0 &lt; A,B &lt; 1010000)     출력     첫째 줄에 A+B를 출력한다.      👀 풀이     브론즈5였는데 브론즈가 아닌데…ㅠ   c/c++로만 푸는 같은 문제도 있는데 그건 난이도가 실버3인거 보니까 어려운 문제가 맞는거 같다.   쉽게 책정된 이유는 파이썬은 그냥 계산해줘서 그렇다고 하는데… 정말 쉽지 않은 문제였다 ㅠㅠ        풀이와 코드의 흐름 자체는 비교적 빨리 생각해 냈지만 자잘한 예외 케이스에 걸려서 많이 틀렸다.         입력으로 들어오는 A, B는 long형을 써도 표현범위를 초과하기 때문에 정수를 저장하는 자료형으로 연산을 할 수 없고 다른 방법으로 해결해야 한다.   c/c++이었으면 unsigned long long형으로 해결할 수도 있다는 글을 봤는데 자바에는 없는 것 같다.   자바는 부호가 있는 정수만 저장할 수 있나?(이거 쓰고 찾아보기)        찾아본 결과는 [Java] 부호없는 자료형이 없는 자바 인데 그냥 자료없는 부호형 만들어주지… 자바는 귀찮은 게 참 많은 것 같다.         그래서 입력으로 들어오는 숫자를 문자열로 받은 뒤 두 문자열의 맨 뒤에서부터 앞으로 이동하면서 두 수를 int형으로 바꿔 더한 뒤        계산한 수를 다시 char로 바꿔 스택에 저장하고 만약 10이 넘어가면 다음 자리수를 계산할 때 계산 결과에 1을 더해주도록 했다.         그리고 두 문자열의 길이가 다를 수 있기 때문에 두 문자열 중 더 짧은 문자열의 길이만큼만 위 연산을 하고   만약 다음 자리수에 1을 더해줘야 한다면 남은 숫자들 중 마지막 자리수에 1을 더해주고 스택에 넣고   더 긴 문자열의 앞에 계산되지 않고 남은 숫자들을 정답 문자열 변수에 넣어준 다음        아까 더한 숫자들을 저장해 놓은 스택에서 하나씩 꺼내서 합쳐주었다.          자세한 것은 코드 옆 주석에…     ☑️ 결과     메모리 : 14208 kb   시간 : 132 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10757","Math","Java"],
        "url": "/boj/boj10757-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 11653. 소인수분해",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/11653     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제       정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.     입력       첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.     출력       N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.      👀 풀이       소인수분해 하는 방법 그대로 코드로 구현했다.   2부터 시작해서 N이 2로 나눠 떨어지면 N을 2로 나누고 2를 출력하고 나눠 떨어지지 않으면 1 증가시켜서 다음 수로 같은 과정을 반복하도록 했다.   최대입력인 10,000,000을 가장 작은 수인 2로 나눠도 최대 5,000,000번의 연산을 하기 때문에 시간복잡도는 충분할 것이라 생각하고 제출해 봤는데 통과되었다.     결과       시간 : 172 ms   메모리 : 14280 KB   코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No11653","Math","Java"],
        "url": "/boj/boj11653-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1929. 소수 구하기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1929     제한       시간 제한 : 2 초   메모리 제한 : 256 MB     문제       M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.     출력       한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.      👀 풀이       M이상 N이하의 수들을 소수를 판별하는 연산을 해서 소수면 출력했다.   하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.   i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.   예를 들어 i=16라면   1*16   2*8   4*4   8*2   16*1   위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.        그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.         https://notepad96.tistory.com/entry/C-%EC%86%8C%EC%88%98-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0   예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.     결과       시간 : 1128 ms   메모리 : 29424 KB   코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1929","Math","Java"],
        "url": "/boj/boj1929-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1978. 소수 찾기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1978     제한     시간 제한 : 2 초   메모리 제한 : 128 MB     문제       주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.     입력       첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.       출력       주어진 수들 중 소수의 개수를 출력한다.        👀 풀이       소수 구하기는 프로그래밍을 처음 배울 때 풀어봤던 문제이기도 하고 예전에 몇 번 풀어봐서 풀이를 떠올리는 것은 어렵지 않았다.   하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.   i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.   예를 들어 i=16라면   1*16   2*8   4*4   8*2   16*1   위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.        그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.         C++ 소수 판별하기   예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.     결과       시간 : 132 ms   메모리 : 14152 KB   코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1978","Math","Java"],
        "url": "/boj/boj1978-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 2581. 소수",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2581     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.   예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로,   이들 소수의 합은 620이고, 최솟값은 61이 된다.     입력       입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.   M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.     출력       M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.   단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.      👀 풀이       소수 구하기는 프로그래밍을 처음 배울 때 풀어봤던 문제이기도 하고 예전에 몇 번 풀어봐서 풀이를 떠올리는 것은 어렵지 않았다.   하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.   i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.   예를 들어 i=16라면   1*16   2*8   4*4   8*2   16*1   위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.        그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.         C++ 소수 판별하기        예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.         이 문제에서는 M 이상 ~ N 이하 범위의 수들을 반복문을 돌리면서 i번째 수가 소수라면 합계에 더해주고 그 중 가장 작은 값도 함께 저장했다.   입력의 최대값이 10,000이기 때문에 소수를 판별하는 알고리즘은 최대한 빠른 것을 사용했다.     결과       시간 : 128 ms   메모리 : 14208 KB   코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2581","Math","Java"],
        "url": "/boj/boj2581-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 4948. 베르트랑 공준",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/4948     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제       베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.   이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.   예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)   자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.     입력       입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.   입력의 마지막에는 0이 주어진다. 1 ≤ n ≤ 123,456     출력       각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.      👀 풀이       n초과 2n이하의 수들을 소수를 판별하는 연산을 해서 소수면 카운트해서 2n까지 판별이 끝나면 총 개수를 출력했다.   하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.   i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.   예를 들어 i=16라면   1*16   2*8   4*4   8*2   16*1   위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.        그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.         소수 구하기   예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.     결과       시간 : 696 ms   메모리 : 14660 KB   코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No4948","Math","Java"],
        "url": "/boj/boj4948-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 3009. 네 번째 점",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/3009     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.     입력       세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.     출력       직사각형의 네 번째 점의 좌표를 출력한다.      👀 풀이       x와 y의 값이 서로 다른 점끼리 더한 값이 같아야 하기 때문에   입력 받으면서 이전 x와 현재 x의 값이 같지 않으면 두 수를 더해주고 아니라면 수를 보관해 뒀다가 이전 x와 현재 x가 같지 않은 두 수의 합에서 빼 주었다.   (x, y 각각 적용)     결과       시간 : 148 ms   메모리 : 16056 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No3009","Math","Java"],
        "url": "/boj/boj3009-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 3053. 택시 기하학",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/3053     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       19세기 독일 수학자 헤르만 민코프스키는 비유클리드 기하학 중 택시 기하학을 고안했다.   택시 기하학에서 두 점 T1(x1,y1), T2(x2,y2) 사이의 거리는 다음과 같이 구할 수 있다.                                   D(T1,T2) =           x1-x2           +           y1-y2                           두 점 사이의 거리를 제외한 나머지 정의는 유클리드 기하학에서의 정의와 같다.   따라서 택시 기하학에서 원의 정의는 유클리드 기하학에서 원의 정의와 같다.   원: 평면 상의 어떤 점에서 거리가 일정한 점들의 집합   반지름 R이 주어졌을 때, 유클리드 기하학에서 원의 넓이와, 택시 기하학에서 원의 넓이를 구하는 프로그램을 작성하시오.     입력       첫째 줄에 반지름 R이 주어진다. R은 10,000보다 작거나 같은 자연수이다.     출력       첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. 정답과의 오차는 0.0001까지 허용한다.      👀 풀이       유클리드 기하학이랑 택시 기하학이 처음 보는 단어여서 이해하는데 시간이 좀 걸렸는데   유클리드 기하학은 학교 다닐 때 배웠던 것처럼 반지름 r의 제곱 * 파이(3.14....)였고   택시 기하학은 반지름 r의 제곱 * 2 였다.   저렇게 구현해서 통과했는데 파이는 무한대로 이어지는 값이라서 Math에 있는 PI를 썼다.     결과       시간 : 132 ms   메모리 : 14556 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No3053","Math","Java"],
        "url": "/boj/boj3053-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 4153. 직각삼각형",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/4153     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       과거 이집트인들은 각 변들의 길이가 3, 4, 5인 삼각형이 직각 삼각형인것을 알아냈다. 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.     입력       입력은 여러개의 테스트케이스로 주어지며 마지막줄에는 0 0 0이 입력된다. 각 테스트케이스는 모두 30,000보다 작은 양의 정수로 주어지며, 각 입력은 변의 길이를 의미한다.     출력       각 입력에 대해 직각 삼각형이 맞다면 “right”, 아니라면 “wrong”을 출력한다.      👀 풀이       피타고라스의 정리로 풀었는데 예제에는 입력이 오름차순으로만 주어져 있어서 처음엔 (a의 제곱 + b의 제곱 = c의 제곱) 수식을 썼는데   중간에 입력이 오름차순으로 들어오지 않는 경우가 있는지 틀렸다.   문제에 오름차순으로 입력이 들어온다는 말이 없어서 예상했긴 하지만… 처음부터 그냥 예외처리 해서 쓸 걸 그랬다.   세 수 중 최대값과 나머지 두 수를 찾아서 피타고라스의 정리 수식을 적용해 주었다.     결과       시간 : 124 ms   메모리 : 14012 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No4153","Math","Java"],
        "url": "/boj/boj4153-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1085. 직사각형에서 탈출",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1085     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다.   직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.     입력       첫째 줄에 x, y, w, h가 주어진다.   1 ≤ w, h ≤ 1,000   1 ≤ x ≤ w-1   1 ≤ y ≤ h-1   x, y, w, h는 정수     출력       첫째 줄에 문제의 정답을 출력한다.      👀 풀이       예제를 보니까 (x, y)에서 가로와 세로 직선 방향으로 직사각형의 변으로 가면 되는 것이라   x는 x와 w - x 값 중 더 작은 값을, y는 y와 h - y 중 더 작은 값을 찾은 다음에 저 둘 중 더 작은 값을 최종 출력하면 정답인 거 같아서 그대로 썼는데 통과되었다.     결과       시간 : 140 ms   메모리 : 14216 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1085","Math","Java"],
        "url": "/boj/boj9020-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1002. 터렛",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1002     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.   이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다.   조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.   조규현의 좌표 (x1, y1)와 백승환의 좌표 (x2, y2)가 주어지고, 조규현이 계산한 류재명과의 거리 r1과 백승환이 계산한 류재명과의 거리 r2가 주어졌을 때,   류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.   한 줄에 x1, y1, r1, x2, y2, r2가 주어진다. x1, y1, x2, y2는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이고,   r1, r2는 10,000보다 작거나 같은 자연수이다.     출력       각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.      👀 풀이       처음엔 무슨 문제인가 싶어서 질문게시판을 보니까 두 원 사이의 접점을 구하는 문제였다.   두 원의 관계는 내접하는 경우, 외접하는 경우, 만나지 않는 경우, 겹쳐지는 경우가 있는데   내접과 외접하는 경우에는 접점이 1개이다. (원 그려보면 됨)   만나지 않는 경우에는 접점이 0이다. 이 땐 서로 멀리 떨어져 있거나 큰 원 안에 작은 원이 있는데 두 원 사이의 접점이 없는 경우이다.   겹쳐지는 경우에는 완전히 똑같이 겹쳐지느냐 조금 겹쳐지느냐에 따라 달라지는데   원점의 위치가 똑같고 반지름도 똑같으면 완전히 겹쳐진다. 이럴 때엔 원의 테두리 어디에든 존재할 수 있으니 무한대이다.        조금 겹쳐지는 경우엔 접점이 항상 2개이다. (이것도 원 그려보면 됨)         원이 서로 내접하는지 아닌지 보려면 두 원점 사이의 거리를 구해야 하는데 이것은 피타고라스의 정리로 구했다.   그런데 피타고라스의 정리를 사용하면 거리는 원래 거리의 제곱값이 나오기 때문에 이것의 제곱근을 구하기 위해 sqrt 함수를 사용했는데 여기서 오차가 생겨서 틀렸다.   4의 제곱근을 구하는 경우라면 문제 없지만 5의 제곱근을 구하는 경우에는 정수로 나눠 떨어지지 않으니까… 여기서 오차가 생긴다.        그래서 두 원점 사이의 거리는 제곱한 상태로 사용해야 한다.         그래서 위의 케이스들을 잘 나눠서 분기처리를 해주면 되는데 처음에는 내접하는 경우와 큰 원 안에 작은 원이 있는데 접점이 없는 경우를 생각하지 못해서 틀렸다.   처음에는 두 원점 사이의 거리와 두 반지름의 합만을 이용해서 연산을 했기 때문에 내접하거나 큰 원 안에 작은 원이 있는제 접점이 없는 경우를 처리할 수 없었다.   (다 귀찮아서 원을 안 그려봐서 생긴 일…)   그래서 또 질문게시판을 참고해서 원을 그려보니까 두 반지름의 차도 이용을 해야 완벽하게 답을 구할 수 있다는 것을 알게 되었다.   두 원점 사이의 거리와 두 반지름의 차가 같으면 내접하고 (거리와 합이 같으면 외접)   두 원점 사이의 거리가 두 반지름의 차보다 작으면 큰 원 안의 작은 원이 접점이 없는 경우였다. (합보다 작으면 서로 겹침)        =&gt; 이거 해결하고 통과했다.         그래서 최종적인 분기처리는            두 원의 원점이 같고 반지름도 같으면 -1       원점이 같지만 반지름이 다르면 -1       거리의 제곱이 반지름 합의 제곱과 같거나 반지름 차의 제곱과 같으면 1       거리의 제곱이 반지름 합의 제곱보다 크거나 반지름 차의 제곱보다 작으면 0       나머지 경우는 2             결과       시간 : 136 ms   메모리 : 14292 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1002","Math","Java"],
        "url": "/boj/boj1002-java/",
        "teaser": null
      },{
        "title": "Mac) Java OpenJDK 버전 여러개 설치해 놓고 돌려가며 쓰기",
        "excerpt":"👀 터미널에서 단어 하나만 입력하면 OpenJDK 8 버전과 OpenJDK 11 버전을 그 때 그 때 기본으로 세팅할 수 있다.   Homebrew로 OpenJDK 설치  /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"     Homebrew가 설치되어 있지 않다면 위 명령어를 터미널에 입력해서 설치한다.   처음엔 그림도 없고 CLI 환경이라 겁 먹었는데 적응되니까 세상에서 젤 편한 브루~ 😄      brew install --cask adoptopenjdk     브루용 터미널을 켠 다음에 위 명령어를 입력하면 현재 OpenJDK의 최신버전을 설치할 수 있다.   현재 17, 18 버전까지 나와있는데 많이 사용하는 버전은 8과 11 버전인 거 같다.   그래서 나도 8과 11 버전만 설치할 것이다.   버전별 명령어 리스트     brew tap AdoptOpenJDK/openjdk brew install --cask adoptopenjdk11     현재 8버전은 깔려 있어서 11버전만 추가로 설치했다.   위 목록에서 설치하고 싶은 버전을 --cask 뒤에 입력하면 된다.   Homebrew를 통해 설치하는 것은 정식 루트를 통하는 것은 아니고 커뮤니티에 배포되어 있는 것을 사용하는 것이라고 하는데 오라클 JDK가 유료화 된 이후로 다 이렇게 써서 문제 되는 것은 없다고 한다.       🍺  adoptopenjdk11 was successfully installed!     정상적으로 설치가 되면 마지막에 성공적으로 설치되었다는 메세지를 볼 수 있다.       % java -version openjdk version \"1.8.0_302\" OpenJDK Runtime Environment (Temurin)(build 1.8.0_302-b08) OpenJDK 64-Bit Server VM (Temurin)(build 25.302-b08, mixed mode)     현재 사용중인 자바의 버전을 확인해보면 기존에 사용하던 것이 있어서 8버전이 나온다.      % /usr/libexec/java_home -V Matching Java Virtual Machines (3):     11.0.11 (x86_64) \"AdoptOpenJDK\" - \"AdoptOpenJDK 11\" /Library/Java/JavaVirtualMachines/adoptopenjdk-11.jdk/Contents/Home     1.8.0_312 (arm64) \"Azul Systems, Inc.\" - \"Zulu 8.58.0.13\" /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home     1.8.0_302 (x86_64) \"Eclipse Temurin\" - \"Eclipse Temurin 8\" /Library/Java/JavaVirtualMachines/temurin-8.jdk/Contents/Home     설치된 모든 자바 버전을 보고 싶으면 /usr/libexec/java_home -V 명령어를 입력하면 된다.   사용중이던 8버전 외에 11버전도 추가로 잘 설치된 것을 볼 수 있다.      그런데… 실리콘 맥용이 아니라서 다시 설치     M1 맥북을 사용중인데 설치하고 보니까 인텔맥 버전(x86_64)이라 왠지 최적화가 좀 덜 될 거 같아서 지우고 실리콘 맥용으로 다시 설치했다.   % cd /Library/Java/JavaVirtualMachines/ JavaVirtualMachines % ls   adoptopenjdk-11.jdk\ttemurin-8.jdk\t\tzulu-8.jdk     JVM 폴더로 이동해서 ls 명령어로 설치된 JDK들을 확인해 보면 목록들이 나온다.      % sudo rm -rf adoptopenjdk-11.jdk     rm 명령어를 사용해 삭제하고 싶은 버전을 입력하면 삭제할 수 있다.      % ls temurin-8.jdk\tzulu-8.jdk     다시 확인해보면 없다.   % /usr/libexec/java_home -V Matching Java Virtual Machines (2):     1.8.0_312 (arm64) \"Azul Systems, Inc.\" - \"Zulu 8.58.0.13\" /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home     1.8.0_302 (x86_64) \"Eclipse Temurin\" - \"Eclipse Temurin 8\" /Library/Java/JavaVirtualMachines/temurin-8.jdk/Contents/Home       Zulu JDK 다운로드     Azul JDK   Azul Systems 홈페이지에 가면 Arm Architecture용으로 나온 JDK를 다운받을 수 있다.   11버전을 선택해서 다운로드한다. (.dmg 파일이 편해서 사용)   더블클릭 후 다음만 누르면 설치가 완료된다.   Zulu JDK 설치 확인  % /usr/libexec/java_home -V Matching Java Virtual Machines (3):     11.0.14 (arm64) \"Azul Systems, Inc.\" - \"Zulu 11.54.23\" /Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home     1.8.0_312 (arm64) \"Azul Systems, Inc.\" - \"Zulu 8.58.0.13\" /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home     1.8.0_302 (x86_64) \"Eclipse Temurin\" - \"Eclipse Temurin 8\" /Library/Java/JavaVirtualMachines/temurin-8.jdk/Contents/Home     11 버전도 arm64로 잘 설치되었다.     단어 하나로 기본으로 사용할 OpenJDK 버전 바꾸기     컴퓨터에 설치된 자바가 하나뿐이라면 그게 자동으로 기본값으로 설정이 되지만 나는 사정상 11로 완전 갈아타면 안 되고 8버전도 써야 하기 때문에 두 개를 바꿔가며 써야 하는데 매번 환경설정을 해주려면 참 귀찮을거 같아서 좀 미뤄왔었다.   그런데 구글링 해 보니까 완전 편한 방법이 있었다.   export JAVA_HOME=$(/usr/libexec/java_home -v 1.8) export PATH=\"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/sbin:$JAVA_HOME\" alias setJava8='export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)' alias setJava11='export JAVA_HOME=$(/usr/libexec/java_home -v 11)'     bash_profile에 위 커맨드들을 추가하면 자바 버전별로 앨리어스를 지정해 사용할 수 있다.      bash_profile 수정하기   유저명@MacBook-Air ~ % ls -a      터미널을 실행하면 아마 기본 경로가 홈 디렉토리일텐데 아니라면 홈 디렉토리로 이동해서 ls -a를 실행한다.   .\t\t\t\t.plastic4 ..\t\t\t\t.rbenv .AnySign4PC\t\t\t.softforum .CFUserTextEncoding\t\t.ssh .DS_Store\t\t\t.swiftpm .IdentityService\t\t.templateengine .Trash\t\t\t\t.viminfo .android\t\t\t.vscode .bash_history\t\t\t.zprofile .bash_profile\t\t\t.zsh_history .bundle\t\t\t\t.zsh_sessions .cache\t\t\t\t.zshrc .config\t\t\t\tAndroidStudioProjects .delfino.conf\t\t\tApplications .dotnet\t\t\t\tDesktop .eclipse\t\t\tDocuments .emulator_console_auth_token\tDownloads .gem\t\t\t\tLibrary .gitconfig\t\t\tMovies .gradle\t\t\t\tMusic .lemminx\t\t\tPictures .local\t\t\t\tPublic .m2\t\t\t\tPycharmProjects .mono\t\t\t\tSites .ms_openjdk_config\t\teclipse-workspace .mysql_history\t\t\tmakefile .npki_pkcs11.cnf\t\tspring-workspace .p2      그러면 이런 목록을 쭉 볼 수 있다.   중간쯤에서 .bash_profile을 볼 수 있다.   @MacBook-Air ~ % vi .bash_profile      위 명령어를 입력하면 수정 모드로 이동한다.   export JAVA_HOME=$(/usr/libexec/java_home -v 1.8) export PATH=\"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/sbin:$JAVA_HOME\" alias setJava8='export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)' alias setJava11='export JAVA_HOME=$(/usr/libexec/java_home -v 11)'      키보드의 I 버튼을 누르면 insert 모드에 진입한다.   위 커맨드들을 복붙해서 붙여넣고 esc를 누르면 insert 모드에서 빠져나온다.   :wq를 입력 후 엔터를 눌러서 수정 모드를 빠져나오자.   @MacBook-Air ~ % source ~/.bash_profile      나와 보면 별 변화가 없어서 이대로 적용이 된 건가 싶지만 위 명령어를 입력해서 최종 적용시켜 주어야 한다.   % setJava11 % java -version openjdk version \"11.0.14\" 2022-01-18 LTS OpenJDK Runtime Environment Zulu11.54+23-CA (build 11.0.14+9-LTS) OpenJDK 64-Bit Server VM Zulu11.54+23-CA (build 11.0.14+9-LTS, mixed mode)  % setJava8 % java -version openjdk version \"1.8.0_312\" OpenJDK Runtime Environment (Zulu 8.58.0.13-CA-macos-aarch64) (build 1.8.0_312-b07) OpenJDK 64-Bit Server VM (Zulu 8.58.0.13-CA-macos-aarch64) (build 25.312-b07, mixed mode)      이제 터미널에서 setJava11만 입력하면 11버전으로 바꿀 수 있다! 8로 돌아가는 것도 마찬가지      출처     [Mac] OpenJDK 버전별로 여러개 설치하기 ( using Homebrew )   MacOS에서 오라클 JDK를 삭제하고 OpenJDK 11 설치  ","categories": ["Java"],
        "tags": ["Java","OpenJDK","Homebrew"],
        "url": "/java/set-java-version/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어) 제어 장치",
        "excerpt":"👀 제어 장치란?     프로그램에 의해 주어진 연산의 순서를 실행해 나가기 위하여 기억 장치, 연산 장치, 입,출력 장치에 신호를 보내고, 또 이들 장치로부터 신호를 받아 다음에 수행해야 할 조작을 결정하는 부분   컴퓨터의 중추선이라 할 수 있다.   컴퓨터의 자료 처리 속도를 MIPS(Million Instructions Per Second)로 나타내는데 1MIPS는 1초에 백만 개의 명령어가 처리될 수 있다는 것을 의미한다.      제어 장치의 구성     제어 장치(control unit)는 주기억 장치에 연결되어 있는 명령어를 순서대로 호출하고 해독하여 그 결과에 따라 연산 장치, 기억 장치, 입,출력 장치에 제어 신호를 보내 원하고자 하는 동작을 유도한다.        1. 프로그램 계수기(PC : Program Counter)     명령의 실행 순서를 정하기 위하여 다음에 실행될 명령이 들어 있는 번지를 기억해 두는 레지스터   명령어 계수기(IC : Instruction Counter) 혹은 위치 계수기(LC : Location Counter)라고도 한다.     2. 명령 레지스터(IR : Instruction Register)     프로그램 계수기(PC)가 지정한 번지에 기억되어 있는 명령을 꺼내어 이 명령을 해석하기 위하여 임시로 보관하여 두는 레지스터   명령부와 번지부로 구성되어 있다.            명령부 : 실행 명령 코드(operation code)가 들어 있다.       번지부 : 데이터가 기억되어 있는 번지(operand)가 들어 있다.           명령부의 명령 코드가 해독기에 옮겨져 해독되며 번지부의 번지가 번지 해독기에 이송되어 해독된다.     3. 명령어 해독기(Instruction Decoder)와 기계 사이클 부호기     명령어 해독기 : 명령 레지스터의 명령부에 있는 명령 코드를 해독하여 기계 사이클 부호기에 그 신호를 보내는 장치   기계 사이클 부호기 : 명령어 해독기로부터 보내져 온 명령을 실행하는 데 필요한 신호를 만들어 시간 통제 및 제어 장치에 보낸다.     4. 시간 통제 및 제어 장치(Timming and Control Unit)     기계 사이클 부호기에서 수신된 신호를 기계 사이클의 클럭에 따라 동기시켜 필요한 최종 신호를 만들어 순서대로 각 장치들로 송출     5. 범용 레지스터(General Register)     CPU 내에서 자료를 처리하는 과정에 자료를 일시적으로 보관하는 장치     6. 작업 레지스터(Working Register)     산술 논리를 수행하는 레지스터로 처리 결과를 보관하는 장치     7. 플래그 레지스터(Flag Register)     상태 레지스터(Status register)라고도 하며 CPU의 연산 결과 상태를 저장   처리 결과 0(zero), 부호(sign), 오버플로우(overflow), 자리올림(carry), 인터럽트(interrupt) 등의 발생 여부를 나타내는 특수 목적 레지스터      제어 장치의 동작     기억 장치에 있는 명령을 꺼낸다(인출 사이클(fecth cycle))   PC(프로그램 계수기)에 초기 번지를 저장하면 주기억 장치의 명령이 그림의 a, b, c 순서로 명령 레지스터(IR)에 옮겨온다.   레지스터에는 1개의 명령 내용인 명령 코드와 번지부가 기억된다. 명령 해독기와 기계 사이클 부호기를 통해 해독된다.   각 장치에 신호를 보내고, 시간 통제 및 제어 장치를 통해 외부 장치들에게 제어 신호를 송출한다.   이 과정에서 PC의 주기억 장치의 번지는 자동으로 증가된다.     1. 인출 사이클(Fetch cycle)     기억 장치의 번지를 확인하여 명령을 읽어낼 때까지의 단계로 이 기간 동안에 명령이 주기억 장치에서 제어 장치 내의 레지스터로 옮겨진다.   🔸 인출 사이클 진행 과정     현 PC(프로그램 계수기)의 내용을 CPU 내부 버스를 통하여 MAR(메모리 주소 레지스터)로 전송한다.   MAR의 값에 의해 주어진 메모리 주소의 내용(명령어)을 데이터 버스를 통하여 MBR(메모리 버퍼 레지스터)에 저장한다.   PC의 값이 증가한다.   MBR의 내용(명령어 코드)을 IR(명령 레지스터)로 이동한다.     2. 실행 사이클(Execution cycle)     읽어진 명령에 의해 필요한 신호를 만들어 결과를 얻을 때까지의 단계   명령 레지스터의 명령 코드 내용이 명령 해독기에 의해 해독되고, 해독된 내용은 부호기에 의해 각 장치로 신호를 보내게 된다.   해독된 내용이 가산 명령이면 부호기의 신호에 의해 누산기(accumulator)의 내용이 소거되고, 명령 레지스터의 번지부가 주기억 장치의 번지 지정에서 산출되어 기억 레지스터로 옮긴 후 누산기와 가산기의 연산에 의해 계산된 결과는 누산기에 임시 저장된다.   여기까지 끝나면 실행 사이클이 끝나고 다시 인출 사이클이 시작된다. 이러한 과정을 기계 사이클(machine cycle)이라 한다.     3. 인터럽트(Interrupt)     CPU의 플래그 레지스터는 인터럽트에 관한 정보를 포함한다.   인터럽트가 CPU에 가해지면 현재 처리 프로그램을 일단 중지시키고, 인터럽트 프로그램을 수행시킨다.   인터럽트는 CPU의 제어 버스에 속하며, 인터럽트용 전기 신호 단자에 의해 CPU가 인지하게 된다.   어떤 처리 프로그램의 실행중에 제어 프로그램의 서비스를 요구하는 예기치 못한 일이 발생했을 때에 이걸 하드웨어로 포착해서 감시 프로그램(Supervisor)에게 제어권을 인도하기 위한 기능   인터럽트가 발생하여 제어권이 제어 프로그램(Control program)에 주어지면 제어 프로그램이 중에 준비된 인터럽트 처리 루틴(Interrupt handling routine)이 실행된다. 이 루틴의 처리가 끝나면 시스템은 인터럽트가 발생하기 전 상태로 되돌아가서 먼저 실행되던 프로그램의 실행을 다시 시작한다.     🔸 인터럽트 종류  1. 기계 체크 인터럽트(Machine check interrupt)     어떤 프로그램 실행중에 장치 착오로 인하여 발생하는 인터럽트   기계에 착오가 발생했을 경우에 인터럽트가 일어나 제어 프로그램으로 제어권이 넘어간다.   제어 프로그램 내의 인터럽트 처리 루틴이 CPU의 제어권을 인도받아서 필요한 진단이나 착오 정정의 처리를 수행한 후 제어권을 다시 처리 프로그램에 되돌려 준다.     2. 외부 인터럽트(External interrupt)     오퍼레이터가 필요에 의해서 콘솔에 있는 인터럽트 키를 누를 때 발생하는 인터럽트   오퍼레이터가 시스템에 어떤 요구나 응답을 할 때 필요하다.   인터럽트 키를 누름으로써 인터럽트가 발생하여 오퍼레이터가 필요한 내용의 명령을 손으로 조작할 수 있다.     3. 프로그램 인터럽트(Program interrupt)     프로그램 실행중에 프로그램 상의 착오나 예외 상태가 발생했을 경우 일어나는 인터럽트     4. 입,출력 인터럽트(I/O interrupt)     CPU는 입,출력 조작의 계시를 명령하는 것 뿐이지 실제로 입,출력 조작을 지시하는 것은 채널에서 이루어진다. 그래서 채널이 입,출력 조작을 함과 동시에 CPU는 다른 처리를 한다.   입,출력 조작이 끝나거나 입,출력 착오가 발생되면 CPU의 서비스가 필요해지므로 채널이 인터럽트 신호를 발생시킨다.   이 때 CPU는 제어 프로그램 중의 인터럽트 처리 루틴(I/O Interrupt handling routine)이 실행된다.     5. 제어(감시) 프로그램 호출 인터럽트(Supervisor call interrupt)     시스템에 의하여 자동적으로 발생하는 인터럽트가 아닌 프로그램 내에서 특정한 서비스를 요구하는 명령으로 인터럽트를 일으키는 경우      출처     컴퓨터 사이언스(김철 저)  ","categories": ["Computer Science"],
        "tags": ["CS","Computer Hardware","Control Unit"],
        "url": "/computer%20science/CS-14/",
        "teaser": null
      },{
        "title": "Java) BOJ 10872. 팩토리얼",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/10872     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제       0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 정수 N(0 ≤ N ≤ 12)이 주어진다.     출력       첫째 줄에 N!을 출력한다.      👀 풀이       N팩토리얼이 1부터 N까지의 누적곱이기 때문에 누적합을 구하는 코드에서 곱하기로만 바꿨다. 단 구한 팩토리얼을 저장할 변수가 0부터 시작하면 무슨 수를 곱해도 0이 되어버리기 때문에 1부터 시작해야 하는 것만 주의하면 된다.     결과       시간 : 128 ms   메모리 : 14220 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10872","Math","Java"],
        "url": "/boj/boj10872-java/",
        "teaser": null
      },{
        "title": "컴퓨터 구조) 컴퓨터 구조 Preview",
        "excerpt":"컴퓨터의 발전     무어의 법칙 덕분에 숱한 기술의 발전이 가능했다.   중요하니까 외우자.     👀 무어의 법칙     싱글 칩의 트랜지스터 수가 2년마다 2배로 증가한다는 법칙(실제로는 2배보다 더 많이 증가)   성능의 급격한 발전으로 인해 과거에 비해 더 싼 가격에 더 좋은 성능을 발휘할 수 있게 되었다.      컴퓨터의 종류  개인 컴퓨터     일반적으로 사용하는 컴퓨터   비교적 저렴하고 저성능     서버 컴퓨터     네트워크 통신이 주 목적   고가, 대용량, 고성능     수퍼 컴퓨터     군사용, 기상청 날씨 예측용 등 특수 목적으로 사용되는 컴퓨터     임베디드 컴퓨터     큰 시스템에 컴퓨터가 하나의 컴포넌트로 구성된 것   적은 전력소모, 저성능, 저가   ex) 스마트폰, 태블릿 PC      데이터의 단위          bit - byte - Kilobyte - Megabyte - Gigabyte - Terabyte - Petabyte - Exabyte         Byte : 8bit   Kilobyte : 2^10 or 1,024 bytes   Megabyte : 2^20 or 1,048,576 bytes   Gigabyte : 2^30 or 1,073,741,824 bytes   Terabyte : 2^40 or 1,099,511,627,776 bytes   Petabyte : 2^50 or 1024 terabytes   Exabyte : 2^60 ir 1024 petabytes      미래의 컴퓨터  Personal Mobile Device (PMD)     스마트폰, 태블릿 PC, 전자안경 등   배터리로 작동되며 인터넷에 연결해서 사용     Cloud computing     Warehouse Scale Computers (WSC) : 특정한 데이터를 서버에서 처리하고 필요할 때 서버에서 다운받아서 사용   Software as a Service (SaaS) : 필요한 소프트웨어를 서비스 형태로 제공받는다.   복잡한 연산은 Cloud에서 처리하고 PMD에서는 간단한 UI 같은 것만 보여주는 것   아마존과 구글의 클라우드 서비스      컴퓨터의 성능  알고리즘 측면     실행되는 operation의 수가 적을수록 성능이 높다.     프로그래밍 언어, 컴파일러, 구조     operation당 실행되는 instruction의 수가 많을수록 성능이 높다.     프로세서와 메모리     단위시간당 instruction을 얼마나 빨리 실행하는지     입출력 시스템     단위시간당 I/O operation을 얼마나 많이 실행하는지에 따라 결정된다.      컴퓨터 구조  Application software     일반적으로 사용자가 사용하는 프로그램   고급언어로 작성된 프로그램     System software     Compiler : 고급언어를 기계어로 번역하는 것   Operating System : 운영체제. 입출력, 메모리 관리, 자원 스케줄링 등을 한다.     Hardware     Processor, memory, I/O controllers      Levels of Program Code  High-level language     C언어 같이 우리가 알아보기 쉬운 언어로 작성한 코드   컴파일러를 거쳐 어셈블리어로 번역된다.     Assembly language     고급언어보다는 알아보기 어렵지만 그래도 사람이 알아볼 수는 있는 정도의 단어들로 작성된 코드   어셈블러(Assembler)를 거쳐 기계어로 번역된다.     Hardware representation     0과 1로 이루어진 코드(Binary digits, bits)   비주얼 스튜디오 같은 IDE엔 컴파일러와 어셈블러가 함께 들어있어서 일반적으로는 함께 실행되지만 단계를 나눠서 실행도 가능하다.      컴퓨터의 구성요소     컴퓨터의 종류는 여러개여도 구성요소는 다 비슷하다.   User-interface divices : display, keyboard, mouse   Storage devices : hard disk, CD/DVD, flash   Network adapters : 다른 컴퓨터와 소통하기 위한 수단      CPU 구성요소     Datapath : 데이터가 어떻게 연산되어 흘러가는지   Control : 프로세서의 컴포넌트 컨트롤   Cache memory : 작고 빠른 SRAM이 있어서 SRAM에 자주 사용하는 데이터를 저장해 놓는다.      추상화(Abstractions)     복잡한 문제를 단순화해서 쉽게 풀 수 있도록 하는 것      메모리 종류  휘발성 메모리 (Volatile main memory)     전원을 끄면 데이터가 날아가는 메모리     비휘발성 메모리 (Non-volatile secondary memory)     전원을 꺼도 데이터가 날아가지 않는 메모리   마그네틱 디스크, 플래시 메모리, CD/DVD 등      반도체 기술     실리콘에 기판을 새겨넣는 것이 반도체 칩을 만드는 과정   conductors(도체), insulators(부도체), switch들이 잘 동작되게 하는 것      컴퓨터의 성능     throughput과 response time로 정의된다.    Response time     operation 하나를 처리하는 데 걸리는 시간   짧을수록 성능이 좋다.    Throughput     단위시간 당 얼마나 많은 일을 할 수 있는지 나타낸 것        높을수록 성능이 좋다.        ❗️ response time은 throughput에 영향을 주지만 throughput은 response time에 영향을 주지 않는다. 그래서 성능은 response time으로 표현할 수 있다.    Execution time     짧을수록 성능이 좋다.   Performance X / Performance Y = Execution time Y / Execution time X = n      Performance와 Execution time은 반비례 관계이다.(기억하기❗️)    Elapsed time     총 걸린 시간   프로세싱, 입출력, OS 오버헤드, 대기시간 등 컴퓨터가 실행되는 동안 모든 것을 처리하는 데 걸린 시간   그 시스템 전체의 성능을 정의하게 된다.    CPU time     어떤 일을 처리할 때 CPU에서 걸리는 시간   그래서 입출력, 다른 작업을 처리하는 데 드는 시간 등은 제외하고 계산된다.   user CPU time과 system CPU time으로 나눌 수 있으며 프로그램마다 CPU와 시스템 성능에 다르게 영향 받는다.      CPU Clocking     CPU의 처리 속도   CPU의 각 부품들은 일정한 시간마다 동작한다. Clock cycle이라 함   Clock period : Clock cycle의 길이   Clock frequency (rate) : 초당 존재하는 Clock cycle의 개수   👀 시간 단위  second, s &gt; millisecond, ms 10^-3 &gt; microsecond, μs 10^-6 &gt; nanosecond, ns 10^-9 &gt; picosecond, ps 10^-12       ❗️ Clock cycle time과 Clock rate는 반비례 관계이다.      출처     KOCW 영남대학교 최규상 교수님 공개강의  ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/computer-architecture-01/",
        "teaser": null
      },{
        "title": "SQL) JOIN",
        "excerpt":"☑️ 문법     같은 컬럼을 가지고 있는 여러 테이블을 묶어서 데이터를 볼 때 사용한다.   1. ON절을 사용한 JOIN   SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_id FROM   employees s JOIN departments d ON     (e.department_id = d.department_id) -- 여기에 입력할 컬럼은 조인시킬 테이블 모두에 있어야 함 WHERE  e.manager_id = 149;      테이블 두 개만 가능한 것은 아니고 세 개, 네 개, … 작성하는 만큼 가능하다.   2. ON절을 사용한 Self-Join   SELECT  worker.last_name emp, manager.last_name mgr FROM    employees worker JOIN employees manager ON      (worker.manager_id = manager.employee_id);      같은 테이블 안에서 JOIN 하는 것도 가능하다.    ❗️ 쿼리문 작성 팁     컬럼명을 입력할 때 해당 컬럼이 속해있는 테이블명을 입력하면 해당 범위에서만 검색을 시행하기 때문에 실행속도가 훨씬 빨라진다. (테이블명을 적지 않아도 실행되지만 그만큼 모든 테이블을 대상으로 검색해서 결과를 가져오기 때문에 실행속도가 훨씬 느리다.)   그래서 실행속도가 빠른 쿼리문을 작성하는 것이 중요하다.   그런데 테이블 풀네임을 일일이 적어주면 너무 길어서 가독성이 떨어지니까 약자로 적을 수 있는데 대신 약자로 적었다면 FROM절에서 어떤 테이블명의 약자인지 꼭 명시해줘야 SQL이 헷갈리지 않고 잘 찾아올 수 있다.   ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-join/",
        "teaser": null
      },{
        "title": "SQL) Subquery",
        "excerpt":"☑️ 문법     GROUP BY절을 제외하고 다 사용가능하며 WHERE, HAVING절에서 제일 많이 활용된다.   SELECT select_list FROM   table WHERE  expr operator (SELECT select_list                       FROM   table);      테이블에서 어떤 정보를 조회할 때 특정 범위 안에 있는 정보만 조회하고 싶은데 그 특정 범위도 알 수가 없어서 쿼리문으로 물어봐야 할 때 사용한다.    예제   SELECT last_name, salary FROM   employees WHERE  salary &gt; (SELECT salary                  FROM   employees                  WHERE  last_name = 'Abel');      Able이라는 사람보다 높은 연봉을 가진 사람들을 조회하고 싶을 때     SELECT last_name, job_id, salary FROM   employees WHERE  salary = (SELECT MIN(salary)                  FROM   employees);      연봉이 가장 적은 사람의 이름, 부서, 연봉정보를 출력하고 싶을 때     SELECT   department_id, MIN(salary) FROM     employees GROUP BY department_id HAVING   MIN(salary) &gt; (SELECT MIN(salary)                         FROM   employees                         WHERE  department_id = 50);      부서번호 50번의 가장 적은 연봉보다는 큰 부서별 가장 적은 연봉을 보고 싶을 때     Inline View     From절에 Subquery가 작성된 경우   SELECT a.last_name, a.salary, a.department_id, b.salavg FROM   employees a JOIN (SELECT   department_id, AVG(salary) salavg                          FROM     employees                          GROUP BY department_id) b -- 이 쿼리구문 안에서만 유효한 inline view ON     a.department_id = b.department_id WHERE  a.salary &gt; b.salavg;      employees 테이블에서 자기가 소속된 부서의 평균 급여보다 본인의 급여가 더 큰 사원만 출력할 때   Inline view는 실제로 존재하는 테이블은 아닌 이 쿼리문을 위한 가상 테이블로, 실제 존재하는 테이블은 아니기 때문에 마지막에 한 칸 띄우고 앨리어스를 꼭 작성해야 한다.  ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-subquery/",
        "teaser": null
      },{
        "title": "JSP) DAO",
        "excerpt":"👀 DAO(Data Access Object)란?     데이터 처리 객체   DB에 관련된 모든 동작을 수행하는 클래스   지금까지 JDBC로 DB와 연결할 때 사용하려는 페이지마다 일일이 연결 코드를 적어줘야 했는데 이제는 DAO를 만들어서 연결 동작을 여기서 수행하도록 하고 DB연결이 필요한 페이지에서는 DAO만 호출하면 된다!   import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  public class MemberDAO {  \t \t// DAO (Data Access Object) : 데이터 처리 객체 \t// =&gt; DB에 관련된 모든 동작을 수행하는 클래스 \t \t// 연결에 필요한 정보 저장 \tprivate Connection con = null; \tprivate PreparedStatement pstmt = null; \tprivate ResultSet rs = null; \tprivate String sql = \"\"; \t \t// 디비연결 동작 \tprivate Connection getConnect() \t{ \t    final String DRIVER = \"com.mysql.cj.jdbc.Driver\"; \t    final String URL = \"jdbc:mysql://localhost:3306/jspdb\"; \t    final String ID = \"root\"; \t    final String PASS = \"1234\"; \t     \t    try // 예외가 발생할지도 모르는 코드 작성  \t    {  \t\t\t// 1. 드라이버 로드 \t\t\tClass.forName(DRIVER);  \t\t\t// 2. 디비연결 \t\t\tcon = DriverManager.getConnection(URL, ID, PASS); \t\t\t \t\t\tSystem.out.println(\"DAO : 디비연결 성공!\" + con); \t\t}  \t    catch (ClassNotFoundException e)  \t    { \t\t\te.printStackTrace(); \t\t}  \t    catch (SQLException e)  \t    { \t\t\t// TODO Auto-generated catch block \t\t\te.printStackTrace(); \t\t} // 연결 정보가 계속 유지되어야 하기 때문에 finally 구문은 안쓴다. \t     \t\t \t\treturn con; \t} // 디비연결 \t \t// 자원해제 \tpublic void CloseDB() \t{ \t\ttry { \t\t\t \t\t\t// 리소스 해제는 생성의 역순으로 한다. \t\t\tif (null != rs) rs.close(); // 연결해제 \t\t\tif (null != pstmt) pstmt.close(); \t\t\tif (null != con) con.close();  \t\t\tSystem.out.println(\"DAO : 자원해제 완료\"); \t\t\t \t\t} catch (SQLException e) { \t\t\t// TODO Auto-generated catch block \t\t\te.printStackTrace(); \t\t}  \t} // 자원해제 \t \t// 회원가입 - insertMember() \tpublic void insertMember(MemberBean mb) \t{ \t\tSystem.out.println(\"DAO : insertMember() 호출\"); \t\ttry { \t\t\t// 1. 드라이버 로드 \t\t\t// 2. 디비연결 \t\t\tcon = getConnect(); \t\t\t \t\t\t// 3. sql 작성 &amp; pstmt 객체 생성 \t\t\tsql = \"insert into itwill_member(id, pass, name, age, gender, email, regdate) \" \t\t\t\t\t+ \"values(?, ?, ?, ?, ?, ?, ?)\"; \t\t\tpstmt = con.prepareStatement(sql); \t\t\t \t\t\t// ??? \t\t\tpstmt.setString(1, mb.getId()); \t\t\tpstmt.setString(2, mb.getPass()); \t\t\tpstmt.setString(3, mb.getName()); \t\t\tpstmt.setInt(4, mb.getAge()); \t\t\tpstmt.setString(5, mb.getGender()); \t\t\tpstmt.setString(6, mb.getEmail()); \t\t\tpstmt.setTimestamp(7, mb.getRegdate()); \t\t\t \t\t\t// 4. sql 실행 \t\t\tint result = pstmt.executeUpdate(); \t\t\tSystem.out.println(\"DAO : 회원가입 성공!\" + result); \t\t\t \t\t} catch (SQLException e) { \t\t\t// TODO Auto-generated catch block \t\t\te.printStackTrace(); \t\t} \t\tfinally { \t\t\t \t\t\tCloseDB(); \t\t} \t} // 회원가입 - insertMember() \t \t// 로그인 - loginCheck(mb) \tpublic int loginCheck(MemberBean mb) \t{ \t\tSystem.out.println(\"DAO : 로그인 - loginCheck(mb)\"); \t\t \t\tint result = -1; \t\ttry { \t\t\t// 1, 2. 디비연결 \t\t\tcon = getConnect(); \t\t\t \t\t\t// 3. sql 작성(select) &amp; pstmt 객체 생성 \t\t\tsql = \"select pass from itwill_member where id=?\"; \t\t\tpstmt = con.prepareStatement(sql); \t\t\t \t\t\t// ?? \t\t\tpstmt.setString(1, mb.getId()); \t\t\t \t\t\t// 4. sql 실행 \t\t\trs = pstmt.executeQuery(); \t\t\t \t\t\t// 5. 데이터처리 \t\t\tif (rs.next()) \t\t\t{ \t\t\t\t// 회원 \t\t\t\tif (mb.getPass().equals(rs.getString(\"pass\"))) \t\t\t\t{ \t\t\t\t\t// 본인 \t\t\t\t\tresult = 1; \t\t\t\t} \t\t\t\telse  \t\t\t\t{ \t\t\t\t\t// 비밀번호 오류 \t\t\t\t\tresult = 0; \t\t\t\t} \t\t\t} \t\t\telse  \t\t\t{ \t\t\t\t// 비회원 \t\t\t\tresult = -1; \t\t\t} \t\t\t \t\t\tSystem.out.println(\"DAO : 로그인체크 완료 (\" + result + \")\"); \t\t\t \t\t} catch (SQLException e) {  \t\t\te.printStackTrace(); \t\t} finally { \t\t\t \t\t\tCloseDB(); \t\t}  \t\tSystem.out.println(\"DAO : 로그인 - loginCheck(mb)\"); \t\treturn result; \t} // 로그인 - loginCheck(mb)  } // MemberDAO      이렇게 DAO 클래스를 만든 다음에     &lt;body&gt;   &lt;%     // 한글처리     request.setCharacterEncoding(\"UTF-8\");          // 전달되는 정보 저장 - 액션태그   %&gt;     &lt;jsp:useBean id=\"mb\" class=\"com.itwillbs.member.MemberBean\"&gt;&lt;/jsp:useBean&gt;     &lt;jsp:setProperty property=\"*\" name=\"mb\"/&gt;   &lt;%     // DB정보를 사용해서 로그인 체크     // DAO 객체 생성     MemberDAO dao = new MemberDAO();     int result = dao.loginCheck(mb);     System.out.println(\"pro : 로그인체크 완료 (\" + result + \")\");          if (1 == result)     {     \tsession.setAttribute(\"id\", mb.getId());     \t%&gt;     \t  &lt;script type=\"text/javascript\"&gt;     \t    alert(\"로그인 성공!\")     \t    location.href='main.jsp';     \t  &lt;/script&gt;     \t&lt;%     }     else if (0 == result)     {     \t%&gt;     \t  &lt;script type=\"text/javascript\"&gt;     \t    alert(\"비밀번호 오류!\");     \t    history.back();     \t  &lt;/script&gt;     \t&lt;%     }     else     {     \t%&gt;     \t  &lt;script type=\"text/javascript\"&gt;     \t    alert(\"비회원 입니다!\");     \t    history.back();     \t  &lt;/script&gt;     \t&lt;%     }          // 체크 결과에 따른 페이지 이동   %&gt; &lt;/body&gt;      JSP 페이지에서는 아까 만든 객체를 호출하기만 하면 된다!  ","categories": ["JSP"],
        "tags": ["Database","JSP","DAO"],
        "url": "/jsp/jdbc-dao/",
        "teaser": null
      },{
        "title": "Java) BOJ 2231. 분해합",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2231     제한       시간 제한 : 2 초   메모리 제한 : 192 MB     문제       어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.   예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다.   반대로, 생성자가 여러 개인 자연수도 있을 수 있다.   자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.     입력       첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.     출력       첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.      👀 풀이            참고 블로그 : https://st-lab.tistory.com/98        N의 생성자 중 가장 작은 수를 구하면 되니까 꼭 모든 수를 탐색할 필요는 없고 1부터 수를 만들어 보면서 N과 같은 수가 나오면 반복을 중단하고 해당 수를 출력하면 된다.   만약 N을 넘어가는데도 생성자가 없다면 0을 출력한다.     결과       시간 : 152 ms   메모리 : 14828 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2231","BruteForce","Java"],
        "url": "/boj/boj2231-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 2798. 블랙잭",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2798     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.   한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.   김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.   이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.   N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.     입력       첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.   합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.     출력       첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.      👀 풀이       참고 블로그 : https://minhamina.tistory.com/38   조합을 구하는 문제같아서 조합 알고리즘을 공부한 뒤 풀었다.        조합인 이유는 수를 뽑는 모든 경우의 수를 탐색해 봐야 하는데 뽑는 순서가 결과에 미치는 영향이 없기 때문이다.        주어지는 N개의 숫자 중 3개를 뽑아서 M보다 작거나 같은 수 중 가장 큰 수를 만들면 되는데 이걸 알기 위해서는 조합이 가능한 모든 경우의 수를 탐색해 봐야 한다.   그래서 재귀로 n개 중에 3개를 뽑는 경우, n-1개 중에 2개를 뽑는 경우, n-2개 중에 1개를 뽑는 경우,… 로 탐색하다가 n-r개 중에 0개를 뽑는 경우가 되면 그동안 뽑은 수들의 합 중 M보다 작거나 같으면서 가장 큰 수를 찾으면 된다.     결과       시간 : 132 ms   메모리 : 14140 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2798","BruteForce","Java"],
        "url": "/boj/boj2798-java/",
        "teaser": null
      },{
        "title": "컴퓨터구조) Performance",
        "excerpt":"CPU Time     한 컴퓨터 프로그램이 CPU를 차지하여 일을 한 시간의 양   컴퓨터의 성능을 측정하기 위해 사용된다.   CPU Time = Instruction Count x CPI x Clock Cycle Time   CPU Time이 적을수록 성능이 좋다고 할 수 있다.   clock cycle을 줄이거나 clock rate가 올라가면 성능이 향상된다.      Instruction Count &amp; CPI  Instruction Count     명령어의 수   CPI     Cycles per Instructions   Instruction의 실행주기   짧은 CPI를 가진 IC가 많을수록 성능이 좋다고 할 수 있다.      성능에 영향을 미치는 요소     알고리즘 : IC, CPI   프로그래밍 언어 : IC, CPI   컴파일러 : IC, CPI   ISA(명령어셋) : IC, CPI, T      Clock period     Duration of a clock cycle   하나의 clock cycle이 걸리는 시간   1/clock rate로 나타낼 수 있다.      Power wall     clock rate는 매년 꾸준히 늘다가 2004년을 기점으로 늘지 않고 있다.   왜냐면 전력소모가 많이 줄었기 때문   전력소모량은 Capacitive loadxVoltage^2xFrequency로 구할 수 있는데 Voltage가 많이 줄었기 때문에 Frequency가 많이 늘어났음에도 전력소모량은 크게 늘지 않았다.   그런데 Voltage가 높을수록 전력소모와 열 발생이 많은데 Voltage를 더이상 줄일 수가 없게 되었기 때문에 기존에 clock rate을 증가시키는 방법으로는 성능 향상을 꾀하기가 어려워졌다.   2004년 이후로 clock rate을 증가시키지 못한 이유가 CPU에서 발생하는 열을 해결하지 못해서였다.   그래서 clock rate을 올리지 않고 성능을 향상시키기 위한 방법으로 Multi-core가 등장하게 된다.      Multiprocessors     Multicore microprocessors : 하나의 칩 안에 프로세서가 여러 개 있는 것   Parallel programming이 필요하다.            하드웨어가 여러 명령을 동시에 실행할 수 있지만 그만큼 프로그래밍이 어렵다.              CPU 성능 측정     SPEC CPU Benchmark로 측정하거나 MIPS(Millions of Instructions per Second : 시간당 몇백만개의 명령을 실행하는가)를 이용해 측정할 수 있는데 SPEC CPU Benchmark가 더 정확하다고 할 수 있다.   SPEC CPU Benchmark는 여러 파트에서 측정한 시간값을 바탕으로 총점을 매기는데 MIPS는 IC와 Exectution time을 이용해 계산하기 때문에 컴퓨터마다 ISA(명령어셋)가 다르고 또 명령어마다 필요한 CPI값이 다를 수 있기 때문에 객관적이라 하기 어렵다.      Amdahl’s Law     컴퓨터의 어느 한 부분의 성능을 향상시키면 전체 성능의 향상은 그 부분이 컴퓨터에서 차지하는 비율만큼 향상된다는 법칙   Corollary : make the common case fast   따라서 전체 시스템에서 차지하는 비율이 높은 부분의 성능을 향상시키는 것이 전체 성능 향상에 도움이 된다.      대기 중 전력소모     CPU를 거의 사용하지 않는 상황에서도 생각보다 전력소모가 크다.            예를 들어 CPU가 10%만 사용중인데 전력은 전체의 47%를 사용한다는 등           그래서 프로세서를 만들 때 전력소모의 비율이 CPU 사용량에 비례되게 설계할 필요가 있는데 쉽지 않다.      출처     KOCW 영남대학교 최규상 교수님 공개강의  ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/computer-architecture-02/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) 네트워크 기초",
        "excerpt":"컴퓨터 네트워크     전송 매체를 통해 서로 연결되어 데이터를 공유, 교환하는 컴퓨터의 모음   예) 인터넷   네트워크는 크게 나누면 유선, 무선 두 종류로 나눌 수 있다.      프로토콜(Protocol)     정보교환을 위해 필요한 통신 규약   사람들끼리 말을 할 때 맥락없이 얘기하지 않고 서로 합의된 맥락 안에서 얘기하듯 컴퓨터 간 통신을 할 때에도 맥락이 필요하다.   예) HTTP, TCP, IP      컴퓨터 네트워킹이 필요한 이유  연결과 통신     멀리 떨어져 있는 사용자와도 효율적으로 정보를 교환하기 위해서   데이터 공유     컴퓨터 네트워크를 통해 쉽고 빠르게 데이터 공유   컴퓨터 네트워크를 사용하는 ❗️ 가장 중요한 이유 중의 하나라고 할 수 있다.   하드웨어 공유     사무실에 프린터는 한 대만 두고 사무실내의 컴퓨터들이 네트워크를 통해 프린터를 공유하는 것처럼 하드웨어 공유를 통해 경비를 절감할 수 있다.   데이터 보안과 관리     네트워크에 연결된 서버에 저장, 데이터 읽기/수정 관리   성능 개선     업무를 여러 컴퓨터에 분산시켜 동시에 처리      기초 용어     노드(Node) : 컴퓨터 네트워크에 연결된 컴퓨터 또는 네트워크 장비를 일반화한 용어   호스트(Host) : 사용자의 요청을 처리하는 컴퓨터를 일반화한 용어   클라이언트(Client) : 서비스를 요청하는 호스트   서버(Server) : 서비스 요청을 받아 서비스를 제공하는 호스트   네트워크 인터페이스(Interface) : 호스트와 컴퓨터 네트워크의 연결 지점으로 네트워크 인터페이스 카드(NIC)라고 한다.   전송 매체(Transmission Medium)            송신측 호스트와 수신측 호스트 사이를 상호 연결하는 물리적인 선로       유선(Wired) 전송 매체와 무선(Wireless) 전송 매체로 구분       링크(Link)라고도 한다.           채널(Channel)            송신측에서 수신측으로 데이터를 전송하기 위해서 사용       유선과 같은 전송매체 또는 무선(Radio) 채널과 같이 다중화(Multiplexing 여러 호스트가 하나의 채널을 공유하는 것) 된 매체에서 하나의 논리적 연결(Logical Connection)을 말함       채널의 전송 용량은 bps(bit per second 초당 보내는 bit의 양) 단위의 전송률 또는 Hz 단위의 대역폭(Bandwidth)으로 표시              컴퓨터 통신구조     서로 다른 시스템간의 통신을 하나의 모듈로 처리하기는 너무 복잡하기 때문에 기능별로 모듈을 세분화해서 구현할 필요가 있다.   세분화된 모듈을 계층화 한 구조가 컴퓨터 통신 구조   계층화 하는 이유     복잡한 시스템의 각 부분을 식별하고 연계하는데 좋다.   모듈화는 시스템의 유지 및 개선을 용이하게 한다.   특정 모듈을 변경하더라도 다른 모듈에 영향을 주지 않는다.              대표적으로 ISO OSI 7계층 통신구조와 인터넷 프로토콜 구조(5계층)이 있다.   인터넷 통신구조     응용(application) : 응용 서비스 지원            HTTP, FTP, SMTP           트랜스포트(transport) : 호스트간의 데이터 전송            TCP, UDP           네트워크(network) : 라우팅            IP, RIP등           데이터링크(datalink) : 네트워크 노드간의 데이터 전송            Ethernet           물리(physical) : 물리적인 케이블    각 계층은 하위계층을 반드시 이용해야 한다.   응용계층쪽으로 갈수록 사용자와 가깝고 물리계층으로 갈수록 하드웨어와 가깝다.      표준화     정보통신 시스템 간의 프로토콜을 정립하는 활동   정보통신 표준 : 정보통신 시스템간의 미리 합의된 규약의 집합   정보통신 분야에 있어서 공통성, 통일성, 호환성, 등을 확보하기 위한 일반적 요구 사항   표준화 기구     ISO(International Organization for Standards)   ITU-T(International Telecommunication Union-Telecommunication)   ANSI(American National Standards Institute)   EIA(Electronic Industries Association)   TIA(Telecommunications Industries Association)   IEEE(Institute of Electrical and Electronics Engineers)   ETSI(European Telecommunications Standards Institute)   IETF(Internet Engineering Task Force) : 인터넷 표준규격 제정(HTTP, FTP), IETF에서 만든 표준은 RFC(Request For Comments)로 시작      출처     KOCW 동서대학교 임효택 교수님 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network"],
        "url": "/computer%20network/computer-network-01/",
        "teaser": null
      },{
        "title": "SQL) 데이터조작어(DML)",
        "excerpt":"   테이블에 저장되어 있는 데이터를 다루는 명령어      1. INSERT 구문     테이블에 새로운 행 추가   ☑️ 문법   INSERT INTO table [(column [, column...])] VALUES      (value [, value...]);   예제   INSERT INTO departments(department_name, namager_id, department_id, location_id) VALUES      ('Java', 201, 290, 1700);  INSERT INTO departments(department_id, department_name) VALUES      (300, 'Jsp');     테이블명 다음에 설정한 컬럼수만큼 values에 값을 채워준다. 나머지는 자동으로 null값이 들어간다.     INSERT INTO departments VALUES      (310, 'Web', null, null);     아니면 null을 넣고 싶은 필드를 직접 지정해 줄 수도 있다.      2. UPDATE 구문     테이블이 기존 행 수정   ☑️ 문법   UPDATE table SET    column = value [, column = value, ...] [WHERE condition];   예제   UPDATE employees SET    department_id = 50 WHERE  employee_id = 113;     이렇게 쓰면 특정 row만 데이터 변경     UPDATE employees SET    department_id = 50;     이렇게 쓰면 해당 테이블 내의 모든 row의 데이터가 바뀐다. 이렇게 쓸 일은 거의 없으니까 UPDATE 사용시에는 WHERE 조건을 잘 확인하자.     UPDATE copy_emp SET    job_id = (SELECT job_id                  FROM   copy_emp                  WHERE  employee_id = 205),        salary = (SELECT salary                  FROM   copy_emp                  WHERE  employee_id = 205) WHERE  employee_id = 113;     수정할 데이터 구문에서 서브쿼리도 사용 가능      3. DELETE 구문     테이블의 기존 행 삭제   ☑️ 문법   DELETE [FROM] table [WHERE        condition];   예제   DELETE FROM departments WHERE       department_id = 60;  DELETE FROM copy_emp;     이렇게 쓰면 전체 삭제      4. 트랜잭션(Transaction)     논리적인 작업 단위   여러 DML이 모여서 하나의 트랜잭션이 구성된다.   DML 작업을 통해 변경한 내용들은 모두 임시저장 되어 있는 상태이다.   그래서 DML 작업 후 commit(DB에 작업내용 최종 저장), rollback(DB 최종 저장 전에 작업내용 되돌리기)으로 트랜잭션을 종료해야 한다.     4-1) 트랜잭션 구성     여러 DML 구문이 하나의 트랜잭션 (select, insert, update, delete)   하나의 DDL 구문이 하나의 트랜잭션 (create, alter, drop, truncate)   하나의 DCL 구문이 하나의 트랜잭션 (grant, revoke)     4-2) 트랜잭션 시작 및 종료  🔸 시작     첫 번째 DML 구문 실행 시   🔸 종료     COMMIT 또는 ROLLBACK 실행 시            DML 쓰다가 DDL/DCL 작성하면 autocommit 되면서 위에 썼던 DML도 같이 커밋된다.(트랜잭션 끝)           DDL 또는 DCL 구문 실행 시(autocommit)            DDL과 DCL은 autocommit을 내포하고 있기 때문에 실행하는 순간 commit되고 트랜잭션이 끝난다.       그래서 rollback이 불가하기 때문에 신중하게 작업하는 것이 좋다.           SQL *PLUS 정상 종료 시(autocommit)            그래픽창의 X를 눌러 끄는 것은 비정상 종료다.       터미널에서 exit 명령어 입력이나 그래픽 툴의 exit 버튼을 눌러서 끄는 것이 정상 종료이다.       비정상 종료 시 autorollback 처리된다.           🔸 SAVEPOINT와 ROLLBACK TO     최종 commit 전에 작업하던 중간 중간으로 되돌아 갈 수 있도록 SAVEPOINT를 만들 수 있다.   하지만 만든 세이브포인트를 확인할 수 있는 명령어는 없기 때문에 만든 사람이 기억하고 있어야 한다.   UPDATE... SAVEPOINT update_done -- 세이브 포인트 생성  ...  INSERT... ROLLBACK TO update_done; -- 세이브 포인트로 되돌리기      세이브 포인트를 만들었다고 그 전까지 했던 작업들이 COMMIT 되는 것은 아니다.   그렇기 때문에 모든 DML 작업이 끝났다면 최종 확인 후 꼭 COMMIT을 해 주어야 한다.  ","categories": ["Database"],
        "tags": ["DB","SQL","DML"],
        "url": "/database/SQL-DML/",
        "teaser": null
      },{
        "title": "DB) 데이터베이스 기본개념",
        "excerpt":"데이터베이스의 필요성     데이터(data) : 의미가 부여되지는 않았지만 현실 세계에서 단순히 관찰하거나 측정해 수집한 사실이나 값   정보(information) : 의사 결정에 유용하게 활용할 수 있도록 데이터를 처리한 결과물   데이터 분류     Wisdom : 지식을 활용할 수 있는 지혜로운 아이디어   Knowledge : 정보를 의미있게 처리, 활용한 것   Information : 가공된 의미있는 2차 데이터   Data : 가공 전의 순수한 데이터   빅데이터 시대     현대는 빅데이터 시대라 할 수 있는데 데이터를 이용해 정보화시킬 수 있는 범위와 능력이 증대되었기 때문이다.   그만큼 데이터를 가공하는 역량이 중요한 시대가 되었다.     정보처리     데이터에서 정보를 추출하는 과정 또는 방법     정보 시스템과 데이터베이스  정보 시스템(information system)     조직 운영에 필요한 데이터를 수집하여 저장해두었다가 필요할 때 유용한 정보를 만들어 주는 수단   데이터베이스     정보 시스템 안에서 저장하고 있다가 필요할 때 제공하는 역할을 담당   여러 가지 업무에 공동으로 필요한 데이터를 유기적으로 결합하여 저장한 집합체. 데이터를 효율적으로 처리하기 위하여 개발된 것으로, 같은 데이터가 중복되는 문제를 없앨 수 있으며 업무가 확대되어도 새로 파일을 준비할 필요가 없다는 장점이 있다.      데이터베이스(DB, Database)     특정 조직의 여러 사용자가 공유하여 사용할 수 있도록 통합해서 저장한 운영 데이터의 집합   데이터베이스의 정의     통합 데이터(integrated data) : 최소의 중복과 통제가능한 중복만 허용하는 데이터   저장 데이터(stored data) : 컴퓨터가 접근할 수 있는 매체에 저장된 데이터   공유 데이터(shared data) : 특정 조직의 여러 사용자가 함께 소유하고 이용할 수 있는 공용 데이터   운영 데이터(operational data) : 조직의 주요 기능을 수행하기 위해 지속적으로(조직이 문 닫을 때까지) 유지해야 하는 데이터   데이터베이스의 특성     실시간 접근(real-time accessibility) : 사용자의 데이터 요구에 실시간으로 응답   계속 변화(continuous evolution) : 데이터의 계속적인 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지            예) 사원의 입사, 퇴사에 따른 변화를 반영           내용 기반 참조(contents reference) : 데이터가 저장된 주소나 위치가 아닌 내용으로 참조            예) 연봉이 5000만원 이상이며 과장급 이상인 사원을 검색하시오.           동시 공유(concurrent sharing) : 서로 다른 데이터의 동시 사용뿐만 아니라 같은 데이터의 동시 사용도 지원  ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/db-01/",
        "teaser": null
      },{
        "title": "DB) 데이터베이스 관리 시스템",
        "excerpt":"데이터베이스 관리 시스템의 등장 배경  파일 시스템(file system)     과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어   응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함   파일 시스템의 문제점     같은 내용의 데이터가 여러 파일에 중복 저장된다.            데이터 중복성       저장 공간의 낭비는 물론 데이터 일관성과 데이터 무결성 유지가 어렵다.             응용 프로그램이 데이터 파일에 종속적이다.            데이터 종속성       사용하는 파일의 구조를 변경하면 응용 프로그램도 함께 변경해야 한다.             데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.   응용 프로그램 개발이 쉽지 않다.      데이터베이스 관리 시스템의 정의 및 특성  데이터베이스 관리 시스템(DBMS, DataBase Management System)     파일 시스템의 문제를 해결하기 위해 제시된 소프트웨어   조직에 필요한 데이터를 데이터베이스에 통합하여 저장하고 관리한다.   데이터베이스 관리 시스템의 주요 기능     정의 기능 : 데이터베이스 구조를 정의하거나 수정할 수 있다.   조작 기능 : 데이터를 삽입, 삭제, 수정, 검색하는 연산을 할 수 있다.   제어 기능 : 데이터를 항상 정확하고 안전하게 유지할 수 있다.   장점     데이터 중복을 통제할 수 있다.   데이터 독립성이 확보된다.   데이터를 동시 공유할 수 있다.   데이터 보안이 향상된다.   데이터 무결성을 유지할 수 있다.   표준화할 수 있다.   장애 발생 시 회복이 가능하다.   응용 프로그램 개발 비용이 줄어든다.   단점     (경제적, 컴퓨터 자원 포함)비용이 많이 든다.   백업과 회복 방법이 복잡하다.   중앙 집중 관리로 인한 취약점이 존재한다.      데이터베이스 관리 시스템의 발전 과정  1세대 : 네트워크 DBMS, 계층 DBMS (1960 ~ 1970)     네트워크 DBMS : 데이터베이스를 계층 형태로 구성            변경이 어렵다.       예) IDS(Integrated Data Store)             계층 DBMS : 데이터베이스를 트리 형태로 구성            구조변경 및 복잡한 현실세계 반영이 어렵다.       예) IMS(Information Management System)             2세대 : 관계 DBMS (1980 ~)     관계 DBMS : 데이터베이스를 테이블 형태로 구성            이해하기 쉽다.       예) 오라클(Oracle), MS SQL 서버, 액세스(Access), 인포믹스(Informix), MySQL             3세대 : 객체지향 DBMS (1980 후반 ~), 객체관계 DBMS (1990 후반 ~)     객체지향 DBMS : 객체를 이용해 데이터베이스 구성            예) 오투(O2), 온투스(ONTOS), 젬스톤(GemStone)                  객체관계 DBMS : 객체 DBMS + 관계 DBMS         현대에는 이해하기 쉬운 2세대 RDBMS를 주로 사용하지만 객체지향 DBMS의 점유율도 점차 높아지고 있다.      출처     데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의  ","categories": ["Database"],
        "tags": ["DB","DBMS","RDBMS"],
        "url": "/database/db-02-management-system/",
        "teaser": null
      },{
        "title": "Java) BOJ 1018. 체스판 다시 칠하기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1018     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다.        지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.       체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다.        따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.       보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다.   당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.     입력       첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.     출력       첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.      👀 풀이       처음엔 좀 어렵게 생각해서 체스판을 앞에서부터도 확인하고 뒤에서부터도 확인하고 첫번째줄부터, 맨 아랫줄부터 거꾸로 올라가면서 확인하기 등 불필요한 탐색을 하는 코드를 작성했다.        그러다 답이 안 나와서 구글링 참고함            https://st-lab.tistory.com/101       88 체스판을 순회하면서 현재 위치부터 +8칸까지가 체스판 색깔을 만족하는지 검사하는 함수 search()를 작성한 후 메인함수에서 입력 크기만큼 88씩 이동하면서 search()를 수행하도록 반복문을 작성한다.     결과       시간 : 132 ms   메모리 : 14312 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1018","BruteForce","Java"],
        "url": "/boj/boj1018-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 7568. 덩치",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/7568     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다.   두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 “더 크다”고 말한다.   예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다.        예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, “덩치”로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.       N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.   이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.   이름\t(몸무게, 키)\t덩치 등수  A\t(55, 185)\t2  B\t(58, 183)\t2  C\t(88, 186)\t1  D\t(60, 175)\t2  E\t(46, 155)\t5      위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다.   그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.     입력       첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.   2 ≤ N ≤ 50   10 ≤ x, y ≤ 200     출력       여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.      👀 풀이       처음에 너무 어렵게 생각해서 덩치 순서대로 배열을 정렬한 다음 정렬한 배열을 다시 순회하면서 정렬된 순서대로 등수를 매기는 방법을 썼는데 틀렸다.        그 후 질문게시판 반례를 찾아보니까 어렵게 생각할 문제가 아니라 내 앞에 있는 사람이 몇 명인지 세는 문제여서 그렇게 수정하니까 통과되었다.         통과 후 배열 순회 횟수 추가 유무에 따라 실행속도가 궁금해져서   등수를 배열에 저장한 다음 마지막에 배열을 순회하면서 출력하는 방식 - 14268KB\t124ms   등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 BufferedWriter로 출력하는 방식 - 14416KB \t132ms   등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 StringBuilder에 저장한 후 출력하는 방식으로 풀어 봤는데 - 15904KB\t 144ms   첫번째가 메모리를 가장 적게 쓰고 속도도 가장 빨랐다.     결과       시간 : 124 ms   메모리 : 14268 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No7568","BruteForce","Java"],
        "url": "/boj/boj7568-java/",
        "teaser": null
      },{
        "title": "OS) Process Management",
        "excerpt":"👀 프로세스 생성 (Process Creation)     부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다.   복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다.   프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다.   프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.   자원의 공유     부모와 자식이 모든 자원을 공유하는 모델   일부를 공유하는 모델   전혀 공유하지 않는 모델 (일반적)   수행 (Execution)     부모와 자식은 공존하며 수행되는 모델   자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델   주소 공간 (Address space)     자식은 부모의 공간을 복사함 (binary and OS data)   자식은 그 공간에 새로운 프로그램을 올린다.(덮어씌움)   유닉스의 예     fork() 시스템 콜이 새로운 프로세스를 생성            부모를 그대로 복사 후 주소 공간 할당           fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 (덮어씌우는 단계)   fork와 exec은 독립적으로 이루어지기 때문에 둘 중 하나만 실행될 수 있다.      프로세스 종료 (Process Termination)     운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.   그래서 단계적인 종료를 통해 모든 자식 프로세스가 먼저 종료된 후 부모가 종료되어야 한다.   System call을 통해 자발적으로 종료되는 경우     프로세스가 마지막 명령을 수행한 후 이를 운영체제에게 알려준다.(exit)   자식이 부모에게 output data를 보냄 (via wait)   프로세스의 각종 자원들이 운영체제에게 반납됨   비자발적으로 종료되는 경우     부모 프로세스가 자식 프로세스의 수행을 강제로 종료시킨다.(abort)   자식이 할당 자원의 한계치를 넘어선 경우   자식에게 할당된 태스크가 더 이상 필요하지 않은 경우   부모가 종료(exit)하는 경우      fork() 시스템 콜   int main() {     int pid; // 부모와 자식을 구분하기 위한 값     pid = fork(); // 새로운 자식 프로세스가 생성되면 여기 다음 줄부터 실행한다.(부모의 문맥을 복사하기 때문)     if (0 == pid)   // this is a child         printf(\"\\n Hello, I am a child!\\n\");     else if (0 &lt; pid)   // this is a parent         printf(\"\\n Hello, I am a parent!\\n\"); }      자식 프로세스를 생성하기 위한 시스템 콜로 부모와 자식을 구분하기 위해 부모의 pid는 0보다 큰 값을 가지고 자식의 pid는 0을 가진다.      exec() 시스템 콜   int main() {     int pid;     pid = fork();     if (0 == pid)   // this is a child     {         printf(\"\\n Hello, I am a child! Now I'll run date \\n\");         execlp(\"/bin/date\", \"/bin/date\", (char *)0);     }     else if (0 &lt; pid)   // this is a parent         printf(\"\\n Hello, I am a parent!\\n\"); }      어떤 프로그램을 새로운 프로세스로 바꿔주기 때문에 execlp()가 호출되는 순간 이후의 코드들은 실행되지 않는다.      wait() 시스템 콜   int main() {     int childPID;     S1;          childPID = fork();          if (0 == childPID)         // child 프로세스 코드 실행     else          wait();              S2; }      프로세스 A가 wait() 시스템 콜을 호출하면 커널은 child가 종료될 때까지 프로세스 A를 sleep시킨다.(block 상태)   자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다.(ready 상태)      exit() 시스템 콜  프로세스의 자발적 종료     마지막 statement 수행 후 exit() 시스템 콜을 통해 종료   프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌   프로세스의 비자발적 종료     부모 프로세스가 자식 프로세스를 강제 종료시킴            자식 프로세스가 한계치를 넘어서는 자원 요청시       자식에게 할당된 태스크가 더 이상 필요하지 않을 때           키보드로 kill, break등을 친 경우   부모가 종료하는 경우 부모 프로세스가 종료되기 전 자식 프로세스들이 먼저 종료된다.      프로세스 간 협력  독립적 프로세스 (Independent process)     프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.   협력 프로세스 (Cooperating process)     프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.   프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)  🔸 메시지를 전달하는 방법     message passing : 커널을 통해 메시지 전달   🔸 주소 공간을 공유하는 방법     shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음   물리적 메모리에 매핑할 때 일부 주소공간을 공유하도록 매핑한다.(사전에 시스템 콜을 통해 운영체제에게 보고되어야 한다)   🔸 thread     thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드들 간에는 주소 공간을 공유하기 때문에 협력이 가능하다.       Message Passing     사용자 프로그램끼리는 메시지를 주고받는 것이 불가능하기 때문에 운영체제 커널을 통해서 메시지를 주고받는다.   Message system     프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템   Direct Communication     통신하려는 프로세스의 이름을 명시적으로 표시해서 메시지를 주고받는 것   Indirect Communication     mailbox(또는 port)를 통해 메시지를 간접 전달하는 방식      출처     운영체제 - 이화여자대학교 KOCW 공개강의  ","categories": ["Operating System"],
        "tags": ["CS","OS","Process"],
        "url": "/operating%20system/OS-04-Process-Management/",
        "teaser": null
      },{
        "title": "Java) BOJ 10989. 수 정렬하기3",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/10989     제한       시간 제한 : 3 초   메모리 제한 : 512 MB     문제       N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.     입력       첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.     출력       첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.      👀 풀이       자바는 제한시간 3초에 메모리 제한은 512라 컬렉션을 쓸 수 없었다.(처음에 컬렉션 sort 써 봤는데 메모리 초과됨 ㅠ)   int 배열 메모리 계산해 보니까 합병정렬을 할 수 있을 정도가 되어서 합병정렬을 구현했다.   N의 최대값 10,000,000 * 4byte(int) = 40,000,000byte = 39,062kb = 약 38mb   합병정렬은 정렬할 배열과 같은 크기의 배열이 하나 더 필요하기 때문에 38 * 2 = 약 76mb   그래서 자바에서 기본적으로 잡아먹는 메모리를 더해도 통과할 수 있을거 같아서 합병정렬로 풀었는데 시간이 좀 아슬아슬했다.     결과       시간 : 2948 ms   메모리 : 383572 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10989","Sorting","Java"],
        "url": "/boj/boj10989-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1427. 소트인사이드",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1427     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.     입력       첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.     출력       첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.      👀 풀이       입력값을 모듈러와 나누기 연산을 하면서 한 자릿수씩 배열에 저장한 다음 Collections의 sort를 사용해 내림차순 정렬했다.     결과       시간 : 124 ms   메모리 : 14260 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1427","Sorting","Java"],
        "url": "/boj/boj1427-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1436. 영화감독 숌",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1436     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.   조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고,        피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.            하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.            종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, …. 과 같다.       따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.        일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.       숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.     입력       첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.     출력       첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.      👀 풀이       브루트포스로 666부터 하나씩 증가시켜가면서 N번째 수를 구하려 했으나 처음에 생각을 잘못 하는 바람에… 틀려서 구글링 참고해서 풀었다.   현재 수에 666이 포함되어 있으면 cnt를 증가시키고 cnt가 N과 같다면 현재 수를 리턴하고 그렇지 않다면 현재 수를 증가시키면서 또 666이 포함되어 있는지 확인한다.   이 때 수를 문자열로 바꿔서 666이 연속되어 있는지 확인해도 되서 처음엔 그렇게 확인하는 함수를 구현했는데 구글링 하니까 자바에는 contains 함수가 있어서 편하게 그걸 썼다.     결과       시간 : 320 ms   메모리 : 86524 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1436","BruteForce","Java"],
        "url": "/boj/boj1436-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 2108. 통계학",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2108     제한       시간 제한 : 2 초   메모리 제한 : 256 MB     문제            수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.       산술평균 : N개의 수들의 합을 N으로 나눈 값   중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값   최빈값 : N개의 수들 중 가장 많이 나타나는 값   범위 : N개의 수들 중 최댓값과 최솟값의 차이   N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.     입력       첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.     출력            첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.            둘째 줄에는 중앙값을 출력한다.            셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.            넷째 줄에는 범위를 출력한다.          👀 풀이       각 알고리즘 자체는 어렵지 않았는데 종류가 많아서 그런가 구현에 시간이 걸렸다.   중앙값 구하는 알고리즘을 더 손에 익히면 좋겠다.   중앙값은 최대힙과 최소힙을 사용해서 중앙값보다 더 큰 수는 최소힙에 저장하고 작은 수는 최대힙에 저장한 후        최대힙과 최소힙의 길이가 같은 경우 top 평균을 구하고 최대힙이 더 크면 최대힙의 top을 반환하고 최소힙이 더 크면 최소힙의 top을 반환하도록 했다.        최빈값은 배열 인덱스에 1:1로 매핑시켜서 빈도를 구하는 방식은 입력값의 범위가 커서 비효율적일 거 같아서 map을 사용했다.   입력값을 &lt; 입력값, 빈도 &gt; 로 map에 저장한 후 입력이 끝나면 map을 순회하면서 가장 높은 빈도수를 구한 다음        가장 높은 빈도수와 일치하는 키값이 하나라면 그걸 바로 리턴하고 여러 개라면 그 수를 모두 배열에 저장한 뒤 오름차순으로 정렬해서 두번째로 작은 수를 구해서 리턴했다.        범위는 입력 받으면서 최댓값과 최솟값을 구해서 두 값의 차를 출력하면 되는데 입력값이 음수도 들어오기 때문에 최댓값을 저장하는 변수의 초기값은 0이 아닌 Integer의 가장 작은 value로 설정하면 된다.     결과       시간 : 1028 ms   메모리 : 105020 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2108","Sorting","Java"],
        "url": "/boj/boj2108-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 2750. 수 정렬하기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2750     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.     입력       첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.     출력       첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.      👀 풀이       제한시간 1초에 N 최대값이 1,000이라 N^2 정렬 알고리즘으로 풀었다.(삽입정렬 사용)     결과       시간 : 188 ms   메모리 : 16936 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2750","Sorting","Java"],
        "url": "/boj/boj2750-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 2751. 수 정렬하기2",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2751     제한       시간 제한 : 2 초   메모리 제한 : 256 MB     문제       N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.     입력       첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.     출력       첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.      👀 풀이       제한시간 2초에 N 최대값이 백만이라 n log n 정렬 알고리즘을 써야 했는데 합병정렬을 쓰면 좋겠지만 구현하기 귀찮기도 하고… 자바에 구현되어 있는 sort 함수 사용법도 익힐겸 저걸 썼다.   처음에는 Arrays.sort를 썼는데 1700ms 가 나와서 시간복잡도를 알아보니까 평균 n log n이지만 최악의 경우에는 n^2이었다.   그래서 최악의 경우에도 n log n을 보장한다는 Collections.sort를 써 봤는데 1600ms 정도가 나와서 크게 시간 차이가 나지는 않았다.   합병정렬 기억을 되살릴 겸 한 번 구현해 보는 것이 좋을 거 같다.     결과       시간 : 1636 ms   메모리 : 171216 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2751","Sorting","Java"],
        "url": "/boj/boj2751-java/",
        "teaser": null
      },{
        "title": "컴퓨터구조) Instructions",
        "excerpt":"Instruction Set     프로세서에서 지원하는 명령어들의 집합   다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다.   현대 컴퓨터는 대부분 간단한 명령어셋(MIPS - RISK 방식)을 가지고 있다.   Instruction Set Architecture (ISA)     하드웨어와 낮은 레벨의 소프트웨어를 연결하는 인터페이스로 시스템 소프트웨어(운영체제)라 할 수 있다.   ISA가 같으면 같은 소프트웨어를 여러 개의 CPU에서 실행할 수 있다.   ABI     ISA와 운영체제 인터페이스를 합친 것   ABI만 같으면 같은 프로그램이 어디에서든 실행될 수 있다.   윈도우 운영체제를 쓰는 컴퓨터들은 어떤 컴퓨터를 쓰든 같은 프로그램을 실행할 수 있는 것      Design Principle  1. 정규화(규칙화)해서 간단하게 만들기     간단할수록 저비용으로 고성능을 만들기가 쉽다.   2. 메모리 용량이 작은 것이 빠르다     메모리 용량을 작은 레지스터를 최대한 활용하는 것이 성능 향상에 도움이 된다.   3. 공통 케이스는 빠르게 만들기     자주 사용하고 비중이 높은 연산은 빠르게 처리하도록 만드는 것이 성능 향상에 좋다.   4. 좋은 디자인을 위해 최대한 통일하기     명령어의 포맷 가짓수는 최대한 줄이고 통일하는 것이 좋다.   포맷이 다르면 디코딩 하는 데 복잡해지고 이것은 성능 하락으로 이어지기 때문이다.       Operations of the Computer Hardware  Arithmetic Operations (산술연산)     register 간 연산으로 RISK 프로세서 방식   add와 subtract, 더하기와 빼기로 이루어져 있으며 피연산자 3개가 필요하다.   add a, b, c      위와 같이 쓰면 b와 c를 더한 값을 a에 저장해라는 의미      Operands of the Computer Hardware  Register Operands     자주 사용하는 데이터에 빠르게 접근하기 위해서 레지스터를 사용한다.   32개의 bit로 이루어져 있으며 word라 부른다.   MIPS는 32개의 32bit 레지스터 파일을 가지고 있다.   Byte Addresses     대부분의 아키텍처는 byte 단위로 메모리를 관리한다.   word는 4bytes로 이루어져 있으며 이것은 하나의 명령어 단위가 된다.   레지스터에 있는 데이터를 메모리에 저장할 때 자리수가 큰 게 최하위 비트(LSB)에 오면 Big Endian, 자리수가 제일 작은 것이 최하위 비트에 오면 Little Endian이라 한다.   Memory Operands     메인 메모리는 자료의 집합을 이용한다.   산술 연산을 하기 위해서 메모리에 접근할 수 있는 명령어가 지정되어 있다.(Load/Store)   메모리는 8bit 크기의 주소로 이루어져 있다.   모든 명령어의 크기는 4bytes이기 때문에 메모리 주소 또한 4bytes 간격으로 나열되어 있다.   MIPS는 빅 엔디안 방식을 사용한다.   Registers vs. Memory     레지스터가 메모리에 접근하는 것 보다 훨씬 빠르다.   그래서 메모리 접근을 최대한 줄이고 레지스터에서 연산하는 것이 성능 향상에 좋은데 그렇다고 너무 레지스터만 써도 성능이 떨어지니까 자주 쓰지 않는 데이터는 메모리로 내려주는 것이 좋다.   한 주소는 32bit로 이루어져 있는데 레지스터 하나는 5bit 크기이기 때문에 메모리에 접근하는 것 보다는 레지스터를 최대한 사용하는 것이 한 번에 처리할 수 있는 코드가 많아진다.   Immediate Operands     피연산자 중에 하나가 상수일 때 사용하는 명령어   addi $s3 , $s3, 4 // 동작은 add와 같음 addi $s2, $s1, -1 // 뺄셈은 -1 사용      상수를 레지스터에서 만들어 쓰지 않으면 메모리에 접근해서 가져와야 하는데 이러면 느리다.   그래서 0 같이 자주 사용되는 상수는 메모리에 접근할 필요 없이 레지스터에서 바로 연산하면 훨씬 빠르다.   Constant Zero     $zero라고 표시하며 read only로만 사용할 수 있다.   주로 레지스터간 move연산을 할 때 사용하는데   add $t1, $s1, $zero      move와 같은 명령어를 따로 만들어서 사용하는 것 보다 add연산을 하는데 나머지 연산자를 0으로 만들어서 사용하면 move/copy와 같은 효과를 낼 수 있어서 명령어를 따로 만들지 않고 이렇게 쓴다.   왜냐면 명령어 셋은 최대한 간단한 것이 성능 향상에 좋기 때문이다.   어떤 특정 연산 처리만을 위한 명령어를 많이 만들어 쓰다 보면 구현 자체도 쉽지 않지만 구현해도 그 명령어를 처리하는 시간이 다른 쉬운 명령어보다 늘어나는데, 그 늘어난 시간은 다른 간단한 명령어의 실행 시간에도 영향을 미쳐서 다 같이 느려진다.      Logical Operations  시프트 연산자     왼쪽 시프트            시프트하면서 생기는 빈 비트는 0으로 채운다.       원래 값에 2^i 을 곱한 효과(음수, 양수 둘 다 적용)           오른쪽 시프트            시프트하면서 생기는 빈 비트는 0으로 채운다.       원래 값을 2^i 만큼 나눈 효과(양수에만 적용됨)           비트 연산자     and, or, nor 연산자를 사용한다.   MIPS에는 NOT 연산자가 없기 때문에 대신 nor 연산자(a도 아니고 b도 아니다)를 사용해서 NOT 연산자와 같은 효과를 낸다.      Instructinos for Making Decisions  Conditional Operations     어떤 조건이 true인 경우에 이름지어져 있는 명령어로 분기를 나누고 false라면 다음 명령어를 계속 실행하는 것 (if ~ else문)   beq rs, rt, L1 // rs와 rt가 같으면 L1에 있는 명령어 실행 bne rs, rt, L2 // rs와 rt가 같지 않으면 L1에 있는 명령어 실행 j L1 // 무조건 L1으로 Jump하는 것     어떤 수들의 대소관계 비교도 전용 명령어를 따로 만들지 않고 beq를 비롯한 여러 명령어들을 조합해서 쓰는 것이 성능 면에서 더 좋기 때문에 조합해서 쓴다.      명령 실행 단계  1) caller가 callee에게 파라미터를 넘긴다. 2) caller가 callee에게 제어권을 넘긴다.(실행) 3) callee가 스택에 메모리를 할당한다. 4) callee가 태스크를 수행한다. 5) callee가 caller가 접근할 수 있는 곳에 결과를 둔다. 6) callee가 caller에게 제어권을 넘긴다.        Procedure 실행에는 Leaf와 Non-Leaf 방식이 있는데 Leaf는 자기 자신을 포함한 어떤 함수도 호출하지 않는 것이고 Non-Leaf는 자기 자신을 포함한 함수를 호출하는 것이다.   프로그래밍 할 때 흔히 작성하는 값 하나를 리턴하고 끝나는 함수는 Leaf 방식이고 재귀 함수와 같은 형태는 Non-Leaf로 이루어진다.   메모리 영역     Text : 프로그램 코드(명령어)가 있는 영역   Static data : 전역 변수가 있는 영역   Dynamic data : heap 영역이라고도 하며 동적으로 할당된 메모리가 있는 영역. 메모리 주소를 가리키는 포인터는 아래에서 위로 이동한다.   Stack : 함수가 호출되면 생기는 지역 변수가 있는 영역. 메모리 주소를 가리키는 포인터는 위에서 아래로 이동한다.      코드가 실행되는 과정  1) 프로그래밍 언어로 프로그램을 작성한다. 2) 컴파일러가 어셈블리어로 번역한다. 3) 어셈블러가 기계어로 번역한다. 4) 기계어로 번역하면서 내가 쓴 코드를 이용해서 만든 기계어 오브젝트와 라이브러리에서 가져오는 코드로 만든 오브젝트가 생기는데 링커가 두 오브젝트 코드들을 합쳐서 실행파일로 만든다. 5) 로더가 실행파일을 메모리에 올려서 실행상태로 만든다.      알고리즘과 수행속도     명령어 수와 CPI가 낮은 것이 무조건 성능이 좋은 것은 아니다. 성능에 영향을 미치는 것은 여러가지 요인이 있다.   컴파일러 최적화는 알고리즘에 영향을 많이 받는다.   그렇기 때문에 뭐니뭐니해도 알고리즘이 효율적이어야 성능이 좋아진다.      배열과 포인터     둘 다 배열을 다룰 때 사용할 수 있지만 배열 인덱스에 접근하려면 내부적으로 인덱스의 주소값을 계산하는 과정이 필요하다. (시작 주소에서부터 몇 칸 떨어져 있는지…)   하지만 포인터는 그런 연산이 필요없이 그냥 4씩 더해주면서 다음 메모리 주소로 이동하면 된다.   그렇지만… 최신 컴파일러는 내가 직접 포인터 연산하는 코드를 쓰는 것과 배열 인덱스로 접근하는 코드가 같은 성능을 낼 수 있도록 최적화를 다 해 준다.   그래서 같은 동작을 수행하는 코드라면 배열 인덱스를 사용하는 코드를 써도 무방하며 포인터를 사용한 코드보다 이해하기도 더 쉽다. 포인터에 비해 버그를 일으키는 코드를 작성할 확률도 줄어드니까 그냥 배열을 쓰자.      x86 Instructions     MIPS와는 명령어 셋이 다르며 설계 면에서도 차이가 있다.   MIPS에 비해 다소 복잡하게 설계되어 있어 고성능으로 만들기 어려운 CISK 아키텍처다.   그래서 고성능을 내기 위해 하드웨어가 내부적으로 복잡한 원래 명령어를 간단한 명령어들로 쪼갠 다음에 실행하는 방식을 쓴다.(결국 RISC와 같은 매커니즘으로 실행되게 된다고 볼 수 있다)   이렇게 보면 인텔은 진작에 망했어야 할 거 같지만 시장 점유율을 성공적으로 높이면서 자리잡았기 때문에 인텔 프로세서에서 실행되는 프로그램들이 많다보니 여전히 높은 점유율을 차지하며 지금까지 오고 있는 것이다.      결론     명령어 여러 개를 한꺼번에 처리하면 효율적이겠지만 그만큼 하드웨어 게이트(로직) 수가 많아지면서 실행 속도가 느려진다. 그리고 다른 명령어도 같이 느려진다.   그래서 간단한 명령어를 여러개 조합해서 쓰는 것이 효율적이다. (RISK Processor 철학)   어셈블리 코드를 쓰면 기계어와 가까워서 좋은 성능을 낼 수 있지만 최신 컴파일러는 C 언어와 같은 고급 언어로 쓴 코드도 어셈블리어와 비슷한 성능을 낼 수 있도록 최적화를 다 해 주기 때문에 그냥 고급 언어를 쓰는 것이 생산성이 더 높고 좋다. (어셈블리어는 생산성이 낮다)      출처     컴퓨터구조 - 영남대학교 KOCW 공개강의  ","categories": ["Computer Science"],
        "tags": ["CS","Instruction"],
        "url": "/computer%20science/computer-architecture-03/",
        "teaser": null
      },{
        "title": "JSP) 커넥션 풀",
        "excerpt":"👀 커넥션 풀 (Connection Pool)이란?     JDBC를 연동하기 위해서는 드라이버를 로드하고 JDBC URL로 접속하여 Connection 객체를 얻어오는 단계를 거쳐야 한다.   커넥션 풀은 데이터베이스와 연결된 Connection 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 Connection 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다.   사용자가 웹 사이트에 Connection 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다.   하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.   커넥션풀의 연결전략  1) DB연결이 필요한 JSP 페이지 (service()) 실행시 DB연결 요청당 1개씩 할당  2) 커넥션의 개수를 제한  3) 커넥션의 사용을 다 한 경우 (객체관리자가 자원을 모두 다 쓰면) 자원 회수    실제 동작 구현     웹브라우저 요청    할당될 커넥션 객체가 있는지 없는지 체크     2-1. 있을 때      3. 커넥션 객체 할당 (pool에 저장된 정보 전달)      4. 객체 사용      5. 객체 사용 반환 (자원해제 X, pool에 저장)    2-2. 없을 때      1. 커넥션 객체를 기다림 (커넥션이 반환될 때 까지)      2. 임시 커넥션 객체 생성 -&gt; 사용 -&gt; 반환 (사라짐)      JNDI (Java Namming and Directory Interface)     명명 서비스 및 디렉토리 서비스에 접근하기 위한 API. 즉 특정 자원에 접근하기 위한 이름으로 사용된다.   아파치 홈페이지에 가서 collections, DBCP, Pool 다운받기            압축 풀어서 commons-collections4-4.4.jar 처럼 옆에 잡다한 이름 안 붙은걸로 복사해서 WEB-INF/lib에 붙여넣기           API를 설치했으면 xml 파일을 만들어야 한다.   XML     태그 형태로 데이터를 저장하는 페이지로 HTML 태그 형태는 아니지만 지정된 태그를 통해서 데이터를 저장하고 사용한다.   src/main/webapp/META-INF에 content.xml 파일을 생성하고 서버에 공유할 리소스를 정의한다.   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  &lt;Context&gt;   &lt;Resource      name=\"jdbc/mysql\"      auth=\"Container\"      type=\"javax.sql.DataSource\"      username=\"root\"      password=\"1234\"      driverClassName=\"com.mysql.cj.jdbc.Driver\"      url=\"jdbc:mysql://localhost:3306/jspdb\"      maxActive=\"500\"   /&gt; &lt;/Context&gt;      이렇게 작성하면 되는데 각 코드 라인의 의미는 다음과 같다.   &lt;Context&gt;   &lt;!-- Context : 프로젝트 --&gt;   &lt;Resource      name=\"디비에 접근하기 위한 이름\"      auth=\"컨테이너 자원 관리자 설정 - Application or Container\"      type=\"리소스를 사용할 때 실제로 사용되는 클래스 타입\"      username=\"디비 아이디\"      password=\"디비 비밀번호\"      driverClassName=\"드라이버 주소\"      url=\"디비 연결 주소\"      maxActive=\"커넥션 회수 대기시간\"   /&gt; &lt;/Context&gt;      xml 파일에서도 주석문 사용이 가능하지만 사용하지 않는 것이 좋다.   왜냐면 주석 처리한 코드가 실행되는 경우가 있는데 이 때 에러가 나도 컴파일 에러가 표시되지 않고 단순 서버 에러라고만 나오기 때문에 원인 찾기가 매우매우 힘들다.   xml 파일까지 만들었다면 MemberDAO 클래스를 커넥션 풀을 사용하도록 수정해야 한다.      MemberDAO 클래스를 커넥션 풀을 쓰도록 수정하기     getConnect() 함수를 아래와 같이 수정한다.   private Connection getConnect() {     try      {         // 커넥션풀을 사용한 디비연결                  // 업캐스팅이라 인터페이스인데 객체 생성 가능         // 프로젝트(CTX)정보 초기화         Context initCTX = new InitialContext();          //\tContext envCTX = (Context) initCTX.lookup(\"java:comp/env\"); //\t\t\t\tenvCTX.lookup(\"jdbc/mysql\"); // 이거랑 아래 한 문장이랑 같은 의미         // java:comp/env/ 여기까지는 항상 고정 &amp; 뒤에 xml 파일의 name에 쓴 내용 넣기         // type=\"javax.sql.DataSource\" 에서 정해준 데이터타입으로 다운캐스팅 해줘야 함         DataSource ds = (DataSource) initCTX.lookup(\"java:comp/env/jdbc/mysql\");                  // ds에 연결정보가 다 들어있으니까 getConnection만 실행         con = ds.getConnection();         System.out.println(\"DAO : 커넥션풀을 사용한 디비연결 성공\");         System.out.println(\"DAO : \" + con);     }      catch (NamingException e)      {         e.printStackTrace();     }      catch (SQLException e)      {         e.printStackTrace();     }          return con; }      이후 사용하는 것은 기존과 같이 사용하면 된다.  ","categories": ["JSP"],
        "tags": ["JSP","ConnectionPool"],
        "url": "/jsp/JSP-connection-pool/",
        "teaser": null
      },{
        "title": "JSP) JSTL",
        "excerpt":"👀 JSTL(JSP Standard Tag Library)이란?     자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태        태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.       CORE 라이브러리 : 기본적인 동작 제공            변수 선언, 조건문, 반복문 코드를 처리하는 태그       페이지 이동처리 태그 (태그만 사용해서 반복문 처리를 할 수 있음)           Formatting 라이브러리            데이터 국제화 처리 (다국어) 태그       형식화 (날짜, 숫자, 시간) 태그           DB 라이브러리 : sql구문처리 동작            CRUD 동작 수행 태그           XML 라이브러리            XML 문서 읽고 처리하는 태그           다운로드 및 설치     톰캣 홈페이지에서 taglibs 메뉴에 들어가서 하단에   taglibs-standard-jstlel-1.2.5.jar taglibs-standard-spec-1.2.5.jar taglibs-standard-impl-1.2.5.jar      세 파일을 다운받는다.   다운받은 파일들을 WEB-INF/lib에 복붙하면 설치 완료      CORE 라이브러리  변수 선언 및 사용   &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;      먼저 페이지 상단에 라이브러리 인클루드 해 주어야 한다.   prefix는 태그의 접두사를 지정해 주는 것으로 prefix에 지정한 문자를 쓰고 :을 쓰면 태그 예약어들을 사용할 수 있다.     &lt;%-- &lt;c:set var=\"변수명\" value=\"값\"/&gt; --%&gt;   &lt;c:set var=\"num3\" value=\"300\"/&gt;   &lt;c:set var=\"num4\" value=\"400\"/&gt;      &lt;!-- 변수값 출력할 때엔 el 표현식 사용 --&gt;   &lt;c:out value=\"${num3 }\"/&gt;   &lt;c:out value=\"${num4 }\"/&gt;   &lt;hr&gt;      ${num3 } + ${num4 } = ${num3 + num4 }      태그 속에서 변수를 선언하고 값을 넣어줄 수 있다.     &lt;c:set var=\"name\" value=\"S22\" scope=\"request\"/&gt;      스크립틀릿을 이용해서 자바 코드로 변수를 선언하면 지역변수로 인식되어서 선언한 페이지에서만 쓸 수 있는데 JSTL 태그를 사용하면 변수의 영역도 지정해 줄 수 있어서 자바 코드를 사용하는 것에 비해 훨씬 활용도를 높일 수 있다.   scope : page, request, session, application 네 영역 모두 설정해 줄 수 있다. scope를 설정하지 않으면 기본값은 page라서 선언한 페이지에서만 쓸 수 있다.   출력   &lt;c:out value=\"안녕하세요 JSTL입니다.\"&gt;&lt;/c:out&gt;      만약 null값을 출력하는 경우 빈공백으로 처리된다. (JSP 표현식은 컴파일 에러남)   컴파일 에러난 페이지를 보여주는 것 보다는 null값을 출력하는게 사용자 신뢰도에는 더 좋다.     &lt; abc&gt;태그는 abc입니다.&lt;hr&gt;  &amp;lt;abc&gt;태그는 abc입니다.&lt;hr&gt;  &lt;c:out value=\"&lt;abc&gt;태그는 abc입니다.\"/&gt;      만약 태그 자체를 출력하고 싶다면 위 세 가지 방법으로 출력이 가능하다.   조건문  if   &lt;!-- jstl 변수 2개 생성(속성) --&gt; &lt;c:set var=\"name\" value=\"itwill\"/&gt; &lt;c:set var=\"tel\" value=\"010-1234-5678\"/&gt;  &lt;!-- 사용자의 이름이 \"itwill\"인지 체크 --&gt; &lt;c:if test=\"${name == 'itwill' }\"&gt;&lt;!-- 표현식 안에서는 작은 따옴표를 써야 함(큰 따옴표 쓰면 밖에 따옴표랑 반응함) --&gt;   사용자 이름 : ${name }&lt;br&gt; &lt;/c:if&gt;  &lt;c:if test=\"${100 lt 200 }\"&gt;&lt;!-- lt : 비교연산자(&lt;)와 같은 역할을 하는 예약어 --&gt;   200이 더 크다.&lt;br&gt; &lt;/c:if&gt;      HTML 태그처럼 태그 사이에 출력하고 싶은 문구를 작성할 수 있다.     switch ~case   &lt;c:choose&gt;   &lt;c:when test=\"${param.num1 le param.num2 }\"&gt;     num1! &lt;br&gt;   &lt;/c:when&gt;   &lt;c:when test=\"${param.num1 lt param.num2 }\"&gt;     num2! &lt;br&gt;   &lt;/c:when&gt;   &lt;c:otherwise&gt;     그 외 나머지&lt;br&gt;   &lt;/c:otherwise&gt; &lt;/c:choose&gt;      choose 태그를 사용해서 switch ~case문을 작성할 수 있다.     반복문   &lt;c:forEach var=\"i\" begin=\"1\" end=\"10\" step=\"1\"&gt;   ${i } &lt;/c:forEach&gt;      위와 같이 for문에서 변수를 선언하고 조건식, 증감식을 설정해 줄 수 있는데 저렇게는 잘 안 쓴다.(단순 순회할 때 for문에서 귀찮은 것들을 덜어내고 쓰는 것이 foreach니까…)     &lt;%   int arr[] = new int[3];   for (int i = 0; i &lt; arr.length; i++)   {     arr[i] = i;   } %&gt; &lt;!-- 이 형태를 많이 쓴다.(items 자리엔 jsp 표현식보다는 el 표현식을 쓴다.) --&gt; &lt;c:forEach var=\"test\" items=\"&lt;%=arr %&gt;\"&gt;   ${test }  &lt;/c:forEach&gt;      위와 같은 형태로 배열을 순회할 때 많이 사용한다.     문자열 Parsing   &lt;c:forTokens var=\"abc\" items=\"a,b,c,d,e,f,g,h\" delims=\",\"&gt;   ${abc }  &lt;/c:forTokens&gt;  &lt;hr&gt; &lt;c:set var=\"data\" value=\"자바 디비 웹 JSP\"/&gt;  &lt;c:forTokens var=\"name\" items=\"${data }\" delims=\" \"&gt;   ${name }&lt;br&gt; &lt;/c:forTokens&gt;      delims에 넣은 인자값을 기준으로 문자열을 자를 수 있다.      Formatting 라이브러리   &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%&gt; &lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\"%&gt;      Formatting 라이브러리는 일반적으로 fmt 접두사를 쓴다.   날짜 출력하기   &lt;c:set var=\"today\" value=\"&lt;%=new Date() %&gt;\"/&gt;  &lt;fmt:formatDate value=\"${today }\"/&gt;&lt;br&gt;  &lt;!-- time: 시간정보 --&gt; &lt;fmt:formatDate value=\"${today }\" type=\"time\"/&gt;&lt;br&gt;  &lt;!-- both: 날짜 &amp; 시간정보 --&gt; &lt;fmt:formatDate value=\"${today }\" type=\"both\"/&gt;&lt;br&gt;  &lt;hr&gt;  &lt;fmt:formatDate value=\"${today }\" dateStyle=\"full\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"long\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"medium\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"short\"/&gt;&lt;br&gt;  &lt;hr&gt;  &lt;fmt:formatDate value=\"${today }\" type=\"both\" dateStyle=\"full\" timeStyle=\"full\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" type=\"time\" timeStyle=\"full\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" type=\"time\" timeStyle=\"long\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" type=\"time\" timeStyle=\"medium\"/&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" type=\"time\" timeStyle=\"short\"/&gt;&lt;br&gt;  &lt;hr&gt; &lt;h3&gt;2022/2/25(금) (오전) 11:50:00 형식으로 표현하기&lt;/h3&gt;&lt;br&gt; &lt;fmt:formatDate value=\"${today }\" pattern=\"yyyy/MM/dd(E)\"/&gt; &lt;fmt:formatDate value=\"${today }\" type=\"time\" pattern=\"(a)hh:mm:ss\"/&gt;      dateStyle에 넣은 값만큼 출력되는 날짜 정보의 갯수를 조절할 수 있다.   통화 출력하기   &lt;c:set var=\"today\" value=\"&lt;%=new Date() %&gt;\"/&gt; ${today } &lt;hr&gt; &lt;fmt:setLocale value=\"ko_kr\"/&gt;&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"full\"/&gt;&lt;br&gt;&lt;!-- 년 월 일 요일 표시 --&gt; &lt;fmt:formatNumber value=\"1000000000000\" type=\"currency\"/&gt;&lt;br&gt;&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;  &lt;hr&gt;  &lt;fmt:setLocale value=\"en_us\"/&gt;&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"full\"/&gt;&lt;br&gt;&lt;!-- 년 월 일 요일 표시 --&gt; &lt;fmt:formatNumber value=\"1000000000000\" type=\"currency\"/&gt;&lt;br&gt;&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;  &lt;hr&gt; &lt;fmt:setLocale value=\"zh_cn\"/&gt;&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"full\"/&gt;&lt;br&gt;&lt;!-- 년 월 일 요일 표시 --&gt; &lt;fmt:formatNumber value=\"1000000000000\" type=\"currency\"/&gt;&lt;br&gt;&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;  &lt;hr&gt; &lt;fmt:setLocale value=\"ja_jp\"/&gt;&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt; &lt;fmt:formatDate value=\"${today }\" dateStyle=\"full\"/&gt;&lt;br&gt;&lt;!-- 년 월 일 요일 표시 --&gt; &lt;fmt:formatNumber value=\"1000000000000\" type=\"currency\"/&gt;&lt;br&gt;&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;      숫자 출력   &lt;fmt:formatNumber value=\"100000000\" groupingUsed=\"false\"/&gt;&lt;br&gt; &lt;fmt:formatNumber value=\"100000000\" groupingUsed=\"true\"/&gt;&lt;br&gt;  &lt;hr&gt;  &lt;h2&gt;소수점 자리 표현&lt;/h2&gt; &lt;fmt:formatNumber value=\"${2.12345676 }\" pattern=\"#.####\"/&gt;&lt;br&gt;  &lt;!-- 0은 .뒤에 0을 채워줌 --&gt; &lt;fmt:formatNumber value=\"20.0\" pattern=\"##.00\"/&gt;&lt;br&gt;  &lt;fmt:formatNumber value=\"0.5\" type=\"percent\"/&gt;&lt;br&gt;  &lt;!-- 통화 심볼도 바꿀 수 있다 --&gt; &lt;fmt:formatNumber value=\"10000000\" type=\"currency\" currencySymbol=\"@\"/&gt;&lt;br&gt;  ","categories": ["JSP"],
        "tags": ["JSP","JSTL"],
        "url": "/jsp/JSP-jstl/",
        "teaser": null
      },{
        "title": "JSP) 서블릿",
        "excerpt":"👀 서블릿(Servlet)이란?     자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 JSP 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다.   즉 JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class) 이런 과정을 거치게 된다.   서블릿 작성 규칙  1) javax.servlet.Servlet 인터페이스 구현  2) 1)의 구현이 어려운 경우 javax.servlet.http.HttpServlet 클래스 상속(일반적으로 사용)  3) doGet()/ doPost() 생성(오버라이딩), HttpServletRequest/ HttpServletResponse 객체 구현  4) IOException/ ServletException을 처리해야 함  5) web.xml 파일을 통해서 주소 매핑 (어노테이션 처리)    서블릿 실행 구조         서블릿 클래스 만들기   import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.itwillbs.test.Student;  // 서블릿 - jsp코드 + java코드를 함께 수행할 수 있는 파일 // 서블릿 클래스 상속받으면 서블릿이 됨  // http://localhost:8090/JSP6/ex1 @WebServlet(\"/ex1\") public class ExServlet extends HttpServlet  {     // 폼태그에서 get method를 썼을 때 호출되는 함수     @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         System.out.println(\"doGet() 호출\"); \t\t         // 응답정보의 내용의 형태는 html문서로 표현하겠다.         response.setContentType(\"text/html; charset=UTF-8\");          // response를 통해서 출력가능한 통로를 생성하겠다. //\t    PrintWriter out = response.getWriter(); // //\t    // 서블릿을 이용한 JSP 페이지 표현 - 사용하진 않을 것임 //\t    out.print(\"&lt;html&gt;\"); //\t    out.print(\"&lt;head&gt;\"); //\t    out.print(\"&lt;/head&gt;\"); //\t    out.print(\"&lt;body&gt;\"); //\t    out.print(\"&lt;h1&gt; 서블릿을 활용한 JSP페이지 만들기&lt;/h1&gt;\"); //\t    out.print(\"&lt;/body&gt;\"); //\t    out.print(\"&lt;/html&gt;\"); //\t    out.close();          // 포워딩 전 request 영역에 정보를 저장         request.setAttribute(\"itwill\", \"busan\");          // 객체정보를 전달         Student kim = new Student();         kim.setName(\"김학생\");         kim.setKor(100);         kim.setEng(90);         kim.setMath(76);         request.setAttribute(\"Student\", kim);          Student user = new Student();         user.setName(\"사용자\");         user.setKor(45);         user.setEng(70);         user.setMath(98);          ArrayList&lt;Student&gt; memberList = new ArrayList&lt;Student&gt;();         memberList.add(kim);         memberList.add(user);          request.setAttribute(\"memberList\", memberList);          // 서블릿 코드를 사용한 화면 출력 X         // =&gt; 포워딩을 사용한 화면 출력 O          // 자바 코드를 이용한 포워딩 방식 - 외우기 //\t    &lt;jsp:forward/&gt; 사용불가 - JSP 페이지가 아닌 자바파일이라서 못 씀         // 이동할 경로 설정         RequestDispatcher dis = request.getRequestDispatcher(\"/jstl/coreSet2.jsp\");          dis.forward(request, response); \t} // doGet() }      이렇게 만들면 되는데 사용할 함수들을 다 오버라이딩 하기 때문에 일일이 작성하지 않아도 된다.   HttpServlet을 상속받고 나면 이클립스가 구현해야 하는 함수들을 다 만들어 준다.   우리는 형태가 만들어진 함수의 내부만 채우면 된다.      JSP 페이지에서 서블릿을 활용한 정보 전달   &lt;!-- 서블릿에서 저장된 정보(request.setAttribute(\"itwill\", \"busan\");) 출력 --&gt;   itwill : &lt;%=request.getAttribute(\"itwill\") %&gt;&lt;br&gt;   itwill : ${itwill }&lt;br&gt;   itwill : ${requestScope.itwill }&lt;br&gt;    &lt;!-- 앞으로는 보안을 위해 주소에 정보가 처리되는 jsp 페이지를 나타내지 않을 것임   \t\t자바 서블릿 코드를 이용해 jsp 페이지 작성(가상주소 생성) --&gt;      자바 서블릿 코드를 이용해 jsp 페이지를 작성할 것이기 때문에 서블릿 클래스를 실행하면 jsp 페이지로 연결되어 액션을 수행하지만 주소창에는 jsp 페이지가 나타나지 않고 어노테이션 @WebServlet(\"/ex1\")에 쓴 /ex1가 맨 뒤에 붙어 주소창에는 http://localhost:8090/JSP6/ex1 와 같은 형태로 나타나게 된다.     ${Student}&lt;br&gt; 학생 이름 : ${Student.getName() }&lt;br&gt; 국어 : ${Student.getKor() }&lt;br&gt; 영어 : ${Student.getEng() }&lt;br&gt; 수학 : ${Student.getMath() }&lt;br&gt;    &lt;%   Student kim = (Student) request.getAttribute(\"Student\"); %&gt; &lt;%=kim.getName() %&gt;&lt;br&gt; ${Student.name }&lt;br&gt;&lt;!-- el 표현식에서는 내부적으로 get/set 메서드를 자동으로 구현해 사용함. 그래서 변수명으로도 접근가능 --&gt;    &lt;!-- 좀 더 간단하게 쓰기 --&gt; &lt;c:set var=\"kim\" value=\"${Student }\"/&gt;    ${kim.name }    &lt;hr&gt;    ${requestScope.memberList }&lt;br&gt; ${requestScope.memberList[0].name }      그리고 아까 서블릿에서 함께 저장했던 클래스 객체도 위와 같이 el 표현식을 사용해서 출력할 수 있다.  ","categories": ["JSP"],
        "tags": ["JSP","Servlet"],
        "url": "/jsp/JSP-servlet/",
        "teaser": null
      },{
        "title": "Java) BOJ 10814. 나이순 정렬",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/10814     제한       시간 제한 : 2 초   메모리 제한 : 256 MB     문제       알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.      길이가 짧은 것부터   길이가 같으면 사전 순으로     입력       첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.     출력       조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.      👀 풀이       Collections.sort와 Comparator 람다식을 이용해 구현했다.   마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.     결과       시간 : 392 ms   메모리 : 23208 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10814","Sorting","Java"],
        "url": "/boj/boj10814-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 11650. 좌표 정렬하기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/11650     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제       2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.     출력       첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.      👀 풀이       처음엔 Pair 클래스에서 Comparable을 구현해서 썼는데 리턴값을 잘못 설정했는지 계속 7%에서 틀렸다 ㅠ.ㅠ   그래서 구글링해서 Comparator 람다식으로 바꾸고 통과함     결과       시간 : 800 ms   메모리 : 51232 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No11650","Sorting","Java"],
        "url": "/boj/boj11650-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 11651. 좌표 정렬하기2",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/11651     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제       2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.     출력       첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.      👀 풀이       11650번에서 썼던 Comparator 함수에서 기준값을 x에서 y로만 바꿔주었다.     결과       시간 : 860 ms   메모리 : 49896 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No11651","Sorting","Java"],
        "url": "/boj/boj11651-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 1181. 단어 정렬",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1181     제한       시간 제한 : 2 초   메모리 제한 : 256 MB     문제       알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.      길이가 짧은 것부터   길이가 같으면 사전 순으로     입력       첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.     출력       조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.      👀 풀이       Collections.sort와 Comparator 람다식을 이용해 구현했다.   마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.     결과       시간 : 392 ms   메모리 : 23208 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1181","Sorting","Java"],
        "url": "/boj/boj1181-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 18870. 좌표 압축",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/18870     제한       시간 제한 : 2 초   메모리 제한 : 512 MB     문제            수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.            Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.            X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자.         입력       첫째 줄에 N이 주어진다.   둘째 줄에는 공백 한 칸으로 구분된 X1, X2, …, XN이 주어진다.   1 ≤ N ≤ 1,000,000   -109 ≤ Xi ≤ 109     출력       첫째 줄에 X’1, X’2, …, X’N을 공백 한 칸으로 구분해서 출력한다.      👀 풀이       입력받은 수 배열에서 i번째 수보다 작은 수의 갯수를 세어서 i번째에 출력하면 되는데 i번째 수보다 작은 수가 몇 개인지 알려면 오름차순으로 정렬을 해 봐야 한다.   오름차순으로 정렬을 해 보면 i번째 수의 앞에 있는 수들은 다 작은 수들이니까 배열을 순회하면서 그 수가 몇 개인지 세면 i번째 수를 압축한 수가 된다.        정답 출력 형식을 보면 입력된 숫자의 순서대로 압축한 수를 출력해야 하는데 입력 배열을 정렬해 버리면 순서가 흐트러져서 정답 형식으로 출력할 수 없다. 그래서 입력 배열과 같은 임시 배열을 만들어 정렬한다.        그런데 최대 백만개가 입력으로 주어지는데 2중 for문을 통해 하나씩 비교하는 O(n^2) 알고리즘을 사용하면 시간초과를 받을 것이기 때문에 정렬 알고리즘은 O(n log n) 시간복잡도를 가지는 것을 쓰는 것이 좋다.   그리고 입력으로 중복된 수가 들어오는데 예제의 답을 보면 중복된 수는 카운트하지 않는다.   즉 1, 1, 2 일 때 2보다 작은 수인 1이 2개 있는데 이럴 경우 답은 0, 0, 1이 되어야 한다. 2보다 작은 수는 1개가 되어야 한다.        그래서 오름차순으로 정렬하고 난 후 중복되는 숫자들은 제거해 주어야 한다. 중복 숫자를 제거하지 않으면 i번째 수보다 작은 수를 셀 때 오차가 생길 것이다.        중복된 숫자들을 제거하고 나면 &lt;i번째 숫자, i번째 숫자보다 작은 숫자의 갯수&gt; pair를 저장하는 map을 만들어서 각 원소를 삽입해준다.        그 다음 마지막으로 입력 원본 배열을 순회하면서 map에서 i번째 원소를 key로 가지는 value를 찾아 출력하면 된다.        시간제한이 2초인데 2788ms로 통과된 거 보면 자바는 느려서 시간을 좀 더 주는 것 같다.     결과       시간 : 2788 ms   메모리 : 254876 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No18870","Sorting","Java"],
        "url": "/boj/boj18870-java/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) 데이터 통신",
        "excerpt":"전송 모드  병렬 전송(Parallel Transfer)     여러 전송라인을 통해 여러 비트들을 동시에 전송   두 장치들간의 거리가 짧은 경우에 일반적으로 사용            예) PC에서 프린터로 전송하는 것       예) 컴퓨터와 주변 장치들간의 연결           긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.   직렬 전송(Serial Transfer)     하나의 전송라인을 사용하여 하나씩 모든 비트를 보낸다.   긴 거리를 전송할 때 병렬 전송에 비해 적은 비용이 들고 신뢰성 증가   하지만 비트를 하나씩 보내는 만큼 병렬 전송에 비해 느리다.   비동기식 전송     한 번에 한 문자씩 보내거나 받는 방식   문자는 7~8 비트로 구성되며, 문자의 앞에 시작비트(Start bit)를, 끝에는 정지비트(Stop bit)를 첨가해서 보냄   송신측과 수신측 사이에 동기를 맞추기 위한 클럭 신호를 사용하지 않음   시작비트는 수신측에 문자에 해당하는 비트가 따라올 것이라는 것을 알려주는 역할   문자 비트들을 모두 수신하면 정지비트가 뒤따른다.   키보드와 프린터 같이 느린 장치들을 위해 사용되며 높은 오버헤드를 가진다.   동기식 전송     정해진 수 만큼의 문자들을 하나의 그룹(프레임)으로 만들어서 일시에 전송하는 방법   일반적으로 비동기식 전송에 비해서 더 빠르다.   송신측과 수신측이 하나의 기준 클럭으로 동기신호를 맞추어 동작   동기화를 위한 클럭라인이 필요하다.   일반적으로 많이 사용하는 방식   바이트기반 전송(Byte-Oriented Transmission)     각 프레임을 바이트(문자)의 연속으로 간주하는 방식   STX(Start of Text), ETX(End of Text), DLE(Data-Link Escape)로 프레임의 시작과 끝을 구분   예) BISYNC, PPP, DDCMP 등   비트기반 전송(Bit-Oriented Transmission)     일반적으로 많이 사용하는 방식   각 프레임을 비트의 연속으로 간주하는 방식   프레임의 시작과 끝을 알리기 위해 플래그(Flag)라고 하는 특수한 비트 패턴, “01111110”을 사용   예) 인터넷에서의 이더넷(Ethernet)과 HDLC(High-level Data Link Control) 등     비트 스터핑(Bit Stuffing)     비트기반 전송에서 프레임의 시작과 끝이 아닌 데이터 필드에 프레임의 시작과 끝을 알리는 플래그가 포함될 수 있다. 그러면 전송이 아직 끝나지 않았는데 수신측에서는 전송이 끝난 것으로 간주하고 데이터 받기를 중단할 것이다.   그래서 이걸 해결하기 위해 사용하는 기법이 비트 스터핑 기법이다.   비트 스터핑 방법     송신측 : 보낼 프레임의 데이터 필드에서 연속된 5개의 1을 발견하면 다섯 번째 1 뒤에 0을 추가함. 이렇게 하면 시작과 끝 부분 외에는 1이 연속해서 6개 위치하는 경우가 없어진다.   수신측 : 연속되는 5개의 1이 수신되고 나서 0이 수신되면 이 0은 비트 스터핑 된 것이라 간주하고 제거함      단방향, 반이중, 전이중  단방향(Simplex)     한 방향으로만 신호 전송이 가능한 형태   예) 공항 모니터, 프린터, TV 방송   반이중(Half duplex)     양쪽 방향에서 보내고 받을 수 있지만 교대로 전송만 가능   예) 무전기   전이중(Full duplex)     양쪽 호스트가 동시에 데이터전송 가능   예) 인터넷      교환 기술     N개의 통신 장비를 각각 직접 연결하면 필요한 연결선의 갯수가 너무 많아진다.   이것에 대한 해결방안으로 각각의 장비들은 통신망에 연결한 뒤 통신망을 이용해 서로 데이터를 주고 받는데 이걸 좀 더 효과적으로 운영하기 위해 교환 기술(Switching Technology)을 사용한다.   회선 교환(Circuit Switching)     공중 전화 망에서 사용   데이터 전송 과정 : 회선 설정 - 데이터 전송 - 회선 해제   단점 : 회선을 설정하고 해제할 때까지 채널의 대역폭을 독점하기 때문에 다른 회선을 동시에 사용할 수 없다.   장점 : 단점의 이유로 신뢰성 있는 데이터 전송이 가능하며 일정한 데이터 전송률로 데이터를 전송한다.   회선 설정(call setup) 시간이 필요하며 링크 및 스위칭 장비가 성능에 영향을 미친다.      오류 검출과 교정기법  해밍코드(오류 교정 코드)     N 비트의 데이터에 k개의 패리티 비트를 더하여 (n+k)비트의 코드워드(Codeword)를 생성   일종의 비트마스킹 기법으로 오류를 검출할 수 있다.   N개의 비트를 사용해서 오류가 생긴 비트를 검출할 것이기 때문에 N 비트 데이터와 k개의 패리티 비트를 사용한다고 할 때 2^k &gt;= n + k + 1 라는 수식이 성립해야 한다.(1을 더해주는 이유는 오류가 생기지 않는 경우도 표현하기 위해서)   수신측은 XOR 연산을 통해 syndrome을 계산해서 syndrome을 10진수로 바꾼 값이 오류발생 위치(syndrome의 모든 비트가 0이면 오류가 없음)      출처     데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network"],
        "url": "/computer%20network/computer-network-02/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) OSI 참조모델",
        "excerpt":"👀 OSI 참조모델     예전엔 제조사별로 각자 통신 모델을 만들어 썼기 때문에 서로 호환이 되지 않아 통신이 되지 않는 경우가 많았다.   그래서 1970년대 후반에 국제 표준화 기구 ISO(Open System Interconnection)가 네트워크 설계의 호환성을 증진시키기 위해 개방시스템 상호접속 참조모델(OSI) 구조를 제안함   OSI란 말은 타사의 시스템 간이라도 데이터를 교환하기 위한 표준을 가질 수 있다는 것을 의미함   OSI는 7계층으로 이루어져 있다.   계층 구조의 장점     크고 복잡한 시스템을 기능별로 나누어 개발 과정을 단순화 하는데 매우 유용하게 사용(모듈화)   각 계층이 제공하는 서비스를 변경하기 쉬움(한 계층을 변경해도 나머지 계층에 영향을 주지 않아 유지 보수가 쉽다)   OSI 참조모델의 계층     N 계층의 프로토콜 모듈은 상대방의 동일 계층 프로토콜 모듈과 통신을 하며 동일 계층에 있는 N 계층 끼리의 통신 규약을 N 계층 프로토콜이라 함   N 계층 프로토콜이 상대방의 동일 계층에 데이터를 직접 전달하는 것이 아니라 하위 계층(N - 1)으로 전달해서 맨 아래 계층인 물리 계층까지 도달하면 케이블을 통해 상대 호스트의 물리 계층으로 데이터를 전달한다.   상대 호스트는 물리 계층에서 받은 데이터를 하나씩 확인하며 상위 계층(N + 1)으로 올려 보낸다.   결과적으로, OSI 7계층 모델에서 상위 계층은 하위 계층의 서비스 사용자(Service User)가 되며, 하위 계층은 상위 계층의 서비스 제공자(Service Provider)가 된다.   서비스 프리미티브(Service Primitive)     동일 호스트상의 서비스 사용자(N + 1계층)와 서비스 제공자(N계층)간에 주고 받는 데이터   N 계층의 서비스는 N 서비스 프리미티브와 이 프리미티브에 관련된 파라미터로 규정   N 서비스 프리미티브는 요청(Request), 통지(Indicator), 응답(Response), 확인(Confirm)으로 구분   송신측에서 수신측으로 Request를 보내면 수신측의 하위 계층에서 Indicator를 발생시킨 뒤 송신측으로 Response를 보낸다. 송신측은 받은 데이터를 확인(Confirm)하며 하위계층에서 상위계층으로 올려보낸다.   송신측에서 데이터를 전송할 때 서비스 프리미티브를 사용하여 N + 1 계층의 송신 데이터(PDU : Protocol Data Unit)는 N 계층의 서비스 데이터 단위(SDU : Service Data Unit)로 N 계층에 넘겨진다.   N 계층에서는 PDU에 프로토콜 제어 정보(PCI : Protocol Control Information)를 헤더로 붙여 N 계층 PDU로 만든 뒤 하위 계층으로 내려보내고 하위 계층에서도 이걸 반복한다.   이러한 계층간 데이터의 전달 과정을 캡슐화(Encapsulation)라고 한다.   OSI 참조모델의 7계층  물리 계층(Physical Layer)     계층 1에 해당하며 전송매체에 대한 전기적, 기계적인 인터페이스를 다룸   전송하고자 하는 데이터를 전송매체에 적합한 전기적 신호로 바꾸는 기능   하드웨어로 구현되며 계층 2 이상은 대부분 소프트웨어로 구현된다.   물리 계층 관련 장치들            리피터(Repeater), 허브(Hub), 케이블, 이더넷(Ethernet) 등과 같은 하드웨어 장치       LAN에서 사용하는 UTP(Unshieled Twisted Pair), STP(Shieled Twisted Pair)와 같은 케이블       LAN의 UTP 케이블에 연결하는 RJ-45 커넥터(흔히 사용하는 인터넷 랜선 커넥터)           데이터링크 계층(Datalink Layer)     물리 계층을 통해 전송되는 데이터의 오류 문제를 해결하여 신뢰성 있는 데이터 전송 기능을 제공하는데 호스트 - 라우터 간 오류 문제만 제어한다.   이를 통해 상위 계층인 네트워크 계층에게 오류 문제에 대한 부담을 줄임   데이터링크 계층에서 전송하는 데이터 단위를 프레임(Frame)이라 한다.   데이터링크 계층의 주요 기능            순서 제어 : 데이터의 순차적 전송을 위해 프레임 번호 부여       오류 제어 : 오류 검출과 교정 (가장 중요한 기능)       흐름 제어 : 연속적인 프레임을 전송할 때 수신측이 수신이 가능한지 여부를 제어. 호스트 간 CPU 성능이 다를 때 느린 쪽이 빠른 쪽의 속도에 어느정도 맞춰 받을 수 있는지 서로 확인한 후 전송하는 등의 제어를 한다.       프레임 동기화 : 데이터 전송시 프레임 단위로 전송           네트워크 계층(Network Layer)     네트워크 상에 존재하는 라우터와 같은 노드(Node)를 거칠 때마다 목적지로의 경로를 찾아주는 라우팅(Routing) 역할을 하는 계층   네트워크 계층의 데이터 전송 단위를 패킷(Packet)이라 부르며 패킷 내에는 송신 호스트의 주소와 목적지 호스트의 주소를 포함   라우터에 패킷이 도착하면 패킷의 목적지 주소에 따라 적합한 라우터로 중개하며 이러한 과정을 통해 목적지에 도착   라우터가 패킷을 중개할 때 자신이 관리하고 있는 라우팅 테이블(Routing Table)을 사용해서 패킷을 어디로 보낼지 결정한다.   네트워크 계층의 예            인터넷의 IP(IP 주소가 이 계층에서 사용하는 주소)       OSI의 X.25           트랜스포트 계층(Transport Layer)     라우터와 같은 노드와는 상관없이 단대단(End-to-end) 신뢰성 있는 데이터 전송 기능을 제공   이를 위해 단대단 오류 복구, 흐름 제어 기능 등을 포함하는데 트랜스포트 계층에서의 제어 기능들은 A 호스트에서 B 호스트까지 가는 모든 경로의 오류 및 흐름을 제어한다.   트랜스포트 계층은 호스트 내에서 동작하는 프로세스(Process)에서 프로세스로 데이터를 전송한다.            네트워크 계층은 호스트에서 호스트로의 데이터 전송에 관계함       네트워크 계층에서 보내는 IP 주소 만으로는 상대 호스트의 어떤 프로세스에서 이 데이터를 보냈는지 알 수 없다. 그래서 각 프로세스별로 포트(Port) 번호를 사용해서 어떤 프로세스에서 보낸 데이터인지 구분한다.       그래서 단대단 전송이라는 용어는 프로세스와 프로세스 간의 전송을 의미한다.           트랜스포트 계층의 데이터 전송 단위(PDU : Protocol Data Unit)에는 송신측 포트 번호와 수신측 포트 번호를 포함한다.   포트 번호는 특정 프로세스를 나타내기 위해 트랜스포트 계층에서 사용하는 주소라 할 수 있다.   인터넷 통신구조에서 TCP와 UDP가 트랜스포트 계층에 해당한다.   세션 계층(Session Layer)     양끝단에 있는 응용 프로세스간의 통신을 제어하는 기능 제공   응용 프로세스간 대화를 위해 세션을 설정하여 사용하는 기능 제공   제공 기능            대화(Dialogue) 형태 : 단방향, 반이중, 전이중       복구(Recovery) 기능 : 체크포인트(Checkpoint) 기능을 제공하여 체크포인트 사이에 오류가 있을 때 마지막 체크포인트 이후의 모든 데이터를 세션 계층이 재전송하는 기능           표현 계층(Presentation Layer)     호스트간에 교환되는 데이터의 표현방법(Syntax)과 의미(Semantic)를 다루는 계층   즉 양쪽 호스트의 데이터 표현 방식이 다를 때 송신 호스트는 양쪽 호스트가 이해할 수 있는 표준화 된 형식으로 인코딩(Encoding)하고, 수신 호스트는 표준화 된 형식을 수신측에 적합한 형식으로 디코딩(Decoding)하는 기능   이외에도 데이터의 안전하고 효율적인 전송을 위해 암호화(Encryption)하거나 압축(Compression)하는 기능 제공   응용 계층(Application Layer)     OSI 7계층 중에서 최상위 계층에 있으며 사용자에게 필요한 응용 서비스를 제공하는 계층   응용 계층에 해당하는 프로토콜            FTAM(File Transfer Access and Management) : 파일 전송 프로토콜이며 인터넷의 FTP와 유사한 서비스       VT(Virtual Terminal) : 가상 단말 서비스 프로토콜이며 인터넷의 Telnet과 유사             SDU와 PDU의 차이     SDU(Service Data Unit) : 상하위 계층간 데이터 전송을 위해 사용하는 데이터 단위   PDU(Protocol Data Unit) : 상대방과의 통신을 위해 사용되는 데이터 단위      출처     데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network","OSI"],
        "url": "/computer%20network/computer-network-03-OSI/",
        "teaser": null
      },{
        "title": "OS) CPU Scheduling",
        "excerpt":"👀 CPU-Burst time     프로세스의 실행은 CPU를 얻어서 작업을 수행하는 것과 I/O 작업을 수행하는 것으로 나눌 수 있다.   이 때 CPU만 쓰면서 Instruction을 실행하는 단계는 CPU burst라 하고 I/O만 실행하는 단계는 I/O burst라 한다.   현재 프로세스가 CPU를 사용중이라면 다른 프로세스는 사용이 끝날 때까지 기다려야 하겠지만 I/O 작업중이라면 다른 프로세스가 CPU를 쓸 수 있다.   프로세스의 종류는 여러 가지가 있기 때문에 시스템 자원을 효율적으로 쓸 수 있도록 CPU 스케줄링이 필요하다.      프로세스의 특성 분류  I/O-bound process     CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job (CPU burst가 아주 짧다)   주로 사람과 Interactive하는 job   CPU-bound process     계산 위주의 job (CPU burst가 아주 길다)      CPU Scheduler     Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.   Dispatcher     CPU의 제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘긴다.   이 과정을 context switch(문맥 교환)라 한다.   CPU 스케줄링이 필요한 경우     Running -&gt; Blocked (예: I/O 요청하는 시스템 콜)   Running -&gt; Ready (예: 할당시간 만료로 timer interrupt)   Blocked -&gt; Ready (얘: I/O 완료 후 인터럽트)        Terminate         스케줄링에는 강제로 빼앗지 않고 자진 반납하는 non-preemptive와 강제로 빼앗는 preemptive가 있다.   현대 대부분의 프로세서는 preemptive를 사용한다.      스케줄링 성능 척도     CPU utilization(이용률) : CPU가 얼마나 쉼 없이 일하는지   Throughput(처리량) : 단위 시간동안 처리하는 작업의 양이 얼마나 많은지   Turnaround time(소요시간, 반환시간) : 프로세스가 CPU를 얻어서 작업을 시작하고 끝날 때까지 걸린 총 시간(대기시간 포함)   Waiting time(대기 시간) : Ready queue에서 CPU를 얻을 때까지 기다린 시간. 작업 시간은 제외하고 순수하게 기다린 시간만 본다.   Response tiem(응답 시간) : (time-sharing 시스템에서) 처음으로 CPU를 얻어서 작업을 시작하기까지 걸린 시간      스케줄링 알고리즘  FCFS (First-Come First-Serve)     선착순 방식으로 먼저 온 순서대로 CPU를 얻어서 작업을 시작하고 나중에 온 프로세스들은 이전 작업이 끝날 때까지 기다린다.   오래 걸리는 작업이 먼저 와서 계속 수행되고 시간이 짧은 작업들이 뒤에서 기다리고 있는 경우에는 효율적이지 않다. 이런 경우엔 평균 대기 시간이 길어짐   짧은 작업이 먼저 와서 처리된 후 오래 걸리는 작업을 처리하게 되면 평균 대기 시간이 짧아지지만 늘 이렇게 프로세스가 도착하지는 않을 것이니까 일반적으로는 효율적이지 않은 방식이라고 할 수 있다.   Convoy effect : 수행 시간이 긴 작업이 먼저 와서 처리되는 동안 짧은 작업들은 수행되지 못하고 기다리고 있는 현상   SJF (Shortest-Job-First)     도착하는 프로세스마다 CPU burst time을 예측해서 CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케줄한다. 그래서 평균 대기시간이 가장 짧다.   두 가지 방식이 있다.            Non-preemptive : 일단 CPU를 잡으면 다음 작업이 지금 수행 중인 작업보다 실행 시간이 더 짧아도 지금 작업이 완료되기 전 까지는 CPU를 넘겨주지 않는다.       Preemptive : 현재 수행 중인 프로세스 다음에 온 프로세스의 수행 시간이 더 짧으면 CPU를 뺏어서 시간이 더 짧은 프로세스에게 넘긴다. 근데 이러다보면 수행 시간이 긴 프로세스는 평생 CPU를 얻지 못 할 수도 있어서(starvation 기아 현상) 아주 좋은 방법은 아니다.           다음 CPU Burst time 예측 방법     완벽하게 계산하기 보다는 과거 데이터로부터 추정(estimate)하는 방식을 사용한다.   n번째 프로세스의 실제 CPU 사용 시간과 n번째 프로세스의 CPU 사용 시간을 예측했던 값들을 일정 비율씩 곱해서 더해주는 방식으로 n + 1번째 프로세스의 CPU burst time을 예측한다.   Priority Scheduling     우선순위 스케줄링이라 하며 프로세스에게 부여된 우선순위가 높은 순서대로 CPU를 할당한다.   이것 또한 나중에 도착했지만 우선순위가 더 높은 프로세스에 대해 Preemptive와 Non-preemptive 방식으로 나뉜다.   우선순위 스케줄링의 문제점 또한 우선순위가 낮은 프로세스는 평생 CPU를 얻지 못하는 Starvation 현상이 생길 수 있다는 것이다.   그래서 Aging 기법을 통해 우선순위가 낮아도 오래 기다렸으면 우선순위를 높여주는 방식을 쓴다.   Round Robin (RR)     대부분의 운영체제에서 사용하는 방식으로 각 프로세스는 동일한 크기의 CPU 할당 시간(time quantum)을 가지고 할당된 시간이 끝나면 CPU를 다음 프로세스에게 넘겨주고 Ready queue의 맨 뒤에 가서 다시 줄을 서는 방식이다.   그래서 모든 프로세스는 Ready queue의 크기만큼 기다리게 되는데 수행 시간이 짧은 프로세스는 그만큼 빨리 CPU를 쓰고 Ready queue에서 빠져나가기 때문에 각 프로세스의 대기 시간은 본인의 CPU 사용 시간에 비례하게 된다.   할당 시간이 너무 크면 FCFS와 다를 바가 없고 너무 작으면 context switch가 자주 일어나 오버헤드가 커지기 때문에 적절한 중간값을 찾는 것이 좋다.   Multilevel Queue     Ready queue를 작업의 종류에 따라 여러 개로 분할해서 각 큐마다 다른 스케줄링 알고리즘을 적용한다.   예를 들어 interactive한 작업들이 담긴 큐라면 RR 스케줄링을 적용하고 CPU burst 작업들이 담긴 큐라면 FCFS 스케줄링을 적용하는 것이다.   이 때 Starvation을 방지하기 위해서 각 큐에 CPU time을 적절한 비율로 할당한다.            예) RR 스케줄링 큐에는 80%를 할당하고 FCFS 스케줄링 큐에는 20% 할당           Multilevel Feedback Queue     Multilevel Queue에서는 한 번 큐가 결정되면 다른 큐로 이동할 수 없어서 나중에 프로세스의 burst time이 바뀌게 되어도 계속 맞지 않는 큐에 있어야 할 수 있다.   이것을 보완한 것이 Multilevel Feedback Queue인데 프로세스가 다른 큐로 이동이 가능하다.   Aging을 이런 방식으로 구현할 수 있다.   Multilevel Feedback Queue scheduler를 정의하는 파라미터들            Queue에 있는 작업의 수 : 작업의 수가 적은 큐에 먼저 할당       각 큐의 스케줄링 알고리즘       프로세스를 상위 큐로 보내는 기준 (예: CPU 사용시간이 짧을 수록)       프로세스를 하위 큐로 보내는 기준 (예: CPU 사용시간이 길수록)       프로세스가 CPU 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준           Multiple-Processor Schduling     CPU가 여러 개인 경우 스케줄링이 더욱 복잡해진다.   Homogeneous processor(동종)인 경우            큐에 한 줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.       반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 더 복잡해짐           Load sharing            일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요       별개의 큐를 두는 방법 vs. 공동 큐를 사용하는 방법           Symmetric Multiprocessing (SMP)            각 프로세서가 각자 알아서 스케줄링 결정           Asymmetric multiprocessing            하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름           Real-Time Scheduling     데드 라인이 있는 작업들에 적용되는 스케줄링   Hard real-time systems : 반드시 정해진 시간 안에 끝내도록 스케줄링   Soft real-time computing : 데드 라인을 조금 어겨도 괜찮기 때문에 Soft real-time task는 일반 프로세스에 비해 높은 우선순위를 갖게 한다.   Thread Scheduling     Local Scheduling : User level thread일 경우 사용자 수준의 스레드 라이브러리에 의해 어떤 스레드를 스케줄 할 지 결정   Global Scheduling : Kernal level thread인 경우 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 스레드를 스케줄 할 지 결정   스케줄링 알고리즘 평가     Queueing models            확률 분포로 주어지는 arrival rate와 service rate 등을 통해 각종 performance index 값을 계산하는데 요즘은 잘 안 쓴다.           Implementation (구현) &amp; Measurement (성능 측정)            실제 시스템에 알고리즘을 구현하여 실제 작업(workload)에 대해서 성능을 측정 비교하는 방식으로 많이 쓰는 방식           Simulation (모의 실험)            알고리즘을 모의 프로그램으로 작성 후 trace를 입력으로 하여 결과 비교              출처     운영체제 - 이화여자대학교 KOCW 공개강의  ","categories": ["Operating System"],
        "tags": ["CS","OS","CpuScheduling"],
        "url": "/operating%20system/OS-05-Cpu-scheduling/",
        "teaser": null
      },{
        "title": "Java) BOJ 15649. N과 M (1)",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/15649     제한       시간 제한 : 1 초   메모리 제한 : 512 MB     문제            자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.            1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열         입력       첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)     출력       한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.   수열은 사전 순으로 증가하는 순서로 출력해야 한다.      👀 풀이       순열을 구하는 문제같아서 순열을 구하는 알고리즘으로 풀었다.   참고 블로그 : https://bcp0109.tistory.com/14     결과       시간 : 340 ms   메모리 : 31232 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No15649","BackTracking","Java"],
        "url": "/boj/boj15649-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 15650. N과 M (2)",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/15650     제한       시간 제한 : 1 초   메모리 제한 : 512 MB     문제            자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.       1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열   고른 수열은 오름차순이어야 한다.     입력       첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)     출력       한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.   수열은 사전 순으로 증가하는 순서로 출력해야 한다.      👀 풀이       순열을 구하는 문제같아서 순열을 구하는 알고리즘으로 풀었다.        참고 블로그 : https://bcp0109.tistory.com/14        이번 문제는 모든 순열을 출력하는 것이 아니고 오름차순으로 정렬된 순열만 출력해야 하기 때문에 다음 순열을 확인하러 갈 때 직전에 뽑은 수보다 큰 숫자만 뽑도록 했다.     결과       시간 : 152 ms   메모리 : 15908 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No15650","BackTracking","Java"],
        "url": "/boj/boj15650-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 15651. N과 M (3)",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/15651     제한       시간 제한 : 1 초   메모리 제한 : 512 MB     문제            자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.       1부터 N까지 자연수 중에서 M개를 고른 수열   같은 수를 여러 번 골라도 된다.     입력       첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)     출력       한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.   수열은 사전 순으로 증가하는 순서로 출력해야 한다.      👀 풀이       순열을 구하는 문제같아서 순열을 구하는 알고리즘으로 풀었다.        참고 블로그 : https://bcp0109.tistory.com/14        이번 문제는 중복 순열을 구해야 하기 때문에 방문 표시를 하지 않고 모든 경우를 탐색하도록 했다.     결과       시간 : 564 ms   메모리 : 158152 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No15651","BackTracking","Java"],
        "url": "/boj/boj15651-java/",
        "teaser": null
      },{
        "title": "Java) BOJ 15652. N과 M (4)",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/15652     제한       시간 제한 : 1 초   메모리 제한 : 512 MB     문제            자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.       1부터 N까지 자연수 중에서 M개를 고른 수열   같은 수를 여러 번 골라도 된다.   고른 수열은 비내림차순이어야 한다.   길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.     입력       첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)     출력       한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.   수열은 사전 순으로 증가하는 순서로 출력해야 한다.      👀 풀이       순열을 구하는 문제같아서 순열을 구하는 알고리즘으로 풀었다.        참고 블로그 : https://bcp0109.tistory.com/14        이번 문제는 중복 순열을 구하는데 오름차순인 순열만 구해야 하기 때문에 마지막으로 뽑은 수보다 큰 수만 뽑도록 했다.     결과       시간 : 228 ms   메모리 : 19616 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No15652","BackTracking","Java"],
        "url": "/boj/boj15652-java/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) 인터넷 프로토콜",
        "excerpt":"👀 인터넷 프로토콜 구조     컴퓨터 상호간의 데이터 전달을 위한 통신구조로 현재 인터넷에서 사용하는 통신구조   TCP/IP(Transmission Control Protocol/Internet Protocol라는 프로토콜을 사용하는데 이것은 인터넷과 연결된 컴퓨터들을 공용어라 할 수 있다.   OSI 참조모델과 다르게 5계층으로 구성되어 있다.   1. 하드웨어 계층     OSI 참조모델과 마찬가지로 물리적으로 연결하는 케이블 등 데이터 통신에 관련된 하드웨어로 구성되어 있다.   2. 네트워크 인터페이스 계층     네트워크 액세스 또는 데이터링크 계층이라고도 한다.   프레임(Frame)을 네트워크 전송매체로 전달하는 것과 네트워크 전송매체에서 프레임을 받아들이는 과정 담당   TCP/IP는 네트워크 접근 방법, 프레임 포맷, 매체에 대해 독립적으로 동작하도록 설계   TCP/IP는 서로 다른 네트워크 형태를 연결하는데 사용 가능            네트워크 형태로는 이더넷(Ethernet), 토큰버스(Token Bus), 토큰링(Token Ring)과 같은 LAN 기술       X.25, 프레임 릴레이(Frame Relay)와 같은 WAN 기술을 포함           네트워크 인터페이스 계층은 OSI 모델에서 데이터 링크 계층에 해당   3. 인터넷 계층     OSI 모델의 네트워크 계층에 해당하며 어드레싱(addressing - IP 주소를 만드는 것), 패키징(packaging - 데이터 전송 단위를 만드는 것), 라우팅(routing - 목적지까지 전송할 수 있도록 라우터에서 중개) 기능을 제공   핵심 프로토콜은 IP, ARP, ICMP, IGMP 등을 포함            IP(Internet Protocol) : IP 주소, 패킷의 라우팅을 책임지는 프로토콜       ARP(Address Resolution Protocol) : 인터넷 계층의 IP 주소를 네트워크 인터페이스 계층의 주소(MAC 주소 또는 물리적 하드웨어 주소)로 변환       ICMP(Internet Control Message Protocol) : IP 패킷의 전달에 따른 오류나 상태를 리포트하고 진단하는 기능       IGMP(Internet Group Management Protocol) : IP 멀티캐스트(multicast) 그룹의 관리           4. 트랜스포트 계층     두 호스트 간에 단대단(End-to-End) 통신을 제공   핵심 프로토콜은 TCP와 UDP(User Datagram Protocol)   TCP            1 대 1 연결 지향(전송 전 송-수신자간 논리적 연결을 먼저 함)       신뢰성 있는 통신 서비스 제공       TCP 연결 설정과 보낸 패킷의 확인, 순서화, 전달 중 손상된 패킷을 복구하는 기능 제공           UDP            1 대 1, 1 대 다의 비연결 지향       신뢰할 수 없는 통신 서비스 제공       주로 전달해야 할 데이터의 크기가 작을 때나, TCP 연결 확립에 의한 부하를 피하려고 할 때 혹은 상위 프로토콜이 신뢰할 수 있는 전달을 책임지는 경우에 사용       예) DNS: 전달해야 할 데이터가 상대적으로 적어서 빠른 응답을 위해 UDP 사용           5. 응용 계층     사용자와 가장 밀접한 관계를 가지고 있는 계층   여러 가지 응용 계층 프로토콜이 존재하며 지속적으로 새로운 프로토콜 개발   가장 많이 알려진 응용 계층 프로토콜로는            HTTP(HyperText transfer Protocol) : WWW의 Web 페이지 파일을 전송하는데 사용       FTP(File transfer Protocol) : 상호 파일 전송을 위해 사용       SMTP(Simple Mail transfer Protocol) : 메일 메시지와 그에 추가된 첨부 파일을 전송하기 위해 사용           TCP/IP 네트워크를 관리하거나 지원하는 응용 계층 프로토콜            DNS(Domain Name System) : 호스트 이름(예 : www.naver.com)을 숫자로 된 IP 주소로 변환하기 위해 사용       RIP(Routing Information Protocol) : IP 네트워크상에서 라우팅 정보를 교환하기 위해 라우터가 사용하는 프로토콜. 이를 이용해 최상의 라우팅 테이블을 유지하고 이 라우팅 테이블을 통해 가장 적합한 곳으로 패킷을 전송한다.       SNMP(Simple Network Management Protocol) : 네트워크 관리 콘솔과 네트워크 장비(라우터, 브리지, 지능형 허브)간에 네트워크 관리 정보를 수집, 교환하기 위해 사용. 네트워크 장비를 원격으로 관리할 수 있다.           인터넷 프로토콜 구현 환경     시스템 공간(계층 1 ~ 4) : 운영 체제에서 동작(자동으로 설치됨)   사용자 공간(계층 5) : 사용자 프로그램으로 동작   프로토콜 캡슐화(Encapsulation)     인터넷 프로토콜도 OSI 참조모델의 캡슐화 개념을 동일하게 사용한다.   그래서 하위 계층으로 내려보내서 물리 계층에 도착하면 상대편에게 보내고 상대편은 물리 계층부터 상위 계층으로 올라가서 사용자에게 최종적으로 메시지를 보여주는 형태와 똑같이 동작한다.   🔸 수신측     응용 계층의 메시지(Message)는 트랜스포트 계층으로 전달되고, 트랜스포트 계층은 전달 받은 데이터 앞에 자신의 헤더를 추가한 후 세그먼트(Segment)를 만들어 네트워크 계층으로 전달   네트워크 계층은 전달 받은 데이터 앞에 자신의 헤더를 추가한 후 데이터그램(Datagram = Packet)을 만들어 링크 계층으로 전달   링크 계층은 전달 받은 데이터에 자신의 헤더를 추가하여 프레임(Frame)을 만든다.   마지막으로 프레임은 물리 계층에 해당하는 전송매체를 통해 상대방에게 전송   🔸 송신측     물리 계층에서 데이터를 수신하여 상위 계층으로 전달하는 과정 반복        각 계층은 자신의 데이터 단위가 도착하게 되면 프로토콜 동작 수행         그래서 인터넷 프로토콜 또한 상위 계층은 하위 계층의 서비스 사용자(Service user)이고, 하위 계층은 서비스 제공자(Service provider)이다.      출처     데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network","Protocol"],
        "url": "/computer%20network/computer-network-03-protocol/",
        "teaser": null
      },{
        "title": "DB) 데이터베이스 시스템",
        "excerpt":"👀 데이터베이스 시스템(DBS : Database System)이란?     데이터베이스에 데이터를 저장하고 이를 관리하여 조직에 필요한 정보를 생성해주는 시스템   즉 데이터베이스 관리 시스템 전체를 아우르는 용어이다.      데이터베이스의 구조  스키마(schema)     데이터베이스에 저장되는 데이터 구조와 제약조건, 데이터 타입 등을 정의한 것   전체적인 뼈대라 할 수 있다.   인스턴스(instance)     스키마에 따라 데이터베이스에 실제로 저장된 값   그래서 스키마는 변하지 않지만 인스턴스는 시간이 흐름에 따라 바뀔 수 있다.   3단계 데이터베이스 구조     미국 표준화 기관인 ANSI/SPARC에서 제안   데이터베이스를 쉽게 이해하고 이용할 수 있도록 하나의 데이터베이스를 관점에 따라 세 단계로 나눈 것   각 단계별로 다른 추상화(abstraction)를 제공한다.            내부 단계에서 외부 단계로 갈수록 추상화 레벨이 높아진다.           3단계 데이터베이스 구조 : 외부 단계     데이터베이스를 개별 사용자 관점에서 이해하고 표현하는 단계   데이터베이스 하나에 외부 스키마가 여러 개 존재할 수 있다.   아파트로 치자면 201호에 사는 사람처럼 각 세대에 사는 사람이라 할 수 있다. 아파트의 개별 세대원들은 본인이 사는 호수에만 관심이 있을 것이다.   🔸 외부 스키마(external schema)     외부 단계에서 사용자에게 필요한 데이터베이스를 정의한 것   각 사용자가 생각하는 데이터베이스의 모습. 즉 논리적 구조로 사용자마다 다름   서브 스키마(sub schema)라고도 한다.   3단계 데이터베이스 구조 : 개념 단계     데이터베이스를 조직 전체의 관점에서 이해하고 표현하는 단계   데이터데이스 하나에 개념 스키마가 하나만 존재함   아파트의 관리자라고 할 수 있다. 여러 세대가 사는 아파트에서 관리하는 사무소는 하나이고 관리 사무소는 아파트라는 조직 전체를 관리한다.   🔸 개념 스키마(conceptual schema)     개념 단계에서 데이터베이스 전체의 논리적 구조를 정의한 것   조직 전체의 관점에서 생각하는 데이터베이스의 모습   전체 데이터베이스에 어떤 데이터가 저장되는지, 데이터들 간에는 어떤 관계가 존재하고 어떤 제약조건이 존재하는지에 대한 정의뿐만 아니라, 데이터에 대한 보안 정책이나 접근 권한에 대한 정의도 포함   3단계 데이터베이스 구조 : 내부 단계     데이터베이스를 저장 장치의 관점에서 이해하고 표현하는 단계   데이터베이스 하나에 내부 스키마가 하나만 존재함   아파트의 건설사 관점이라고 할 수 있다. 아파트의 구조를 설계하고 그에 맞춰 짓는 동안 하나의 건설사에서 관리한다.   🔸 내부 스키마(internal schema)     전체 데이터베이스가 저장 장치에 실제로 저장되는 방법을 정의한 것   레코드 구조, 필드 크기, 레코드 접근 경로 등 물리적 저장 구조를 정의   3단계 데이터베이스 구조의 사상 또는 매핑  스키마 사이의 대응 관계     외부/개념 사상 : 외부 스키마와 개념 스키마의 대응 관계            응용 인터페이스(application interface)라고도 함           개념/내부 사상 : 개념 스키마와 내부 스키마의 대응 관계            저장 인터페이스(storage interface)라고도 함           미리 정의된 사상 정보를 이용하여 사용자가 원하는 데이터에 접근한다.   데이터베이스를 3단계 구조로 나누고 단계별로 스키마를 유지하며 스키마 사이의 대응 관계를 정의하는 궁극적인 목적은 데이터 독립성의 실현이다.   데이터 독립성(data independency)     하위 스키마를 변경하더라도 상위 스키마가 영향을 받지 않는 특성   🔸 논리적 데이터 독립성     개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않음   개념 스키마가 변경되면 관련된 외부/개념 사상만 정확하게 수정해주면 됨   🔸 물리적 데이터 독립성     내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않음   내부 스키마가 변경되면 관련된 개념/내부 사상만 정확하게 수정해주면 됨   데이터 사전(data dictionary)     시스템 카탈로그(system catalog)라고도 한다.   데이터베이스에 저장되는 데이터에 관한 정보, 즉 메타 데이터를 유지하는 시스템 데이터베이스            메타 데이터(meta data) : 데이터에 대한 데이터           스키마, 사상 정보, 다양한 제약조건 등을 저장   데이터베이스 관리 시스템이 스스로 생성하고 유지함   일반 사용자도 접근이 가능하지만 저장된 내용을 검색만 할 수 있음   데이터 디렉토리(data directory)     데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보를 저장하는 시스템 데이터베이스   일반 사용자의 접근은 허용되지 않음   사용자 데이터베이스(user database)     사용자가 실제로 이용하는 데이터가 저장되어 있는 일반 데이터베이스      데이터베이스 사용자     데이터를 이용하기 위해 접근하는 모든 사람   이용 목적에 따라 데이터베이스 관리자, 최종 사용자, 응용 프로그래머로 나눌 수 있다.   데이터베이스 관리자(DBA : Database Administrator)     데이터베이스 시스템을 운영, 관리하는 사람   주로 데이터 정의어와 데이터 제어어를 사용   주요 업무            데이터베이스 구성 요소 선정       데이터베이스 스키마 정의       물리적 저장 구조와 접근 방법 결정       무결성 유지를 위한 제약조건 정의       보안 및 접근 권한 정책 결정       백업 및 회복 기법 정의       시스템 데이터베이스 관리       시스템 성능 감시 및 성능 분석       데이터베이스 재구성           최종 사용자(end user)     데이터베이스에 접근하여 데이터를 조작(삽입, 삭제, 수정, 검색)하는 사람   주로 데이터 조작어 사용   캐주얼 사용자와 초보 사용자로 구분   응용 프로그래머(application programmer)     데이터 언어를 삽입하여 응용 프로그램을 작성하는 사람   주로 데이터 조작어 사용      데이터 언어     사용자와 데이터베이스 관리 시스템 간의 통신 수단   사용 목적에 따라 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분   데이터 정의어(DDL : Data Definition Language)     스키마를 정의하거나 수정 또는 삭제하기 위해 사용   데이터 조작어(DML : Data Manipulation Language)     데이터의 삽입, 삭제, 수정, 검색 등의 처리를 요구하기 위해 사용   절차적 데이터 조작어와 비절차적 데이터 조작어로 구분됨   절차적 데이터 조작어(procedural DML)            사용자가 어떤(what) 데이터를 원하고 그 데이터를 얻기 위해 어떻게(how) 처리해야 하는지 설명       즉 데이터의 처리 절차를 설명해야 한다.           비절차적 데이터 조작어(nonprocedural DML)            사용자가 결과적으로 어떤(what) 데이터를 원하는지만 설명       데이터를 얻기 위한 절차를 설명할 필요가 없다.       선언적 언어(declarative language)라고도 한다.           데이터 제어어(DCL : Data Control Language)     내부적으로 필요한 규칙이나 기법을 정의하기 위해서 사용   사용 목적            무결성 : 정확하고 유효한 데이터만 유지       보안 : 허가받지 않은 사용자의 데이터 접근 차단, 허가된 사용자에 권한 부여       회복 : 장애가 발생해도 데이터 일관성 유지       동시성 제어 : 동시 공유 지원              데이터베이스 관리 시스템의 구성     데이터베이스 관리와 사용자의 데이터 처리 요구를 수행한다.   주요 구성 요소     질의 처리기(query processor)            사용자의 데이터 처리 요구를 해석하여 처리       DDL 컴파일러, DML 프리 컴파일러, DML 컴파일러, 런타임 데이터베이스 처리기, 트랜잭션 관리자 등을 포함           저장 데이터 관리자(stored data manager)            디스크에 저장된 사용자 데이터베이스와 데이터 사전을 관리하고, 여기에 실제로 접근하는 역할 담당              출처     데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의  ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/db-03-database-system/",
        "teaser": null
      },{
        "title": "DB) 데이터 모델링",
        "excerpt":"👀 데이터베이스 설계     사용자의 다양한 요구 사항을 고려하여 데이터베이스를 생성하는 과정   E-R 모델과 릴레이션 변환 규칙을 이용한 설계 과정은 5단계로 이루어져 있다.   1단계 : 요구 사항 분석     데이터베이스의 용도 파악   관련된 현실 세계가 어떻게 구성되어 있는지 파악한다.   결과물 : 요구 사항 명세서   2단계 : 개념적 설계     DBMS에 독립적인 개념적 구조 설계   현실세계에 있는 정보를 알아보기 쉽게 표시한다.   결과물 : 개념적 스키마(E-R 다이어그램)   3단계 : 논리적 설계     DBMS에 적합한 논리적 구조 설계   결과물 : 논리적 스키마(릴레이션 스키마)   4단계 : 물리적 설계     DBMS로 구현 가능한 물리적 구조 설계   결과물 : 물리적 스키마   5단계 : 구현          SQL 문을 작성한 후 이를 DBMS에서 실행하여 데이터베이스 생성              1 ~ 3단계가 가장 핵심이 되는 단계들이며 각 단계의 설계 과정 중에 오류가 발견되어 변경이 필요하면 이전 단계로 되돌아가 설계 내용을 변경할 수 있다.          데이터 모델링(data modeling)     현실 세계에 존재하는 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 변환 과정   데이터베이스 설계의 핵심 과정   모든 데이터는 특징을 추출하는 추상화(abstraction) 과정을 거쳐서 데이터베이스로 옮겨진다.   개념적 데이터 모델링(conceptual modeling)     현실 세계의 중요 데이터를 추출하여 개념 세계로 옮기는 작업   논리적 데이터 모델링(logical modeling)     개념 세계의 데이터를 데이터베이스에 저장하는 구조로 표현하는 작업   데이터 모델(data model)     데이터 모델링의 결과물을 표현하는 도구   개념적 데이터 모델     사람의 머리로 이해할 수 있도록 현실 세계를 개념적 모델링하여 데이터베이스의 개념적 구조로 표현하는 도구   예) 개체-관계 모델   논리적 데이터 모델     개념적 구조를 논리적 모델링하여 데이터베이스의 논리적 구조로 표현하는 도구   예) 관계 데이터 모델      개체-관계 모델(E-R model: Entity-Relationship model)     피터 첸(Peter Chen)이 제안한 개념적 데이터 모델   개체와 개체 간의 관계를 이용해 현실 세계를 개념적 구조로 표현   핵심 요소 : 개체, 속성, 관계   개체-관계 다이어그램(E-R diagram)     E-R 다이어그램이라고도 하며 개체 - 관계 모델을 이용해 현실 세계를 개념적으로 모델링한 결과물을 그림으로 표현한 것   개체(entity)     현실 세계에서 조직을 운영하는 데 꼭 필요한 사람이나 사물과 같이 구별되는 모든 것   저장할 가치가 있는 중요 데이터를 가지고 있는 사람이나 사물, 개념, 사건 등   다른 개체와 구별되는 이름을 가지고 있고, 각 개체만의 고유한 특성이나 상태, 즉 속성을 하나 이상 가지고 있음   예) 서점에 필요한 개체 : 고객, 책   예) 학교에 필요한 개체 : 학과, 과목   파일 구조의 레코드(record)와 대응됨   E-R 다이어그램에서 사각형으로 표현하고 사각형 안에 이름을 표기한다.   속성(attribute)     개체나 관계가 가지고 있는 고유의 특성   의미 있는 데이터의 가장 작은 논리적 단위   파일 구조의 필드(field)와 대응됨   E-R 다이어그램에서 타원으로 표현하고 타원 안에 이름을 표기   개체 타입(entity type)     개체를 고유의 이름과 속성들로 정의한 것   파일 구조의 레코드 타입(record type)에 대응됨   개체 인스턴스(entity instance)     개체를 구성하고 있는 속성이 실제 값을 가짐으로써 실체화된 개체   개체 어커런스(entity occurrence)라고도 함   파일 구조의 레코드 인스턴스(record instance)에 대응됨   개체 집합(entity set)     특정 개체 타입에 대한 기체 인스턴스들을 모아놓은 것   속성의 분류  속성 값의 개수에 따른 분류  🔸 단일 값 속성(single-valued attribute)     값을 하나만 가질 수 있는 속성   예) 고객 개체의 이름, 적립금 속성   🔸 다중 값 속성(multi-valued attribute)     값을 여러 개 가질 수 있는 속성   예) 고객 개체의 연락처 속성   예) 책 개체의 저자 속성   E-R 다이어그램에서 이중 타원으로 표현   의미의 분해 가능성에 따른 분류  🔸 단순 속성(simple attribute)     의미를 더는 분해할 수 없는 속성   예) 고객 개체의 적립금 속성   예) 책 개체의 이름, ISBN, 가격 속성   🔸 복합 속성(composite attribute)     의미를 분해할 수 있는 속성   예) 고객 개체의 주소 속성            시, 도, 구, 동, 우편번호 등으로 의미를 세분화해서 쪼갤 수 있다.           예) 고객 개체의 생년월일 속성            연, 월, 일로 의미를 세분화할 수 있다.           유도 속성(derived attribute)     기존의 다른 속성의 값에서 유도되어 결정되는 속성   값이 별도로 저장되지 않음   예) 책 개체의 가격과 할인율 속성으로 계산되는 판매가격 속성            가격 - 할인율 = 책 가격이 되기 때문에 책 개체의 가격은 유도 속성이라 할 수 있다.           예) 고객 개체의 출생연도 속성으로 계산되는 나이 속성            출생연도를 이용해서 고객의 나이를 계산할 수 있기 때문에 고객 개체의 나이 속성은 유도 속성이라 할 수 있다.           E-R 다이어그램에서 점선 타원으로 표현된다.   널 속성(null attribute)     널 값이 허용되는 속성   널(null) 값     아직 결정되지 않았거나 모르는 값 또는 존재하지 않는 값   공백이나 0과는 의미가 다른데, 공백이나 0도 공백과 0이라는 값이 있는 것이다. 그래서 공백, 0 != null   예) 등급 속성이 널 값이라는 의미는 등급이 아직 결정되지 않았음을 의미   키 속성(key attribute)     각 개체 인스턴스를 식별하는 데 사용되는 속성   모든 개체 인스턴스의 키 속성 값이 다름   둘 이상의 속성들로 구성되기도 함   예) 고객 개체의 고객아이디 속성   E-R 다이어그램에서 밑줄로 표현한다.   관계(relationship)     개체와 개체가 맺고 있는 의미 있는 연관성   개체 집합들 사이의 대응 관계, 즉 매핑(mapping)을 의미   예) 고객 개체와 책 개체 간의 구매 관계 (“고객은 책을 구매한다”)   E-R 다이어그램에서 마름모로 표현한다.   관계의 유형 : 관계에 참여하는 개체 타입의 수에 따라     이항 관계 : 개체 타입 두 개가 맺는 관계   삼항 관계 : 개체 타입 세 개가 맺는 관계   순환 관계 : 개체 타입 하나가 자기 자신과 맺는 관계   관계의 유형 : 매핑 카디널리티 기준  일대일(1 : 1) 관계     개체 A의 각 개체 인스턴스가 개체 B의 개체 인스턴스 하나와 관계를 맺을 수 있고, 개체 B의 각 개체 인스턴스도 개체 A의 개체 인스턴스 하나와 관계를 맺을 수 있음   예) 일처일부제에서의 혼인관계   일대다(1 : n) 관계     개체 A의 각 개체 인스턴스가 개체 B의 개체 인스턴스 여러 개와 관계를 맺을 수 있지만, 개체 B의 각 개체 인스턴스는 개체 A의 개체 인스턴스 하나와 관계를 맺을 수 있음   예) 하나의 부서에 여러 사원이 소속되어 있는 관계   다대다(n : m) 관계     개체 A의 각 개체 인스턴스가 개체 B의 개체 인스턴스 여러 개와 관계를 맺을 수 있고, 개체 B의 각 개체 인스턴스도 개체 A의 개체 인스턴스 여러 개와 관계를 맺을 수 있음   고객은 책을 여러 권 살 수 있고 책 또한 여러 고객들에 의해서 구매될 수 있는 관계   매핑 카디널리티(mapping cardinality)     관계를 맺는 두 개체 집합에서, 각 개체 인스턴스가 연관성을 맺고 있는 상대 개체 집합의 인스턴스 개수   관계의 참여 특성  필수적 참여(전체 참여)     모든 개체 인스턴스가 관계에 반드시 참여해야 하는 것을 의미   예) 모든 고객은 책을 반드시 구매해야 한다면 고객 개체가 책 개체와의 구매 관계에 필수적으로 참여하는 것   E-R 다이어그램에서 이중선으로 표현   선택적 참여(부분 참여)     개체 인스턴스 중 일부만 관계에 참여해도 되는 것을 의미   예) 고객이 서점에 있는 모든 책을 사야 하는 것은 아니기 때문에 이런 경우엔 책 개체가 고객 개체와의 구매 관계에 선택적으로 참여한다고 할 수 있다.   관계의 종속성     약한 개체(weak entity) : 다른 개체의 존재 여부에 의존적인 개체   오너 개체(owner entity) : 다른 개체의 존재 여부를 결정하는 개체   오너 개체와 약한 개체는 일반적으로 일대다의 관계를 가지고, 약한 개체는 오너 개체와의 관계에 필수적으로 참여하는 특징이 있다.   약한 개체는 오너 개체의 키를 포함하여 키를 구성하는 특징이 있다.   예) 직원 개체와 부양가족 개체 사이의 부양 관계            직원 개체는 부양가족을 꼭 가지지 않아도 되지만 부양가족은 직원 개체가 꼭 있어야 한다. 그래서 직원 개체는 오너 개체, 부양가족 개체는 약한 개체라 할 수 있다.           E-R 다이어그램에서 약한 개체는 이중 사각형으로 표한하고 약한 개체가 오너 개체와 맺는 관계는 이중 마름모로 표현      출처     데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의  ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/db-04-data-modeling/",
        "teaser": null
      },{
        "title": "Java) BOJ 9663. N-Queen",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/9663     제한       시간 제한 : 10 초   메모리 제한 : 128 MB     문제            N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.            N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.         입력       첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)      출력       첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.      👀 풀이       어디서 들어본 거 같은데 모르겠어서 구글링했다.        참고 블로그 : https://st-lab.tistory.com/118        체스판 위에 퀸을 놓은 뒤 그 위치의 다음 위치부터 검사해서 어떤 위치가 퀸이 있는 위치에서 상하좌우 대각선 방향에 있는 곳이라면 그냥 넘어가고 아니라면 퀸을 놓기 위한 함수를 재귀호출하는 것이다.   탐색 위치가 체스판의 끝에 도달하면 재귀 호출을 종료한다. (자세한 건 주석에..)     결과       시간 : 5320 ms   메모리 : 14532 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No9663","BackTracking","Java"],
        "url": "/boj/boj9663-java/",
        "teaser": null
      },{
        "title": "에러해결 Log) cvc-id.3 A field of identity constraint 'web-app-filter-name-uniqueness' matched element 'web-app', but this element does not have a simple type.",
        "excerpt":"사용환경     MacBook Air (M1, 2020) 16GB   JDK 8   Eclipse 2021-12   tomcat 8      에러의 발생         JSP수업 중 서블릿 실습을 따라하고 있었는데 분명 방금 전 까지는 실행이 잘 됐는데 새 서블릿 클래스를 만들고 나서 서버를 재시작 하니까 갑자기 무한루프가 돌기 시작했다… 그래서 급히 구글 검색했지만 딱히 만족할만한 결과를 얻지 못해서 .xml 파일을 뒤져봤다.            사진에서 17번째 줄에 에러 메시지가 표시되고 있지만 저건 처음부터 저랬는데도 실행하는데 아무 문제가 없었어서 그냥 이클립스 버그인가 보다 하고 넘겼었다.   심지어 오늘 수업에서 직전까지 하던 실습을 할 때 까지도 잘 됐었음! 그런데 다른 파일들은 에러가 날 만한 부분이 없었고 계속 저기만 문제라고 하고 있어서 에러 메시지를 눌러보았다.            눌러보니까 굉장히 긴 메시지가 나오길래 혹시나 싶어서 그대로 복붙해서 구글에 검색해 보니까 역시 이걸 해결하신 분이 계셨다.   해결방법은 아주 간단했는데 .xml 파일 상단의 &lt;wep-app xmlns:xsi=\"~\"로 시작하는 부분에서 저 뒤에 있는 xsi:schemaLocation=\"~\"에 있는 주소 중 http://java.sun.com 부분을 http://JAVA.sun.com으로 고치거나 http://Java.sun.com으로 고치면 되는.. 아주 간단한 것이었다.            바꾸니까 17번째 줄의 에러 메시지도 사라지고 더 이상 무한루프를 돌지 않고 서블릿 실행도 잘 되었다.   이럴거면 처음에 자동으로 만들어 줄 때 부터 자바를 대문자로 써서 만들어 주면 되지 않았을까… 사람 번거롭게 하네 😔      참고     [에러해결] web.xml에서 cvc-id.3: A field of identity constraint ‘web-app-filter-name-uniqueness’ matched element ‘web-app’, but this element does not have a simple type.  ","categories": ["ErrorLog"],
        "tags": ["Error","Solve","Log"],
        "url": "/errorlog/warning-log-01/",
        "teaser": null
      },{
        "title": "Java) BOJ 2580. 스도쿠",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2580     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제            스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.            나머지 빈 칸을 채우는 방식은 다음과 같다.       각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.        굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.       게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.     입력       아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.     출력            모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.            스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.          👀 풀이       처음엔 for문을 여러번 돌려서 n^3에 가깝게 풀었는데 그래서 그런지 시간 초과가 났다…        그래서 시간을 줄여보려고 입력 받으면서 0인 칸만 따로 저장한 뒤 거기만 탐색하는 방식으로도 해 봤지만 역시 1%에서 시간초과가 나서 질문 게시판과 구글링을 참고했다.        스도쿠의 가로세로줄과 3*3 칸을 검사한 뒤 겹치는 숫자가 없도록 넣어야 하기 때문에 이것을 검사하는 함수를 만들어서 0인 위치에 대해서 1~9 까지의 숫자를 넣어서 검사를 실시한 뒤 해당 숫자를 넣을 수 있으면 수를 삽입한 뒤 스도쿠에 숫자를 넣는 함수를 재귀호출한다.   스도쿠 칸을 채우는 방법이 여러 개가 있을 수 있기 때문에 보드판이 다 채워지는대로 보드판을 출력하고 System.exit(0)을 사용해서 프로그램을 종료한다.     결과       시간 : 672 ms   메모리 : 28336 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2580","BackTracking","Java"],
        "url": "/boj/boj2508-java/",
        "teaser": null
      },{
        "title": "C++) BOJ 1049. 기타줄",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1049     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제            Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.            끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.         입력       첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.     출력       첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.      👀 풀이       브랜드에 상관없이 총 구매 가격이 최소가 되기만 하면 되기 때문에 입력 받으면서 6개 팩 중 가장 싼 가격과 낱개 중 가장 싼 가격을 저장해 놓았다.   그리고 기타줄의 갯수만큼 사는데 6개 팩으로 사는 것이 더 싸면 정답 변수에 6개 팩의 가격을 더해주고 아나리면 낱개를 남은 기타줄의 갯수만큼 곱해서 더해주었다.     결과       시간 : 0 ms   메모리 : 2020 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1049","BackTracking","C++"],
        "url": "/boj/boj1049-cpp/",
        "teaser": null
      },{
        "title": "에러해결 Log) JSP 절대경로 지정하기",
        "excerpt":"사용환경     MacBook Air (M1, 2020) 16GB   JDK 8   Eclipse 2021-12   tomcat 8.5      에러의 발생           역시 여느 때와 같은 JSP 수업 시간… Model2 MVC 패턴으로 웹 페이지를 만드는 것을 실습하고 있었는데 서블릿을 통해 가상주소로 페이지를 열다 보니까 jsp 페이지 자체는 잘 열리는데 jsp 페이지와 연결된 외부 css파일의 경로를 제대로 찾질 못해서 기본으로 적용되어 있던 css가 제대로 적용되질 않았다.   이걸 해결하고 수업이 끝났다면 좋았겠지만 여기까지 했을 때 마침 수업 시간이 끝나버려서… 다음 수업까지 기다릴 수도 있었겠지만 간단해 보이는 걸 해결 못하니까 너무 신경쓰였다. 그래서 고쳐 보겠다고 경로를 온갖 방법으로 지정을 해 줬는데 계속 상대 경로를 지정하는 것이었어서 그런지 페이지로 이동하는 경로에 따라 어떤 경우엔 잘 되고 어떤 경우엔 잘 나오지 않는 등 여러가지로 css 파일이 완벽하게 로드되지 않았다.   물론 절대경로도 나름 시도를 해 보았으나 잘못 알고 있었는지 절대경로도 먹히질 않았다… 주륵 🥲      문제 해결      구글에 jsp 절대경로를 검색하니까 자료가 많았다.   절대경로를 설정하는 간단한 방법은 루트를 뜻하는 /를 입력하고 하위 폴더명을 타고타고 입력하는 것이지만 저게 먹히지 않았기 때문에 다른 방법을 찾았다.   바로    ${pageContext.request.contextPath}    를 이용해 어느 경우라도 절대경로가 적용될 수 있게 해주는 것이다.     한 시간동안 헤메면서도 생각했지만 jsp 페이지에 직접 접근했을 때와 서블릿을 통해 접근했을 때 상대경로의 기준이 달라져서 그러는 것 같았는데 찾아보니까 진짜였다.     &lt;link href=\"${pageContext.request.contextPath}/css/default.css\" rel=\"stylesheet\" type=\"text/css\"&gt;      이런 식으로 찾아가고자 하는 폴더와 파일의 경로를 el 표현식을 사용한 contextPath 뒤에 입력해주면 절대경로로 세팅되면서 정상적으로 css 파일을 찾아가게 된다.   그런데 방금 적용시켜 보니까 jsp 액션태그의 경로에는 절대경로를 넣으니까 500 에러가 나서 액션태그는 피하고 HTML 태그에만 적용시켜 주면 될 거 같다.         짠👏 적용 끝!  ","categories": ["ErrorLog"],
        "tags": ["Error","Solve","Log"],
        "url": "/errorlog/warning-log-02/",
        "teaser": null
      },{
        "title": "C++) BOJ 1149. RGB거리",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1149     제한       시간 제한 : 0.5 초 (추가 시간 없음)   메모리 제한 : 128 MB     문제            RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.            집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.       1번 집의 색은 2번 집의 색과 같지 않아야 한다.   N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.   i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.     입력       첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.     출력       첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.      👀 풀이       처음엔 현재 집까지 칠했을 때 비용과 이번에 칠할 수 있는 색 중 더 가격이 싼 색을 더한 가격을 dp 배열에 합산해서 마지막 인덱스 중 최소값을 출력했는데 마지막 예제가 통과하지 못했다.   질문 게시판 보니까 현재 최소값이 최종적으로 최소값이 되지 않을 수 있는 경우 때문이었다. ㅠㅠ   근데 문제는 알아도 해결할 방법이 떠오르질 않아서 질문 게시판을 더 찾아봤는데 어떤 분이 주어지는 행렬에서 각 행에 숫자를 하나 골라서 인접하지 않은 수들과의 합 중 최소값을 구하는 것이라고 써 놓은 것을 보고 아이디어를 얻어서 수정하니까 통과되었다.    3   26 40 83   49 60 57   13 89 99      여기서 수직 방향으로는 합을 구하지 않고 대각선 방향(\\/)에 있는 수들과 현재 행의 수의 합 중 최소를 구하는 것임      풀고 나니까 왜 실버1인지 알 거 같기도 했다… 쓸데없이 어렵게 생각해서 시간 날림 ㅠ     결과       시간 : 0 ms   메모리 : 2044 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1149","DP","C++"],
        "url": "/boj/boj1149-cpp/",
        "teaser": null
      },{
        "title": "C++) BOJ 2864. 5와 6의 차이",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2864     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제            상근이는 2863번에서 표를 너무 열심히 돌린 나머지 5와 6을 헷갈리기 시작했다.            상근이가 숫자 5를 볼 때, 5로 볼 때도 있지만, 6으로 잘못 볼 수도 있고, 6을 볼 때는, 6으로 볼 때도 있지만, 5로 잘못 볼 수도 있다.            두 수 A와 B가 주어졌을 때, 상근이는 이 두 수를 더하려고 한다. 이때, 상근이가 구할 수 있는 두 수의 가능한 합 중, 최솟값과 최댓값을 구해 출력하는 프로그램을 작성하시오.         입력       첫째 줄에 두 정수 A와 B가 주어진다. (1 &lt;= A,B &lt;= 1,000,000)     출력       첫째 줄에 상근이가 구할 수 있는 두 수의 합 중 최솟값과 최댓값을 출력한다.      👀 풀이       한 자리씩 검사하면서 5라면 6으로 만들었을 때의 합을 구하고(최대값) 6이라면 5로 만들었을 때의 합(최소값)을 구했다.     결과       시간 : 0 ms   메모리 : 2024 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2864","BackTracking","C++"],
        "url": "/boj/boj2864-cpp/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 1 - 페이지 템플릿 세팅 및 서블릿 매핑",
        "excerpt":"개발환경     OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백앤드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황           오늘 진행한 것은 무료 템플릿 사이트에서 다운받은 템플릿을 이용해 기본적인 사이트 틀을 만들었다.   메인 페이지를 만들고 로그인 페이지와 회원가입 페이지 폼을 만들어서 연결시키는 것 까지 했다.     &lt;servlet&gt;     &lt;servlet-name&gt;CafeFrontController&lt;/servlet-name&gt;     &lt;servlet-class&gt;com.project.cafe.CafeFrontController&lt;/servlet-class&gt;   &lt;/servlet&gt;      &lt;servlet-mapping&gt;     &lt;servlet-name&gt;CafeFrontController&lt;/servlet-name&gt;     &lt;url-pattern&gt;*.me&lt;/url-pattern&gt;   &lt;/servlet-mapping&gt;      물론 HTML을 이용해 그냥 연결시키지 않았고 서블릿을 이용해 Model2 MVC 패턴을 적용시킬 계획이기 때문에 .xml 페이지에서 서블릿 클래스 매핑을 통해 페이지 경로를 주소창에 노출시키면서 연결하는 것이 아닌, 주소창에는 가상 주소를 보여주도록 하기 위한 틀을 만들었다.   매핑될 가상주소는 하나로 고정시키는 것이 아닌, 페이지별 용도에 따라 다른 주소를 출력할 수 있도록 *을 사용해 맨 뒤에 .me만 붙으면 그 주소를 올바른 것으로 인식하고 대응시킬 수 있도록 했다.     import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class CafeFrontController extends HttpServlet { \tprotected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\t// 1. 전달되는 가상주소 계산 \t\t// 매핑된(.me로 끝나는) 주소를 받아옴 \t\tString requestURI = req.getRequestURI(); \t\tSystem.out.println(\"requestURI : \" + requestURI); \t\t \t\t// 매핑된 해당 프로젝트 주소를 구함 \t\tString ctxPath = req.getContextPath(); \t\tSystem.out.println(\"ctxPath : \" + ctxPath); \t\t \t\t// 매핑된 주소 - 프로젝트 주소 = 계속 바뀔 뒷자리 주소 구함 \t\tString command = requestURI.substring(ctxPath.length()); \t\tSystem.out.println(\"command : \" + command); \t\t \t\tSystem.out.println(\"C : 가상주소 계산 완료\\n\"); \t\t// 1. 전달되는 가상주소 계산 \t\t \t\t \t\t// 2. 가상주소 매핑 \t\tActionForward forward = null; \t\t \t\tif (command.equals(\"/main.me\")) \t\t{ \t\t\tSystem.out.println(\"C : 메인페이지 호출\"); \t\t\t \t\t\tforward = new ActionForward(); \t\t\tforward.setPath(\"./main/main.jsp\"); \t\t\tforward.setRedirect(false); \t\t} \t\t \t\tSystem.out.println(\"C : 가상주소 매핑 완료\\n\"); \t\t// 2. 가상주소 매핑 \t\t \t\t \t\t// 3. 페이지 이동 \t\tif (null != forward) // 페이지 이동정보가 있을 때 \t\t{ \t\t\tif (forward.isRedirect()) \t\t\t{ \t\t\t\tresp.sendRedirect(forward.getPath()); \t\t\t} \t\t\telse  \t\t\t{ \t\t\t\tRequestDispatcher dis = req.getRequestDispatcher(forward.getPath()); \t\t\t\tdis.forward(req, resp); \t\t\t} \t\t\t \t\t\tSystem.out.println(\"C : 페이지 이동 완료\"); \t\t} \t\t// 3. 페이지 이동 \t} \t \t@Override \tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t}  \t@Override \tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t} }      이런 식으로 서블릿 클래스를 만든 다음     &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"     pageEncoding=\"UTF-8\"%&gt;  &lt;%   response.sendRedirect(\"./main.me\"); %&gt;      실제 실행시킬 페이지인 index.jsp에서는 매핑된 서블릿으로 연결시켜서 실행되도록 했다.     &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"     pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;!-- Start Head --&gt;   &lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- End Head --&gt;  &lt;body class=\"modern\"&gt;  &lt;!-- START MODULE AREA 2: Menu 1 --&gt;   &lt;jsp:include page=\"../inc/subTop.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- END MODULE AREA 2: Menu 1 --&gt;      그리고 이런 식으로 헤더와 푸터 부분은 다른 jsp 페이지로 분리해서 새로운 페이지가 추가되어도 헤더와 푸터 페이지를 액션 태그를 써서 인클루드만 해 주고 헤더와 푸터 부분에서 수정 사항이 생기면 top.jsp, bottom.jsp 페이지만 수정하면 되도록 만들었다.   이렇게 만들어놓고 나니까 헤더 부분에서 수정할 점이 생겨도 페이지 하나만 수정하면 되니까 정말 편하다.      마감까지     D-30  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-01/",
        "teaser": null
      },{
        "title": "C++) BOJ 21921. 블로그",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/21921     제한       시간 제한 : 1 초   메모리 제한 : 512 MB     문제            찬솔이는 블로그를 시작한 지 벌써 N일이 지났다.            요즘 바빠서 관리를 못 했다가 방문 기록을 봤더니 벌써 누적 방문 수가 6만을 넘었다.            찬솔이는 X일 동안 가장 많이 들어온 방문자 수와 그 기간들을 알고 싶다.            찬솔이를 대신해서 X일 동안 가장 많이 들어온 방문자 수와 기간이 몇 개 있는지 구해주자.         입력            첫째 줄에 블로그를 시작하고 지난 일수 N와 X가 공백으로 구분되어 주어진다.            둘째 줄에는 블로그 시작 1일차부터 N일차까지 하루 방문자 수가 공백으로 구분되어 주어진다.         출력            첫째 줄에 X일 동안 가장 많이 들어온 방문자 수를 출력한다. 만약 최대 방문자 수가 0명이라면 SAD를 출력한다.            만약 최대 방문자 수가 0명이 아닌 경우 둘째 줄에 기간이 몇 개 있는지 출력한다.          👀 풀이       입력 배열의 처음부터 X일만큼의 합을 구하면서 한 칸씩 뒤로 이동하는데 그 중 합계가 가장 높은 경우와 그 일수들을 따로 저장해 주었다.   N개 중 X개의 합을 매번 구하면 좀 비효율적이란 생각이 들어 처음에 N 배열의 0번 원소부터 X개의 합을 구한 뒤 그것을 최대값으로 설정한 다음 다른 X개의 합을 구하는 반복문에서는 i가 1부터 시작하면서 i-1번째 원소는 합계에서 빼고 i+(X-1)번째 원소를 더해주며 부분 합계를 구했다.   그 과정에서 현재 최대값과 같은 값이 나오면 최대 일수를 계산하는 카운트를 증가시키고 현재 최대값보다 큰 값이 나오면 카운트를 1로 초기화한 뒤 최대값을 갱신해 주었다.     결과       시간 : 20 ms   메모리 : 2876 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No21921","Sliding Window","C++"],
        "url": "/boj/boj21921-cpp/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 2 - DB 테이블 만들기",
        "excerpt":"개발환경     OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백앤드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황           오늘은 좀 더 진행하기 전에 E-R 다이어그램을 만들면서 DB 테이블을 정리하고 가는 것이 좋을 거 같아서 내 프로젝트에 필요한 E-R 다이어그램을 만들었다.   회원은 게시판에 글과 댓글을 쓰지 않을 수도 있지만 쓴다면 여러 개 쓸 수 있고 게시글과 댓글은 회원이 쓸 때에만 생성될 수 있다. 그리고 댓글 또한 게시글이 없으면 생성될 수 없고 한 게시글에 댓글이 달리지 않을 수도, 여러 개의 댓글이 달릴 수도 있다.   일단 이 정도로 틀을 잡아놓고 테이블들을 생성했다.   1. 회원 테이블(cafe_members)   CREATE TABLE `cafe_members` (   `member_num` int NOT NULL AUTO_INCREMENT,   `id` varchar(10) NOT NULL,   `pass` varchar(10) NOT NULL,   `name` varchar(20) NOT NULL,   `birth` date NOT NULL,   `age` int NOT NULL,   `gender` varchar(2) NOT NULL,   `postalcode` int NOT NULL,   `road_address` varchar(500) NOT NULL,   `detail_address` varchar(500) NOT NULL,   `phone` varchar(11) NOT NULL,   `email` varchar(200) DEFAULT NULL,   `regdate` timestamp NOT NULL,   PRIMARY KEY (`member_num`),   UNIQUE KEY `id` (`id`) );            member_num : 회원 번호. 1부터 차례대로 증가하며 회원의 고유 식별자로 사용   id : 회원 아이디. 중복되지 않도록 unique 조건을 걸어주었다.   pass : 회원 비밀번호   name : 회원 이름   birth : 회원의 생년월일   age : 회원 나이   gender : 회원 성별   postalcode : 우편번호   road_address : 회원의 거주지 도로명 주소   detail_address : 거주지 상세 주소   phone : 회원 휴대폰 번호   email : 회원 이메일 주소   regdate : 회원이 가입한 날짜. timestamp로 가입하는 당시의 날짜와 시간으로 자동 저장   2. 게시글(post)   CREATE TABLE `cafe_board` (   `num` int NOT NULL,   `id` varchar(10) NOT NULL,   `title` varchar(200) NOT NULL,   `content` varchar(5000) NOT NULL,   `readcount` int DEFAULT NULL,   `re_ref` int DEFAULT NULL,   `re_lev` int DEFAULT NULL,   `re_seq` int DEFAULT NULL,   `date` date DEFAULT NULL,   `ip` varchar(200) DEFAULT NULL,   `image` varchar(200) DEFAULT NULL,   `file` varchar(200) DEFAULT NULL,   `comment_count` int DEFAULT NULL,   `image_uid` varchar(200) DEFAULT '없음',   `file_uid` varchar(200) DEFAULT '없음',   PRIMARY KEY (`num`) );            num : 게시글 번호. 1부터 차례대로 증가하며 고유 식별자로 사용   id : 작성자 아이디   title : 게시글 제목   content : 게시글 내용   readcount : 조회수   re_ref : 게시글 그룹. 답글을 달게 되면 몇 번 게시글의 답글인지 구분할 때 쓸 그룹이다.   re_lev : 게시글의 들여쓰기 레벨. 어떤 게시글의 답글이면 1번 들여쓰고 답글의 답글이면 2번 들여쓰는 용도로 사용할 값이다.   re_seq : 게시글 그룹에서 작성된 순서. 어떤 게시글에 답글이 달린 순서를 표시할 값이다.   date : 최초로 작성된 날짜. YYYY-MM-DD 형식   ip : 작성자의 IP 주소   image : 이미지 업로드 시 이미지 파일명   file : 파일 업로드 시 파일명   comment_count : 해당 글에 작성된 댓글 개수   image_uid : 서버에 저장되는 이미지 파일 이름. 서로 다른 사용자가 같은 이름의 파일을 올렸을 때 서버상에서 중복처리된 실제 파일명. 게시글 로드 시 uid 기준으로 첨부된 파일을 불러올 것이다.   file_uid : 서버에 저장되는 파일 이름. 서로 다른 사용자가 같은 이름의 파일을 올렸을 때 서버상에서 중복처리된 실제 파일명   3. 댓글(comment)   create table comment (     num int primary key auto_increment,     post_num int not null,     writer varchar(10) not null,     content longtext not null,     commented_date datetime not null, );            num : 댓글 번호. 1부터 차례대로 증가하며 고유 식별자로 사용   post_num : 댓글이 등록된 글 번호   writer : 댓글 작성자 아이디   content : 댓글 내용   commented_date : 댓글이 작성된 날짜      마감까지     D-29  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-02/",
        "teaser": null
      },{
        "title": "OS) Process Synchronization",
        "excerpt":"👀 Process Synchronization 문제     컴퓨터에 저장되어 있는 어떤 데이터를 변경하려면 그 데이터에 접근해서 변경하는 연산을 한 뒤 연산 결과를 다시 그 데이터가 있는 자리에 갱신시켜줘야 한다.   그런데 이 때 하나의 프로세스만 접근해서 작업을 하면 문제가 없지만 컴퓨터에는 수많은 프로세스가 있고 하나의 데이터에 여러 프로세스가 접근하는 상황이 생길 수 있다.   이 때 아무런 제어 없이 여러 프로세스가 접근해서 하나의 데이터를 변경시키면 서로 다른 시점에 데이터를 변경하게 될 수 있고 그러다보면 데이터가 사용자의 의도와 다르게 변경될 수 있다(데이터 불일치 문제). 그래서 이걸 막고 데이터의 일관성 유지를 위해서 공유 데이터에 접근할 때 협력 프로세스 간의 실행 순서를 정해주어야 한다.   🔸 Race condition     여러 프로세스들이 동시에 공유 데이터에 접근하는 상황   데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐   Race condition을 막기 위해 concurrent process(동시 접근)는 동기화(synchronize)되어야 한다.      Race Condition이 발생하는 상황  1. 커널 수행 중 인터럽트 발생 시     커널 데이터를 처리하는 도중에 인터럽트가 생긴 경우   해결책 : 먼저 작업 중이던 커널 코드의 작업이 끝나기 전 까지는 인터럽트를 받지 않는다.   2. 프로세스가 시스템 콜을 하여 커널 모드로 수행 중인데 context switch가 일어나는 경우     A 프로세스가 PC를 증가시키는 도중에 다른 커널 코드 B에게 CPU를 뺏겼다가 뺏어간 쪽의 작업이 끝난 후 다시 돌려 받으면 A는 B가 증가시키기 전의 PC 정보를 가지고 있기 때문에 A가 증가시키는 PC는 정확한 값으로 증가되지 않는다.   해결책 : 커널 모드에서 수행 중일 때는 CPU를 preempt하지 않고 커널 모드에서 사용자 모드로 돌아갈 때 preempt한다.   3. Multiprocessor에서 shared memory 내의 커널 데이터     위 경우들은 같은 CPU 내에서만 할 수 있는 동작들이기 때문에 멀티 프로세서 환경에서는 적용이 어렵다.   여러 프로세스들이 하나의 공유 메모리에 접근해야 할 때 각각의 CPU에서 동시에 접근해서 데이터를 변경할 수 있다.   해결책 1 : 한 번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법   해결책 2 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법      The Critical-Section Problem     n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우   각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재   하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.   프로그램적 해결법의 충족 조건     Mutual Exclusion(상호 배제/배타적 접근)            프로세스 Pirk critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안 된다.           Progress(진행)            아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해 주어야 한다.           Bounded Waiting(유한 대기)            프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.       무한대로 기다리지 않게 해서 starvation을 방지            가정            모든 프로세스의 수행 속도는 0보다 크다.       프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.           기본적인 해결 방법     두 개의 프로세스 P0, P1이 있다고 가정했을 때   do {     entry section   /* lock */     critical section     exti section    /* unlock */     remainder section } while(1);      프로세스들은 수행의 동기화를 위해 몇몇 변수를 공유할 수 있다. - Synchronization variable   Algorithm 1   int turn;   /* 누구 차례인지 표시할 변수.  Synchronization variable */ initially turn = 0;  do {     while (turn != 0);  /* 내 턴이 아닌 동안 대기 */     critical section     turn = 1;   /* 상대편으로 턴 넘김 */     remainder section } while (1);      위 코드대로만 진행되면 문제가 없어 보이지만 반드시 상대 프로세스가 들어와서 turn을 바꿔 주어야만 다른 프로세스가 critical section에 들어갈 수 있기 때문에 만약 A 프로세스가 더 빈번하게 critical section에 들어가야 하는 경우 B 프로세스는 상대적으로 덜 들어가기 때문에 turn이 바뀌지 않아 A 프로세스가 들어갈 수 없는 상황이 생긴다.   Algorithm 2   boolean flag[2];    /* critical section에 들어가고자 하는 의중을 표시하는 flag */ initially flag[모두] = false; /* 처음엔 critical section에 아무도 없음 */  do {     flag[i] = true;     /* 진입 표시 */     while (flag[j]);    /* 상대 프로세스도 진입해 있으면 대기 */     critical section     flag[i] = false;    /* 나왔다고 표시 */     remainder section } while (1);      위 코드에서는 만약 A 프로세스가 첫번째 줄만 실행하고 CPU를 뺏긴 경우 상대 프로세스도 첫번째 줄을 실행하고 두번째 줄에서 대기하게 될 것이다. 즉 둘 다 무한히 대기하게 된다.   Algorithm 3 (Peterson’s Algorithm)   do {     flag[i] = true;     /* 진입 표시 */     turn = j;           /* 상대편으로 턴 변경 */     while (flag[j] &amp;&amp; turn == j);   /* 들어가고자 하는 프로세스와 턴 모두 확인 */     critical section     flag[i] = false;     remainder section } while (1);      알고리즘 1과 2를 합친 방법으로 앞선 두 가지 방법에서 있었던 문제들을 모두 해결할 수 있다.   Busy Waiting(= spin lock)            하지만 critical section에 프로세스가 이미 있어서 못 들어가는 것이 확실한 상황에서도 계속 CPU를 얻어서 while문 조건을 확인해야 하기 때문에 지속적으로 CPU와 memory를 소모하게 된다.           하드웨어적으로 해결하기     Instruction 하나로 Synchronization variable 읽기와 쓰기를 동시에 실행하면 위의 알고리즘으로 해결하고자 했던 문제들을 간단히 해결할 수 있다.   boolean lock = false;  do {     while (Test_and_set(lock); /* lock이 걸려있다면 lock을 걸고 기다릴 것이고 걸려있지 않다면 lock을 걸고 들어갈 것임 */     critical section     lock = false;     remainder section } while (1);       Semaphores     프로그래머가 매번 앞의 작업들을 하려면 귀찮으니까 그 작업들을 추상화시킨 것   integer variable 형태로 자원의 갯수를 가지고 있다.   아래의 두 가지 atomic 연산에 의해서만 접근할 수 있다.   /* P(S) : 공유 데이터를 획득하는 연산 */ while (S &lt;= 0) do wait; /* 사용할 수 있는 자원이 없으면 대기 */ S--;  /* V(S) : 공유 데이터를 사용 후 반납 */ S++;   세마포어를 이용한 코드 - Busy-wait   semaphore mutex;    /* initially 1 : 1개가 critical section에 들어갈 수 있다 */  do {     P(mutex);   /* 자원이 남아 있으면 하나 감소시키고 입장 */     critical section     V(mutex);   /* 자원 반납 및 증가 */     remainder section } while (1);      대기하는 프로세스가 있으면 자원이 생겼는지 계속 확인해야 하기 때문에 busy-wait하게 된다.   세마포어를 이용한 코드 - Block &amp; wekeup     세마포어를 다음과 같이 정의한다.   typedef struct {     int value;          /* semaphore */     struct process *L;  /* 프로세스 대기열 */ } semaphore;      block과 wakeup을 다음과 같이 가정한다.            block : 커널은 block을 호출한 프로세스를 suspend 시킨 후 이 프로세스의 PCB를 세마포어에 대한 대기열에 넣음       wakeup : block된 프로세스를 wakeup 시킨 후 이 프로세스의 PCB를 ready queue로 옮김           세마포어 연산 정의   /* P(S) */ S.value--;  /* 입장 전에 자원의 수를 감소시킴 */ if (S.value &lt; 0)    /* 현재 쓸 수 있는 자원이 없으면 대기시킨다 */ {     add this process to S.L;     block(); }  /* V(S) */ S.value++; if (S.value &lt;= 0)   /* P 연산에서 자원을 미리 감소시키고 들어가기 때문에 자원을 반납했는데도 갯수가 0 이하라면 기다리고 있는 프로세스가 있는 것 */ {     remove a process P from S.L;     wakeup(P); }   👀 Busy-wait vs. Block/wakeup     critical section의 길이가 긴 경우 Block/wakeup이 적당   critical section의 길이가 매우 짧은 경우 Block/wakeup 오버헤드가 Busy-wait 오버헤드보다 더 커질 수 있다.   일반적으로는 Block/wakeup 방식이 좋다.     세마포어의 두 종류     Counting semaphore            도메인이 0 이상인 임의의 정수값       주로 리소스의 갯수를 세는 데 사용한다.           Binary semaphore            0 또는 1 값만 가질 수 있는 세마포어       주로 mutual exclusion (lock/unlock)에 사용           Deadlock and Starvation  Deadlock     둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상   1과 2 두 개의 자원을 얻어야 하는 A 프로세스가 있을 때 만약 A 프로세스가 1번 자원만 얻고 B 프로세스에게 CPU를 뺏긴 후 B 프로세스가 2번 자원을 얻으면 A 프로세스는 CPU를 다시 돌려받아도 2번 자원을 얻지 못해서 다음으로 진행할 수 없다. B 프로세스 또한 1번 자원이 필요하다면 영원히 기다리게 된다.   이러한 현상을 해결하기 위해서 자원을 획득하는 순서를 정해줘서 1번 자원을 먼저 얻어야만 2번 자원을 얻을 수 있게 하는 방식을 사용할 수 있다.   Starvation     indefinite blocking   프로세스가 suspend된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상      Classical Problems of Synchronization  🔸 Bounded buffer problem     Producer-Consumer Problem이라고도 하며 데이터 입력을 위한 버퍼를 생성하는 생산자와 그 버퍼를 읽어서 수정된 데이터를 반영할 소비자로 나누는 개념이다.   생산자는 빈 버퍼가 있는지 확인 후(없으면 기다림) 공유데이터에 lock을 걸고 버퍼에 데이터를 입력한 다음 lock을 풀고 든 버퍼를 하나 증가시킨다.   소비자는 든 버퍼가 있는지 확인 후(없으면 기다림) 공유데이터에 lock을 걸고 버퍼에서 데이터를 꺼낸 뒤 lock을 풀고 빈 버퍼를 하나 증가시킨다.   공유 데이터     버퍼 및 버퍼 조작 변수(empty/full buffer의 시작 위치)   동기화 변수     mutual exclusion : 공유데이터의 mutual exclusion을 위해 필요   resource count : 남은 empty/full buffer의 수를 표시하기 위해 필요   /* Producer */ do {     produce an item in x     ...     P(empty);     P(mutex);     ...     add x to buffer     ...     V(mutex);     V(full); } while (1);  /* Consumer */ do {     P(full);     P(mutex);     ...     remove an item from buffer to y     ...     V(mutex);     V(empty);     ...     consume the item in y     ... } while (1);   🔸 Readers-Writers Problem     한 프로세스가 DB에 write 중일 때 다른 프로세스가 접근하면 안 됨   read는 동시에 여럿이 해도 됨   solution            Writer가 DB에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기 중인 Reader들을 다 DB에 접근하게 해준다.       Writer는 대기 중인 Reader가 하나도 없을 때 DB 접근이 허용된다.       일단 Writer가 DB에 접근 중이면 Reader들은 접근이 금지된다.       Writer가 DB에서 빠져 나가야만 Reader의 접근이 허용된다.           공유 데이터     DB 자체   readcount : 현재 DB에 접근 중인 Reader의 수   동기화 변수     mutex : 공유 변수 readcount를 접근하는 코드(critical section)의 mutual exclusion 보장을 위해 사용   db : Reader와 Writer가 공유 DB 자체를 올바르게 접근하는 역할   int readcount = 0; DB 자체; semaphore mutex = 1, db = 1;  /* Writer */ P(db); ... writing DB ... ... V(db);  /* Reader */ P(mutex); readcount++; if (readcount == 1) P(db);  /* Writer 대기시킴 */ V(mutex); ... reading DB ... ... P(mutex); readcount--; if (readcount == 0) V(db);  /* Writer 입장 가능 */ V(mutex);      하지만 위 코드대로만 하면 Reader가 계속 들어와서 Writer가 영원히 기다리게 될 수 있기 때문에(starvation) Writer의 우선순위를 높여줘서 너무 오래 기다리지 않게 한다.   🔸 Dining-Philosophers Problem     다섯 명의 철학자가 원형 테이블에 앉아서 생각과 식사를 반복하는데 젓가락이 5개(2개 세트 아님)밖에 없음   철학자는 내 양 옆에 있는 젓가락을 옆에 있는 철학자들이 쓰고 있지 않아야 젓가락을 사용해 밥을 먹을 수 있다.   이 때 어떤 철학자의 양 옆에 있는 철학자들이 계속 밥을 먹어서 어떤 철학자가 젓가락을 영원히 쓰지 못하면 굶어 죽는다는.. 그런 문제이다.   해결 방안            4명의 철학자만 테이블에 동시에 앉을 수 있도록 한다.       젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다.       비대칭 : 짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록 한다.              Monitor  세마포어의 문제점     코딩하기 힘들다. - 문제가 생겼을 때 버그 잡기 힘듦   정확성(correctness)의 입증이 어렵다.   자발적 협력(voluntary cooperation)이 필요하다.   한 번의 실수가 모든 시스템이 치명적인 영향을 끼친다.   예   V(mutex) critical section P(mutex)     Mutual exclusion이 깨짐    P(mutex) critical section P(mutex)          Deadlock             위 경우들처럼 순서가 바뀌거나 같은 연산을 두 번 쓰는 실수가 생기면 오작동이 생긴다.       Monitor     동시 수행 중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기 위한 high-level synchronization construct   객체 지향 프로그래밍에서 class에 멤버 변수와 함수를 담아서 사용하듯이 공유 데이터를 모니터 안에 선언하고 공유 데이터에 접근하려면 모니터 내부의 함수를 통해서만 하도록 하는 방법   모니터 내의 함수는 한 번에 하나만 실행할 수 있기 때문에 lock을 걸 필요가 없다. 그래서 프로그래머 입장에서는 좀 더 간편하게 프로그램을 짤 수 있다.      출처     운영체제 - 이화여자대학교 KOCW 공개강의  ","categories": ["Operating System"],
        "tags": ["CS","OS","Process","Synchronization"],
        "url": "/operating%20system/OS-06-process-synchronization/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 3 - 회원가입 기능 만들기",
        "excerpt":"개발환경     OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     오늘은 저번 시간에 만든 DB 테이블과 내가 만든 사이트를 연동해서 회원가입 기능을 구현했다.   1. xml 파일 만들기     DB 연결이 필요한 페이지마다 DB 연결을 위한 코드를 작성하면 비효율적이니까 먼저 xml 파일에 연결에 필요한 정보를 저장한 후 불러온다.   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;Context&gt;   &lt;!-- Context : 프로젝트 --&gt;   &lt;Resource      name=\"디비에 접근하기 위한 이름\"      auth=\"컨테이너 자원 관리자 설정 - Application or Container\"      type=\"리소스를 사용할 때 실제로 사용되는 클래스 타입\"      username=\"디비 아이디\"      password=\"디비 비밀번호\"      driverClassName=\"드라이버 주소\"      url=\"디비 연결 주소\"      maxActive=\"커넥션 회수 대기시간\"   /&gt; &lt;/Context&gt;      기본 형식과 각 라인의 의미는 위와 같으며   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;Context&gt;   &lt;Resource     name = \"jdbc/cafe\"      auth = \"container\"      type = \"javax.sql.DataSource\"      driverClassName = \"com.mysql.cj.jdbc.Driver\"      url = \"jdbc:mysql://localhost:3306/cafedb\"      username = \"root\"     password = \"1234\"   /&gt; &lt;/Context&gt;      나는 이렇게 작성했다.   2. DTO, DAO 클래스 만들기     회원 가입에 필요한 정보를 모아서 한꺼번에 전달할 수 있는 객체를 만들기 위해 MemberDTO 클래스를 만들었다.   import java.sql.Date; import java.sql.Timestamp;  public class MemberDTO  { \tprivate int num; \tprivate String id; \tprivate String pass; \tprivate String name; \tprivate Date birth; \tprivate int age; \tprivate String gender; \tprivate String address; \tprivate String phone; \tprivate String email; \tprivate Timestamp regdate; \t     // getter/setter 작성 }      그리고 DB 연결을 처리할 서블릿 클래스를 만들었다. 커넥션 풀을 사용하도록 구현했다.   import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet;  import javax.naming.Context; import javax.naming.InitialContext; import javax.sql.DataSource;  public class MemberDAO  { \tprivate Connection con = null; \tprivate PreparedStatement pstmt = null; \tprivate ResultSet rs = null; \tprivate String sql = \"\"; \t \t// DB 연결정보 준비 \tprivate Connection getCon() throws Exception \t{ \t\t// Context 객체 생성 \t\tContext initCTX = new InitialContext(); \t\tDataSource ds = (DataSource) initCTX.lookup(\"java:comp/env/jdbc/cafe\"); \t\tcon = ds.getConnection(); \t\tSystem.out.println(\"DAO : 1.2. DB 연결 성공\"); \t\tSystem.out.println(\"DAO : \" + con); \t\t \t\treturn con; \t} \t \t// DB 자원해제 \tpublic void CloseDB() \t{ \t\ttry  \t\t{ \t\t\tif (null != rs) rs.close(); \t\t\tif (null != pstmt) pstmt.close(); \t\t\tif (null != con) con.close(); \t\t}  \t\tcatch (Exception e)  \t\t{ \t\t\te.printStackTrace(); \t\t} \t}       // insertMember(dto) \tpublic void insertMember(MemberDTO dto) \t{ \t\tSystem.out.println(\"insertMember(dto) 호출\"); \t\t \t\t// 1.2. DB 연결 \t\ttry  \t\t{ \t\t\tcon = getCon(); \t\t\t \t\t\t// 3. sql 작성 &amp; pstmt 연결 \t\t\tsql = \"insert into cafe_members(id, pass, name, birth, age, gender, address, phone, email, regdate) \" \t\t\t\t\t+ \"values(?,?,?,?,?,?,?,?,?,?)\"; \t\t\t \t\t\tpstmt = con.prepareStatement(sql); \t\t\t \t\t\tpstmt.setString(1, dto.getId()); \t\t\tpstmt.setString(2, dto.getPass()); \t\t\tpstmt.setString(3, dto.getName()); \t\t\tpstmt.setDate(4, dto.getBirth()); \t\t\tpstmt.setInt(5, dto.getAge()); \t\t\tpstmt.setString(6, dto.getGender()); \t\t\tpstmt.setString(7, dto.getAddress()); \t\t\tpstmt.setString(8, dto.getPhone()); \t\t\tpstmt.setString(9, dto.getEmail()); \t\t\tpstmt.setTimestamp(10, dto.getRegdate()); \t\t\t \t\t\t// 4. sql 실행 \t\t\tpstmt.executeUpdate(); \t\t\t \t\t\tSystem.out.println(\"DAO : 회원가입 완료\"); \t\t}  \t\tcatch (Exception e)  \t\t{ \t\t\te.printStackTrace(); \t\t} \t\tfinally  \t\t{ \t\t\tCloseDB(); \t\t} \t\t \t\tSystem.out.println(\"DAO : insertMember(dto) 끝!\"); \t} \t// insertMember(dto) }   3. 회원가입 처리 동작을 수행할 Action 클래스 만들기     jsp 페이지에서 회원가입 처리를 수행하지 않고 자바 클래스에서 처리할 것이다.   Action 페이지에서 구현해야 하는 기능을 빼먹지 않고 강제하기 위해서 인터페이스를 implements 한 뒤 오버라이딩하여 구현했다.   import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public interface Action  { \tpublic ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception; }  import java.sql.Date; import java.sql.Timestamp;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  // 회원가입 처리동작 수행 // model 객체로 pro 페이지 역할을 한다. public class MemberJoinAction implements Action { \t@Override \tpublic ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception  \t{ \t\tSystem.out.println(\"M : MemberJoinAction - execute() 호출\"); \t\t \t\t// 한글처리 \t\trequest.setCharacterEncoding(\"UTF-8\"); \t\t \t\t// 전달받은 파라미터 저장 (JSP 페이지가 아니므로 액션태그는 쓸 수 없고 setter를 이용해 저장한다) \t\tMemberDTO dto = new MemberDTO(); \t\tdto.setId(request.getParameter(\"id\")); \t\tdto.setPass(request.getParameter(\"pass\")); \t\tdto.setName(request.getParameter(\"name\")); \t\tdto.setAddress(request.getParameter(\"address\")); \t\tdto.setAge(Integer.parseInt(request.getParameter(\"age\"))); \t\tdto.setBirth(Date.valueOf(request.getParameter(\"birth\"))); \t\tdto.setEmail(request.getParameter(\"email\")); \t\tdto.setGender(request.getParameter(\"gender\")); \t\t \t\t// 폰번호 3개 필드 합친 후 저장 \t\tStringBuilder sb = new StringBuilder(); \t\tsb.append(request.getParameter(\"phone1\")); \t\tsb.append(request.getParameter(\"phone2\")); \t\tsb.append(request.getParameter(\"phone3\")); \t\tdto.setPhone(sb.toString()); \t\t \t\t// 날짜 정보 추가 저장 \t\tdto.setRegdate(new Timestamp(System.currentTimeMillis())); \t\t \t\tSystem.out.println(\"M : 전달된 회원 정보 저장\"); \t\tSystem.out.println(\"M : \" + dto); \t\t \t\t// DAO 객체 생성 \t\tMemberDAO dao = new MemberDAO(); \t\t \t\t// 회원가입 메서드 호출 \t\tdao.insertMember(dto); \t\t \t\tSystem.out.println(\"M : 회원가입 완료\"); \t\t \t\t// 페이지 이동 (로그인 페이지로 - ./login.me) \t\tActionForward forward = new ActionForward(); \t\tforward.setPath(\"./login.me\"); \t\tforward.setRedirect(true); // Action 페이지를 노출하지 않고 가상 주소를 보여줘야 하니까 true로 설정해서 주소줄에 표시되는 주소를 바꾼다. \t\t \t\treturn forward; \t} }      DB 테이블에서 회원의 생년월일 정보를 DATE 타입으로 설정했기 때문에 이 단계에서 생년월일은 어떻게 세팅해서 넣어줘야 하는지 몰라서 좀 헤멨다. 그 동안 Timestamp만 쓰고 Date를 쓰는 것이 처음이었기 때문에…😅   처음엔 YYYY-DD-MM 형태로 입력되는 데이터에서 ‘-‘을 빼고 숫자만 있는 형태로 new Date 객체를 생성해서 넣어보기도 하는 등 헤메다가 구글링 후 Date.valueOf(\"YYYY-DD-MM\") 형태로 넣어주면 된다는 것을 알게 되어서 request 객체의 getParameter()를 그대로 넣었다.   jsp 페이지의 &lt;input&gt; 태그의 date 타입으로 입력받기 때문에 전달되는 데이터의 형태가 YYYY-DD-MM였다.   4. 회원가입 페이지에서 MemberJoinAction 클래스 연결     join.jsp 페이지에서 폼태그의 action 부분을 수정한다.   &lt;h3&gt;회원가입&lt;/h3&gt;    &lt;form id=\"join\" action=\"./MemberJoinAction.me\" method=\"post\"&gt;    &lt;div class=\"formRow\"&gt;    &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;아이디 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"id\"&gt;    &lt;/div&gt;    &lt;div class=\"formRow\"&gt;    &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"password\" name=\"pass\"&gt;    &lt;/div&gt;    ...   5. Controller에서 Action 클래스 연결하기     MemberFrontController 클래스의 doProcess() 함수의 가상주소 매핑 부분을 수정한다.   protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  { \t// 1. 전달되는 가상주소 계산 \t...          \t// 2. 가상주소 매핑 \tAction action = null; \tActionForward forward = null; \t\t \tif (command.equals(\"/main.me\") || command.equals(\"/join.me\") || command.equals(\"/login.me\")) \t{ \t\tforward = new ActionForward();  \t\tif (command.equals(\"/main.me\")) \t\t{ \t\t\tSystem.out.println(\"C : 메인페이지 호출\"); \t\t\tforward.setPath(\"./main/main.jsp\");\t\t\t\t \t\t} \t\telse if (command.equals(\"/join.me\")) \t\t{ \t\t\tSystem.out.println(\"C : 회원가입 페이지 호출\"); \t\t\tforward.setPath(\"./member/join.jsp\");\t\t\t\t \t\t} \t\telse if (command.equals(\"/login.me\")) \t\t{ \t\t\tSystem.out.println(\"C : 로그인 페이지 호출\"); \t\t\tforward.setPath(\"./member/login.jsp\");\t\t\t\t \t\t} \t\t\t \t\tforward.setRedirect(false); \t} \telse if (command.equals(\"/MemberJoinAction.me\")) \t{ \t\tSystem.out.println(\"C : /MemberJoinAction.me 호출\"); \t\tSystem.out.println(\"C : 이전 페이지 정보를 가져와서 DB 테이블에 저장 후 페이지 이동\"); \t\t\t \t\taction = new MemberJoinAction(); // 인터페이스를 통해 객체를 생성함으로써 약한결합이 되도록 한다. \t\t\t \t\ttry  \t\t{ \t\t\tforward = action.execute(req, resp); \t\t}  \t\tcatch (Exception e)  \t\t{ \t\t\te.printStackTrace(); \t\t} \t} \t\t \tSystem.out.println(\"C : 가상주소 매핑 완료\\n\"); \t// 2. 가상주소 매핑              // 3. 페이지 이동     ... }   6. 동작 테스트 결과!        잘 들어간다!   그리고 회원가입이 완료되면 로그인 페이지로 이동하는 것까지 잘 구현되었다.   뿌듯-!😄      마감까지     D-28  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-03/",
        "teaser": null
      },{
        "title": "OS) Deadlock",
        "excerpt":"👀 Deadlock(교착상태)란?     일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태   Resource(자원)     하드웨어, 소프트웨어 등을 포함하는 개념   예) I/O device, CPU cycle, memory space, semaphore 등   프로세스가 자원을 사용하는 절차            Request -&gt; Allocate -&gt; Use -&gt; Release           데드락이 발생하는 예     시스템에 2개의 tape drive가 있고 프로세스 P1, P2 각각이 하나의 tape drive를 보유한 채 다른 하나를 기다리고 있는 경우     P0          P1 P(A);       P(B); P(B);       P(A);      두 세마포어가 필요한 자원을 서로 자원을 하나씩 가진 상태에서 상대가 내놓기를 기다리는 경우   데드락 발생의 4가지 조건  Mutual exclusion (상호 배제)     매 순간 하나의 프로세스만이 자원을 사용할 수 있음   No preemption (비선점)     프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음   Hold and wait (보유 대기)     자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음   Circular wait (순환 대기)     자원을 기다리는 프로세스간에 사이클이 형성되어야 함   프로세스 1, 2, 3, 4가 있을 때            1은 2가 가진 자원을 기다림       2는 3이 가진 자원을 기다림       3은 4가 가진 자원을 기다림       4는 1이 가진 자원을 기다림             데드락 처리 방법  Deadlock Prevention     자원 할당 시 데드락의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것   Deadlock Avoidance     자원 요청에 대한 부가적인 정보를 이용해서 데드락의 가능성이 없는 경우에만 자원 할당   시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당   Deadlock Detection and recovery     데드락 발생은 허용하되 그에 대한 detection 루틴을 두어 데드락 발견시 recover   Deadlock Ingorance     데드락을 시스템이 책임지지 않음   UNIX를 포함한 대부분의 OS가 채택   데드락 자체가 자주 발생하는 일이 아니기 때문에 데드락에 대비한다고 시스템의 자원 분배를 조절하는 것은 비효율적이기 때문에 사용자가 알아서 처리하도록 한다.     데드락 방지  Mutual exclusion     공유해서는 안 되는 자원의 경우 반드시 성립해야 함   즉 이 조건이 반드시 성립한다면 데드락이 발생할 수 없다.   Hold and Wait     프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다.   방법 1 : 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법   방법 2 : 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청   No Preemption     프로세스가 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨   모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작됨   즉 자원을 선점할 수 있게 하는 것   state를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용 (예: CPU, memory)   Circular Wait     모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당   예를 들어 순서가 3인 자원을 보유 중인 프로세스가 순서가 1인 자원을 할당받기 위해서는 우선 순서 3을 release해야 한다.        자원 요청 사이클이 생성되지 않게 하는 것        하지만 위 기법들을 적용하면 Utilization(이용률) 저하, Throughput(성능) 감소, Starvation 문제가 생겨서 굉장히 비효율적이다.     Deadlock Avoidance     자원 요청에 대한 부가정보를 이용해서 자원 할당이 데드락으로부터 안전한지 동적으로 조사해서 안전한 경우에만 할당   가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법   Resource Allocation Graph algorithm     자원당 하나의 인스턴스만 있을 때 사용하는 방법   자원들과 프로세스들 간을 실선과 점선으로 잇는 그래프를 그려 할당과 요청된 자원은 실선으로 표시하고 어떤 프로세스가 미래에 한 번은 사용할 수 있는 자원은 점선으로 표시하는 것이다.   새로운 자원 요청이 들어오면 실선을 점선으로 바꿨을 때 사이클이 생기지 않을 때에만 요청 자원을 할당한다.   사이클 생성 여부 조사시 프로세스의 수가 n일 때 O(n^2) 시간이 걸린다.   Banker’s Algorithm     가정            모든 프로세스는 자원의 최대 사용량을 미리 명시       프로세스가 요청 자원을 모두 할당받은 경우 유한 시간 안에 이들 자원을 다시 반납한다.           방법            기본 개념 : 자원 요청 시 safe 상태를 유지할 경우에만 할당       총 요청 자원의 수가 가용 자원의 수보다 적은 프로세스를 선택 (그런 프로세스가 없으면 unsafe 상태)       위의 경우에 부합하는 프로세스가 있으면 그 프로세스에게 자원 할당       할당받은 프로세스가 종료되면 모든 자원 반납       모든 프로세스가 종료될 때까지 이러한 과정 반복           Deadlock Detection and Recovery  Detection     Banker's Algorithm과 유사한 방법으로 사이클의 존재 여부를 주기적으로 검사하여 자원을 할당하는 방법이 있다.   Recovery  Process termination     데드락 된 모든 프로세스 종료   데드락이 해결될 때 까지 데드락에 갇혀 있는 프로세스를 하나씩 종료   Resource preemption     비용을 최소화 할 victim 선정   safe state로 rollback하여 프로세스 재시작   Starvation 문제            동일한 프로세스가 계속해서 victim으로 선정되는 경우       cost factor에 rollback 횟수도 같이 고려             Deadlock Ignorance     데드락이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음   데드락은 매우 드물게 발생하므로 데드락에 대한 조치 자체가 더 큰 오버헤드일 수 있다.   만약, 시스템에 데드락이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처   UNIX, Windows 등 대부분의 범용 OS가 채택      출처     운영체제 - 이화여자대학교 KOCW 공개강의  ","categories": ["Operating System"],
        "tags": ["CS","OS","Process","Deadlock"],
        "url": "/operating%20system/OS-07-Deadlock/",
        "teaser": null
      },{
        "title": "C++) BOJ 2579. 계단 오르기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/2579     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제            계단 오르는 데는 다음과 같은 규칙이 있다.       계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.   연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.   마지막 도착 계단은 반드시 밟아야 한다.        따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.       각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.     입력            입력의 첫째 줄에 계단의 개수가 주어진다.            둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.         출력       첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.      👀 풀이            참고 풀이 : https://yabmoons.tistory.com/510        dp로 어떻게 풀어야 할 지 대충은 알겠는데 구체적인 풀이가 안 떠올라서 구글링했다.   처음에는 1번 계단과 2번 계단부터 시작하는 경우를 나눈 규칙에 따라 다음 계단을 올라가며 최대값을 구하는데 마지막 계단을 밟지 못하는 경우가 생길수도 있으니까 규칙에 따라 왔을 때 마지막 계단에 도착하지 못하면 다시 되돌아가서 다른 경우를 탐색하는 방식으로 하려 했었다.        그래서 재귀로 짜려고 했는데 되돌아가서 다시 탐색해야 하는 경우에 대한 조건 설정하는 것이 너무 애매해서 할 수 없었다 ㅠㅠ 그래서 구글링…             문제 풀이의 키포인트는 i번째 계단을 밟았을 때 얻을 수 있는 최대값을 구해서 dp 배열에 저장하는 것인데             1번 계단에 왔을 때의 최대값은 1번 계단의 값이다.             2번 계단에 왔을 때의 최대값은 1번+2번 계단의 값이 될 것이다.             3번 계단에 왔을 때의 최대값은 1번+3번 계단 or 2번+3번 계단의 값만 가능하다.        4번 계단에 왔을 때의 최대값은 1번+3번+4번 계단 or 2번+4번 계단 or 1번+2번+4번 계단의 값이 가능하다.   여기서 2, 3번째 경우를 보면 둘 다 2번 계단을 밟고 4번까지 오는데 두 경우 중 1+2+4번 경우가 항상 더 큰 값이 나올 것이다.   그래서 4번 계단에 왔을 때엔 1번+3번+4번 계단 or 1번+2번+4번 계단의 값 중 하나가 최대값이 될 것이다.   이걸 바꿔 표현하면 1번까지 왔을 때의 최대값 + 3번 + 4번 or 2번까지 왔을 때의 최대값 + 4번이 된다.   여기서 4에 i를 대입하면 i번째 계단 = i-3까지 왔을 때의 최대값 + i-1번째 계단 + i번째 계단 or i-2까지 왔을 때의 최대값 + i번째 계단이 된다.   dp 배열에 대입하면 dp[i]는 i번째 계단에 왔을 때의 최대값이라고 정의하면        dp[i] = max(dp[i-3] + stair[i-1] + stair[i], dp[i-2] + stair[i])        dp 배열의 마지막 계단 인덱스값을 출력하면 정답이 된다.     결과       시간 : 0 ms   메모리 : 2020 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2579","DP","C++"],
        "url": "/boj/boj1525-cpp/",
        "teaser": null
      },{
        "title": "컴퓨터구조) Function과 매크로 함수의 차이점",
        "excerpt":"Function     function call이 이뤄짐에 따라 중간에 생기는 연산값을 저장하고 불러오는 과정이 필요하며 return값에 따라 Jump &amp; Link가 이뤄져야 하고 그에 따라 스택 프레임 포인터도 변경해줘야 하는 등 할 게 많다.   function call과 return 없이 순차적으로 실행하는 코드에 비해 수행해야 할 명령어의 수가 많아지기 때문에 오버헤드가 커지고 성능이 떨어진다.   매크로 함수     함수를 매크로로 작성하면 실행 될 때 Text 영역에 위치하게 된다. 즉 형태는 function call을 하는 것 같지만 프로그램 코드로 인식되어 Text 영역에 있기 때문에 Jump &amp; Link가 발생하지 않아 오버헤드가 적고 성능이 올라간다.   하지만 그만큼 Text가 길어져서 그만큼 차지하는 공간이 늘어나게 된다.    👀 두 방식에 각각 장단점이 있기 때문에 상황에 맞게 사용하면 된다.   오버헤드     부담이라 할 수 있다.   추가적으로 해야 하는 일이기 때문에 컴퓨터가 어떤 작업을 수행할 때 오버헤드가 크다는 것은 그 작업을 수행하기 위해 필요한 명령어의 수가 많아지기 때문이라고 할 수 있다.      출처     컴퓨터구조 - 고려대학교 KOCW 공개강의  ","categories": ["Computer Science"],
        "tags": ["CS","function"],
        "url": "/computer%20science/function/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 4 - 회원가입 유효성 검사하기",
        "excerpt":"개발환경     OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     오늘은 저번에 구현한 기본적인 회원가입 틀에서 사용자가 입력한 정보의 유효성을 검사하는 코드를 추가했다.   Ajax를 이용해 비동기방식으로 사용자가 입력한 아이디의 중복체크를 하려 했는데 학원 선생님이 워낙 짧게 알려주고 수업 시간이 다 끝나버린 데다 나도 웹 개발은 처음이라 당초 예상과 다르게 아이디 유효성 체크를 구현하는 데에 오랜 시간이 소요되었다.   그래도 숱한 구글링 끝에 아이디 중복체크 부분은 내가 원하는대로 구현이 되었다!   내가 모티브로 잡고 구현했던 기능은 네이버 회원가입 페이지의 아이디 중복검사 기능이다.   회원가입 페이지에 아이디 중복여부를 알려주는 문구 추가      join.jsp   &lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- jQuery 라이브러리 로드 부분은 top.jsp에 있음 --&gt; &lt;script src=\"${pageContext.request.contextPath}/js/join.js\"&gt;&lt;/script&gt;  ... 중간 생략  &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;아이디 &lt;/label&gt;&lt;input type=\"text\" name=\"id\" id=\"id\" placeholder=\"5~10자 이내의 영문+숫자만 입력하세요.\"&gt;     &lt;/div&gt; &lt;div id=\"idMsg\"&gt;&lt;/div&gt;      jQuery를 이용해서 &lt;div id=\"idMsg\"&gt;&lt;/div&gt; 태그에 중복인지 아닌지 알려주는 메세지를 삽입할 것이다.   MemberFrontController.java   package com.project.cafe.member.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class MemberFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null;          // .. 생략         else if (command.equals(\"/IdCheck.me\"))         {             System.out.println(\"C : /IdCheck.me 호출\"); \t\t\t             action = new IdCheck(); \t\t\t             try {                 forward = action.execute(req, resp);             }             catch (Exception e) {                 e.printStackTrace();             }         }         // .. 생략 \t\t \t\t         // 3. 페이지 이동         // .. 생략 \t} \t \t@Override \tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t}  \t@Override \tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t} }      컨트롤러에서 DB접속 동작을 수행할 서블릿 IdCheck와 연결시켜 준다.   IdCheck.java   package com.project.cafe.member.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.member.db.MemberDAO;  public class IdCheck implements Action {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : IdCheck - execute() 호출\"); \t\t         MemberDAO dao = new MemberDAO();         PrintWriter out = response.getWriter();         boolean result = dao.isExist(request.getParameter(\"id\"));         if (result)             out.print(\"false\");         else              out.print(\"true\"); \t\t         out.close(); \t\t         return null; \t} }      PrintWriter를 이용해 출력 스트림을 만들어 DB 검색 결과를 보내도록 했다. 검색 결과가 있다면 중복되는 아이디가 있어서 사용할 수 없는 아이디니까 false, 없다면 중복되는 아이디가 없어서 사용 가능한 아이디니까 true   이 부분을 구현하면서 출력 스트림에 대해 다시 공부하게 되어서 좋았다! 역시 그냥 배우는 것 보다는 직접 써 봐야 머리에 잘 들어온다.   MemeberDAO - isExist(id)   // isExist(id) public boolean isExist(String id) {     System.out.println(\"DAO : isExist() 호출\"); \t\t     try {         // 1. 2. DB 연결         con = getCon(); \t\t\t         // 3. sql 작성 &amp; pstmt 연결         sql = \"select id from cafe_members where id=?\";         pstmt = con.prepareStatement(sql);         pstmt.setString(1, id); \t\t\t         // 4. sql 실행         rs = pstmt.executeQuery(); \t\t\t         System.out.println(\"DAO : 아이디 정보 조회 완료\"); \t\t\t         if (rs.next()) return true;         else return false;     }      catch (Exception e) {         e.printStackTrace();     }     finally {         CloseDB();     } \t\t     System.out.println(\"DAO : isExist(id) 끝!!!\"); \t\t     return true; } // isExist(id)      매개변수로 받은 아이디를 이용해 DB에서 조회한 후 해당 아이디가 존재한다면 true를, 존재하지 않으면 false를 리턴하도록 했다.   매개변수로 받은 아이디가 존재하지 않을 때에만(return false) 모든 정보를 입력했을 때에 회원가입 프로세스가 진행되도록 할 것이기 때문에 기본 리턴값은 true로 설정했다.   join.js   $(document).ready(function(){     var $idCheck = idCheck(); });  function idCheck() {     var ret; \t     $('#id').blur(function(){         $.ajax({             type: 'POST',             async: false,             url: './idCheck.me',             data: {                 'id': $('#id').val()             },             dataType: 'text',             success: function(data) {                 if (data === 'true')                 {                     var userId = $('#id').val();                     if (5 &gt; userId.length || 10 &lt; userId.length)                     {                         $id = false;                         $('#idMsg').text('5자리 이상 10자리 이하로 입력해 주세요.');                         $('#idMsg').css('color', 'red');                     }                     else                      {                         ret = true;                         $('#idMsg').text('사용할 수 있는 아이디입니다.');                         $('#idMsg').css('color', 'green');                     }                 }                 else                  {                     ret = false;                     $('#idMsg').text('이미 존재하는 아이디입니다.');                     $('#idMsg').css('color', 'red');                 }             },             error: function(data) {                 console.log('error');             }         });     }); \t     return ret; }      IdCheck에서 출력 스트림으로 받은 결과값을 이용해 아이디 입력란 하단에 출력할 메세지를 결정하는데 리턴값이 false라면 사용불가 메세지를 바로 출력하면 되지만 true인 경우에 사용가능 메세지를 바로 출력하니까 아이디를 입력하지 않고 입력란 바깥을 클릭했을 때에도 사용가능한 아이디라는 메세지가 출력되었다. 아이디를 입력하지 않았을 때에도 DB에서 검색되지 않을 테니까 최종적으로 사용이 가능하다는 파라미터가 리턴될 것이다.        그래서 리턴값이 true인 경우에는 아이디 입력란에 입력되어 있는 문자열의 길이를 검사한 후 그에 따라 분기를 나누었다.       여기까지 해서 네이버 회원가입 페이지의 아이디 중복검사 기능과 같게 구현했다! 뿌듯뿌듯 ☺️               진행상황 2         휴대폰 번호 입력받는 부분을 세 칸으로 나누었기 때문에 각 필드마다 정해진 자리수만큼 입력하면 다음 칸으로 자동으로 커서가 넘어가도록 하는 부분을 구현했다.   1. 사용자에게서 휴대폰 번호 입력받는 부분 수정     join.jsp   &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_TelField\"&gt;휴대폰 번호 &lt;/label&gt;     &lt;label class=\"phone\"&gt;     &lt;input id=\"phone1\" type=\"tel\" name=\"phone1\" size=\"1\" maxlength=\"3\" oninput=\"tabCursor(1)\"&gt; -      &lt;input id=\"phone2\" type=\"tel\" name=\"phone2\" size=\"3\" maxlength=\"4\" oninput=\"tabCursor(2)\"&gt; -      &lt;input id=\"phone3\" type=\"tel\" name=\"phone3\" size=\"3\" maxlength=\"4\"&gt;     &lt;/label&gt; &lt;/div&gt;   2. javascript로 커서 이동하는 함수 구현     join.js   // 휴대폰 번호 필드 1, 2번 칸에서 지정된 숫자만큼 입력하면 다음 칸으로 커서 넘기는 함수 function tabCursor(_section) { \tvar ph = 0; \tswitch (_section) \t{ \t\tcase 1: \t\t\tph = document.join.phone1.value.length; \t\t\tif (3 === ph) \t\t\t\tjoin.phone2.focus(); \t\t\tbreak; \t\t \t\tcase 2: \t\t\tph = document.join.phone2.value.length; \t\t\tif (4 === ph) \t\t\t\tjoin.phone3.focus(); \t\t\tbreak; \t} }       처음에 내 뜻대로 구현되지 않을 때에는 머리를 많이 쥐어뜯었지만 구현을 완료하고 나니까 참 뿌듯하다 😄      마감까지     D-26  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-04/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 5 - 회원가입 유효성 검사 구현 완료",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     어제 회원가입 페이지에서 사용자가 입력한 아이디의 유효성을 검증하는 부분까지 구현했다.   그리고 오늘 회원가입 시 사용자가 입력한 정보가 유효한지 검증하는 로직을 모두 구현했다!   1. join.jsp   &lt;h3&gt;회원가입&lt;/h3&gt;&lt;br&gt; &lt;form name=\"join\" action=\"./MemberJoinAction.me\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;아이디 &lt;/label&gt;&lt;input type=\"text\" name=\"id\" id=\"id\" placeholder=\"5~10자 이내의 영문+숫자 조합\"&gt;     &lt;/div&gt;     &lt;div id=\"idMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 &lt;/label&gt;&lt;input type=\"password\" name=\"pass\" id=\"pass\" placeholder=\"8~20자 영문+숫자+특수문자 조합\"&gt;     &lt;/div&gt;     &lt;div id=\"passMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 확인 &lt;/label&gt;&lt;input type=\"password\" name=\"confirm\" id=\"confirm\" placeholder=\"비밀번호를 다시 입력하세요.\"&gt;     &lt;/div&gt;     &lt;div id=\"confirmMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;이름 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"name\" class=\"name\" placeholder=\"이름을 입력하세요.\"&gt;     &lt;/div&gt;     &lt;div id=\"nameMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;생년월일 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"date\" name=\"birth\" class=\"birth\"&gt;     &lt;/div&gt;     &lt;div id=\"birthMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;성별 &lt;/label&gt;&lt;input class=\"radio\" type=\"radio\" name=\"gender\" id=\"gender\" value=\"남\"&gt;&lt;label class=\"radioText\"&gt;남&lt;/label&gt;      &lt;input class=\"radio\" id=\"gender\" type=\"radio\" name=\"gender\" value=\"여\"&gt;&lt;label class=\"radioText\"&gt;여&lt;/label&gt;     &lt;/div&gt;     &lt;div id=\"genderMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;도시 &lt;/label&gt;         &lt;select name=\"city\"&gt;             &lt;option selected disabled&gt;도시를 선택하세요.&lt;/option&gt;             &lt;option&gt;서울&lt;/option&gt;             &lt;option&gt;부산&lt;/option&gt;             &lt;option&gt;대전&lt;/option&gt;         &lt;/select&gt;     &lt;/div&gt;     &lt;div id=\"cityMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_TelField\"&gt;휴대폰 번호 &lt;/label&gt;     &lt;label class=\"phone\"&gt;     &lt;input id=\"phone1\" type=\"tel\" name=\"phone1\" size=\"1\" maxlength=\"3\" oninput=\"tabCursor(1)\"&gt; -      &lt;input id=\"phone2\" type=\"tel\" name=\"phone2\" size=\"3\" maxlength=\"4\" oninput=\"tabCursor(2)\"&gt; -      &lt;input id=\"phone3\" type=\"tel\" name=\"phone3\" size=\"3\" maxlength=\"4\"&gt;     &lt;/label&gt;     &lt;/div&gt;     &lt;div id=\"phoneMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_EmailField\"&gt;이메일 &lt;/label&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"abc123@gmail.com\"&gt;     &lt;/div&gt;     &lt;div id=\"emailMsg\"&gt;&lt;/div&gt;     &lt;button type=\"submit\" class=\"btn\"&gt;Send form&lt;/button&gt; &lt;/form&gt;      html 부분은 무료 템플릿 사이트에 있는 것을 다운받아서 사용한 것이고 입력 정보 유효성 검사를 위해 각 필드별로 id와 class만 추가했다.   거주지를 입력하는 부분은 약식으로 도시 3개만 넣었다.   form 태그를 최종 submit 하기 전에 finalCheck() 함수를 호출해 입력한 정보들의 유효성 검사를 완료한 후에 결과에 따라 페이지를 이동하도록 했다.   2. join.js   var $id = false; var $pass = false; var $passConfirm = false; var $name = false; var $birth = false; var $gender = false; var $city = false; var $phone = false; var $email = false;   $(document).ready(function() { \tidCheck(); \tpassCheck(); \tpassConfirm(); \tnameCheck(); \tbirthCheck(); \temailCheck(); });  // 휴대폰 번호 필드 1, 2번 칸에서 지정된 숫자만큼 입력하면 다음 칸으로 커서 넘기는 함수 function tabCursor(section) { \tvar ph = 0; \tswitch (section) \t{ \t\tcase 1: \t\t\tph = $(\"#phone1\").val(); \t\t\tif (3 === ph.length) \t\t\t\t$(\"#phone2\").focus(); \t\t\tbreak; \t\t \t\tcase 2: \t\t\tph = $(\"#phone2\").val(); \t\t\tif (4 === ph.length) \t\t\t\t$(\"#phone3\").focus(); \t\t\tbreak; \t} }   function idCheck() { \t$('#id').blur(function() \t{ \t\t$.ajax({ \t\t\ttype: 'POST', \t\t\tasync: false, \t\t\turl: './idCheck.me', \t\t\tdata: { \t\t\t\t'id': $('#id').val() \t\t\t}, \t\t\tdataType: 'text', \t\t\tsuccess: function(data) { \t\t\t\tif (data === 'true') \t\t\t\t{ \t\t\t\t\tvar userId = $('#id').val(); \t\t\t\t\tif (5 &gt; userId.length || 10 &lt; userId.length) \t\t\t\t\t{ \t\t\t\t\t\t$id = false; \t\t\t\t\t\t$('#idMsg').text('5자리 이상 10자리 이하로 입력해 주세요.'); \t\t\t\t\t\t$('#idMsg').css('color', 'red'); \t\t\t\t\t} \t\t\t\t\telse  \t\t\t\t\t{ \t\t\t\t\t\t$id = true; \t\t\t\t\t\t$('#idMsg').text('사용할 수 있는 아이디입니다.'); \t\t\t\t\t\t$('#idMsg').css('color', 'green'); \t\t\t\t\t} \t\t\t\t} \t\t\t\telse  \t\t\t\t{ \t\t\t\t\t$id = false; \t\t\t\t\t$('#idMsg').text('이미 존재하는 아이디입니다.'); \t\t\t\t\t$('#idMsg').css('color', 'red'); \t\t\t\t} \t\t\t}, \t\t\terror: function(data) { \t\t\t\tconsole.log('error'); \t\t\t} \t\t}); \t}); }  // 비밀번호 유효성 검사하는 함수 function passCheck() { \t$('#pass').blur(function() \t{ \t\tvar pass = $('#pass').val(); \t\tvar num = pass.search(/[0-9]/g); \t\tvar eng = pass.search(/[a-z]/ig); \t\tvar spe = pass.search(/[`~!@@#$%^&amp;*|₩₩₩'₩\";:₩/?]/gi);  \t\tif (8 &gt; pass.length || 20 &lt; pass.length) \t\t{ \t\t\t$pass = false; \t\t\t$('#passMsg').text('8자 ~ 20자 이내로 입력해 주세요.'); \t\t\t$('#passMsg').css('color', 'red'); \t\t} \t\telse if (pass.search(/\\s/) != -1) \t\t{ \t\t\t$pass = false; \t\t\t$('#passMsg').text('공백 없이 입력해 주세요.'); \t\t\t$('#passMsg').css('color', 'red'); \t\t} \t\telse if (num &lt; 0 || eng &lt; 0 || spe &lt; 0) \t\t{ \t\t\t$pass = false; \t\t\t$('#passMsg').text('영문, 숫자, 특수문자를 포함해서 입력해 주세요.'); \t\t\t$('#passMsg').css('color', 'red'); \t\t} \t\telse  \t\t{ \t\t\t$pass = true; \t\t\t$('#passMsg').text('사용 가능한 비밀번호 입니다!'); \t\t\t$('#passMsg').css('color', 'green'); \t\t} \t}); }  // 재입력한 비밀번호가 맞는지 확인하는 함수 function passConfirm() { \t$('#confirm').blur(function()  \t{ \t\tvar pass = $('#confirm').val();  \t\tif (0 &gt;= pass.length) \t\t{ \t\t\t$passConfirm = false; \t\t\t$('#confirmMsg').text('비밀번호를 한 번 더 입력해 주세요.'); \t\t\t$('#confirmMsg').css('color', 'red'); \t\t} \t\telse if ($('#pass').val() !== pass) \t\t{ \t\t\t$passConfirm = false; \t\t\t$('#confirmMsg').text('비밀번호가 일치하지 않습니다.'); \t\t\t$('#confirmMsg').css('color', 'red'); \t\t} \t\telse \t\t{ \t\t\t$passConfirm = true; \t\t\t$('#confirmMsg').text('비밀번호가 일치합니다!'); \t\t\t$('#confirmMsg').css('color', 'green'); \t\t} \t}); }  // 이름 입력 여부 확인하는 함수 function nameCheck() { \t$('.name').blur(function() \t{ \t\tvar name = $('.name').val();  \t\tif (\"\" === name) \t\t{ \t\t\t$name = false; \t\t\t$('#nameMsg').text('이름을 입력해 주세요.'); \t\t\t$('#nameMsg').css('color', 'red'); \t\t} \t\telse  \t\t{ \t\t\t$name = true; \t\t\t$('#nameMsg').text(''); \t\t} \t}); }  // 생년월일 유효성 검사하는 함수 function birthCheck() { \t// input 태그에서 date type으로 입력받아서 태그단에서 미리 유효한 날짜만 선택할 수 있게 하지만 첫 프로젝트라 연습 삼아 구현했다. \t$('.birth').blur(function() \t{ \t\tvar birth = $('.birth').val(); \t\t \t\tvar birthArr = birth.split('-'); \t\tvar year = birthArr[0]; \t\tvar month = birthArr[1]; \t\tvar day = birthArr[2]; \t\tvar today = new Date(); \t\tvar curYear = today.getFullYear();  \t\tif (10 &gt;= birth.length) \t\t{ \t\t\tif (1900 &gt; year || curYear &lt; year)  \t\t\t\t$birth = false; \t\t\telse if (1 &gt; month || 12 &lt; month)  \t\t\t\t$birth = false; \t\t\telse if (1 &gt; day || 31 &lt; day)  \t\t\t\t$birth = false; \t\t\telse if (31 == day &amp;&amp; (4 == month || 6 == month || 9 == month || 11 == month)) \t\t\t\t$birth = false; \t\t\telse if (2 == month) \t\t\t{ \t\t\t\t// 2월엔 윤년 여부 검사 \t\t\t\tvar leapYear = (0 == year % 4 &amp;&amp; (0 != year % 100 || 0 == year % 400)); \t\t\t\tif (29 &lt; day || (29 == day &amp;&amp; !leapYear)) \t\t\t\t\t$birth = false; \t\t\t\telse  \t\t\t\t\t$birth = true; \t\t\t} \t\t\telse  \t\t\t\t$birth = true; \t\t} \t\telse  \t\t\t$birth = false; \t}); }  // 성별 선택 여부 확인하는 함수 function genderCheck() { \tif ($('input[name=gender]').is(\":checked\")) \t{ \t\t$gender = true; \t\t$('#genderMsg').text(''); \t}\t \telse \t{ \t\t$gender = false; \t\t$('#genderMsg').text('성별을 선택하세요!'); \t\t$('#genderMsg').css('color', 'red');\t \t} }  // 도시 선택 여부 확인하는 함수 function cityCheck() { \tif ('0' == $('[name=city] &gt; option:selected').val()) \t{ \t\t$city = false; \t\t$('#cityMsg').text(\"거주 중인 도시를 선택하세요!\"); \t\t$(\"#cityMsg\").css(\"color\", \"red\"); \t}\t \telse  \t{ \t\t$city = true; \t\t$('#cityMsg').text(''); \t} }  // 휴대폰 번호 유효성 검사하는 함수 function phoneCheck() { \tvar first = $(\"#phone1\").val(); \tvar second = $(\"#phone2\").val(); \tvar third = $(\"#phone3\").val(); \t \tif (\"010\" == first &amp;&amp; 4 == second.length &amp;&amp; 4 == third.length) \t{ \t\t$phone = true; \t\t$(\"#phoneMsg\").text(\"\"); \t}\t \telse  \t{ \t\t$phone = false; \t\t$(\"#phoneMsg\").text(\"휴대폰 번호 형식이 올바르지 않습니다!\"); \t\t$(\"#phoneMsg\").css(\"color\", \"red\"); \t} }  // 이메일 유효성 검사하는 함수 function emailCheck() { \t$(\"#email\").blur(function() \t{ \t\tvar email = $(\"#email\").val(); \t\tvar regEmail = /^([0-9a-zA-Z_\\.-]+)@([0-9a-zA-Z_-]+)(\\.[0-9a-zA-Z_-]+){1,2}$/; \t\tif (regEmail.test(email)) \t\t{ \t\t\t$email = true; \t\t\t$(\"#emailMsg\").text(\"\"); \t\t} \t\telse  \t\t{ \t\t\t$email = false; \t\t\t$(\"#emailMsg\").text(\"이메일 형식이 올바르지 않습니다!\"); \t\t\t$(\"#emailMsg\").css(\"color\", \"red\"); \t\t} \t}); }  // 마지막 제출 전에 유효성 검사하는 함수 function finalCheck()  { \tvar join = document.join; \tif (!$id) \t{ \t\tjoin.id.focus(); \t\treturn false; \t} \t\t \tif (!$pass) \t{ \t\tjoin.pass.focus(); \t\treturn false; \t}  \tif (!$passConfirm) \t{ \t\tjoin.confirm.focus(); \t\treturn false; \t}  \tif (!$name) \t{ \t\tjoin.name.focus(); \t\treturn false; \t}  \tif (!$birth) \t{ \t\tjoin.birth.focus(); \t\treturn false; \t} \t \tgenderCheck(); \tif (!$gender) \t\treturn false;  \tcityCheck(); \tif (!$city) \t\treturn false; \t \tphoneCheck(); \tif (!$phone) \t{ \t\tjoin.phone1.focus(); \t\treturn false; \t} \t \tif (!$email) \t{ \t\tjoin.email.focus(); \t\treturn false; \t} }      입력 데이터 중 생년월일은 input 태그에서 type=\"date\"로 지정해서 입력 단계에서 유효성 검사가 이루어지긴 하는데 웹 개발 프로젝트는 처음 진행하는 것이라 연습 삼아 String형으로만 입력을 받았을 때에 유효성 검사를 확인하는 코드도 작성해 보았다. 사실상 필요 없는 부분이라 최종 빌드 때엔 삭제할 예정이다.      마감까지     D-25  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-05/",
        "teaser": null
      },{
        "title": "C++) BOJ 10610. 30",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/10610     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제            어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.            미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라.         입력       N을 입력받는다. N는 최대 105개의 숫자로 구성되어 있으며, 0으로 시작하지 않는다.     출력       미르코가 만들고 싶어하는 수가 존재한다면 그 수를 출력하라. 그 수가 존재하지 않는다면, -1을 출력하라.      👀 풀이            참고 풀이 : https://ongveloper.tistory.com/114            문제 이해를 잘못해서.. 자꾸 틀려서 구글링했다.        입력으로 주어지는 N이 자릿수를 말하는 것이 아니라 N개의 수이기 때문에 최대 10^5개의 숫자가 입력으로 주어진다.        그래서 정수형으로는 절대 받을 수 없는 숫자였던 것이다… 문자열로 입력을 받아야 했음 - 틀린 이유 1        입력을 해결하고 나면 이제 이 수들의 배치를 바꿔가며 30의 배수가 되는지 확인해야 하는데 처음에는 문제 이해 자체를 잘못했기 때문에 입력받은 수를 배열로 바꿔서 prev_permutation으로 순열을 구한 다음 30의 배수인지 구하는 코드를 작성했다. 물론 입력 자체가 잘못되었기 때문에 틑림   입력의 최대값이 아주 크기 때문에 처음에 작성했던 것처럼 완전 탐색 방식으로는 시간초과를 받을 수 밖에 없고 규칙을 찾아서 적용해야 한다.        일단 30의 배수가 되려면 맨 마지막 자릿수가 0이어야 하고 3으로 나누어 떨어지려면 각 자릿수를 더한 값이 3의 배수가 되어야 한다.                    입력받은 수를 내림차순으로 정렬한 후 맨 마지막 원소가 0인지 검사 후 0이 아니면 -1 출력                       1번을 통과했으면 각 자릿수를 더해서 3의 배수가 되는지 확인한 후 결과값 출력            언제쯤.. 무난하게 풀 수 있을까…     결과       시간 : 4 ms   메모리 : 2300 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10610","Greedy","C++"],
        "url": "/boj/boj10610-cpp/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 6 - 휴대폰 인증기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     openAPI 사용법을 익히고 싶어서 휴대폰 번호 인증하기 기능을 만들어 보았다.   그동안 openAPI 쓰면 쉽게 만들 수 있다, 개발이 편해진다 하는 말을 참 많이 들었는데 직접 해 보니까 쉽지 않아서 많이 헤멨다… 😔 처음 해 보는 것이라 그런걸까?   그리고 아직 Spring framework는 배우지 않은 상태라서 Java와 Servlet을 이용해 MVC Model2 패턴으로 구현해야 하는데 대부분의 자료는 Spring framework를 이용한 것이라 더 어렵게 느껴졌던 것 같다. 하지만 지금까지는 코드로 일일이 구현해 왔던 것을 Spring에서는 어노테이션으로 처리할 수 있는 것을 보니까 빨리 Spring을 배워 보고 싶어졌다.   그래도 이번 구현을 통해 휴대폰 번호 인증 로직이 어떻게 돌아가는 지 알게 되었고 openAPI도 어떤 방식으로 사용하는지 어느 정도 알게 되어서 좋은 경험이었다고 생각한다.   1. 네이버 클라우드 회원가입 하기          대부분의 휴대폰 번호 인증 API는 유료였는데 네이버 클라우드의 API는 한 달에 50건까지 무료라서 사용했다.        NAVER CLOUD PlATFORM[SENS API] - 네이버 문자 인증   기본적인 프로젝트 생성 방법은 이 블로그 글을 참고했다.   처음엔 Products &amp; Services 탭에서 활성화 된 메뉴가 아주 적을 수 있는데 결제 수단을 등록해 주면 모든 메뉴를 볼 수 있다.   2. join.jsp에 휴대폰 번호 인증란 추가   &lt;!-- join.jsp --&gt;  ... 생략  &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_TelField\"&gt;휴대폰 번호 &lt;/label&gt;     &lt;label class=\"phone\"&gt;     &lt;input id=\"phone1\" type=\"tel\" name=\"phone1\" size=\"1\" maxlength=\"3\" oninput=\"tabCursor(1)\"&gt; -      &lt;input id=\"phone2\" type=\"tel\" name=\"phone2\" size=\"3\" maxlength=\"4\" oninput=\"tabCursor(2)\"&gt; -      &lt;input id=\"phone3\" type=\"tel\" name=\"phone3\" size=\"3\" maxlength=\"4\"&gt;     &lt;button id=\"requestBtn\" class=\"btn\" type=\"submit\" name=\"requestBtn\"&gt;휴대폰인증&lt;/button&gt;     &lt;/label&gt; &lt;/div&gt; &lt;div id=\"phoneMsg\"&gt;&lt;/div&gt; &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_EmailField\"&gt;인증번호 &lt;/label&gt;     &lt;label class=\"phone\"&gt;     &lt;input type=\"text\" name=\"validateNum\" id=\"validateNum\"&gt;     &lt;button id=\"validateBtn\" class=\"btn\" type=\"submit\" name=\"validateBtn\"&gt;인증번호 확인&lt;/button&gt;     &lt;/label&gt; &lt;/div&gt; &lt;div id=\"validateMsg\"&gt;&lt;/div&gt;  ... 생략   3. 휴대폰 번호 인증을 처리하는 클래스 만들기     네이버 클라우드 플랫폼 SMS API 사용법 전체 코드, 예제 코드, Java, Spring, 스프링, Simple &amp; Easy Notification Service, SENS        이 블로그 글을 참고해서 구현했다. 지금까지 수업에서 JSON을 배운 적이 없어서 처음 API 문서를 봤을 때 굉장히 난감했는데 이 글 덕분에 코드를 분석하며 JSON을 무슨 용도로, 어떻게 사용하는 지 알 수 있었다.        [이렇게 사용하세요!] SMS 문자 메시지 발송 앱 사용하기 (SENS API 활용법)   API의 각 항목에 대한 가이드는 공식 블로그를 참고했다. 여기만 확인해도 서비스 아이디가 뭔지, uri는 또 무슨 용도인지… 등등을 알 수 있다.   // SmsService.java  import java.io.BufferedReader; import java.io.DataOutputStream; import java.io.InputStreamReader; import java.io.UnsupportedEncodingException; import java.net.HttpURLConnection; import java.net.URL; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.util.ArrayList; import java.util.Base64; import java.util.Random;  import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec;  import org.json.simple.JSONArray; import org.json.simple.JSONObject;  public class SmsService  {     private String makeSignature(String method, String url, String timestamp, String accessKey, String secretKey) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException     {         String space = \" \";\t\t\t\t\t// one space         String newLine = \"\\n\";\t\t\t\t\t// new line \t\t         String message = new StringBuilder()             .append(method)             .append(space)             .append(url)             .append(newLine)             .append(timestamp)             .append(newLine)             .append(accessKey)             .toString(); \t\t         SecretKeySpec signingKey;         String encodeBase64String;         try {             signingKey = new SecretKeySpec(secretKey.getBytes(\"UTF-8\"), \"HmacSHA256\");             Mac mac = Mac.getInstance(\"HmacSHA256\");             mac.init(signingKey);             byte[] rawHmac = mac.doFinal(message.getBytes(\"UTF-8\"));             encodeBase64String = Base64.getEncoder().encodeToString(rawHmac);         }         catch (Exception e) {             encodeBase64String = e.toString();         } \t\t     return encodeBase64String; } \t //\t{ //    \"type\":\"(SMS | LMS | MMS)\", // sms 타입 //    \"contentType\":\"(COMM | AD)\", // 메세지 타입 //    \"countryCode\":\"string\", // 국가번호 //    \"from\":\"string\",\t\t// 발신번호 //    \"subject\":\"string\",\t\t// 기본 메시지 제목 //    \"content\":\"string\",\t\t// 기본 메시지 내용 //    \"messages\":[\t\t\t// 메시지 정보(Object) - 최대 1000개 //        { //            \"to\":\"string\",\t// 수신번호(String) //            \"subject\":\"string\", // 개별 메시지 제목(String) //            \"content\":\"string\"  // 개별 메시지 내용(String) //        } //    ] //} \t     @SuppressWarnings(\"unchecked\")     public int sendSms(String dstPhoneNumber)     {         System.out.println(\"sendSms() 호출\"); \t\t         String method = \"POST\";\t\t\t\t\t// method         String smsUrl = \"https://sens.apigw.ntruss.com\";\t// url (include query string)         String requestUrl = \"/sms/v2/services/\";         String requestUrlType = \"/messages\";         String accessKey = \"{user access key id}\";\t\t\t// access key id (from portal or Sub Account)         String secretKey = \"{user secret key}\";         String serviceId = \"{user service id}\";         String timestamp = Long.toString(System.currentTimeMillis());\t\t\t// current timestamp (epoch) \t\t         requestUrl += serviceId + requestUrlType;         String apiUrl = smsUrl + requestUrl; \t\t         JSONObject bodyJson = new JSONObject();         JSONObject toJson = new JSONObject();         JSONArray toArr = new JSONArray(); \t\t         toJson.put(\"to\", dstPhoneNumber);         toArr.add(toJson); \t\t         bodyJson.put(\"type\", \"SMS\");         bodyJson.put(\"contentType\", \"COMM\");         bodyJson.put(\"countryCode\", \"82\");         bodyJson.put(\"from\", \"발신번호로 등록한 폰번호\");         bodyJson.put(\"subject\", \"[Web 발신]\");          // 난수 생성         int min = 1000;         int max = 9999;         int validateNum = (int) (Math.random() * (max - min + 1)) + min;         bodyJson.put(\"content\", \"인증번호 : \" + Integer.toString(validateNum));         System.out.println(\"validateNum : \" + validateNum); \t\t         bodyJson.put(\"messages\", toArr); \t\t         String body = bodyJson.toString(); \t\t         System.out.println(\"body : \" + body); \t\t         try {             URL url = new URL(apiUrl); \t\t\t             HttpURLConnection con = (HttpURLConnection) url.openConnection();             con.setUseCaches(false);             con.setDoOutput(true);             con.setDoInput(true);             con.setRequestProperty(\"Content-Type\", \"application/json\");             con.setRequestProperty(\"x-ncp-apigw-timestamp\", timestamp);             con.setRequestProperty(\"x-ncp-iam-access-key\", accessKey);             con.setRequestProperty(\"x-ncp-apigw-signature-v2\", makeSignature(method, requestUrl, timestamp, accessKey, secretKey));             con.setRequestMethod(method);             con.setDoOutput(true);             DataOutputStream dos = new DataOutputStream(con.getOutputStream()); \t\t\t             dos.write(body.getBytes());             dos.flush();             dos.close(); \t\t\t             int responseCode = con.getResponseCode();             BufferedReader br;             System.out.println(\"responseCode : \" + responseCode);             if (202 == responseCode)             {                 // 정상호출                 br = new BufferedReader(new InputStreamReader(con.getInputStream()));             }             else              {                 // 에러발생                 br = new BufferedReader(new InputStreamReader(con.getErrorStream()));             } \t\t\t             String inputLine;             StringBuffer response = new StringBuffer();             while (null != (inputLine = br.readLine()))                 response.append(inputLine); \t\t\t             br.close(); \t\t\t             System.out.println(response.toString());         }         catch (Exception e) {             System.out.println(e);         } \t\t         System.out.println(\"sendSms() 끝\"); \t\t         return validateNum;     } }      난수를 발생시켜서 인증번호를 만들었으며 사용자가 입력한 번호와 비교하기 위해서 생성된 난수를 리턴하도록 했다.   난수는 4자리 숫자를 만들도록 범위를 지정해 주었다.   4. 문자 전송 결과를 받아올 서블릿 생성   import java.io.IOException; import java.io.PrintWriter;  import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  @WebServlet(\"/validatePhone.me\") public class ValidatePhone extends HttpServlet  { \tprotected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tresp.setContentType(\"text/html; charset=utf-8\"); \t\t \t\tSmsService smsService = new SmsService(); \t\tPrintWriter out = resp.getWriter(); \t\t \t\tint validateNum = smsService.sendSms(req.getParameter(\"phone\")); \t\tout.print(validateNum); \t\t \t\tout.close(); \t} \t \t@Override \tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t}  \t@Override \tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t} }      문자 전송 후 발생된 난수를 받아와 출력 스트림을 이용해 response 객체로 전달하도록 했다.   5. join.js에서 join.jsp와 인증 페이지를 연결하는 코드 작성   ... 생략  var $validateNum; var $checkValidate = false;   $(document).ready(function() {     ...     중략          getToken();     checkValidateNum(); });  function getToken() {     $('#requestBtn').click(function()     {         phoneCheck();         if ($phone)         {             var phoneNum = $('#phone1').val() + $('#phone2').val() + $('#phone3').val();             $.ajax({                 type: 'POST',                 async: false,                 url: './validatePhone.me',                 data: {                     'phone': phoneNum                 },                 dataType: 'text',                 success: function(data)                 {                     alert('인증번호 전송 완료!');                     $validateNum = data;                 }             });\t\t\t\t\t         }     }); }  function checkValidateNum() {     $('#validateBtn').click(function()     {         var userInput = $(\"#validateNum\").val();         if ($validateNum === userInput)         {             $checkValidate = true;             $(\"#validateMsg\").text(\"인증이 완료되었습니다!\");             $(\"#validateMsg\").css(\"color\", \"green\");             $(\"#validateBtn\").prop(\"disabled\", true);             $(\"#requestBtn\").prop(\"disabled\", true);             $(\"#validateBtn\").css(\"background\", \"gray\");             $(\"#requestBtn\").css(\"background\", \"gray\");         }         else          {             $checkValidate = false;             $(\"#validateMsg\").text(\"인증번호가 일치하지 않습니다.\");             $(\"#validateMsg\").css(\"color\", \"red\");         }     }); }  // 마지막 제출 전에 유효성 검사하는 함수 function finalCheck()  {     var join = document.join;     if (!$id)     {         join.id.focus();         return false;     } \t\t     if (!$pass)     {         join.pass.focus();         return false;     }      if (!$passConfirm)     {         join.confirm.focus();         return false;     }      if (!$name)     {         join.name.focus();         return false;     }      if (!$birth)     {         join.birth.focus();         return false;     } \t     genderCheck();     if (!$gender)         return false;      cityCheck();     if (!$city)         return false; \t     phoneCheck();     if (!$phone)     {         join.phone1.focus();         return false;     } \t     if (!$checkValidate)     {         join.validateNum.focus();         return false;     } \t     if (!$email)     {         join.email.focus();         return false;     } }   ... 생략      서블릿을 이용해 문자 전송 요청을 보내고 발생된 난수를 받아올 것이기 때문에 Ajax를 이용했다.   인증번호 확인 버튼을 누르면 서블릿에서 받아온 번호와 비교해서 일치하는지 아닌지 확인 후 결과를 알려준다.            오늘 얻은 팁     만약 css 변경 사항이 적용되지 않을 때에는 css 파일 경로 설정하는 부분의 맨 뒤에 ?를 붙여주면 된다.   &lt;link rel=\"stylesheet\" href=\"${pageContext.request.contextPath}/css/modules.css?after\"&gt;           이런 식으로 맨 뒤에 ?를 붙이고 다음에는 아무 말이나 입력해도 되고 입력하지 않아도 된다.            이제 로그인 기능 만들어야지…           마감까지     D-24  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-06/",
        "teaser": null
      },{
        "title": "DB) 관계 데이터 모델링",
        "excerpt":"👀 관계 데이터 모델의 개념     개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델   하나의 개체에 대한 데이터를 하나의 릴레이션에 저장   기본 용어  릴레이션(relation)     하나의 개체에 대한 데이터를 2차원 테이블의 구조로 저장한 것   파일 관리 시스템 관점에서 파일(file)에 대응   속성(attribute)     릴레이션의 열, 애트리뷰트로 세로줄!   파일 관리 시스템 관점에서 필드(field)에 대응   투플(tuple)     릴레이션의 행. 가로줄!   파일 관리 시스템 관점에서 레코드(record)에 대응   도메인(domain)     하나의 속성이 가질 수 있는 모든 값의 집합   속성 값을 입력 및 수정할 때 적합성의 판단 기준이 됨   일반적으로 속성의 특성을 고려한 데이터 타입으로 정의   널(null)     속성 값을 아직 모르거나 해당되는 값이 없음을 표현   차수(degree)     하나의 릴레이션에서 속성의 전체 개수   카디널리티(cardinality)     하나의 릴레이션에서 투플의 전체 개수     릴레이션의 구성  릴레이션 스키마(relation schema)     릴레이션의 논리적 구조. 뼈대라 할 수 있다.   릴레이션의 이름과 릴레이션이 포함된 모든 속성 이름으로 정의            예) 고객(고객 아이디, 고객 이름, 나이, 등급, 직업, 적립금)           릴레이션 내포(relation intension)라고도 함   정적인 특징이 있음   릴레이션 인스턴스(relation instance)     어느 한 시점에 릴레이션에 존재하는 투플들의 집합. 릴레이션 안에 실제로 들어있는 값이다.   릴레이션 외연(relation extension)이라고도 함   시간이 흐름에 따라 투플이 계속 추가되거나 삭제될 수 있기 때문에 동적인 특징이 있다.     데이터베이스의 구성  데이터베이스 스키마(database schema)     데이터베이스의 전체 구조   데이터베이스를 구성하는 릴레이션 스키마의 모음   데이터베이스 인스턴스(database instance)     데이터베이스를 구성하는 릴레이션 인스턴스의 모음     릴레이션의 특성     투플의 유일성            하나의 릴레이션에는 동일한 투플이 존재할 수 없다.           투플의 무순서            하나의 릴레이션에서 투플 사이의 순서는 무의미하다.           속성의 무순서            하나의 릴레이션에서 속성 사이의 순서는 무의미하다.           속성의 원자성            속성 값으로 원자 값만 사용할 수 있다. 즉 한 속성 필드에 값이 2개 이상 들어갈 수 없음!             키(key)     릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합   키의 특성     유일성(uniqueness)            하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함           최소성(minimality)            꼭 필요한 최소한의 속성들로만 키를 구성           키의 종류  슈퍼키(super key)     유일성을 만족하는 속성 또는 속성들의 집합   예) 고객 릴레이션의 슈퍼키 : 고객아이디, (고객아이디, 고객이름), (고객이름, 주소) 등   후보키(candidate key)     유일성과 최소성을 만족하는 속성 또는 속성들의 집합   예) 고객 릴레이션의 후보키 : 고객아이디, (고객이름, 주소) 등   기본키(primary key)     후보키 중에서 기본적으로 사용하기 위해 선택한 키   널값을 가질 수 있는 속성이 포함된 후보키는 부적합   값이 자주 변경될 수 있는 속성이 포함된 후보키는 부적합   단순한 후보키를 선택   예) 고객 릴레이션의 기본키 : 고객아이디   대체키(alternate key)     기본키로 선택되지 못한 후보키   예) 고객 릴레이션의 대체키 : (고객이름, 주소)   외래키(foreign key)     다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합   릴레이션들 간의 관계를 표현   참조하는 릴레이션 : 외래키를 가진 릴레이션(주문 릴레이션)   참조되는 릴레이션 : 외래키가 참조하는 기본키를 가진 릴레이션(고객 릴레이션)   역할            고객 릴레이션과 주문 릴레이션이 관계를 맺어 주문 릴레이션의 투플과 연관성 있는 고객 릴레이션의 투플을 연결할 수 있음       외래키 속성과 그것이 참조하는 기본키 속성의 이름은 달라도 되지만 도메인은 같아야 한다.           하나의 릴레이션에는 외래키가 여러 개 존재할 수도 있고 외래키를 기본키로 사용할 수도 있다.   같은 릴레이션의 기본키를 참조하는 외래키도 정의할 수 있다.   외래키 속성은 널 값을 가질 수도 있다.     무결성 제약조건(integrity constraint)     데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙   무결성 : 데이터를 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것   개체 무결성 제약조건(entity integrity constraint)     기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙   참조 무결성 제약조건(referential integrity constraint)     외래키는 참조할 수 없는 값을 가질 수 없는 규칙   널 값은 가질 수 있지만 널 값이 아닌데 참조하려는 테이블에는 해당 값이 없으면 외래키로 사용할 수 없다.      출처     데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의  ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/db-05-relation/",
        "teaser": null
      },{
        "title": "C++) BOJ 1213. 팰린드롬 만들기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1213     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제            임한수와 임문빈은 서로 사랑하는 사이이다.            임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.            임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.            임문빈을 도와 임한수의 영어 이름을 팰린드롬으로 바꾸는 프로그램을 작성하시오.         입력       첫째 줄에 임한수의 영어 이름이 있다. 알파벳 대문자로만 된 최대 50글자이다.     출력       첫째 줄에 문제의 정답을 출력한다. 만약 불가능할 때는 “I’m Sorry Hansoo”를 출력한다. 정답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.      👀 풀이            예전에 팰린드롬인지 판별하는 문제를 풀었던 기억이 나서 판별하는 알고리즘에다 팰린드롬 문자열을 출력하는 알고리즘을 추가로 구현했다.        주어진 문자열이 팰린드롬인지 판별하는 방법은        문자열의 길이가 짝수일 때엔 같은 알파벳의 갯수가 모두 짝수여야 한다. 예제 입력의 AABB와 같은 문자열은 A 2개 B 2개로 모든 구성 요소가 각각 짝수개 있기 때문에 팰린드롬이다. 하나라도 홀수면 팰린드롬이 될 수 없다.             문자열의 길이가 홀수일 때엔 알파벳 하나만 홀수개여야 하고 나머지는 모두 짝수개가 있어야 한다. ABCC와 같이 홀수개인 문자가 2개 있으면 팰린드롬을 만들 수 없다.             그래서 입력으로 주어지는 문자열을 한 번 순회하면서 각 알파벳의 갯수를 센다.         그 다음 센 갯수를 바탕으로 주어진 문자열이 팰린드롬인지 아닌지 판별한다.   팰린드롬이라면        길이가 짝수일 땐 알파벳의 갯수를 센 배열을 앞에서부터 순회하면서 각 알파벳들의 절반 횟수만큼만 먼저 정답 문자열에 더해준 뒤 저걸 복사해서 반대로 뒤집은 다음 정답 문자열에 더한다.        길이가 홀수일 땐 짝수와 비슷하게 하는데 갯수가 홀수인 문자는 1을 뺀 값에서 절반만큼만 정답 문자열에 더해준다.   짝수 갯수인 문자들은 문자열의 길이가 짝수일 때와 마찬가지로 더해준다.        다 더했으면 역시 복사한 뒤 뒤집어서 정답에 마저 더해준다.        팰린드롬이 여러 개일 때엔 사전순으로 빠른 순서대로 출력하라고 했으므로 위와 같이 구하면 정답이다.     결과       시간 : 0 ms   메모리 : 2028 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1213","String","C++"],
        "url": "/boj/boj1213-cpp/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 7 - 로그인 기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     오늘은 로그인 기능을 만들었다.   login.jsp   ... 생략  &lt;h3&gt;로그인&lt;/h3&gt; &lt;form name=\"login\" action=\"./main.me\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;아이디 &lt;/label&gt;&lt;input id=\"id\" type=\"text\" name=\"id\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 &lt;/label&gt;&lt;input id=\"pass\" type=\"password\" name=\"pass\"&gt;     &lt;/div&gt;     &lt;button type=\"submit\" class=\"btn\"&gt;Login&lt;/button&gt; &lt;/form&gt;  ... 생략      submit 버튼을 누르면 메인페이지로 이동하되 DB 조회 결과 확인 후 이동하도록 onsubmit 조건을 걸어주었다.   login.js   var $login = false;  function loginCheck()  {     console.log(\"loginCheck() 호출\");     $.ajax({         type: 'POST',         async: false,         url: \"./LoginCheck.me\",         data: {             'id': $(\"#id\").val(),             'pass': $(\"#pass\").val()         },         dataType: 'text',         success: function(data)          {             console.log(\"success data : \" + data);             if (1 == data)              {                 // 회원                 $login = true;                 alert(\"로그인 성공!\");                 location.href = \"./main.me\";             }             else if (0 == data)              {                 // 비밀번호 오류                 alert(\"아이디 혹은 비밀번호가 일치하지 않습니다!\");                 $login = false;             }             else              {                 // 비회원                 alert(\"회원이 아닙니다.\");                 $login = false;             }         },         error: function(data)          {             console.log(\"error\");         }     }); }  function finalCheck()  {     loginCheck();     if ($login)         return true;     else         return false; }      Ajax로 DB 조회 결과를 알아오도록 했다.   MemberFrontController.java   package com.project.cafe.member.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class MemberFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null;          // .. 생략         else if (command.equals(\"/LoginCheck.me\"))         {             System.out.println(\"C : /LoginCheck.me 호출\"); \t\t\t             action = new LoginCheck(); \t\t\t             try {                 forward = action.execute(req, resp);             }             catch (Exception e) {                 e.printStackTrace();             }         }         // .. 생략 \t\t         // 3. 페이지 이동         // .. 생략     }      // .. 생략 }      컨트롤러에서 DB연결 작업을 수행할 서블릿과 연결한다.   LoginCheck.java   package com.project.cafe.member.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class LoginCheck implements Action {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : LoginCheck - execute() 호출\"); \t\t         PrintWriter out = response.getWriter();         HttpSession session = null;         MemberDAO dao = new MemberDAO(); \t\t         MemberDTO dto = new MemberDTO();         dto.setId(request.getParameter(\"id\"));         dto.setPass(request.getParameter(\"pass\")); \t\t         int result = dao.loginCheck(dto);         if (1 == result)         {             session = request.getSession();             session.setAttribute(\"id\", dto.getId());             session.setMaxInactiveInterval(600);         } \t\t         out.print(result); \t\t         out.close();          return null;     } }      로그인에 성공했을 때에만 세션 값을 설정해 주었다.   top.jsp에서 로그인 유무에 따라 상단 메뉴 다르게 출력하기   &lt;p class=\"MOD_HEADER1_Phone\"&gt; &lt;%     String id = (String)session.getAttribute(\"id\");     System.out.println(\"session id : \" + id); \t\t     if (null == id)     {         %&gt;             &lt;a href=\"./login.me\"&gt;로그인&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;             &lt;a href=\"./join.me\"&gt;회원가입&lt;/a&gt;         &lt;%     }     else      {         %&gt;             &lt;a href=\"./logout.me\"&gt;로그아웃&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;             &lt;a href=\"./myPage.me\"&gt;마이페이지&lt;/a&gt;         &lt;%     } %&gt; &lt;/p&gt;      top.jsp는 상단 메뉴 부분을 출력하는 파일이다. 모든 html/jsp 페이지마다 상단 메뉴를 출력하는 코드를 써 놓으면 관리하기 힘들고 중복되는 부분도 많이 생기니까 Header와 Footer 부분을 따로 분리해서 각 페이지마다 top.jsp와 bottom.jsp를 JSP 액션태그를 이용해 include 해 주었다.   로그인 결과를 받아오면서 저장한 세션 값을 바탕으로 상단 메뉴를 다르게 출력한다.         로그인 성공 시 출력하는 상단 메뉴   LogoutAction.java 생성   package com.project.cafe.member.action;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class LogoutAction implements Action {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         if (null != request.getSession())             request.getSession().invalidate(); \t\t         ActionForward forward = new ActionForward();         forward.setPath(\"./main.me\");         forward.setRedirect(true); \t\t         return forward;     } }      로그아웃 동작을 수행할 서블릿도 만들었다.         로그아웃 완료 시 출력하는 상단 메뉴   이제 마이페이지에서 내 정보를 조회하는 기능을 만들어야겠다! ☺️      마감까지     D-22  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-07/",
        "teaser": null
      },{
        "title": "에러해결 Log) java.lang.IllegalStateException 응답이 이미 커밋된 후에는 sendRedirect()를 호출할 수 없습니다.",
        "excerpt":"사용환경     MacBook Air (M1, 2020) 16GB   JDK 8   Eclipse 2021-12   tomcat 8.5      에러의 발생     현재 MVC Model2 패턴을 적용한 웹 사이트를 만드는 프로젝트를 진행중이다.   페이지 이동 요청이 들어왔을 때 front에서 이동할 페이지를 매핑한 다음 서블릿에서 필요한 액션들을 처리한 후 최종 목적지로 이동하게 된다.   나는 마이페이지 기능을 구현하고 있었는데, 로그인 후 마이페이지에 입장하려면 비밀번호를 한 번 더 입력한 후 일치하면 회원 정보를 수정할 수 있는 페이지로 이동하고 그렇지 않으면 비밀번호가 틀렸다는 알림창을 띄우고 싶었다.   그래서 JAVA 코드에서 JavaScript 코드를 사용할 수 있어야 했다.   그리하여 처음에 시도했던 모델… 👇   MemberFrontConroller.java   import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.api.sms.SmsService;  public class MemberFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException     {         // 1. 전달되는 가상주소 계산         // 매핑된(.me로 끝나는) 주소를 받아옴         String requestURI = req.getRequestURI();         System.out.println(\"requestURI : \" + requestURI);          // 매핑된 해당 프로젝트 주소를 구함         String ctxPath = req.getContextPath();         System.out.println(\"ctxPath : \" + ctxPath);          // 매핑된 주소 - 프로젝트 주소 = 계속 바뀔 뒷자리 주소 구함         String command = requestURI.substring(ctxPath.length());         System.out.println(\"command : \" + command);          System.out.println(\"C : 가상주소 계산 완료\\n\");         // 1. 전달되는 가상주소 계산           // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null;          if (command.equals(\"/MemberJoinAction.me\"))         {             System.out.println(\"C : /MemberJoinAction.me 호출\");             System.out.println(\"C : 이전 페이지 정보를 가져와서 DB 테이블에 저장 후 페이지 이동\");              action = new MemberJoinAction(); // 인터페이스를 통해 객체를 생성함으로써 약한결합이 되도록 한다.              try             {                 forward = action.execute(req, resp);             }             catch (Exception e)             {                 e.printStackTrace();             }         }         else if (command.equals(\"/memberUpdateAction.me\"))         {             System.out.println(\"C : /memberUpdateAction.me 호출\");              action = new MemberUpdateAction();              try {                 forward = action.execute(req, resp);             }             catch (Exception e) {                 e.printStackTrace();             }         }         else if (command.equals(\"/CheckPassAction.me\"))         {             System.out.println(\"C : /CheckPassAction.me 호출\");              action = new CheckPassAction();              try {                 forward = action.execute(req, resp);             }             catch (Exception e) {                 e.printStackTrace();             }         }         else         {             forward = new ActionForward();              if (command.equals(\"/main.me\"))             {                 System.out.println(\"C : 메인페이지 호출\");                 forward.setPath(\"./main/main.jsp\");             }             else if (command.equals(\"/join.me\"))             {                 System.out.println(\"C : 회원가입 페이지 호출\");                 forward.setPath(\"./member/join.jsp\");             }             else if (command.equals(\"/login.me\"))             {                 System.out.println(\"C : 로그인 페이지 호출\");                 forward.setPath(\"./member/login.jsp\");             }             else if (command.equals(\"/logout.me\"))             {                 System.out.println(\"C : 로그아웃 페이지 호출\");                 forward.setPath(\"/logout.me\");             }             else if (command.equals(\"/checkPass.me\"))             {                 System.out.println(\"C : 비번 한 번 더 입력하는 페이지 호출\");                 forward.setPath(\"./member/checkPass.jsp\");             }             else if (command.equals(\"/myPage.me\"))             {                 System.out.println(\"C : 마이페이지 호출\");                 forward.setPath(\"./member/myPage.jsp\");             }              forward.setRedirect(false);         }          System.out.println(\"C : 가상주소 매핑 완료\\n\");         // 2. 가상주소 매핑           // 3. 페이지 이동         if (null != forward) // 페이지 이동정보가 있을 때         {             if (forward.isRedirect())             {                 System.out.println(\"C : sendRedirect 방식 - \" + forward.getPath() + \" 이동\");                 resp.sendRedirect(forward.getPath());             }             else             {                 System.out.println(\"C : forward 방식 - \" + forward.getPath() + \" 이동\");                 RequestDispatcher dis = req.getRequestDispatcher(forward.getPath());                 dis.forward(req, resp);             }              System.out.println(\"C : 페이지 이동 완료\");         }         // 3. 페이지 이동     }      @Override     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException     {         doProcess(req, resp);     }      @Override     protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException     {         doProcess(req, resp);     } }      이동하고자 하는 페이지로 매핑해 주는 front   CheckPassAction.java   import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class CheckPassAction implements Action {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception     {         System.out.println(\"M : CheckPassAction - execute() 호출\");          // 파라메터 저장         String id = request.getParameter(\"id\");         String pass = request.getParameter(\"pass\");          // 회원정보 저장         MemberDTO dto = new MemberDTO();         dto.setId(id);         dto.setPass(pass);          response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter();         ActionForward forward = new ActionForward();          // DB 연동해서 아이디와 비밀번호가 일치하는 지 확인         MemberDAO dao = new MemberDAO();         int result = dao.loginCheck(dto);         if (1 == result)         {             // 비번 일치             forward.setPath(\"./myPage.me\");         }         else         {             // 비번 불일치             out.println(\"&lt;script&gt;alert('비밀번호가 일치하지 않습니다!');&lt;/script&gt;\");             forward.setPath(\"./checkPass.me\");         }          forward.setRedirect(true);         out.close();          return forward;     } }      front의 페이지 매핑 형태가 forward 형식이기 때문에 Action 클래스에서 DB 연동 동작을 처리한 후 이동할 페이지 정보를 front로 리턴해서 이동하는 형식을 취했다.        그런데 이렇게 실행하니까 동작이 제대로 안 됨…             java.lang.IllegalStateException: 응답이 이미 커밋된 후에는, sendRedirect()를 호출할 수 없습니다.        👆 이런 에러 메시지가 나오며 이동이 제대로 되질 않았다 ㅠ.ㅠ   그래서 오늘 학원 와서 선생님한테 여쭤보니까 자바 코드와 자바스크립트 코드를 함께 썼을 때엔 자바스크립트 코드가 가장 나중에 실행되기 때문에 위와 같은 형태로 쓰면 자바 코드가 먼저 실행 되면서 자바스크립트가 알림창을 띄우기 전에 이미 다른 페이지로 이동한 상태가 되는 것이었다.   그래서 이미 이동한 상태에서 자바스크립트 코드로 알림창을 띄우려 하니 충돌이 생겨서 제대로 동작하지 않는 것이었다. 커밋이 되었다는 뜻이 이러한 의미였다.     문제 해결     그래서 자바스크립트 코드로 페이지를 이동하도록 수정했다.   CheckPassAction.java   import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class CheckPassAction implements Action  { \t@Override \tpublic ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception  \t{ \t\tSystem.out.println(\"M : CheckPassAction - execute() 호출\"); \t\t \t\t// 파라메터 저장 \t\tString id = request.getParameter(\"id\"); \t\tString pass = request.getParameter(\"pass\"); \t\t \t\t// 회원정보 저장 \t\tMemberDTO dto = new MemberDTO(); \t\tdto.setId(id); \t\tdto.setPass(pass); \t\t \t\tresponse.setContentType(\"text/html; charset=utf-8\"); \t\tPrintWriter out = response.getWriter(); \t\t \t\t// DB 연동해서 아이디와 비밀번호가 일치하는 지 확인 \t\tMemberDAO dao = new MemberDAO(); \t\tint result = dao.loginCheck(dto); \t\tif (1 == result) \t\t{ \t\t\t// 비번 일치 \t\t\tout.println(\"&lt;script&gt;location.href='./myPage.me';&lt;/script&gt;\"); \t\t} \t\telse  \t\t{ \t\t\t// 비번 불일치 \t\t\tout.println(\"&lt;script&gt;alert('비밀번호가 일치하지 않습니다!'); history.back();&lt;/script&gt;\"); \t\t} \t\t \t\tout.close(); \t\t \t\treturn null; \t} }      자바스크립트 코드로 페이지 이동이 이루어지도록 하기 위해서 페이지 이동 정보를 담은 객체를 만들지 않고 null을 리턴했다.   어제 한 시간 넘게 고민했는데 학원 선생님한테 여쭤보니까 5분만에 해결 되었다. 😅         고민 끝! 수정 완료!!  ","categories": ["ErrorLog"],
        "tags": ["Error","Solve","Log"],
        "url": "/errorlog/warning-log-03/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 8 - 회원 정보 수정 기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     마이페이지로 이동해서 회원 정보를 수정할 수 있는 기능을 추가했다.   로그인 하면 마이페이지로 이동할 수 있는 버튼이 활성화 된다.   checkPass.jsp   &lt;!-- 회원정보 수정 페이지로 가기 전에 비밀번호 한 번 더 확인 후 이동 --&gt; &lt;h3&gt;마이페이지&lt;/h3&gt; &lt;%     String id = (String)session.getAttribute(\"id\");     if (null == id)         response.sendRedirect(\"./login.me\"); %&gt; &lt;form name=\"checkPass\" action=\"./CheckPassAction.me\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     &lt;input type=\"hidden\" value=\"&lt;%=id%&gt;\" name=\"id\"&gt;     &lt;div class=\"formRow\"&gt;         비밀번호를 한 번 더 입력해 주세요.     &lt;/div&gt;&lt;br&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 &lt;/label&gt;&lt;input id=\"pass\" type=\"password\" name=\"pass\"&gt;     &lt;/div&gt;     &lt;button type=\"submit\" class=\"btn\"&gt;확인&lt;/button&gt; &lt;/form&gt;      마이페이지로 이동하기 전에 비밀번호를 한 번 더 확인 할 것이다.   checkPass.js   function finalCheck() {     var checkPass = document.checkPass; \t     if (0 &gt;= checkPass.pass.value.length)     {         // 비밀번호가 입력되지 않았으면 false         alert(\"비밀번호를 입력해 주세요!\");         checkPass.pass.focus();         return false;     } }      자바스크립트 코드를 사용해서 빈 데이터가 넘어가지 않게 처리했다.   CheckPassAction.java   import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class CheckPassAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : CheckPassAction - execute() 호출\"); \t\t         // 파라메터 저장         String id = request.getParameter(\"id\");         String pass = request.getParameter(\"pass\"); \t\t         // 회원정보 저장         MemberDTO dto = new MemberDTO();         dto.setId(id);         dto.setPass(pass); \t\t         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter(); \t\t         // DB 연동해서 아이디와 비밀번호가 일치하는 지 확인         MemberDAO dao = new MemberDAO();         int result = dao.loginCheck(dto);         if (1 == result)         {             // 비번 일치             out.println(\"&lt;script&gt;\");             out.println(\"location.href='./myPage.me';\");             out.println(\"&lt;/script&gt;\");         }         else          {             // 비번 불일치             out.println(\"&lt;script&gt;\");             out.println(\"alert('비밀번호가 일치하지 않습니다!');\");             out.println(\"history.back();\");             out.println(\"&lt;/script&gt;\");         } \t\t         out.close(); \t\t         return null;     } }      입력된 비밀번호가 전달되면 DB와 접속해서 비밀번호가 일치하는 지 확인한다.   비밀번호가 틀렸을 때에 알림창을 출력하기 위해서 자바스크립트 코드를 사용한다. 그래서 여기에서의 페이지 이동방식도 자바스크립트로 처리해 주었다.(페이지 이동은 자바 코드로 하면서 알림창 출력만 자바스크립트로 하면 충돌 생겨서 정상 동작이 안 됨)   관련글 : 에러해결 Log) java.lang.IllegalStateException 응답이 이미 커밋된 후에는 sendRedirect()를 호출할 수 없습니다.   myPage.jsp   ... 생략  &lt;h3&gt;마이페이지&lt;/h3&gt;&lt;br&gt; &lt;%     String id = (String) session.getAttribute(\"id\");     if (null == id)         response.sendRedirect(\"./login.me\");       \t         MemberDAO dao = new MemberDAO();         MemberDTO dto = dao.getMember(id);       \t         String[] regdate = dto.getRegdate().toString().split(\" \"); %&gt; &lt;form name=\"myPage\" action=\"./MemberUpdateAction.me\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;회원번호 &lt;/label&gt;&lt;input type=\"text\" name=\"memberNum\" id=\"memberNum\" value=\"&lt;%=dto.getMemberNum() %&gt;\" readonly&gt;     &lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;아이디 &lt;/label&gt;&lt;input type=\"text\" name=\"id\" id=\"id\" value=\"&lt;%=dto.getId() %&gt;\" readonly&gt;     &lt;/div&gt;     &lt;div id=\"idMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 &lt;/label&gt;&lt;input type=\"password\" name=\"pass\" id=\"pass\"&gt;     &lt;/div&gt;     &lt;div id=\"passMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 확인 &lt;/label&gt;&lt;input type=\"password\" name=\"confirm\" id=\"confirm\"&gt;     &lt;/div&gt;     &lt;div id=\"confirmMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;이름 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"name\" class=\"name\" value=\"&lt;%=dto.getName()%&gt;\"&gt;     &lt;/div&gt;     &lt;div id=\"nameMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;생년월일 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"date\" name=\"birth\" class=\"birth\" value=\"&lt;%=dto.getBirth()%&gt;\"&gt;     &lt;/div&gt;     &lt;div id=\"birthMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;나이 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"age\" class=\"age\" value=\"&lt;%=dto.getAge()%&gt;\" disabled&gt;     &lt;/div&gt;     &lt;div id=\"ageMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;성별 &lt;/label&gt;&lt;input class=\"radio\" type=\"radio\" name=\"gender\" id=\"gender\" value=\"남\"             &lt;%if (dto.getGender().equals(\"남\")) { %&gt;                  checked             &lt;%} %&gt;&gt;&lt;label class=\"radioText\"&gt;남&lt;/label&gt;          &lt;input class=\"radio\" id=\"gender\" type=\"radio\" name=\"gender\" value=\"여\"             &lt;%if (dto.getGender().equals(\"여\")) { %&gt;                 checked             &lt;%} %&gt;&gt;&lt;label class=\"radioText\"&gt;여&lt;/label&gt;     &lt;/div&gt;     &lt;div id=\"genderMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\"&gt;         &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;도시 &lt;/label&gt;         &lt;select name=\"city\"&gt;             &lt;option selected disabled&gt;도시를 선택하세요.&lt;/option&gt;             &lt;option              &lt;%if (dto.getAddress().equals(\"서울\")) { %&gt;                 selected             &lt;%} %&gt;&gt;서울&lt;/option&gt;             &lt;option             &lt;%if (dto.getAddress().equals(\"부산\")) { %&gt;                 selected             &lt;%} %&gt;&gt;부산&lt;/option&gt;             &lt;option             &lt;%if (dto.getAddress().equals(\"대전\")) { %&gt;                 selected             &lt;%} %&gt;&gt;대전&lt;/option&gt;         &lt;/select&gt;     &lt;/div&gt;     &lt;div id=\"cityMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\" id=\"phoneArea\"&gt;         &lt;label for=\"MOD_TEXTFORM_TelField\"&gt;휴대폰 번호 &lt;/label&gt;         &lt;label class=\"phone\"&gt;             &lt;input id=\"phone1\" type=\"tel\" name=\"phone1\" size=\"1\" maxlength=\"3\" value=\"&lt;%=dto.getPhone().substring(0, 3) %&gt;\" oninput=\"tabCursor(1)\"&gt; -              &lt;input id=\"phone2\" type=\"tel\" name=\"phone2\" size=\"3\" maxlength=\"4\" value=\"&lt;%=dto.getPhone().substring(3, 7) %&gt;\" oninput=\"tabCursor(2)\"&gt; -              &lt;input id=\"phone3\" type=\"tel\" name=\"phone3\" size=\"3\" maxlength=\"4\" value=\"&lt;%=dto.getPhone().substring(7, 11) %&gt;\"&gt;             &lt;button id=\"requestBtn\" class=\"btn\" type=\"submit\" name=\"requestBtn\" onclick=\"changePhoneBtnStatus();\"&gt;&lt;/button&gt;         &lt;/label&gt;     &lt;/div&gt;     &lt;div id=\"phoneMsg\"&gt;&lt;/div&gt;     &lt;div class=\"formRow\" id=\"validateArea\"&gt;         &lt;label for=\"MOD_TEXTFORM_EmailField\"&gt;인증번호 &lt;/label&gt;         &lt;label class=\"phone\"&gt;             &lt;input type=\"text\" name=\"validateNum\" id=\"validateNum\"&gt;             &lt;button id=\"validateBtn\" class=\"btn\" type=\"submit\" name=\"validateBtn\"&gt;인증번호 확인&lt;/button&gt;         &lt;/label&gt;     &lt;/div&gt;         &lt;div id=\"validateMsg\"&gt;&lt;/div&gt;         &lt;div class=\"formRow\"&gt;             &lt;label for=\"MOD_TEXTFORM_EmailField\"&gt;이메일 &lt;/label&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" value=\"&lt;%=dto.getEmail()%&gt;\"&gt;         &lt;/div&gt;         &lt;div id=\"emailMsg\"&gt;&lt;/div&gt;         &lt;div class=\"formRow\"&gt;             &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;가입일 &lt;/label&gt;&lt;input type=\"text\" name=\"regdate\" id=\"regdate\" value=\"&lt;%=regdate[0] %&gt;\" readonly&gt;         &lt;/div&gt;     &lt;button type=\"submit\" class=\"btn\"&gt;회원 정보 수정&lt;/button&gt; &lt;/form&gt;  생략 ...      회원번호와 아이디, 가입일과 같은 정보들은 변경할 수 없게 했다.   비밀번호는 빈 칸으로 두고 비밀번호를 입력해야만 최종 정보 수정을 할 수 있도록 했다.(기존과 같은 비밀번호 입력해도 ok)   휴대폰 번호는 기본적으로 변경할 필요가 없되, 변경을 원하면 휴대폰변경 버튼을 눌러서 변경할 수 있도록 했다. 이에 대한 처리는 자바스크립트로 해 주었다.   myPage.js   ... 생략(join.js 코드와 유사)  function changePhoneBtnStatus() {     // 휴대폰 번호 변경 버튼을 클릭하면 부분만 새로고침     $changePh = true;     $(\"#phoneArea\").load(location.href + \" #phoneArea\");     $(\"#validateArea\").load(location.href + \" #validateArea\"); }  function changePhone() {     if ($changePh)     {         // 휴대폰 번호 변경          // 휴대폰변경 버튼을 누르면 휴대폰 번호 입력란과 인증번호 입력란을 활성화 시킴         $(\"#phone1\").removeAttr(\"readonly\");         $(\"#phone2\").removeAttr(\"readonly\");         $(\"#phone3\").removeAttr(\"readonly\");         $(\"#validateNum\").removeAttr(\"disabled\");         $(\"#validateBtn\").removeAttr(\"disabled\");         $(\"#requestBtn\").html(\"휴대폰인증\");     }     else      {         // 초기값은 변경 불가능         $(\"#phone1\").attr(\"readonly\", true);         $(\"#phone2\").attr(\"readonly\", true);         $(\"#phone3\").attr(\"readonly\", true);         $(\"#validateNum\").attr(\"disabled\", true);         $(\"#validateBtn\").attr(\"disabled\", true);         $(\"#requestBtn\").html(\"휴대폰변경\");     } }  생략 ...      입력한 정보의 유효성을 검사하는 부분은 join.js에 썼던 코드와 같은 것을 사용해서 생략했다.   휴대폰변경 버튼을 클릭하면 휴대폰 번호와 인증번호 입력 필드 부분만 새로고침한다. 이후 인증 로직은 회원 가입 때 썼던 것과 동일   MemberFrontController.java   package com.project.cafe.member.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.api.sms.SmsService;  public class MemberFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException      {         // 주소 계산 부분 생략         ...                  // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null;          if (command.equals(\"/MemberJoinAction.me\"))         {             System.out.println(\"C : /MemberJoinAction.me 호출\");             System.out.println(\"C : 이전 페이지 정보를 가져와서 DB 테이블에 저장 후 페이지 이동\"); \t\t\t             action = new MemberJoinAction(); // 인터페이스를 통해 객체를 생성함으로써 약한결합이 되도록 한다. \t\t\t             try {                 forward = action.execute(req, resp);             }              catch (Exception e) {                 e.printStackTrace();             }         }         else if (command.equals(\"/MemberUpdateAction.me\"))         {             System.out.println(\"C : /MemberUpdateAction.me 호출\"); \t\t\t             action = new MemberUpdateAction(); \t\t\t             try {                 forward = action.execute(req, resp);             }             catch (Exception e) {                 e.printStackTrace();             }         }         else if (command.equals(\"/CheckPassAction.me\"))         {             System.out.println(\"C : /CheckPassAction.me 호출\"); \t\t\t             action = new CheckPassAction(); \t\t\t             try {                 forward = action.execute(req, resp);             }             catch (Exception e) {                 e.printStackTrace();             }         }         else         {             forward = new ActionForward();              if (command.equals(\"/main.me\"))             {                 System.out.println(\"C : 메인페이지 호출\");                 forward.setPath(\"./main/main.jsp\");\t\t\t\t             }             else if (command.equals(\"/join.me\"))             {                 System.out.println(\"C : 회원가입 페이지 호출\");                 forward.setPath(\"./member/join.jsp\");\t\t\t\t             }             else if (command.equals(\"/login.me\"))             {                 System.out.println(\"C : 로그인 페이지 호출\");                 forward.setPath(\"./member/login.jsp\");\t\t\t\t             }             else if (command.equals(\"/logout.me\"))             {                 System.out.println(\"C : 로그아웃 페이지 호출\");                 forward.setPath(\"/logout.me\");             }             else if (command.equals(\"/checkPass.me\"))             {                 System.out.println(\"C : 비번 한 번 더 입력하는 페이지 호출\");                 forward.setPath(\"./member/checkPass.jsp\");             }             else if (command.equals(\"/myPage.me\"))             {                 System.out.println(\"C : 마이페이지 호출\");                 forward.setPath(\"./member/myPage.jsp\");             } \t\t\t             forward.setRedirect(false);         } \t\t         System.out.println(\"C : 가상주소 매핑 완료\\n\");         // 2. 가상주소 매핑 \t\t         // 3. 페이지 이동         if (null != forward) // 페이지 이동정보가 있을 때         {             if (forward.isRedirect())             {                 System.out.println(\"C : sendRedirect 방식 - \" + forward.getPath() + \" 이동\");                 resp.sendRedirect(forward.getPath());             }             else              {                 System.out.println(\"C : forward 방식 - \" + forward.getPath() + \" 이동\");                 RequestDispatcher dis = req.getRequestDispatcher(forward.getPath());                 dis.forward(req, resp);             } \t\t\t             System.out.println(\"C : 페이지 이동 완료\");         }         // 3. 페이지 이동     } \t     @Override     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException      {         doProcess(req, resp);     }      @Override     protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException      {         doProcess(req, resp);     } }      수정하고 싶은 회원 정보를 입력하고 제출 버튼을 누르면 Front로 이동해서 매핑된 페이지로 이동한다.   회원 정보를 DB에서 업데이트 할 것이니까 MemberUpdateAction() 객체를 만들어서 이동한다.   MemberUpdateAction.java   package com.project.cafe.member.action;  import java.io.PrintWriter; import java.sql.Date; import java.util.Calendar;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  // 회원 정보 수정 public class MemberUpdateAction implements Action {     private int getAge(String birth)     {         int year = Integer.parseInt(birth.split(\"-\")[0]);         int curYear = Calendar.getInstance().get(Calendar.YEAR); \t\t         return curYear - year;     } \t     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : MemberUpdateAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 전달받은 파라미터 저장         MemberDTO dto = new MemberDTO();         dto.setAddress(request.getParameter(\"city\")); \t\t         // 나이 계산         int age = getAge(request.getParameter(\"birth\"));         dto.setAge(age); \t\t         dto.setBirth(Date.valueOf(request.getParameter(\"birth\")));         dto.setEmail(request.getParameter(\"email\"));         dto.setGender(request.getParameter(\"gender\"));         dto.setId(request.getParameter(\"id\"));         dto.setName(request.getParameter(\"name\"));         dto.setName(request.getParameter(\"name\"));         dto.setPass(request.getParameter(\"pass\")); \t\t         // 폰번호 3개 필드 합치기         String phone = request.getParameter(\"phone1\") + request.getParameter(\"phone2\") + request.getParameter(\"phone3\");         dto.setPhone(phone); \t\t         System.out.println(\"M : 수정된 회원 정보 저장\");         System.out.println(\"M : \" + dto); \t\t         // DAO 객체 생성         MemberDAO dao = new MemberDAO(); \t\t         // update 함수 호출         int result = dao.updateMember(dto); \t\t         System.out.println(\"M : result - \" + result);         System.out.println(\"M : 회원 정보 수정 완료\"); \t\t         response.setContentType(\"text/html; charset=UTF-8\");         PrintWriter out = response.getWriter();         out.print(\"&lt;script&gt;\");         out.print(\"alert('정보 수정이 완료되었습니다.');\");         out.print(\"location.href='./myPage.me';\");         out.print(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      전달된 정보들을 MemberDTO 객체에 저장한 뒤 DB와 연결해서 update 동작을 수행한다.   수정이 완료되면 알림창을 띄우기 위해서 자바스크립트 코드를 사용했다.   MemberDAO - updateMember(dto)   public int updateMember(MemberDTO dto) {     int result = -1; \t\t     try {         // 1.2 DB 연결         // 회원 정보가 존재하는 지 먼저 확인한 후에 수정 동작 수행         con = getCon();         sql = \"select * from cafe_members where id=?\";         pstmt = con.prepareStatement(sql);         pstmt.setString(1, dto.getId());         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             if (rs.getString(\"id\").equals(dto.getId()))             {                 // 회원 정보가 있으면                 // 3. sql 작성 &amp; pstmt 객체 생성                 sql = \"update cafe_members set pass=?, name=?, birth=?, age=?, gender=?, address=?, phone=?, email=? where id=?\";                 pstmt = con.prepareStatement(sql); \t\t\t\t\t                 // ? 채우기                 pstmt.setString(1, dto.getPass());                 pstmt.setString(2, dto.getName());                 pstmt.setDate(3, dto.getBirth());                 pstmt.setInt(4, dto.getAge());                 pstmt.setString(5, dto.getGender());                 pstmt.setString(6, dto.getAddress());                 pstmt.setString(7, dto.getPhone());                 pstmt.setString(8, dto.getEmail());                 pstmt.setString(9, dto.getId()); \t\t\t\t\t                 // 4. sql 실행                 pstmt.executeUpdate(); \t\t\t\t\t                 // 5. 데이터 처리                 // 수정 성공                 result = 1;                 System.out.println(\"DAO : 회원 정보 수정 완료\");             }             else              {                 result = 0;             }         }         else          {             // 회원 정보 없음 - 비회원             result = -1;         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         CloseDB();     } \t\t     return result; }      select 조회 결과 일치하는 회원 정보가 있을 때에만 update 동작을 수행한다.        마이페이지에 들어가기 전에 비밀번호를 한 번 더 확인하고 들어오기 때문에 항상 정보가 있는 회원만 들어오게 되지만 그래도 업데이트 동작은 안전하게 하는 것이 정석이라 배워서 이렇게 구현했다.        이제 회원 탈퇴 기능을 만들어야지…!      마감까지     D-16  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-08/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 9 - 회원 탈퇴 기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     마이페이지에 접속해서 회원 탈퇴를 할 수 있는 기능을 만들었다.   myPage.jsp      &lt;form action=\"./delete.me\" method=\"post\"&gt;     &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=dto.getId()%&gt;\"&gt;     &lt;input type=\"hidden\" name=\"pass\" value=\"&lt;%=dto.getPass()%&gt;\"&gt;     &lt;button type=\"submit\" class=\"btn\"&gt;회원탈퇴&lt;/button&gt; &lt;/form&gt;      마이페이지 하단에 회원 탈퇴 버튼을 추가했다.   바로 탈퇴 동작을 수행하지 않고 delete.me 페이지로 이동해 비밀번호를 한 번 더 확인한 후에 진행할 것이다.   MemberFrontController.java   import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.api.sms.SmsService;  public class MemberFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // 매핑된(.me로 끝나는) 주소를 받아옴         String requestURI = req.getRequestURI();         System.out.println(\"requestURI : \" + requestURI); \t\t         // 매핑된 해당 프로젝트 주소를 구함         String ctxPath = req.getContextPath();         System.out.println(\"ctxPath : \" + ctxPath); \t\t         // 매핑된 주소 - 프로젝트 주소 = 계속 바뀔 뒷자리 주소 구함         String command = requestURI.substring(ctxPath.length());         System.out.println(\"command : \" + command); \t\t         System.out.println(\"C : 가상주소 계산 완료\\n\");         // 1. 전달되는 가상주소 계산 \t\t \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null;  \t\t...         생략                  else         {             forward = new ActionForward();              ...             생략                          else if (command.equals(\"/myPage.me\"))             {                 System.out.println(\"C : 마이페이지 호출\");                 forward.setPath(\"./member/myPage.jsp\");             }             else if (command.equals(\"/delete.me\"))             {                 System.out.println(\"C : 삭제 확인 페이지 호출\");                 forward.setPath(\"./member/delete.jsp\");             } \t\t\t             forward.setRedirect(false);         } \t\t         System.out.println(\"C : 가상주소 매핑 완료\\n\");         // 2. 가상주소 매핑 \t\t \t\t         // 3. 페이지 이동         ... \t} \t \t@Override \tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t}  \t@Override \tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  \t{ \t\tdoProcess(req, resp); \t} }      컨트롤러에서 삭제 전 비밀번호를 확인하는 페이지로 연결시켜 준다.   delete.jsp   &lt;h3&gt;회원탈퇴&lt;/h3&gt; &lt;%     String id = (String)session.getAttribute(\"id\");     if (null == id)         response.sendRedirect(\"./login.me\"); %&gt; &lt;form name=\"checkPass\" action=\"./MemberDeleteAction.me\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     &lt;input type=\"hidden\" value=\"&lt;%=id%&gt;\" name=\"id\"&gt;     &lt;input type=\"hidden\" value=\"delete\" name=\"actionType\"&gt;     &lt;div class=\"formRow\"&gt;         탈퇴하시려면 비밀번호를 한 번 더 입력해 주세요.     &lt;/div&gt;&lt;br&gt;     &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;비밀번호 &lt;/label&gt;&lt;input id=\"pass\" type=\"password\" name=\"pass\"&gt;     &lt;/div&gt;     &lt;button type=\"submit\" class=\"btn\"&gt;확인&lt;/button&gt; &lt;/form&gt;      보통 로그인 된 상태로 여기까지 오겠지만 혹시 모르니까 로그인 정보가 없을 때의 예외처리를 해 주었다.   마이페이지 입장 전 비밀번호를 확인하는 페이지인 checkPass.jsp 페이지와 동일한 구성이기 때문에 onsubmit 필드의 함수는 checkPass.js의 finalCheck() 함수를 그대로 썼다.   MemberDeleteAction.java   package com.project.cafe.member.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession;  import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class MemberDeleteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : MemberDeleteAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 전달된 정보 저장         MemberDTO dto = new MemberDTO();         dto.setId(request.getParameter(\"id\"));         dto.setPass(request.getParameter(\"pass\")); \t\t         // DB 연결해서 삭제         MemberDAO dao = new MemberDAO();         int result = dao.deleteMember(dto); \t\t         // 삭제 완료 알림창 띄우고 메인페이지 이동         response.setContentType(\"text/html; charset=UTF-8\");         PrintWriter out = response.getWriter();         if (1 == result)         {             // 탈퇴가 완료되면 세션 초기화 및 메인으로 이동             HttpSession session = request.getSession();             session.invalidate(); \t\t\t             out.write(\"&lt;script&gt;\");             out.write(\"alert('회원 탈퇴가 완료되었습니다.');\");             out.write(\"location.href='./main.me';\");             out.write(\"&lt;/script&gt;\");         }         else          {             out.write(\"&lt;script&gt;\");             out.write(\"alert('비밀번호가 일치하지 않습니다!');\");             out.write(\"history.back();\");\t\t\t             out.write(\"&lt;/script&gt;\");         } \t\t         out.close(); \t\t         return null;     } }      회원정보 수정을 할 때와 마찬가지로 DB와 연결해서 회원 정보가 존재하는 지 확인한 후 결과에 따라 탈퇴 동작을 수행한다.   회원탈퇴를 했는데 로그인 상태로 남아있지 않게 하기 위해서 delete가 완료되면 세션 초기화를 해 주었다.   MemberDAO.java - deleteMember(dto)   public int deleteMember(MemberDTO dto) {     int result = -1; \t\t     try {         // 1.2 DB 연결         con = getCon(); \t\t\t         // 3. sql 작성 &amp; pstmt 생성         sql = \"select pass from cafe_members where id=?\";         pstmt = con.prepareStatement(sql);         pstmt.setString(1, dto.getId()); \t\t\t         // 4. sql 실행         rs = pstmt.executeQuery(); \t\t\t         // 5. 데이터 처리         if (rs.next())         {             if (rs.getString(\"pass\").equals(dto.getPass()))             {                 // 삭제하는 쿼리문 실행                 sql = \"delete from cafe_members where id=?\";                 pstmt = con.prepareStatement(sql);                 pstmt.setString(1, dto.getId()); \t\t\t\t\t                 result = pstmt.executeUpdate(); \t\t\t\t\t                 System.out.println(\"DAO : 회원정보 삭제 완료\");             }             else                 result = 0;         }         else             result = -1;     }     catch (Exception e) {         e.printStackTrace();     }     finally {         CloseDB();     }          return result; }      DB 접속 후 입력받은 회원정보가 DB에 존재하며 아이디와 비밀번호가 일치하는 지 확인한 후 삭제 동작을 수행한다.         이렇게 회원 탈퇴도 완료!   이제 게시판 만들어야지!      마감까지     D-14  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-09/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 10 - 게시판 만들기 시작",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시판을 만들기 위한 기본 세팅만 했다.   새로운 게시판 전용 컨트롤러를 만들고 xml 페이지에서 매핑시켜 주었다.   web.xml   ... 생략  &lt;!-- 회원(Member) 처리 컨트롤러 --&gt; &lt;servlet&gt;     &lt;servlet-name&gt;MemberFrontController&lt;/servlet-name&gt;     &lt;servlet-class&gt;com.project.cafe.member.action.MemberFrontController&lt;/servlet-class&gt; &lt;/servlet&gt;    &lt;servlet-mapping&gt;     &lt;servlet-name&gt;MemberFrontController&lt;/servlet-name&gt;     &lt;url-pattern&gt;*.me&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 회원(Member) 처리 컨트롤러 --&gt;    &lt;!-- 게시판(Board) 처리 컨트롤러 --&gt; &lt;servlet&gt;     &lt;servlet-name&gt;BoardFrontController&lt;/servlet-name&gt;     &lt;servlet-class&gt;com.project.cafe.board.action.BoardFrontController&lt;/servlet-class&gt; &lt;/servlet&gt;    &lt;servlet-mapping&gt;     &lt;servlet-name&gt;BoardFrontController&lt;/servlet-name&gt;     &lt;url-pattern&gt;*.bo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;  ... 생략      게시판용 컨트롤러를 추가하기 위해서 서블릿 매핑을 추가해 주었다.   두 번째 하니까 좀 더 쉽게 느껴진다. ☺️   ActionForward.java   package com.project.cafe.action; // MemberController에서도 같이 사용하는 클래스라서 다른 패키지 사용  public class ActionForward  {     // 페이지를 이동할 때 필요한 정보를 저장하는 클래스 \t     private String path; // 이동경로     private boolean isRedirect; // 이동방식 \t     // isRedirect = true  =&gt; 주소가 바뀌고 화면도 바뀜     // isRedirect = false  =&gt; 주소는 바뀌지 않고 화면만 바뀜 \t     public String getPath() {return path;}     public void setPath(String path) {this.path = path;}     public boolean isRedirect() {return isRedirect;}     public void setRedirect(boolean isRedirect) {this.isRedirect = isRedirect;} }   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // 매핑된(.bo로 끝나는) 주소를 받아옴         String requestURI = request.getRequestURI();         System.out.println(\"requestURI : \" + requestURI); \t\t         // 매핑된 해당 프로젝트 주소 구함         String ctxPath = request.getContextPath();         System.out.println(\"ctxPath : \" + ctxPath); \t\t         // 매핑된 주소(requestURI)에서 프로젝트 주소(ctxPath)를 빼서 계속 바뀌는 맨 뒤 주소를 구함         String command = requestURI.substring(ctxPath.length());         System.out.println(\"command : \" + command); \t\t         System.out.println(\"1. 가상주소 계산 완료\\n\"); \t\t \t\t         // 2. 가상주소 매핑         ActionForward forward = null; \t\t         if (command.equals(\"/board.bo\"))         {             System.out.println(\"C : /board.bo 호출\"); \t\t\t             forward = new ActionForward();             forward.setPath(\"./contents/boardList.jsp\");             forward.setRedirect(false);         }         else if (command.equals(\"/boardWrite.bo\"))         {             System.out.println(\"C : /boardWrite.bo 호출\"); \t\t\t             forward = new ActionForward();             forward.setPath(\"./contents/boardWrite.jsp\");             forward.setRedirect(false);         } \t\t         System.out.println(\"2. 가상주소 매핑 완료\"); \t\t \t\t         // 3. 페이지 이동         if (null != forward)         {             // 페이지 정보가 있을 때             if (forward.isRedirect())             {                 System.out.println(\"C : sendRedirect 방식으로 페이지 이동 : \" + forward.getPath());                 response.sendRedirect(forward.getPath());             }             else              {                 System.out.println(\"C : forward 방식으로 페이지 이동 : \" + forward.getPath());                 RequestDispatcher dis = request.getRequestDispatcher(forward.getPath());                 dis.forward(request, response);             } \t\t\t             System.out.println(\"3. 페이지 이동 완료\");         }     } \t     @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         doProcess(request, response);     }      @Override     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         doProcess(request, response);     } }      게시판용 컨트롤러를 만들고 게시글 리스트를 보는 페이지와 글쓰기 페이지를 연결시켜 주었다.   그런데 글쓰기 페이지로 연결하는 기능을 만들고 나서 생각해 보니까 로그인 한 사용자인지 확인을 하지 않고 글쓰기 버튼을 누르면 무조건 연결시켜 주고 있었다… 😅 이제부터 로그인 한 회원만 글을 쓸 수 있도록 유효성 검사하는 부분을 추가할 것이다!      마감까지     D-14  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-10/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 11 - 회원만 게시판 글 쓸 수 있게 하기",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     로그인 한 회원만 게시판에 글을 쓸 수 있도록하는 유효성 검사를 추가했다.   boardList.jsp   &lt;%     String id = (String)session.getAttribute(\"id\"); \t     boolean isLogin = false;     if (null == id) isLogin = false;     else isLogin = true; %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;     &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;         &lt;h2&gt;최신글 보기&lt;/h2&gt;         &lt;p align=\"right\"&gt;&lt;button type=\"button\" class=\"btn\" id=\"writeBtn\"              onclick=\"memberCheck(&lt;%=isLogin%&gt;);\"&gt;글쓰기&lt;/button&gt;&lt;/p&gt;         &lt;table class=\"type09\"&gt;         &lt;colgroup&gt;             &lt;col width=\"10%\"&gt;             &lt;col width=\"60%\"&gt;             &lt;col width=\"10%\"&gt;             &lt;col width=\"10%\"&gt;             &lt;col width=\"10%\"&gt;         &lt;/colgroup&gt;         &lt;thead&gt;         &lt;tr&gt;         &lt;th scope=\"cols\"&gt;No.&lt;/th&gt;         &lt;th scope=\"cols\"&gt;제목&lt;/th&gt;         &lt;th scope=\"cols\"&gt;작성자&lt;/th&gt;         &lt;th scope=\"cols\"&gt;작성일&lt;/th&gt;         &lt;th scope=\"cols\"&gt;조회수&lt;/th&gt;         &lt;/tr&gt;         &lt;/thead&gt;         &lt;tbody&gt;         &lt;tr&gt;         &lt;th scope=\"row\"&gt;번호&lt;/th&gt;         &lt;td&gt;내용이 들어갑니다.&lt;/td&gt;         &lt;td&gt;작성자&lt;/td&gt;         &lt;td&gt;작성일&lt;/td&gt;         &lt;td&gt;조회수&lt;/td&gt;         &lt;/tr&gt;         &lt;/tbody&gt;         &lt;/table&gt;     &lt;/div&gt;     &lt;/div&gt; &lt;/section&gt;   boardList.js   function memberCheck(flag) {     if (flag)     {         location.href = './boardWrite.bo';     }     else      {         alert('로그인 페이지로 이동합니다.');         location.href = './login.me';     } }      현재 세션에 저장된 아이디 정보를 확인한 후 자바스크립트를 이용해 간단한 유효성 검사를 해 주었다.   이제 DB에 접속해서 작성한 글을 저장하는 기능을 만들려고 했는데 어제 맥을 업데이트 했더니 MySQL Workbench가 켜지지 않는다… 다운그레이드 하러 가야겠다…. 😔      마감까지     D-13  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-11/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 12 - 게시판 글쓰기 기능 만들기",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     엊그제 저녁에 했던 맥 Monterey 12.3 버전 업데이트 이후로 MySQL Workbench가 실행되지 않아서 업데이트 직전 백업본으로 다운그레이드를 했다. 맥 초기화를 하고 OS를 새로 설치하는 과정에서 오류가 생겨서(아침에 수리센터 문 열자마자 가야 하나 싶어서 식은땀이 났다) 예상보다 시간이 오래 걸리는 바람에 어제는 작업을 많이 하지 못 했다. 🥲 맥 업데이트는 함부로 하지 말아야 하는 것이란 걸 배웠다…   오늘은 게시판에 글을 쓰면 글 목록을 새로 업데이트 해서 보여주는 기능을 만들 것이다.   boardWrite.jsp   &lt;% \tString id = (String)session.getAttribute(\"id\"); \tif (null == id) \t\tresponse.sendRedirect(\"./login.me\"); %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;     \t&lt;h2&gt;게시글 작성&lt;/h2&gt;     \t&lt;form name=\"write\" action=\"./BoardWriteAction.bo\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     \t&lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;제목 &lt;/label&gt;&lt;input type=\"text\" name=\"title\" id=\"title\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_MsgField\"&gt;내용 &lt;/label&gt;           &lt;textarea id=\"MOD_TEXTFORM_MsgField\" name=\"content\"&gt;&lt;/textarea&gt;         &lt;/div&gt;          &lt;button type=\"submit\" class=\"btn\"&gt;글 등록&lt;/button&gt;       &lt;/form&gt;       &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      게시글의 작성 정보를 Action class로 전달할 때 누가 쓴 글인지 구분할 수 있도록 아이디 정보도 함께 넘겨준다.   아이디 정보는 로그인 시 세션에 저장하며 이 페이지에서 보여줄 필요는 없으니까 hidden 타입으로 전달한다.   BoardFrontController.java   ...생략  // 2. 가상주소 매핑 Action action = null; ActionForward forward = null; \t\t if (command.equals(\"/BoardWriteAction.bo\")) {     System.out.println(\"C : /BoardWriteAction.bo 호출\"); \t\t\t     action = new BoardWriteAction(); \t\t\t     try {         forward = action.execute(request, response);     }     catch (Exception e) {         e.printStackTrace();     } }  ...생략      글 등록 버튼을 누르면 컨트롤러로 와서 DB에 글을 저장하는 동작을 수행하는 Action class로 연결된다.   BoardDTO.java   package com.project.cafe.board.db;  import java.sql.Date;  public class BoardDTO  {     int num;     String id;     String title;     String content;     int readcount;     int re_ref;     int re_lev;     int re_seq;     Date date;     String ip;     String file; \t     public int getNum() {return num;}     public void setNum(int num) {this.num = num;}     public String getId() {return id;}     public void setId(String id) {this.id = id;}     public String getTitle() {return title;}     public void setTitle(String title) {this.title = title;}     public String getContent() {return content;}     public void setContent(String content) {this.content = content;}     public int getReadcount() {return readcount;}     public void setReadcount(int readcount) {this.readcount = readcount;}     public int getRe_ref() {return re_ref;}     public void setRe_ref(int re_ref) {this.re_ref = re_ref;}     public int getRe_lev() {return re_lev;}     public void setRe_lev(int re_lev) {this.re_lev = re_lev;}     public int getRe_seq() {return re_seq;}     public void setRe_seq(int re_seq) {this.re_seq = re_seq;}     public Date getDate() {return date;}     public void setDate(Date date) {this.date = date;}     public String getIp() {return ip;}     public void setIp(String ip) {this.ip = ip;}     public String getFile() {return file;}     public void setFile(String file) {this.file = file;} \t     @Override     public String toString() {         return \"BoardDTO [num=\" + num + \", id=\" + id + \", title=\" + title + \", content=\" + content + \", readcount=\" \t\t\t\t+ readcount + \", re_ref=\" + re_ref + \", re_lev=\" + re_lev + \", re_seq=\" + re_seq + \", date=\" + date \t\t\t\t+ \", ip=\" + ip + \", file=\" + file + \"]\";     } }      게시글 정보를 저장하기 위한 클래스로 DB에 만든 테이블의 각 컬럼명에 대응되는 변수를 모두 만들어 주었다.   boardWriteAction.java   package com.project.cafe.board.action;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardWriteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardWriteAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 파라메터를 DTO에 저장         BoardDTO dto = new BoardDTO();         dto.setContent(request.getParameter(\"content\"));         dto.setId(request.getParameter(\"id\"));         dto.setTitle(request.getParameter(\"title\")); \t\t         // 사용자 ip주소 저장         dto.setIp(request.getRemoteAddr());         System.out.println(\"M : \" + dto); \t\t         // DB에 DTO 보내서 저장         BoardDAO dao = new BoardDAO();         dao.insertPost(dto); \t\t         // 완료되면 글 목록 페이지로 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./boardList.bo\");         forward.setRedirect(true); \t\t         System.out.println(\"M : 글쓰기 완료. 페이지정보 리턴\"); \t\t         return forward;     } }      Action class에서 DB와 연결해서 insert 작업을 수행한다.   글쓰기 동작이 완료되면 글 목록 페이지로 이동한다.   BoardDAO.java   package com.project.cafe.board.db;  import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  import javax.naming.Context; import javax.naming.InitialContext; import javax.sql.DataSource;  public class BoardDAO  {     // DB 연결동작 처리 \t     private Connection con = null;     private PreparedStatement pstmt = null;     private ResultSet rs = null;     private String sql = \"\"; \t     // getCon()     private Connection getCon() throws Exception     {         // 외부파일 불러오기 (META-INF/context.xml)         Context ctxInit = new InitialContext();         DataSource ds = (DataSource) ctxInit.lookup(\"java:comp/env/jdbc/cafe\");         con = ds.getConnection(); \t\t         System.out.println(\"DAO : 1.2. DB 연결 완료\"); \t\t         return con;     }     // getCon() \t     // closeDB()     public void closeDB()     {         try {             if (null != rs)\trs.close();             if (null != pstmt) pstmt.close();             if (null != con) con.close();         }         catch (SQLException e) {             e.printStackTrace();         }\t\t     }     // closeDB() \t     // insertPost(dto)     public void insertPost(BoardDTO dto)     {         int postNum = 0;  \t\t         try {             // 1.2. DB 연결             con = getCon(); \t\t\t             // 3. sql 작성 &amp; pstmt 객체             // 이번 차례에 DB에 저장될 글번호 계산             sql = \"select max(num) from cafe_board\";             pstmt = con.prepareStatement(sql); \t\t\t             if (rs.next())                 postNum = rs.getInt(1) + 1; \t\t\t             // 3. 데이터 삽입용 sql 작성 &amp; pstmt 설정             sql = \"insert into cafe_board(num, id, title, content, readcount, re_ref, re_lev, re_seq, date, ip, file) \"                     + \"values(?,?,?,?,?,?,?,?,now(),?,?)\";             pstmt = con.prepareStatement(sql); \t\t\t             // ? 채우기             pstmt.setInt(1, postNum);             pstmt.setString(2, dto.getId());             pstmt.setString(3, dto.getTitle());             pstmt.setString(4, dto.getContent());             pstmt.setInt(5, 0); // 처음에 조회수 0             pstmt.setInt(6, postNum); // 답글의 그룹. 일반글의 글번호와 동일하게 만듦             pstmt.setInt(7, 0); // 답글의 레벨. 처음엔 들여쓰기 없음             pstmt.setInt(8, 0); // 답글의 순서. 처음엔 가장 최상단             pstmt.setString(9, dto.getIp());             pstmt.setString(10, dto.getFile()); \t\t\t             // 4. sql 실행             pstmt.executeUpdate(); \t\t\t             System.out.println(\"DAO : 게시글 DB 삽입 완료\");         }         catch (Exception e) {             e.printStackTrace();         }         finally {             closeDB();         }     }     // insertPost(dto) }      DB에 게시글 데이터 삽입을 위한 함수를 만들었다.   re_ref, re_lev, re_seq 필드는 초기값 세팅만 해 두고 나중에 답글 기능을 구현할 때 사용할 것이다.   BoardFrontController.java   ... 생략  // 2. 페이지 매핑 else if (command.equals(\"/boardList.bo\")) {     System.out.println(\"C : /boardList.bo 호출\"); \t\t\t     action = new BoardListAction(); \t\t\t     try {         forward = action.execute(request, response);     }     catch (Exception e) {         e.printStackTrace();     } }  ... 생략      게시글 삽입이 완료되면 front로 와서 게시글 목록 페이지로 이동할 것이다.   그 전에 게시글 목록을 보여줘야 하니까 DB에 접속해서 저장된 게시글 정보를 가져와야 한다.   그래서 게시글 목록 페이지로 바로 이동하지 않고 Action class를 호출해서 DB에서 정보를 가져오는 동작을 수행한다.   BoardListAction.java   package com.project.cafe.board.action;  import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardListAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardListAction - execute() 호출\"); \t\t         // BoardDAO 객체 생성         BoardDAO dao = new BoardDAO(); \t\t         // DB에 저장된 글 갯수 가져오기         int postCnt = dao.getPostCount(); \t\t         // 페이징 처리 알고리즘 /////////////////////         // 한 페이지에 표시할 글 갯수         int pageSize = 10; \t\t         // 현재 페이지 정보가 몇 페이지인지 확인한 후 현재 페이지 정보를 가지고 이동         String pageNum = request.getParameter(\"pageNum\");         if (null == pageNum)         {             // 페이지 정보가 없으면 첫페이지인 1로 설정             pageNum = \"1\";         } \t\t         // 페이지 정보로 시작 행 번호 계산하기 1, 11, 21, 31, ...         int curPage = Integer.parseInt(pageNum);         int startRow = (curPage - 1) * pageSize + 1; \t\t         // DB에서 글 목록 가져오기         ArrayList&lt;BoardDTO&gt; postList = null;         if (0 != postCnt)         {             // 한 페이지에 표시할 만큼만 글 목록을 가져오기             postList = dao.getPostList(startRow, pageSize);         } \t\t         // 하단 페이징 처리하기 //////////////////////         // 현재 글 갯수만큼 페이지 이동 번호 출력하기 \t\t         // 페이지 전체 블럭 갯수 계산         int pageCnt = postCnt / pageSize + ((0 == postCnt % pageSize) ? 0 : 1); \t\t         // 한 번에 보여줄 페이지 블럭 갯수         int pageBlockCnt = 10; \t\t         // 시작 페이지블록 번호 구하기 \t1~10 =&gt; 1\t\t11~20 =&gt; 11 ...         int startBlock = ((curPage - 1) / pageBlockCnt) * pageBlockCnt + 1; \t\t         // 끝 페이지블록 번호 구하기         int endBlock = startBlock + pageBlockCnt - 1;         if (endBlock &gt; pageCnt)             endBlock = pageCnt;         // 하단 페이징 처리 끝 ////////////////////// \t\t         // request 영역에 글 목록 정보 저장         request.setAttribute(\"postCnt\", postCnt);         request.setAttribute(\"postList\", postList); \t\t         // request 영역에 페이징 처리 정보 저장         request.setAttribute(\"pageNum\", pageNum);         request.setAttribute(\"pageCnt\", pageCnt);         request.setAttribute(\"pageBlockCnt\", pageBlockCnt);         request.setAttribute(\"startBlock\", startBlock);         request.setAttribute(\"endBlock\", endBlock); \t\t         // 페이지 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./contents/boardList.jsp\");         forward.setRedirect(false); \t\t         return forward;     } }      각 페이지마다 정해진 갯수만큼 글을 보여줄 것이기 때문에 DB에서 정해진 갯수만큼만 글을 가져온다.   게시글 갯수에 따라서 글 목록을 보여주는 페이지를 이동할 수 있게 하기 위해서 게시판 하단에 페이지 정보를 보여주는데 필요한 정보도 함께 계산해서 request 영역에 저장한다.   BoardDAO.java   ... 생략  public int getPostCount() {     int ret = 0; \t\t     try {         con = getCon(); \t\t\t         // 전체 글 갯수 가져오기         sql = \"select count(*) from cafe_board\";         pstmt = con.prepareStatement(sql); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())             ret = rs.getInt(1); \t\t\t         System.out.println(\"DAO : 총 글 갯수 \" + ret);     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }  public ArrayList&lt;BoardDTO&gt; getPostList(int startRow, int pageSize) {     ArrayList&lt;BoardDTO&gt; postList = new ArrayList&lt;BoardDTO&gt;(); \t\t     try {         con = getCon(); \t\t\t         // 글 자르기 : limit 시작행-1, 갯수         // 시작행-1부터 x개 만큼 가져온다.         // 정렬 : re_ref(내림차순) / re_seq(오름차순)         sql = \"select * from cafe_board order by re_ref desc, re_seq asc limit ?,?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, startRow - 1); // 시작행 - 1         pstmt.setInt(2, pageSize); // 갯수 \t\t\t         rs = pstmt.executeQuery(); \t\t\t         while (rs.next())         {             // 글 1개의 정보(dto)에 저장한 후 배열에 저장             BoardDTO dto = new BoardDTO(); \t\t\t\t             dto.setContent(rs.getString(\"content\"));             dto.setDate(rs.getDate(\"date\"));             dto.setFile(rs.getString(\"file\"));             dto.setId(rs.getString(\"id\"));             dto.setIp(rs.getString(\"ip\"));             dto.setNum(rs.getInt(\"num\"));             dto.setRe_lev(rs.getInt(\"re_lev\"));             dto.setRe_ref(rs.getInt(\"re_ref\"));             dto.setRe_seq(rs.getInt(\"re_seq\"));             dto.setReadcount(rs.getInt(\"readcount\"));             dto.setTitle(rs.getString(\"title\")); \t\t\t\t             postList.add(dto);         } \t\t\t         System.out.println(\"DAO : 글 정보 저장 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return postList; }      DB에서 글 갯수를 가져오는 코드를 작성하는 도중에 pstmt까지 다 세팅해 놓고서는 executeQuery()를 해 주지 않아서 중간에 에러가 났었다…ㅎ 실행문을 잊지 말자! 🥲   boardList.jsp   ...생략  &lt;%     System.out.println(\"boardList.jsp 호출\");      String id = (String)session.getAttribute(\"id\"); \t     boolean isLogin = false;     if (null == id) isLogin = false;     else isLogin = true; \t     // 글 목록과 페이지 정보 저장     int postCnt = (int)request.getAttribute(\"postCnt\");     ArrayList&lt;BoardDTO&gt; postList = (ArrayList&lt;BoardDTO&gt;)request.getAttribute(\"postList\"); \t     String pageNum = (String)request.getAttribute(\"pageNum\");     int pageCnt = (int)request.getAttribute(\"pageCnt\");     int pageBlockCnt = (int)request.getAttribute(\"pageBlockCnt\");     int startBlock = (int)request.getAttribute(\"startBlock\");     int endBlock = (int)request.getAttribute(\"endBlock\"); %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h2&gt;최신글 보기 (전체 글 갯수 : &lt;%=postCnt %&gt;)&lt;/h2&gt;       &lt;p align=\"right\"&gt;&lt;button type=\"button\" class=\"btn\" id=\"writeBtn\"            onclick=\"memberCheck(&lt;%=isLogin%&gt;);\"&gt;글쓰기&lt;/button&gt;&lt;/p&gt;       &lt;table class=\"type09\"&gt;         &lt;colgroup&gt;           &lt;col width=\"10%\"&gt;           &lt;col width=\"50%\"&gt;           &lt;col width=\"10%\"&gt;           &lt;col width=\"20%\"&gt;           &lt;col width=\"10%\"&gt;         &lt;/colgroup&gt;         &lt;thead&gt;           &lt;tr&gt;             &lt;th scope=\"cols\"&gt;No.&lt;/th&gt;             &lt;th scope=\"cols\"&gt;제목&lt;/th&gt;             &lt;th scope=\"cols\"&gt;작성자&lt;/th&gt;             &lt;th scope=\"cols\"&gt;작성일&lt;/th&gt;             &lt;th scope=\"cols\"&gt;조회수&lt;/th&gt;           &lt;/tr&gt;         &lt;/thead&gt;         &lt;tbody&gt;         &lt;%             if (null != postList) {             for (int i = 0; i &lt; postList.size(); i++)              {                 BoardDTO dto = postList.get(i);         %&gt;           &lt;tr&gt;             &lt;th scope=\"row\"&gt;&lt;%=dto.getNum() %&gt;&lt;/th&gt;             &lt;td&gt;               &lt;a href=\"#\"&gt;&lt;%=dto.getTitle() %&gt;&lt;/a&gt;             &lt;/td&gt;             &lt;td&gt;&lt;%=dto.getId() %&gt;&lt;/td&gt;             &lt;td&gt;&lt;%=dto.getDate() %&gt;&lt;/td&gt;             &lt;td&gt;&lt;%=dto.getReadcount() %&gt;&lt;/td&gt;           &lt;/tr&gt;         &lt;%}} %&gt;         &lt;/tbody&gt;         &lt;/table&gt;&lt;br&gt;         &lt;div id=\"boardPage\"&gt;           &lt;%if (startBlock &gt; pageBlockCnt) { %&gt;             &lt;a href=\"./boardList.bo?pageNum=&lt;%=startBlock - pageBlockCnt%&gt;\"&gt;[이전]&lt;/a&gt;           &lt;%} %&gt; \t\t\t           &lt;%for (int i = startBlock; i &lt;= endBlock; i++) { %&gt;             &lt;a href=\"./boardList.bo?pageNum=&lt;%=i%&gt;\"&gt;[&lt;%=i %&gt;]&lt;/a&gt;           &lt;%} %&gt; \t\t\t           &lt;%if (endBlock &lt; pageBlockCnt &amp;&amp; postCnt &gt; pageBlockCnt) { %&gt;             &lt;a href=\"./boardList.bo?pageNum=&lt;%=startBlock + pageBlockCnt%&gt;\"&gt;[다음]&lt;/a&gt;           &lt;%} %&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt; &lt;/section&gt;      이제 게시글 목록 페이지로 오면 드디어 작성된 게시글들이 출력된다!         뿌듯하다! 😄   이제 각 게시글 제목을 누르면 내용을 볼 수 있는 기능을 구현할 것이다.      마감까지     D-12  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-12/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 03-3. 숫자 카드 게임",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 03 - 3. 숫자 카드 게임     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제            여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임            단, 게임의 룰을 지키며 뽑아야 한다.          숫자가 쓰인 카드들이 N X M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하고, M은 열의 개수를 의미   먼저 뽑고자 하는 카드가 포함된 행을 선택한다.   선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑는다.   따라서 처음에 카드를 골라낼 행을 선택할 때, 이후 해당 행에서 가장 숫자가 낮은 카드를 뽑아야 하는 것을 고려해 가장 높은 숫자를 뽑을 수 있도록 해야한다.     입력       첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다. (1 &lt;= N, M &lt;= 100)   둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수이다.     출력       첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.      👀 풀이       처음에 문제의 4번 조건이 이해가 안 되서 문제 이해를 위한 구글링을 해야 했다…   구글링 결과 각 행에서 가장 낮은 숫자를 뽑은 다음 그 중에서 가장 큰 수를 뽑는 문제였다.        이걸 이렇게 어렵게 설명할 필요가 있나? ㅠㅠ 문제 이해력 좀 올려야 겠다…        문제 풀이는 2차원 배열을 입력받은 후   2중 반복문으로 각 행에서 가장 작은 숫자를 찾은 뒤 그 수를 지금까지 찾은 가장 큰 수와 비교해서 더 큰 값으로 갱신해주는 방식으로 짰다.     코드          정답 참고 코드 1       책의 해설을 참고하여 min() 함수를 사용한 코드         정답 참고 코드 2       2중 반복문과 min() 함수를 사용한 코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","Greedy","Python"],
        "url": "/boj/CodingTestBook-03-3-py/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 13 - 게시글 조회 기능 만들기",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시판 목록에서 게시글을 선택하면 내용을 볼 수 있는 기능을 만들었다.   boardList.jsp   ...생략  &lt;thead&gt;   &lt;tr&gt;     &lt;th scope=\"cols\"&gt;No.&lt;/th&gt;     &lt;th scope=\"cols\"&gt;제목&lt;/th&gt;     &lt;th scope=\"cols\"&gt;작성자&lt;/th&gt;     &lt;th scope=\"cols\"&gt;작성일&lt;/th&gt;     &lt;th scope=\"cols\"&gt;조회수&lt;/th&gt;   &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;%   if (null != postList) {     for (int i = 0; i &lt; postList.size(); i++)      {       BoardDTO dto = postList.get(i); %&gt;   &lt;tr&gt;     &lt;th scope=\"row\"&gt;&lt;%=dto.getNum() %&gt;&lt;/th&gt;     &lt;td&gt;       &lt;a href=\"./BoardContent.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=dto.getTitle() %&gt;&lt;/a&gt;     &lt;/td&gt;     &lt;td&gt;&lt;%=dto.getId() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=dto.getDate() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=dto.getReadcount() %&gt;&lt;/td&gt;   &lt;/tr&gt; &lt;%}} %&gt; &lt;/tbody&gt;  ...생략      글 목록을 출력하는 부분에서 a 태그를 사용해 하이퍼링크를 추가했다.   글 번호와 현재 페이지 정보를 get 방식으로 파라미터로 넘겨준다.   페이지 정보를 넘겨주는 이유는 글을 보고 나서 목록으로 다시 돌아갈 때 사용자가 이전에 있던 페이지로 이동하기 위해서다.   BoardFrontController.java   // .. 생략  protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException  {     // .. 생략          // 2. 가상주소 매핑     Action action = null;     ActionForward forward = null;          // .. 생략      else if (command.equals(\"/BoardContent.bo\"))     {         System.out.println(\"C : /BoardContent.bo 호출\"); \t\t\t         action = new BoardContentAction(); \t\t\t         try {             forward = action.execute(request, response);         }         catch (Exception e) {             e.printStackTrace();         }     }      // .. 생략      글 제목을 누르면 Controller로 와서 글 내용을 보여주는 페이지로 연결된다.   BoardContentAction.java   package com.project.cafe.board.action;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardContentAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardContentAction - execute() 호출\"); \t\t         // 전달받은 파라메터(글 번호, 페이지정보) 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         String pageNum = request.getParameter(\"pageNum\"); // 페이지번호는 DB 처리할 때 사용하진 않아서 형변환 필요 X \t\t         // DAO 객체 생성         BoardDAO dao = new BoardDAO();          // 글 조회수 1 증가         dao.updateReadCount(num); \t\t         // 글 정보 불러오기         BoardDTO dto = dao.getPost(num); \t\t         // request 영역에 글 정보랑 페이지정보 저장         request.setAttribute(\"dto\", dto);         request.setAttribute(\"pageNum\", pageNum); \t\t         // 페이지 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./contents/boardContent.jsp\");         forward.setRedirect(false); \t\t         return forward;     } }      Action class에 오면 DB와 연결해서 글 조회수를 증가시킨 후 글 정보를 가져오는 동작을 수행한다.   BoardDAO.java - updateReadCount(num)   public void updateReadCount(int num) {     try {         con = getCon(); \t\t\t         sql = \"update cafe_board set readcount = readcount + 1 where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, num); \t\t\t         pstmt.executeUpdate(); \t\t\t         System.out.println(\"DAO : 조회수 1 증가 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } }      글 정보를 가져오기에 앞서 조회수를 먼저 증가시킨다.   BoardDAO.java - getPost(num)   public BoardDTO getPost(int num) {     BoardDTO dto = null; \t\t     try {         con = getCon(); \t\t\t         sql = \"select * from cafe_board where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, num); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             dto = new BoardDTO(); \t\t\t\t             dto.setContent(rs.getString(\"content\"));             dto.setDate(rs.getDate(\"date\"));             dto.setFile(rs.getString(\"file\"));             dto.setId(rs.getString(\"id\"));             dto.setIp(rs.getString(\"ip\"));             dto.setNum(rs.getInt(\"num\"));             dto.setRe_lev(rs.getInt(\"re_lev\"));             dto.setRe_ref(rs.getInt(\"re_ref\"));             dto.setRe_seq(rs.getInt(\"re_seq\"));             dto.setReadcount(rs.getInt(\"readcount\"));             dto.setTitle(rs.getString(\"title\")); \t\t\t\t             System.out.println(\"DAO : 글 1개 정보 저장 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return dto; }      조회수 증가가 완료되면 글 1개의 정보를 가져온다.   boardContent.jsp   &lt;%     String id = (String)session.getAttribute(\"id\"); \t     boolean isLogin = false;     if (null == id) isLogin = false;     else isLogin = true; \t     BoardDTO dto = (BoardDTO)request.getAttribute(\"dto\");     String pageNum = (String)request.getAttribute(\"pageNum\"); %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h2&gt;최신글 보기&lt;/h2&gt;       &lt;p align=\"right\"&gt;&lt;button type=\"button\" class=\"btn\" id=\"writeBtn\"          onclick=\"memberCheck(&lt;%=isLogin%&gt;);\"&gt;글쓰기&lt;/button&gt;&lt;/p&gt;       &lt;table class=\"type09\"&gt;         &lt;colgroup&gt;           &lt;col width=\"10%\"&gt;           &lt;col width=\"45%\"&gt;           &lt;col width=\"10%\"&gt;           &lt;col width=\"20%\"&gt;           &lt;col width=\"15%\"&gt;         &lt;/colgroup&gt;         &lt;thead&gt;           &lt;tr&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getNum() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getTitle() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getId() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getDate() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;조회수 &lt;%=dto.getReadcount() %&gt;&lt;/th&gt;           &lt;/tr&gt;         &lt;/thead&gt;         &lt;tbody&gt;           &lt;tr&gt;             &lt;td colspan=\"5\"&gt;&lt;%=dto.getContent() %&gt;&lt;/td&gt;           &lt;/tr&gt;           &lt;tr&gt;             &lt;td colspan=\"2\"&gt;첨부파일&lt;/td&gt;             &lt;td colspan=\"3\"&gt;&lt;%=dto.getFile() %&gt;&lt;/td&gt;           &lt;/tr&gt;         &lt;/tbody&gt;       &lt;/table&gt;&lt;br&gt;       &lt;div id=\"boardPage\"&gt;       &lt;button type=\"button\" class=\"btn\"          onclick=\"location.href='#';\"&gt;수정하기&lt;/button&gt;       &lt;button type=\"button\" class=\"btn\"          onclick=\"location.href='#';\"&gt;삭제하기&lt;/button&gt;       &lt;button type=\"button\" class=\"btn\"          onclick=\"location.href='#';\"&gt;답글쓰기&lt;/button&gt;       &lt;button type=\"button\" class=\"btn\"          onclick=\"location.href='./BoardList.bo?pageNum=&lt;%=pageNum%&gt;';\"&gt;목록이동&lt;/button&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      이제 글 내용을 보여주는 페이지로 오면 DB에서 불러온 내용을 화면에 출력한다.   하단에 목록이동 버튼을 누르면 글을 보기 전에 머물러 있던 페이지로 이동한다.         연결 성공!   다음에는 게시글 수정 기능을 만들 것이다.      마감까지     D-11  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-13/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 14 - 게시글 수정 기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시글 수정 기능을 만들었다.   boardContent.jsp   &lt;%     String id = (String)session.getAttribute(\"id\"); \t     boolean isLogin = false;     if (null == id) isLogin = false;     else isLogin = true; \t     BoardDTO dto = (BoardDTO)request.getAttribute(\"dto\");     String pageNum = (String)request.getAttribute(\"pageNum\"); %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;     \t&lt;h2&gt;최신글 보기&lt;/h2&gt; \t  \t&lt;p align=\"right\"&gt;&lt;button type=\"button\" class=\"btn\" id=\"writeBtn\"  \t  \t\tonclick=\"memberCheck(&lt;%=isLogin%&gt;);\"&gt;글쓰기&lt;/button&gt;&lt;/p&gt;         &lt;table class=\"type09\"&gt;         &lt;colgroup&gt;           &lt;col width=\"10%\"&gt;           &lt;col width=\"45%\"&gt;           &lt;col width=\"10%\"&gt;           &lt;col width=\"20%\"&gt;           &lt;col width=\"15%\"&gt;         &lt;/colgroup&gt;         &lt;thead&gt;           &lt;tr&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getNum() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getTitle() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getId() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;&lt;%=dto.getDate() %&gt;&lt;/th&gt;             &lt;th scope=\"cols\"&gt;조회수 &lt;%=dto.getReadcount() %&gt;&lt;/th&gt;           &lt;/tr&gt;         &lt;/thead&gt;         &lt;tbody&gt;           &lt;tr&gt;             &lt;td colspan=\"5\" style=\"white-space:pre-wrap; word-wrap:break-word; word-break: break-all;\"&gt;&lt;%=dto.getContent() %&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/td&gt;           &lt;/tr&gt;           &lt;tr&gt;             &lt;td colspan=\"2\"&gt;첨부파일&lt;/td&gt;             &lt;td colspan=\"3\"&gt;&lt;%=dto.getFile() %&gt;&lt;/td&gt;           &lt;/tr&gt;         &lt;/tbody&gt;         &lt;/table&gt;&lt;br&gt;         &lt;div id=\"boardPage\"&gt;           &lt;%if (null != id &amp;&amp; id.equals(dto.getId())) { %&gt;             &lt;button type=\"button\" class=\"btn\"                onclick=\"location.href='./BoardModify.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;';\"&gt;수정하기&lt;/button&gt;             &lt;button type=\"button\" class=\"btn\"                onclick=\"location.href='#';\"&gt;삭제하기&lt;/button&gt;           &lt;%} %&gt;           &lt;button type=\"button\" class=\"btn\"              onclick=\"location.href='#';\"&gt;답글쓰기&lt;/button&gt;           &lt;button type=\"button\" class=\"btn\"              onclick=\"location.href='./BoardList.bo?pageNum=&lt;%=pageNum%&gt;';\"&gt;목록이동&lt;/button&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      게시글을 보러 들어가면 본인이 쓴 글일 때에만 수정하기 버튼과 삭제하기 버튼이 활성화 된다.        게시글 본문은 엔터에 따라 줄바꿈이 되도록 본문을 출력하는 td 태그에만 줄바꿈용 스타일 적용을 해 주었다.       white-space : 단어 사이 공백을 처리하는 속성.            pre-wrap : 스페이스와 줄 바꿈을 보존하고 자동 줄 바꿈           word-wrap : 띄어쓰기가 없는 긴 단어를 어떻게 처리할 지 정하는 속성.            break-word : 요소의 경계에서 break point가 아니어도 줄바꿈           word-break : 텍스트가 들어가는 블록 요소에서 단어 단위로 줄 바꿈을 할 지, 글자 단위로 줄 바꿈을 할 지 정하는 속성            break-all : 한글, 영문 모두 글자 단위로 줄 바꿈           BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // ..생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t         // .. 생략         else if (command.equals(\"/BoardModify.bo\"))         {             System.out.println(\"C : /BoardModify.bo 호출\"); \t\t\t             action = new BoardModifyAction(); \t\t\t             try {                 forward = action.execute(request, response);             }             catch (Exception e) {                 e.printStackTrace();             }         } \t\t \t\t         // 3. 페이지 이동         // .. 생략     } \t     @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         doProcess(request, response);     }      @Override     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         doProcess(request, response);     } }      새로운 Action class인 BoardModifyAction 클래스를 만들어 이동한다.   BoardModifyAction.java   package com.project.cafe.board.action;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardModifyAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardModifyAction - execute() 호출\"); \t\t         // 파라메터 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         String pageNum = request.getParameter(\"pageNum\"); \t\t         // DB에서 글 정보 가져오기         BoardDAO dao = new BoardDAO();         BoardDTO dto = dao.getPost(num); \t\t         // request 영역에 글 정보 저장         request.setAttribute(\"dto\", dto);         request.setAttribute(\"pageNum\", pageNum); \t\t         // 페이지 이동정보 설정         ActionForward forward = new ActionForward();         forward.setPath(\"./contents/boardModify.jsp\");         forward.setRedirect(false); \t\t         return forward;     } }      DB에 가서 게시글 수정 페이지에 출력할 기존 글 정보를 가져온 뒤 수정 페이지로 이동한다.   boardModify.jsp   &lt;%     String id = (String)session.getAttribute(\"id\");     if (null == id)         response.sendRedirect(\"./login.me\"); \t     BoardDTO dto = (BoardDTO)request.getAttribute(\"dto\");     String pageNum = (String)request.getAttribute(\"pageNum\"); %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;     \t&lt;h2&gt;게시글 수정&lt;/h2&gt;     \t&lt;form name=\"write\" action=\"./BoardModifyPro.bo\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     \t&lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;         &lt;input type=\"hidden\" name=\"num\" value=\"&lt;%=dto.getNum()%&gt;\"&gt;         &lt;input type=\"hidden\" name=\"pageNum\" value=\"&lt;%=pageNum%&gt;\"&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;제목 &lt;/label&gt;           &lt;input type=\"text\" name=\"title\" id=\"title\" value=\"&lt;%=dto.getTitle()%&gt;\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_MsgField\"&gt;내용 &lt;/label&gt;           &lt;textarea id=\"MOD_TEXTFORM_MsgField\" name=\"content\"&gt;&lt;%=dto.getContent() %&gt;&lt;/textarea&gt;         &lt;/div&gt;          &lt;button type=\"submit\" class=\"btn\"&gt;글 수정하기&lt;/button&gt;       &lt;/form&gt;       &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      DB에서 가져온 기존 글 정보를 출력한다.   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t         // .. 생략         else if (command.equals(\"/BoardModifyPro.bo\"))         {             System.out.println(\"C : /BoardModifyPro.bo 호출\"); \t\t\t             action = new BoardModifyProAction(); \t\t\t             try {                 forward = action.execute(request, response);             }             catch (Exception e) {                 e.printStackTrace();             }         }                  // 3. 페이지 이동         // .. 생략 \t} }      수정한 내용을 DB에 저장하는 동작을 수행할 서블릿으로 이동한다.   BoardModifyProAction.java   package com.project.cafe.board.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardModifyProAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardModifyProAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 파라메터 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         String title = request.getParameter(\"title\");         String content = request.getParameter(\"content\");         String pageNum = request.getParameter(\"pageNum\"); \t\t         // DB에서 기존 글 정보를 찾은 다음 새 내용으로 수정         BoardDTO dto = new BoardDTO();         dto.setNum(num);         dto.setTitle(title);         dto.setContent(content);          BoardDAO dao = new BoardDAO();         int result = dao.modifyPost(dto); \t\t         response.setContentType(\"text/html; charset=UTF-8\");         PrintWriter out = response.getWriter();         if (1 != result)         {             // 해당 글 정보 없음             out.println(\"&lt;script&gt;\");             out.println(\"alert('해당 글 정보 없음!');\");             out.println(\"location.href='./BoardList.bo';\");             out.println(\"&lt;/script&gt;\"); \t\t\t             return null;         } \t\t         // 게시글 내용 페이지로 이동         out.println(\"&lt;script&gt;\");         out.println(\"location.href='./BoardContent.bo?num=\"+num+\"&amp;pageNum=\"+pageNum+\"';\");         out.println(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      DB에 접속해서 update 동작을 수행한 뒤 수정 내용을 확인할 수 있도록 게시글 본문 페이지로 이동한다.   게시글 본문 페이지로 이동할 때 본문 내용을 불러오는 서블릿이 호출되기 때문에 글 번호와 페이지정보만 파라미터로 넘겨주면 된다.   로그인 한 사용자 중 본인 글일 때에만 수정할 수 있게 해 놔서 예외 상황은 안 생길 것이라고 보지만 혹시 모르니까 예외처리를 해 놓았다.   BoardDAO.java - modifyPost(dto)   public int modifyPost(BoardDTO dto) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         // 번호로 해당 글 찾기         sql = \"select * from cafe_board where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, dto.getNum()); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             // update 동작 수행             sql = \"update cafe_board set title=?, content=? where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setString(1, dto.getTitle());             pstmt.setString(2, dto.getContent());             pstmt.setInt(3, dto.getNum()); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 글 수정 완료\");         }         else ret = -1;     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }           이제 게시글 본문 페이지로 이동하면 수정한 내용이 적용되어 보이고 DB에도 수정된 내용이 반영되어 있다.            다음엔 게시글 삭제 기능을 만들 것이다.          마감까지     D-11  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-14/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 15 - 게시글 삭제 기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시글 삭제 기능을 만들었다.   boardContent.jsp   &lt;div id=\"boardPage\"&gt;   &lt;%if (null != id &amp;&amp; id.equals(dto.getId())) { %&gt;     &lt;button type=\"button\" class=\"btn\"        onclick=\"location.href='./BoardModify.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;';\"&gt;수정하기&lt;/button&gt;     &lt;button type=\"button\" class=\"btn\"        onclick=\"location.href='deleteCheck(&lt;%=dto.getNum()%&gt;, &lt;%=pageNum%&gt;);\"&gt;삭제하기&lt;/button&gt;   &lt;%} %&gt;      로그인 한 사용자 중 작성 글의 ID와 일치하는 사용자 본인일 때에만 삭제하기 버튼이 활성화 된다.   버튼을 누르면 정말 삭제할 것인지 확인하는 함수를 호출해 알림창을 띄운다.   boardContent.js - deleteCheck(num, pageNum)   function deleteCheck(num, pageNum) {     if (confirm('정말 삭제 하시겠습니까?'))         location.href='./BoardDelete.bo?num='+num+'&amp;pageNum='+pageNum; }      취소 버튼을 누르면 게시글 본문 페이지에 머무르고 확인 버튼을 누르면 삭제 동작을 수행하는 서블릿으로 연결하기 위해 컨트롤러로 이동한다.   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t \t\t// .. 생략 \t\telse if (command.equals(\"/BoardDelete.bo\")) \t\t{ \t\t\tSystem.out.println(\"C : /BoardDelete.bo 호출\"); \t\t\t \t\t\taction = new BoardDeleteAction(); \t\t\t \t\t\ttry { \t\t\t\tforward = action.execute(request, response); \t\t\t} \t\t\tcatch (Exception e) { \t\t\t\te.printStackTrace(); \t\t\t} \t\t} \t\t \t\t         // 3. 페이지 이동         // .. 생략 \t} }      컨트롤러로 오면 게시글 삭제 동작을 수행할 액션 클래스로 연결한다.   BoardDeleteAction.java   package com.project.cafe.board.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO;  public class BoardDeleteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardDeleteAction - execute() 호출\"); \t\t         // 파라메터 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         String pageNum = request.getParameter(\"pageNum\"); \t\t         // DB 연결해서 해당 글 삭제         BoardDAO dao = new BoardDAO();         int result = dao.deletePost(num); \t\t         response.setContentType(\"text/html; charset=UTF-8\");         PrintWriter out = response.getWriter();         // 글 리스트 페이지로 이동         if (1 != result)         {             // 해당 게시글 정보 없음             out.println(\"&lt;script&gt;\");             out.println(\"alert('해당 게시글 정보가 없습니다!');\");             out.println(\"location.href='./BoardList.bo';\");             out.println(\"&lt;/script&gt;\"); \t\t\t             out.close(); \t\t\t             return null;         }          out.println(\"&lt;script&gt;\");         out.println(\"alert('게시글 삭제가 완료되었습니다.');\");         out.println(\"location.href='./BoardList.bo?pageNum=\"+pageNum+\"';\");         out.println(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      DB와 연결해서 글 정보를 확인한 후 삭제 동작을 수행한다.   로그인 한 본인 글일 때에만 삭제 동작에 접근할 수 있어서 글 삭제에 실패하는 경우는 생기지 않을 것이라 생각하지만 혹시 모르니까 예외처리를 해 주었다.   BoardDAO.java - deletePost(num)   public int deletePost(int num) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         // 삭제 대상 글 찾기         sql = \"select * from cafe_board where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, num); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             sql = \"delete from cafe_board where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setInt(1, num); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 글 삭제 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }      글 삭제가 완료되면 전체 게시글 목록으로 이동한다.        그러면 선택한 글이 삭제된 리스트를 볼 수 있다. DB에서도 삭제 완료 됨!       다음엔 답글 기능을 만들 것이다.      마감까지     D-10  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-15/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 16 - 답글 작성 기능 구현",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시글에 답글을 작성할 수 있는 기능을 만들었다.   boardContent.jsp   &lt;div id=\"boardPage\"&gt;   &lt;%if (null != id &amp;&amp; id.equals(dto.getId())) { %&gt;     &lt;button type=\"button\" class=\"btn\"        onclick=\"location.href='./BoardModify.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;';\"&gt;수정하기&lt;/button&gt;     &lt;button type=\"button\" class=\"btn\"        onclick=\"location.href='./BoardDeleteConfirm.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;';\"&gt;삭제하기&lt;/button&gt;   &lt;%} %&gt;     &lt;button type=\"button\" class=\"btn\"        onclick=\"location.href='./BoardReWrite.bo?num=&lt;%=dto.getNum()%&gt;&amp;re_ref=&lt;%=dto.getRe_ref()%&gt;&amp;re_lev=&lt;%=dto.getRe_lev()%&gt;&amp;re_seq=&lt;%=dto.getRe_seq()%&gt;';\"&gt;답글쓰기&lt;/button&gt;     &lt;button type=\"button\" class=\"btn\"        onclick=\"location.href='./BoardList.bo?pageNum=&lt;%=pageNum%&gt;';\"&gt;목록이동&lt;/button&gt; &lt;/div&gt;      답글을 작성할 수 있는 페이지로 연결하는 링크를 추가했다.   답글을 작성하려는 게시글 아래에 새로 작성한 답글을 배치할 것이기 때문에 작성하려는 답글 그룹의 정보인 re_ref, 답글의 들여쓰기 레벨 정보인 re_lev, 답글이 작성된 순서 정보인 re_seq들을 파라메터로 넘긴다.   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t         // .. 생략         else          {             forward = new ActionForward();              // .. 생략             else if (command.equals(\"/BoardReWrite.bo\"))             {                 System.out.println(\"C : /BoardReWrite.bo 호출\"); \t\t\t\t                 forward.setPath(\"./contents/boardReWrite.jsp\");             }              forward.setRedirect(false);         } \t\t         // 3. 페이지 이동         // .. 생략     } }      컨트롤러에서 답글을 작성하는 페이지로 이동한다.   boardReWrite.jsp   &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"     pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt;  &lt;!-- Start Head --&gt;   &lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt;   &lt;script src=\"${pageContext.request.contextPath }/js/boardWrite.js\"&gt;&lt;/script&gt; &lt;!-- End Head --&gt;  &lt;body class=\"modern\"&gt;  &lt;!-- START MODULE AREA 2: Menu 1 --&gt;   &lt;jsp:include page=\"../inc/subTop.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- END MODULE AREA 2: Menu 1 --&gt;  &lt;!-- START MODULE AREA 3: Sub Navigation 1 --&gt; &lt;%     String id = (String)session.getAttribute(\"id\");     if (null == id)         response.sendRedirect(\"./login.me\"); %&gt; &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h2&gt;답글 작성&lt;/h2&gt;       &lt;form name=\"write\" action=\"./BoardReWriteAction.bo\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;     \t         &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;         &lt;input type=\"hidden\" name=\"num\" value=\"&lt;%=request.getParameter(\"num\")%&gt;\"&gt;         &lt;input type=\"hidden\" name=\"re_ref\" value=\"&lt;%=request.getParameter(\"re_ref\")%&gt;\"&gt;         &lt;input type=\"hidden\" name=\"re_lev\" value=\"&lt;%=request.getParameter(\"re_lev\")%&gt;\"&gt;         &lt;input type=\"hidden\" name=\"re_seq\" value=\"&lt;%=request.getParameter(\"re_seq\")%&gt;\"&gt;     \t         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;제목 &lt;/label&gt;&lt;input type=\"text\" name=\"title\" id=\"title\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_MsgField\"&gt;내용 &lt;/label&gt;           &lt;textarea id=\"MOD_TEXTFORM_MsgField\" name=\"content\"&gt;&lt;/textarea&gt;         &lt;/div&gt;          &lt;button type=\"submit\" class=\"btn\"&gt;글 등록&lt;/button&gt;       &lt;/form&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt; &lt;!-- END MODULE AREA 3: Sub Navigation 1 --&gt;  &lt;!-- START MODULE AREA 5: Footer 2 --&gt;   &lt;jsp:include page=\"../inc/bottom.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- END MODULE AREA 5: Footer 2 --&gt;  &lt;script src=\"${pageContext.request.contextPath }/js/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;  &lt;/html&gt;      게시글을 작성하는 페이지인 boardWrite.jsp와 크게 달라지는 것이 없어서 복사해서 썼다.   답글 작성에 필요한 정보들만 추가로 저장하는 input 태그를 추가했다.   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t         // .. 생략         else if (command.equals(\"/BoardReWriteAction.bo\"))         {             System.out.println(\"C : /BoardReWriteAction.bo 호출\"); \t\t\t             action = new BoardReWriteAction(); \t\t\t             try {                 forward = action.execute(request, response);             }             catch (Exception e) {                 e.printStackTrace();             }         } \t\t         // 3. 페이지 이동         // .. 생략     } }      DB에 접속해서 새 글을 삽입하는 동작을 수행해야 하니까 서블릿으로 연결한다.   BoardReWriteAction.java   package com.project.cafe.board.action;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardReWriteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardReWriteAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 파라메터 저장         BoardDTO dto = new BoardDTO();         dto.setContent(request.getParameter(\"content\"));         dto.setId(request.getParameter(\"id\"));         dto.setIp(request.getRemoteAddr());         dto.setNum(Integer.parseInt(request.getParameter(\"num\")));         dto.setRe_lev(Integer.parseInt(request.getParameter(\"re_lev\")));         dto.setRe_ref(Integer.parseInt(request.getParameter(\"re_ref\")));         dto.setRe_seq(Integer.parseInt(request.getParameter(\"re_seq\")));         dto.setReadcount(0);         dto.setTitle(request.getParameter(\"title\")); \t\t         // DB 연결해서 글 저장         BoardDAO dao = new BoardDAO();         dao.reWritePost(dto); \t\t         // 게시글 목록으로 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./BoardList.bo\");         forward.setRedirect(true); \t\t         return forward;     } }      새 글을 삽입하는 동작이기 때문에 기본적인 틀은 BoardWriteAction.java와 같지만 부모가 되는 게시글을 설정해 주어야 하기 때문에 DAO 객체의 호출 함수가 다르다.   BoardDAO.java - reWritePost(dto)   public void reWritePost(BoardDTO dto) {     int curNum = 0; // 이번에 쓸 글 번호 \t\t     try {         con = getCon(); \t\t\t         // 글 번호 계산         sql = \"select max(num) from cafe_board\";         pstmt = con.prepareStatement(sql); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())             curNum = rs.getInt(1) + 1; \t\t\t         System.out.println(\"DAO : 답글번호 : \"+curNum); \t\t\t         // 답글순서 재배치(seq 변경)         // re_ref 가 같은 그룹내에서 update 동작 수행 - re_seq값이 기존값보다 큰 값이 있을 때 re_seq + 1         // 없으면(0) 정렬할 게 없으니까 그냥 지나갈 것임         sql = \"update cafe_board set re_seq = re_seq + 1 where re_ref = ? and re_seq &gt; ?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, dto.getRe_ref());         pstmt.setInt(2, dto.getRe_seq()); \t\t\t         int result = pstmt.executeUpdate();         if (0 &lt; result)             System.out.println(\"DAO : 답글 순서 재배치\"); \t\t\t         // 답글 저장 동작 수행         sql = \"insert into cafe_board(num, id, title, content, readcount, re_ref, re_lev, re_seq, date, ip, file)\"             + \" values(?,?,?,?,?,?,?,?,now(),?,?)\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, curNum);         pstmt.setString(2, dto.getId());         pstmt.setString(3, dto.getTitle());         pstmt.setString(4, dto.getContent());         pstmt.setInt(5, 0); \t\t\t         pstmt.setInt(6, dto.getRe_ref()); // 게시글 그룹         pstmt.setInt(7, dto.getRe_lev() + 1); // 들여쓰기 - 기준글 + 1         pstmt.setInt(8, dto.getRe_seq() + 1); // 그룹 내 순서 - 기준글 + 1 \t\t\t         pstmt.setString(9, dto.getIp());         pstmt.setString(10, dto.getFile()); \t\t\t         pstmt.executeUpdate(); \t\t\t         System.out.println(\"DAO : 답글 작성 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } }      답글을 작성할 때 re_ref 필드를 이용해 부모 글을 설정해 준 다음 들여쓰기 레벨과 게시글 그룹 내 순서를 설정해 준다.   자세한 알고리즘은 프로젝트) Cafe(웹 사이트) 만들기 17 - 게시판 답글 작성 알고리즘 포스트에 따로 작성했다.   boardList.jsp   &lt;thead&gt;   &lt;tr&gt;     &lt;th scope=\"cols\"&gt;No.&lt;/th&gt;     &lt;th scope=\"cols\"&gt;제목&lt;/th&gt;     &lt;th scope=\"cols\"&gt;작성자&lt;/th&gt;     &lt;th scope=\"cols\"&gt;작성일&lt;/th&gt;     &lt;th scope=\"cols\"&gt;조회수&lt;/th&gt;   &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;%     if (null != postList) {         for (int i = 0; i &lt; postList.size(); i++)          {             BoardDTO dto = postList.get(i); %&gt;   &lt;tr&gt;     &lt;th scope=\"row\"&gt;&lt;%=dto.getNum() %&gt;&lt;/th&gt;     &lt;td&gt;     &lt;%         int width = 0;         if (0 &lt; dto.getRe_lev()) // 답글일 때         {             width = 10 * dto.getRe_lev();     %&gt;       &lt;img class=\"reImg\" src=\"./contents/level.gif\" width=\"&lt;%=width%&gt;\" height=\"15\"&gt;       &lt;img class=\"reImg\" src=\"./contents/re.gif\"&gt;     &lt;%         }     %&gt;       &lt;a href=\"./BoardContent.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=dto.getTitle() %&gt;&lt;/a&gt;     &lt;/td&gt;     &lt;td&gt;&lt;%=dto.getId() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=dto.getDate() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=dto.getReadcount() %&gt;&lt;/td&gt;   &lt;/tr&gt; &lt;%}} %&gt; &lt;/tbody&gt;      새 글 삽입 과정이 끝나고 나면 게시글 목록에서 새로 작성된 답글을 확인할 수 있다.   답글은 따로 표시하기 위해서 이미지를 추가했다.   이 때 더미 이미지(level.gif)를 이용해 들여쓰기 레벨에 따라 들여쓰기를 먼저 한 뒤 답글 이미지(re.gif)를 표시하고 제목을 출력한다.         다음에 만들 기능은 파일 업로드 기능!      마감까지     D-10  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-16/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 16_1 - 게시판 답글 작성 알고리즘",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      게시글 답글 작성 알고리즘     re_ref : 부모글과 그로부터 파생된 자식글들이 같은 값을 가지기 위한 필드   re_lev : 같은 re_ref 내에서의 들여쓰기 깊이   re_seq : 같은 re_ref 내에서의 순서   첫 번째 글쓰기 입력     처음엔 답글이 아닌 일반 글들이 각자 고유한 re_ref 번호를 가지고 등록된다.                  num       title       re_ref       re_lev       re_seq                               1       1st       1       0       1                         2       2nd       2       0       1                         3       3rd       3       0       1                   1번 글에 답변 글 달기  순서1) re_ref값은 부모글 1st의 re_ref값을 사용한다.  순서2) re_seq값은 부모글 1st에서 1 증가 한 값을 사용한다.  순서3) re_lev값은 부모글 1st에서 1 증가 한 값을 사용한다.       그러면 아래와 같이 글이 등록될 것이다.                  num       title       re_ref       re_lev       re_seq                               1       1st       1       0       1                         2       2nd       2       0       1                         3       3rd       3       0       1                         4       1st_re1       1       1       2                      re_seq값이 1인 글은 부모글, 1보다 크면 자식글이라는 것을 알 수 있다.   1번 글의 답변 글에 또 답변 글 달기     1번 글에 답글을 달 때와 같은 순서로 작성하면 아래와 같이 등록될 것이다.                  num       title       re_ref       re_lev       re_seq                               1       1st       1       0       1                         2       2nd       2       0       1                         3       3rd       3       0       1                         4       1st_re1       1       1       2                         5       1st_re1_re1       1       2       3                   1번 글에 답변 글 달기  순서1) re_ref값은 부모글 1st의 re_ref값을 사용한다.  순서2) re_seq값은 부모글 1st에서 1 증가 한 값을 사용한다. 단 부모글을 제외한 값 re_ref 내에서 먼저 입력된 글은 re_seq값을 1 증가시킨다.  순서3) re_lev값은 부모글 1st에서 1 증가 한 값을 사용한다.                   num       title       re_ref       re_lev       re_seq                               1       1st       1       0       1                         2       2nd       2       0       1                         3       3rd       3       0       1                         4       1st_re1       1       1       3                         5       1st_re1_re1       1       2       4                         6       1st_re2       1       1       2                      그러면 위와 같은 값을 가지게 된다.   re_ref값을 기준으로 먼저 내림차순 정렬을 한 뒤 re_ref값 내에서 2차로 re_seq값을 기준으로 오름차순 정렬을 한다.                  num       title       re_ref       re_lev       re_seq                               3       3rd       3       0       1                         2       2nd       2       0       1                         1       1st       1       0       1                         6       1st_re2       1       1       2                         4       1st_re1       1       1       3                         5       1st_re1_re1       1       2       4                      그러면 이렇게 최신 글이 가장 위로 올라오면서 들여쓰기 레벨에 따라 작성된 글을 볼 수 있다.      마감까지     D-8  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-16_1/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 04 연습문제 2. 시각",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 04 - 연습문제 2. 시각     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제            정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다.       00시 00분 03초        00시 13분 30초            반면에 다음은 3이 하나라도 포함되어 있지 않으므로 세면 안 되는 시각이다.       00시 02분 55초   01시 27분 45초     입력       첫째 줄에 정수 N이 입력된다. (0 &lt;= N &lt;= 23)     출력       00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다.      👀 풀이       하루는 86,400초로 00시 00분 00초 ~ 23시 59분 59초까지 생길 수 있는 경우의 수는 최대가 86,400개이다.   그래서 모든 경우를 하나씩 탐색해 보아도 시간 안에 해결할 수 있다.   00시 00분 00초부터 1초씩 늘려가면서 문자열로 바꾼 뒤 그 안에 3이 포함되어 있는지 확인하면 된다.   먼저 시간 단위로 반복문을 돌고 그 안에서 분 단위로 반복문을 돌고 그 안에서 초 단위로 반복문을 도는 3중 반복문을 작성하면 쉽게 풀 수 있다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Implementation","Python"],
        "url": "/boj/CodingTestBook-04-e2-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 04 실전문제 2. 왕실의 나이트",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 04 - 실전문제 2. 왕실의 나이트     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       행복 왕국의 왕실 정원은 체스판과 같은 8 X 8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서 있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다.   나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.      수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기   수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기      8 X 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오. 이때 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a부터 h로 표현한다.     입력       첫째 줄에 8 X 8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열이 입력된다. 입력 문자는 a1처럼 열과 행으로 이뤄진다.     출력       첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오.      👀 풀이       나이트가 이동할 수 있는 모든 방향 쌍을 배열에 저장한 다음 반복문을 돌려 그 방향으로 이동했을 때 체스판 안 인지 확인해서 체스판 안일 때에만 경우의 수를 증가시키면 된다.   입력 중 열은 a1과 같이 알파벳으로 주어지기 때문에 이걸 숫자로 바꿔주는 것이 계산하기 편하다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Implementation","Python"],
        "url": "/boj/CodingTestBook-04-h3-py/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) Application",
        "excerpt":"👀 Application?     응용프로그램이라고도 하며 사용자가 직접 다루는 프로그램을 의미한다.   그래서 네트워크 응용프로그램이라면 인터넷 상에서 통신을 할 때 사용자가 직접 다루게 되는 프로그램을 의미하게 된다.   종류에는 이메일, 크롬과 같은 웹 브라우저, P2P 파일 공유 프로그램, SNS, 카카오톡과 같은 메신저, 온라인 게임, 유튜브와 같은 비디오 스트리밍 서비스 등이 있다.     Application structures  Client-sever model     최초로 사용되었던 방식으로 중앙에 서버 하나가 있고 클라이언트들이 그 하나의 서버에 접속해서 데이터를 받는 형태이다.   이 모델에서는 서버가 유일하게 데이터를 제공하는 장치이다.   그래서 서버가 꺼져 있으면 데이터를 받을 수 없다. 그렇기 때문에 서버 컴퓨터는 항상 켜져 있어야 한다.   클라이언트는 서버에 접속해야만 데이터를 받을 수 있기 때문에 서버의 IP 주소는 항상 같아야 한다.   서버 하나에 너무 많은 클라이언트가 몰리면 서버의 성능이 떨어지기 때문에 부하를 분산하기 위해서 서버를 여러 개 둔다.   클라이언트가 다른 클라이언트와 통신하고 싶다면 서버를 거쳐야만 한다. 직접 통신 불가능   Perr-to-peer (P2P) model     서버를 거치지 않고 각 컴퓨터들이 직접 연결되어 있는 형태로 네트워크에 참여하는 모든 컴퓨터들이 데이터 제공자이자 소비자가 된다. 특정한 하나의 서버가 없다.   그래서 모든 컴퓨터가 항상 켜져 있을 필요는 없다. 데이터를 주고받고자 할 때에만 켜도 된다.   부하가 분산되기 때문에 클라이언트가 많아져도 안정적이고 지속적인 서비스가 가능하다.   꼭 고정된 IP 주소를 가지지 않아도 된다.     Application Layer Protocol     인터넷 프로토콜은 5개의 층(layer)으로 이루어져 있는데 이 층 간에 통신을 할 때 필요한 규약이다.        우리가 서로 대화할 때 서로 이해 가능한 문법과 의미를 지켜서 얘기하는 것처럼 네트워크 응용프로그램도 서로 해석할 수 있는 프로토콜을 이용해 데이터를 주고받는다.       message syntax : 요구하는 데이터가 무엇이고 이 데이터들을 어떻게 늘어놓을 것인지   message semantics : 이 데이터들을 어떻게 해석할 것인지        message pragmatics : 어떤 순서로 어떻게 응답할 것인지       응용프로그램 프로토콜에는 Open protocol과 Proprietary protocol이 있는데 Open protocol은 전체 규칙이 표준화되어 공개되어 있어(HTTP, SMTP) 누구나 접근해 그 규격에 맞는 메시지를 만들어 통신할 수 있다.   반면에 Proprietary protocol은 기업에서 자체적으로 만들어 사용하는 고유한 프로토콜로 만든 곳에서 공개하지 않으면 알 수 없다.     Transport Layer Protocol     데이터를 전송할 때엔 데이터가 손실되지 않는지, 전송속도는 얼마나 나오는지 등 데이터가 제대로 전송될 수 있도록 신경써야 하는 부분이 있다. 그런데 이런 것들을 응용프로그래머가 일일이 다루기는 어렵다.   그래서 Transport Layer에서 이런 것들에 대한 요구사항을 만족시켜 준다.   TCP     신뢰성 있는 전송   Error control : 에러가 없을 때까지 재전송   Flow control : 보내는 쪽은 받는 쪽이 받을 수 있을 만큼만 보낸다.   Congestion control : 라우터나 스위치에 데이터가 쌓이지 않도록 제어   이메일, 웹, 파일 전송 등에서 사용   UDP     신뢰성 없는 전송   TCP가 제공하는 기능들을 제공하지 않는다.   이렇게 보면 쓸모 없어보이지만 오디오/비디오와 같은 멀티미디어 데이터를 전송할 때 유용하게 사용될 수 있다.   받은 데이터에 손실이 있어도 수정하지 않고 그대로 보내기 때문에 유튜브처럼 데이터에 손실이 좀 생겨도 보는데에 지장이 없는 서비스에서는 빠르게 전송할 수 있다.   비디오 스트리밍 서비스나 통화 서비스 등에서 사용      출처     컴퓨터 네트워킹 - 부산대학교 K-MOOC 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network","Application"],
        "url": "/computer%20network/computer-network-application/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) REST",
        "excerpt":"👀 REST?     서버가 클라이언트의 상태 정보를 가지고 있지 않는 것   HTTP를 통한 서버 클라이언트 모델에서 서버가 클라이언트의 위치와 같은 현재 상태를 유지하는 정보를 가지고 있으면 오버헤드가 크다.   그래서 클라이언트의 상태 정보를 서버에 저장하지 않고 서버와 클라이언트 간에 주고받는 HTTP 메세지 안에 클라이언트의 상태 정보를 담고 그것을 해석할 수 있는 방법까지 담는다.   서버는 특정 클라이언트에 대한 정보를 저장하고 있지 않아도 HTTP request 메세지만 보고 클라이언트의 상태를 알 수 있고 클라이언트는 HTTP response 메세지를 받으면 어떤 방식으로 메세지를 가져와야 할 지 알 수 있다.   이런 아키텍처를 따르는 서비스를 RESTful이라 한다.     REST 요구사항     클라이언트-서버 구조로 이루어져야 한다.   HTTP 메세지 안에 모든 정보가 들어있어야 한다. (다른 데이터 스토리지 사용 X)   서버의 response가 클라이언트 쪽 또는 어떤 웹 캐시에 저장할 수 있어야 한다.   클라이언트가 웹 서버에 바로 연결되었든 다른 중간 지점을 거쳐서 연결이 되었든 클라이언트 입장에서는 서비스를 받는 데에 차이가 없어야 한다.   자바스크립트와 같이 어떤 코드가 클라이언트 기기에 다운로드 되었을 때 클라이언트 기기에 그 코드를 해석할 수 있는 방법이 없어도 그것을 실행할 수 있게 해 주는 응용프로그램을 전달해야 한다.   특정한 컴퓨터 아키텍처에 상관없이 어디서든 실행할 수 있어야 한다.      출처     컴퓨터 네트워킹 - 부산대학교 K-MOOC 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network","Application"],
        "url": "/computer%20network/computer-network-restful/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 04 실전문제 3. 게임 개발",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 04 - 실전문제 3. 게임 개발     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다. 캐릭터가 있는 장소는 1 X 1 크기의 정사각형으로 이뤄진 N X M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한 곳을 바라본다.   맵의 각 칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다. 캐릭터의 움직임을 설정하기 위해 정해 놓은 매뉴얼은 이러하다.      현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다.   캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 곳이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다. 왼쪽 방향에 가보지 않은 칸이 있다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.   만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.      현민이는 위 과정을 반복적으로 수행하면서 캐릭터의 움직임에 이상이 있는지 테스트하려고 한다. 매뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.     입력       첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력한다. (3 &lt;= N, M &lt;= 50)   둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (A, B)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다. 방향 d의 값으로는 다음과 같이 4가지가 존재한다.            0 : 북쪽       1 : 동쪽       2 : 남쪽       3 : 서쪽           셋째 줄부터 맵이 육지인지 바다인지에 대한 정보가 주어진다. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어 있다.            0 : 육지       1 : 바다           처음에 게임 캐릭터가 위치한 칸의 상태는 항상 육지이다.     출력       첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다.      👀 풀이       캐릭터가 이동하기 전에 왼쪽으로 회전시킨 다음 이동할 수 있는 위치가 바다가 아니거나 아직 방문하지 않은 곳이라면 이동시킨다. (방문표시 배열 필요)   이동할 수 없다면 회전 횟수를 증가시킨다. 회전 횟수가 4가 되면 4방향 다 돌았는데도 이동할 수 있는 곳이 없었던 것이다.   4방향 다 이동할 수 없다면 뒤로 한 칸 이동시키는데, 만약 뒤에도 바다가 있어서 이동할 수 없다면 이동을 중단한다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Implementation","Python"],
        "url": "/boj/CodingTestBook-04-h4-py/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 17 - 메인 화면에서 최신글 미리보기 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     원래는 파일 업로드 기능을 만들려고 했으나 수업 진도가 생각보다 늦어져서 다른 기능을 먼저 추가하기로 했다.   오늘은 ajax를 이용해 비동기 방식으로 메인 페이지에서 최신글 몇 개를 미리 볼 수 있는 기능을 만들었다.      main.jsp   &lt;!-- Start Head --&gt;   &lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt;   &lt;script src=\"${pageContext.request.contextPath }/js/main.js\"&gt;&lt;/script&gt; &lt;!-- End Head --&gt;  &lt;section data-theme=\"_bgp\"&gt;   &lt;div data-layout=\"_r\" class=\"MOD_ARTICLEBLOCKS1\"&gt;     &lt;div data-layout=\"al16 ec8\" class=\"MOD_ARTICLEBLOCKS1_Cont\"&gt;     &lt;h2&gt;최신글&lt;/h2&gt;       &lt;a href=\"\" class=\"MOD_ARTICLEBLOCKS1_BlockLarge\" id=\"mainHref1\"&gt;         &lt;div style=\"background-image:url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/96252/aperitif-large-object1-luca-bravo.jpg)\" class=\"MOD_ARTICLEBLOCKS1_Img\" role=\"img\" aria-label=\"alt text\"&gt;&lt;/div&gt;         &lt;div class=\"MOD_ARTICLEBLOCKS1_Txt\"&gt;           &lt;h3 class=\"MOD_ARTICLEBLOCKS1_Title\" id=\"mainTitle1\"&gt;Article Title&lt;/h3&gt;           &lt;p class=\"MOD_ARTICLEBLOCKS1_Category\" id=\"mainContent1\"&gt;Category&lt;/p&gt;         &lt;/div&gt;       &lt;/a&gt;     &lt;/div&gt;     &lt;div data-layout=\"al16 ch8 ec4\" class=\"MOD_ARTICLEBLOCKS1_Cont\"&gt;       &lt;a href=\"\" class=\"MOD_ARTICLEBLOCKS1_BlockSmall\" id=\"mainHref2\"&gt;         &lt;div style=\"background-image:url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/96252/aperitif-large-object1-luca-bravo.jpg)\" class=\"MOD_ARTICLEBLOCKS1_Img\" role=\"img\" aria-label=\"alt text\"&gt;&lt;/div&gt;          &lt;div class=\"MOD_ARTICLEBLOCKS1_Txt\"&gt;           &lt;h3 class=\"MOD_ARTICLEBLOCKS1_Title\" id=\"mainTitle2\"&gt;Article Title&lt;/h3&gt;           &lt;p class=\"MOD_ARTICLEBLOCKS1_Category\" id=\"mainContent2\"&gt;Category&lt;/p&gt;         &lt;/div&gt;       &lt;/a&gt;     &lt;/div&gt;     &lt;div data-layout=\"al16 ch8 ec4\" class=\"MOD_ARTICLEBLOCKS1_Cont\"&gt;       &lt;a href=\"\" class=\"MOD_ARTICLEBLOCKS1_BlockSmall\" id=\"mainHref3\"&gt;         &lt;div style=\"background-image:url(https://s3-us-west-2.amazonaws.com/s.cdpn.io/96252/aperitif-large-object1-luca-bravo.jpg)\" class=\"MOD_ARTICLEBLOCKS1_Img\" role=\"img\" aria-label=\"alt text\"&gt;&lt;/div&gt;          &lt;div class=\"MOD_ARTICLEBLOCKS1_Txt\"&gt;           &lt;h3 class=\"MOD_ARTICLEBLOCKS1_Title\" id=\"mainTitle3\"&gt;Article Title&lt;/h3&gt;           &lt;p class=\"MOD_ARTICLEBLOCKS1_Category\" id=\"mainContent3\"&gt;Category&lt;/p&gt;         &lt;/div&gt;       &lt;/a&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      Article Title과 Category 부분에 각각 글 제목과 내용 일부를 출력할 것이다.   직접 만든 것은 아니고 다운 받은 템플릿을 약간 변형해서 만들었다.   main.js   $(document).ready(function() {     getFeeds(); });  function getFeeds() {     $.ajax({         type: 'POST',         async: false,         url: './GetFeed.bo',         dataType: 'json',         data: {             'cnt': 3,             'len': 70         },         success: function(data) {             if (data != null)             {                 for (var i = 0; i &lt; data.length; i++)                 {                     var titleId = '#mainTitle';                     titleId += (i + 1);                     $(titleId).html(data[i].title);                      var contentId = '#mainContent';                     contentId += (i + 1);                     $(contentId).html(data[i].content);                      var hrefId = '#mainHref';                     hrefId += (i + 1);                     $(hrefId).attr('href', './BoardContent.bo?num='+data[i].num+'&amp;pageNum=1');                 }             }         }     }); }      메인 화면이 로드되었을 때 다른 페이지 이동 없이 보여져야 하니까 ajax를 이용해 비동기 방식으로 보여줄 것이다.   최대 cnt의 수만큼 게시물을 가져오되 내용물은 len 길이만큼만 가져오도록 했다.   태그의 아이디는 맨 뒤에 숫자만 바껴서 i 값에 따라 변경되도록 했다.   각 게시물마다 다른 글번호를 가진 페이지로 연결되어야 하기 때문에 게시글 하나를 불러올 때마다 해당 게시글의 a 태그의 href를 바꿔주었다.   최신글 3개만 보여주기 때문에 페이지 번호는 1번으로 고정한다.   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t         // .. 생략         else if (command.equals(\"/GetFeed.bo\"))         {             System.out.println(\"C : /GetFeed.bo 호출\"); \t\t\t             action = new GetFeed(); \t\t\t             try {                 forward = action.execute(request, response);             }             catch (Exception e) {                 e.printStackTrace();             }         } \t\t         // 3. 페이지 이동         // .. 생략 \t} }      컨트롤러에서 DB에 접속해서 작업을 수행할 서블릿과 연결한다.   GetFeed.java   package com.project.cafe.board.action;  import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import org.json.simple.JSONArray; import org.json.simple.JSONObject;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class GetFeed implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"ajax 시작_GetFeed - execute() 호출\"); \t\t         BoardDAO dao = new BoardDAO();         ArrayList&lt;BoardDTO&gt; list = dao.getPosts                 (Integer.parseInt(request.getParameter(\"cnt\")), Integer.parseInt(request.getParameter(\"len\"))); \t\t         // DB에서 가져온 데이터들을 json에 저장         JSONArray feedList = new JSONArray();         for (int i = 0; i &lt; list.size(); i++)         {             JSONObject feed = new JSONObject();             feed.put(\"num\", list.get(i).getNum());             feed.put(\"title\", list.get(i).getTitle());             feed.put(\"content\", list.get(i).getContent()); \t\t\t             feedList.add(feed);         } \t\t         // 클라이언트에게 데이터 보내기         // 한글처리         response.setCharacterEncoding(\"UTF-8\");         // json 데이터 넘김         response.getWriter().print(feedList.toJSONString());         response.getWriter().close(); \t\t         return null;     } }      서블릿으로 연결해서 게시글들을 가져온다.   데이터는 json에 담아서 보낸다.   BoardDAO - getPosts(cnt, len)   public ArrayList&lt;BoardDTO&gt; getPosts(int cnt, int len) {     ArrayList&lt;BoardDTO&gt; list = new ArrayList&lt;BoardDTO&gt;(); \t\t     try {         con = getCon(); \t\t\t         sql = \"select title, content from cafe_board order by num desc limit ?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, cnt); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         while (rs.next())         {             BoardDTO dto = new BoardDTO();             dto.setTitle(rs.getString(\"title\")); \t\t\t\t             // 문자열 일부만 저장             String content = rs.getString(\"content\");             if (len &gt; content.length())                 content = content.substring(0, content.length() - 1);             else             {                 content = content.substring(0, len);                 content = content.concat(\"...\");             } \t\t\t\t             dto.setContent(content); \t\t\t\t             list.add(dto);         } \t\t\t         System.out.println(\"DAO : 글 \"+list.size()+\"개 저장 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return list; }      네이버 블로그 메인 페이지의 html 소스를 보니까 각 포스트별 미리보기 창에서 텍스트 자체는 일정 글자수 만큼만 출력하고 이상은 … 이 붙은 형태로 되어 있어서 이렇게 구현해 보았다.   일단 구현한 후 학원 선생님한테 여쭤보니까 이런 방식으로 구현하면 된다고 하셔서 이대로 고정하기로 했다. 😄      마감까지     D-7  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-17/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 05 실전문제 4. 미로 탈출",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 05 - 실전문제 4. 미로 탈출     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       동빈이는 N X M 크기의 직사각형 형태의 미로에 갇혀 있다. 미로에는 여러 마리의 괴물이 있어 이를 피해 탈출해야 한다. 동빈이의 위치는 (1, 1)이고 미로의 출구는 (N, M)의 위치에 존재하며 한 번에 한 칸씩 이동할 수 있다. 이때 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있다. 미로는 반드시 탈출할 수 있는 형태로 제시된다. 이때 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하시오. 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함하여 계산한다.     입력       첫째 줄에 두 정수 N, M(4 &lt;= N, M &lt;= 200)이 주어진다. 다음 N개의 줄에는 각각 M개의 정수(0 혹은 1)로 미로의 정보가 주어진다. 각각의 수들은 공백 없이 붙어서 입력으로 제시된다. 또한 시작 칸과 마지막 칸은 항상 1이다.     출력       첫째 줄에 최소 이동 칸의 개수를 출력한다.      👀 풀이       BFS로 상하좌우에 이동 가능한 칸을 탐색하면서 현재 칸에서 이동 가능한 다음 칸은 현재 칸의 숫자 + 1을 해 주었다.   BFS 탐색이 끝나면 (N - 1, M - 1) 위치의 숫자를 출력한다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BFS","Python"],
        "url": "/boj/CodingTestBook-05-11-py/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 18 - 우편번호 검색 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     다음 우편번호 서비스 API를 이용해 회원가입 시 우편번호와 주소를 검색하는 기능을 추가했다.   다음 우편번호 서비스   join.jsp   &lt;div class=\"formRow\"&gt;   &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;우편번호 &lt;/label&gt;   &lt;label class=\"phone\"&gt;     &lt;input type=\"text\" name=\"postalcode\" id=\"postalcode\" placeholder=\"우편번호\" readonly&gt;     &lt;button id=\"postalBtn\" class=\"btn\" name=\"postalBtn\" onclick=\"execDaumPostcode()\"&gt;우편번호 찾기&lt;/button&gt;&lt;br&gt;   &lt;/label&gt; &lt;/div&gt; &lt;div id=\"postalCodeMsg\"&gt;&lt;/div&gt; &lt;span id=\"guide\" style=\"color:#999;display:none\"&gt;&lt;/span&gt; &lt;div class=\"formRow\"&gt;   &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;도로명 주소 &lt;/label&gt;   &lt;input type=\"text\" id=\"roadAddress\" name=\"roadAddress\" placeholder=\"도로명주소\" readonly&gt; &lt;/div&gt; &lt;div class=\"formRow\"&gt;   &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;상세 주소 &lt;/label&gt;   &lt;input type=\"text\" id=\"detailAddress\" name=\"detailAddress\" placeholder=\"상세주소\"&gt; &lt;/div&gt;  &lt;script src=\"//t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js\"&gt;&lt;/script&gt; &lt;script&gt; function execDaumPostcode() {     new daum.Postcode({         oncomplete: function(data) {             // 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분.              // 도로명 주소의 노출 규칙에 따라 주소를 표시한다.             // 내려오는 변수가 값이 없는 경우엔 공백('')값을 가지므로, 이를 참고하여 분기 한다.             var roadAddr = data.roadAddress; // 도로명 주소 변수             var extraRoadAddr = ''; // 참고 항목 변수              // 법정동명이 있을 경우 추가한다. (법정리는 제외)             // 법정동의 경우 마지막 문자가 \"동/로/가\"로 끝난다.             if(data.bname !== '' &amp;&amp; /[동|로|가]$/g.test(data.bname)){                 extraRoadAddr += data.bname;             }             // 건물명이 있고, 공동주택일 경우 추가한다.             if(data.buildingName !== '' &amp;&amp; data.apartment === 'Y'){                extraRoadAddr += (extraRoadAddr !== '' ? ', ' + data.buildingName : data.buildingName);             }             // 표시할 참고항목이 있을 경우, 괄호까지 추가한 최종 문자열을 만든다.             if(extraRoadAddr !== ''){                 extraRoadAddr = ' (' + extraRoadAddr + ')';             }              // 우편번호와 주소 정보를 해당 필드에 넣는다.             document.getElementById('postalcode').value = data.zonecode;             document.getElementById(\"roadAddress\").value = roadAddr;             // document.getElementById(\"sample4_jibunAddress\").value = data.jibunAddress;                              // 참고항목 문자열이 있을 경우 해당 필드에 넣는다.             /*if(roadAddr !== ''){                 document.getElementById(\"sample4_extraAddress\").value = extraRoadAddr;             } else {                 document.getElementById(\"sample4_extraAddress\").value = '';             }*/              var guideTextBox = document.getElementById(\"guide\");             // 사용자가 '선택 안함'을 클릭한 경우, 예상 주소라는 표시를 해준다.             if(data.autoRoadAddress) {                 var expRoadAddr = data.autoRoadAddress + extraRoadAddr;                 guideTextBox.innerHTML = '(예상 도로명 주소 : ' + expRoadAddr + ')';                 guideTextBox.style.display = 'block';              } else if(data.autoJibunAddress) {                 var expJibunAddr = data.autoJibunAddress;                 guideTextBox.innerHTML = '(예상 지번 주소 : ' + expJibunAddr + ')';                 guideTextBox.style.display = 'block';             } else {                 guideTextBox.innerHTML = '';                 guideTextBox.style.display = 'none';             }         }     }).open(); } &lt;/script&gt;       API 안내 페이지에 나와 있는대로 추가하고 나에게 맞게 조금만 수정하니까 아주 쉽게 추가가 되었다.   MemberJoinAction.java   package com.project.cafe.member.action;  import java.io.PrintWriter; import java.sql.Date; import java.sql.Timestamp; import java.util.Calendar;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  // 회원가입 처리동작 수행 // model 객체로 pro 페이지 역할을 한다. public class MemberJoinAction implements Action {     private int getAge(String birth)     {         int year = Integer.parseInt(birth.split(\"-\")[0]);         int curYear = Calendar.getInstance().get(Calendar.YEAR); \t\t         return curYear - year;     } \t     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : MemberJoinAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 전달받은 파라미터 저장 (JSP 페이지가 아니므로 액션태그는 쓸 수 없고 setter를 이용해 저장한다)         MemberDTO dto = new MemberDTO();         dto.setId(request.getParameter(\"id\"));         dto.setPass(request.getParameter(\"pass\"));         dto.setName(request.getParameter(\"name\"));         dto.setBirth(Date.valueOf(request.getParameter(\"birth\")));         dto.setEmail(request.getParameter(\"email\"));         dto.setGender(request.getParameter(\"gender\")); \t\t         // 입력받은 생년월일로 나이 계산         int age = getAge(request.getParameter(\"birth\"));         dto.setAge(age); \t\t         // 우편번호 저장         dto.setPostalcode(Integer.parseInt(request.getParameter(\"postalcode\"))); \t\t         // 주소 필드 합친 후 저장         String roadAddress = request.getParameter(\"roadAddress\");         String detailAddress = request.getParameter(\"detailAddress\");         dto.setAddress(roadAddress + \" \" + detailAddress); \t\t         // 폰번호 3개 필드 합친 후 저장         StringBuilder sb = new StringBuilder();         sb.append(request.getParameter(\"phone1\"));         sb.append(request.getParameter(\"phone2\"));         sb.append(request.getParameter(\"phone3\"));         dto.setPhone(sb.toString()); \t\t         // 날짜 정보 추가 저장         dto.setRegdate(new Timestamp(System.currentTimeMillis())); \t\t         System.out.println(\"M : 전달된 회원 정보 저장\");         System.out.println(\"M : \" + dto); \t\t         // DAO 객체 생성         MemberDAO dao = new MemberDAO(); \t\t         // 회원가입 메서드 호출         dao.insertMember(dto); \t\t         System.out.println(\"M : 회원가입 완료\"); \t\t         // 페이지 이동 (로그인 페이지로 - ./login.me)\t\t         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter();         out.print(\"&lt;script&gt;\");         out.print(\"alert('회원가입이 완료되었습니다!');\");         out.print(\"location.href='./login.me';\");         out.print(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      우편번호 필드가 추가되었기 때문에 회원가입처리를 하는 부분도 수정해 주었다.   DB 테이블에 우편번호를 저장할 컬럼도 추가해 주었다.      마감까지     D-5  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-18/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 19 - 메일 보내기 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     사이트 관리자에게 메일을 보낼 수 있는 기능을 만들었다.   자바 메일 API를 사용했다.   JSP 2.3 &amp; Servlet 3.1 책을 참고했다.   자바 메일 API 추가     javax.mail.jar - javax.mail.jar만 다운로드 후 WEB-INF/lib에 넣으면 된다.   actication.jar - 여기서 jaf-1_1_1.zip 다운로드 후 압축 풀어서 activation.jar 파일만 WEB-INF/lib에 넣으면 된다.   contactUs.jsp   &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"     pageEncoding=\"UTF-8\"%&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt;  &lt;!-- Start Head --&gt;   &lt;jsp:include page=\"../inc/top.jsp\"&gt;&lt;/jsp:include&gt;   &lt;script src=\"${pageContext.request.contextPath }/js/contactUs.js\"&gt;&lt;/script&gt; &lt;!-- End Head --&gt;  &lt;body class=\"modern\"&gt;  &lt;!-- START MODULE AREA 2: Menu 1 --&gt;   &lt;jsp:include page=\"../inc/subTop.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- END MODULE AREA 2: Menu 1 --&gt;  &lt;!-- START MODULE AREA 3: Sub Navigation 1 --&gt; &lt;section&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;!-- &lt;div data-layout=\"de6 ec5 ec-n3\"&gt;       &lt;p&gt;&lt;/p&gt;     &lt;/div&gt; --&gt;     &lt;div data-layout=\"de10 ec-half\"&gt;       &lt;h3&gt;Contact us&lt;/h3&gt;       &lt;form name=\"mail\" action=\"./SendMailAction.bo\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;이름 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"name\"&gt;         &lt;/div&gt;         &lt;div id=\"nameMsg\"&gt;&lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_EmailField\"&gt;답변 받을 이메일 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_EmailField\" type=\"email\" name=\"email\"&gt;         &lt;/div&gt;         &lt;div id=\"emailMsg\"&gt;&lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_TelField\"&gt;제목 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_TelField\" type=\"tel\" name=\"title\"&gt;         &lt;/div&gt;         &lt;div id=\"titleMsg\"&gt;&lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_MsgField\"&gt;내용 &lt;/label&gt;&lt;textarea id=\"MOD_TEXTFORM_MsgField\" placeholder=\"내용을 입력하세요...\" name=\"content\"&gt;&lt;/textarea&gt;         &lt;/div&gt;         &lt;div id&gt;&lt;/div&gt;         &lt;button type=\"submit\" class=\"btn\"&gt;보내기&lt;/button&gt;       &lt;/form&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt; &lt;!-- END MODULE AREA 3: Sub Navigation 1 --&gt;  &lt;!-- START MODULE AREA 5: Footer 2 --&gt;   &lt;jsp:include page=\"../inc/bottom.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- END MODULE AREA 5: Footer 2 --&gt;  &lt;script src=\"${pageContext.request.contextPath }/js/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;  &lt;/html&gt;      폼태그를 이용해 입력한 정보들을 서블릿으로 전송한다.   contactUs.js   function finalCheck() {     var mail = document.mail; \t     if (mail.name.value.length &lt;= 0)     {         alert('이름을 입력하세요!');         mail.name.focus();         return false;     } \t     if (mail.email.value.length &lt;= 0)     {         alert('연락 받을 이메일을 입력하세요!');         mail.email.focus();         return false;     } \t     if (mail.title.value.length &lt;= 0)     {         alert('제목을 입력하세요!');         mail.title.focus();         return false;     } \t     if (mail.content.value.length &lt;= 0)     {         alert('내용을 입력하세요!');         mail.content.focus();         return false;     } }      메일을 보내기 전 모든 필드가 입력되었는지 확인 후 모든 분기가 true일 때에만 서블릿으로 이동한다.   BoardFrontController.java   package com.project.cafe.board.action;  import java.io.IOException;  import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFrontController extends HttpServlet {     protected void doProcess(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException      {         // 1. 전달되는 가상주소 계산         // .. 생략 \t\t         // 2. 가상주소 매핑         Action action = null;         ActionForward forward = null; \t\t         // .. 생략         else if (command.equals(\"/SendMailAction.bo\"))         {             System.out.println(\"C : /SendMailAction.bo 호출\"); \t\t\t             action = new SendMailAction(); \t\t\t             try {                 forward = action.execute(request, response);             }             catch (Exception e) {                 e.printStackTrace();             }         }         // .. 생략 \t\t         // 3. 페이지 이동         // .. 생략     }       // .. 생략 }      컨트롤러에서 메일 전송 동작을 수행할 서블릿으로 연결한다.   SendMailAction.java   package com.project.cafe.board.action;  import java.io.PrintWriter; import java.util.Date; import java.util.Properties;  import javax.mail.Address; import javax.mail.Authenticator; import javax.mail.Message; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class SendMailAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : SendMailAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"utf-8\"); \t\t         // 파라미터 저장         String sender = request.getParameter(\"email\");         String receiver = \"메일을 받는데 사용할 관리자 메일주소\";         String title = request.getParameter(\"title\");         String content = request.getParameter(\"content\");         String name = request.getParameter(\"name\"); \t\t         StringBuilder sb = new StringBuilder();         sb.append(\"이름 : \");         sb.append(name);         sb.append(\"&lt;br&gt;\");         sb.append(\"메일주소 : \");         sb.append(sender);         sb.append(\"&lt;br&gt;\");         sb.append(\"내용 : \");         sb.append(content); \t\t         // 메일 보내는 동작 수행         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter(); \t\t         try {             // 서버 정보를 Properies 객체에 저장             Properties properties = System.getProperties(); \t\t\t             // Starttls Command를 사용할 수 있게 설정             properties.put(\"mail.smtp.starttls.enable\", \"true\"); \t\t\t             // SMTP 서버를 지정             properties.put(\"mail.smtp.host\", \"smtp.gmail.com\"); \t\t\t             // AUTH command를 사용하여 사용자 인증을 할 수 있게 하는 설정 부분             properties.put(\"mail.smtp.auth\", \"true\"); \t\t\t             // 서버 포트를 지정하는 부분             properties.put(\"mail.smtp.port\", \"587\"); \t\t\t             // 인증 정보 생성             Authenticator auth = new GoogleAuthentication(); \t\t\t             // 메일을 전송하는 역할을 하는 단위인 Session 객체 생성             Session s = Session.getDefaultInstance(properties, auth); \t\t\t             // 생성한 Session 객체를 사용하여 전송할 Message 객체 생성             Message message = new MimeMessage(s); \t\t\t             // 메일을 송신할 송신 주소 생성             Address senderAddr = new InternetAddress(sender); \t\t\t             // 메일을 수신할 수신 주소 생성             Address receiverAddr = new InternetAddress(receiver); \t\t\t             // 메일 전송에 필요한 값들 설정             message.setHeader(\"content-type\", \"text/html; charset=utf-8\");             message.setFrom(senderAddr);             message.addRecipient(Message.RecipientType.TO, receiverAddr);             message.setSubject(title);             message.setContent(sb.toString(), \"text/html; charset=utf-8\");             message.setSentDate(new Date()); \t\t\t             // 메시지를 메일로 전송             Transport.send(message); \t\t\t             out.print(\"&lt;script&gt;\");             out.print(\"alert('메일이 정상적으로 전송되었습니다.');\");             out.print(\"location.href='./Contact.bo';\");             out.print(\"&lt;/script&gt;\");         }         catch (Exception e) {             out.print(\"SMTP 서버가 잘못 설정되었거나 서비스에 문제가 있습니다.\");             e.printStackTrace();         } \t\t         return null;     } }      받은 메일을 열어볼 때 줄을 바꿔서 보여주기 위해서 &lt;br&gt; 태그를 추가했다.   처음엔 \\n과 System.lineSeparator() 등 자바에서 줄을 바꾸는 코드를 썼는데 메일을 받으면 줄이 바뀌지 않아서 한참 찾아 헤멨다.   알고보니 메일이 출력되는 필드도 HTML이라 HTML태그로 줄바꿈을 작성해야 했다. message.setContent(sb.toString(), \"text/html; charset=utf-8\");이 구문의 \"text/html; charset=utf-8\"이 힌트였다…   참고글   GoogleAuthentication.java   package com.project.cafe.board.action;  import javax.mail.Authenticator; import javax.mail.PasswordAuthentication;  public class GoogleAuthentication extends Authenticator  {     PasswordAuthentication passAuth; \t     public GoogleAuthentication()     {         // 첫번째 인자는 구글 아이디, 두번째는 비밀번호         passAuth = new PasswordAuthentication(\"구글아이디\", \"앱 비밀번호\");     } \t     public PasswordAuthentication getPasswordAuthentication() {return passAuth;} }      구글 SMTP를 사용할 것이기 때문에 구글 계정 인증 정보를 받아오는 클래스를 만들었다.   앱 비밀번호는 앱 비밀번호 설정 페이지에서 설정할 수 있다.         이제 메일을 보내보면 작성한 대로 잘 간다! 👏      마감까지     D-5  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-19/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 06 실전문제 4. 두 배열의 원소 교체",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 06 - 실전문제 4. 두 배열의 원소 교체     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       동빈이는 두 개의 배열 A와 B를 가지고 있다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다. 동빈이는 최대 K번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말한다. 동빈이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이며, 여러분은 동빈이를 도와야 한다.   N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 N, K가 공백으로 구분되어 입력된다. (1 &lt;= N &lt;= 100,000,0 &lt;= K &lt;= N)   두 번째 줄에 배열 A의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000보다 작은 자연수이다.   세 번째 줄에 배열 B의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000보다 작은 자연수이다.     출력       최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력한다.      👀 풀이       배열 A의 최솟값을 배열 B의 최댓값과 K번만큼 바꿔가면 된다.   그럴려면 배열 A는 오름차순 정렬, 배열 B는 내림차순 정렬을 해야 한다.   그 후 0번째부터 K - 1번째 원소까지 두 배열의 원소를 바꿔주면 되는데 배열 A의 i번째 원소가 배열 B의 i번째 원소보다 작을 때에만 바꿔준다. 만약 배열 A의 i번째 원소가 배열 B의 i번째 원소보다 크다면 거기부터는 배열 B의 원소가 항상 작은 것이기 때문에 남은 K번만큼 계속 바꾸면 오답을 받게 될 것이다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BFS","Python"],
        "url": "/boj/CodingTestBook-06-12-py/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 20 - 파일업로드 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     파일업로드 기능을 추가했다.   COS 라이브러리를 사용했다.   COS 라이브러리 다운로드 및 설치     http://www.servlets.com/   위 사이트에 접속해서 하단에 Download 탭에 있는 압축파일을 다운로드 한다.   다운받은 파일 압축을 푼 후 cos.jar 파일을 WEB-INF/lib 폴더에 넣는다.   boardWrite.jsp   &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;     \t&lt;h2&gt;게시글 작성&lt;/h2&gt;     \t&lt;form name=\"write\" action=\"./BoardWriteAction.bo\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return finalCheck();\"&gt;     \t&lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;제목 &lt;/label&gt;&lt;input type=\"text\" name=\"title\" id=\"title\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_MsgField\"&gt;내용 &lt;/label&gt;           &lt;textarea id=\"MOD_TEXTFORM_MsgField\" name=\"content\"&gt;&lt;/textarea&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;파일 등록 &lt;/label&gt;&lt;input type=\"file\" name=\"file\" id=\"file\"&gt;         &lt;/div&gt;         &lt;button type=\"submit\" class=\"btn\"&gt;글 등록&lt;/button&gt;       &lt;/form&gt;       &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      기존에 글을 작성하던 페이지에 업로드 할 파일을 등록하는 태그를 추가했다.   사용자가 선택한 파일 객체가 전송될 수 있도록 인코딩 타입을 multipart/form-data로 지정해 주었다.   BoardWriteAction.java   package com.project.cafe.board.action;  import javax.servlet.ServletContext; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.oreilly.servlet.MultipartRequest; import com.oreilly.servlet.multipart.DefaultFileRenamePolicy; import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardWriteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardWriteAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // 파일 업로드 먼저 하기         // 1. 저장경로 생성         ServletContext ctx = request.getServletContext();         String realPath = ctx.getRealPath(\"/upload\"); \t\t         // 2. 파일의 저장크기         int maxSize = 10 * 1024 * 1024; // 10MB \t\t         // 3. 파일업로드(객체 생성)         MultipartRequest multi = new MultipartRequest(                 request,                  realPath,                 maxSize,                 \"utf-8\",                 new DefaultFileRenamePolicy()                 ); \t\t         // 파라메터를 DTO에 저장         // MultipartRequest 객체 안에 들은 파라미터 정보에 접근해야 한다.         BoardDTO dto = new BoardDTO();         dto.setContent(multi.getParameter(\"content\"));         dto.setId(multi.getParameter(\"id\"));         dto.setTitle(multi.getParameter(\"title\"));                  // 파일이름에 접근할 때엔 getFilesystemName() 메소드 사용         dto.setFile(multi.getFilesystemName(\"file\")); \t\t         // 사용자 ip주소 저장         dto.setIp(request.getRemoteAddr());         System.out.println(\"M : \"+dto); \t\t         // DB에 DTO 보내서 저장         BoardDAO dao = new BoardDAO();         dao.insertPost(dto); \t\t         // 완료되면 글 목록 페이지로 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./BoardList.bo\");         forward.setRedirect(true); \t\t         return forward;     } }   BoardDAO - insertPost(dto)   public void insertPost(BoardDTO dto) {     int postNum = 0;  \t\t     try {         // 1.2. DB 연결         con = getCon(); \t\t\t         // 3. sql 작성 &amp; pstmt 객체         // 이번 차례에 DB에 저장될 글번호 계산         sql = \"select max(num) from cafe_board\";         pstmt = con.prepareStatement(sql); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())             postNum = rs.getInt(1) + 1; \t\t\t         // 3. 데이터 삽입용 sql 작성 &amp; pstmt 설정         sql = \"insert into cafe_board(num, id, title, content, readcount, re_ref, re_lev, re_seq, date, ip, file) \"                 + \"values(?,?,?,?,?,?,?,?,now(),?,?)\";         pstmt = con.prepareStatement(sql); \t\t\t         // ? 채우기         pstmt.setInt(1, postNum);         pstmt.setString(2, dto.getId());         pstmt.setString(3, dto.getTitle());         pstmt.setString(4, dto.getContent());         pstmt.setInt(5, 0); // 처음에 조회수 0         pstmt.setInt(6, postNum); // 답글의 그룹. 일반글의 글번호와 동일하게 만듦         pstmt.setInt(7, 0); // 답글의 레벨. 처음엔 들여쓰기 없음         pstmt.setInt(8, 0); // 답글의 순서. 처음엔 가장 최상단         pstmt.setString(9, dto.getIp()); \t\t\t         if (dto.getFile() == null)             pstmt.setString(10, \"없음\");         else              pstmt.setString(10, dto.getFile()); \t\t\t         // 4. sql 실행         pstmt.executeUpdate(); \t\t\t         System.out.println(\"DAO : 게시글 DB 삽입 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } }      기존에 새 게시글을 DB 삽입하는 동작을 수행하던 BoardWriteAction과 insertPost() 메소드를 약간 수정했다.   boardContent.jsp   &lt;tbody&gt;   &lt;tr&gt;     &lt;td colspan=\"5\" style=\"white-space:pre-wrap; word-wrap:break-word; word-break: break-all;\"&gt;&lt;%=dto.getContent() %&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/td&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td colspan=\"2\"&gt;첨부파일&lt;/td&gt;     &lt;td colspan=\"3\"&gt;     &lt;!-- 첨부파일이 있을 때에만 하이퍼링크 연결 --&gt;       &lt;% if (dto.getFile() == null || dto.getFile().equals(\"없음\")) { %&gt;         &lt;%=dto.getFile() %&gt;       &lt;% }         else { %&gt;         &lt;a href=\"./BoardFileDownloadAction.bo?file_name=&lt;%=dto.getFile() %&gt;\"&gt;&lt;%=dto.getFile() %&gt;&lt;/a&gt;       &lt;% } %&gt;     &lt;/td&gt;   &lt;/tr&gt; &lt;/tbody&gt;      게시글 내용을 보여주는 페이지에서는 첨부파일이 있을 때에만 하이퍼링크를 연결하도록 했다.           여기까지 하면 파일 유무에 따라서 하이퍼링크 연결까지 된다.   BoardFileDownloadAction.java   package com.project.cafe.board.action;  import java.io.FileInputStream; import java.net.URLEncoder;  import javax.servlet.ServletContext; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardFileDownloadAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardFileDownloadAction - execute() 호출\"); \t\t         // 전달된 파일 이름 저장         String fileName = request.getParameter(\"file_name\"); \t\t         // 서버에 업로드 된 폴더 찾기         String savePath = \"upload\"; \t\t         // 서버에 업로드 된 파일의 위치 계산(물리적 경로)         ServletContext ctx = request.getServletContext();         String downloadPath = ctx.getRealPath(savePath); \t\t         System.out.println(\"downloadPath : \"+downloadPath); \t\t         // 다운로드 할 파일의 전체 경로 계산         // 사용자 OS에 따라 연결문자 구분         String filePath = null;         String agent = request.getHeader(\"User-Agent\");         System.out.println(\"agent: \"+agent); \t\t         if (agent.indexOf(\"Windows\") != -1)             filePath = downloadPath + \"\\\\\" + fileName;         else             filePath = downloadPath + \"/\" + fileName; \t\t         System.out.println(\"filePath : \"+filePath); \t\t         /////////////////////////////////////////// \t\t         // 파일을 저장하는 배열(버퍼)         byte[] b = new byte[4096]; // 4kb \t\t         // 데이터를 주고받을 수 있는 통로 만들기         FileInputStream fis = new FileInputStream(filePath); \t\t         // MIME 타입 얻어오기         String mimeType = ctx.getMimeType(filePath);         System.out.println(\"mimeType: \"+mimeType); \t\t         // MIME 타입 정보가 없는 경우         if (mimeType == null)         {             // 실제로 잘 알려지지 않은 이진파일을 의미하며, 브라우저가 자동 실행하지 않고 실행여부를 질문한다.             mimeType = \"application/octet-stream\";         } \t\t         // 브라우저가 전달받은 MIME 타입으로 응답정보 설정         response.setContentType(mimeType); \t\t         // IE / 그 외 나머지 브라우저 구분         boolean ieBrowser = (agent.indexOf(\"MISE\") &gt; -1 || agent.indexOf(\"Trident\") &gt; -1);         if (ieBrowser)         {             // 인터넷 익스플로러일 때             // 인터넷 익스플로러에서는 한글 다운로드시 한글 인코딩이 깨져서 utf-8로 바꿔준다.             // 인터넷 익스플로러에서는 공백문자 표시가 [+]라서 [%20]으로 바꿔준다.             fileName = URLEncoder.encode(fileName, \"utf-8\").replaceAll(\"\\\\+\", \"%20\");         }         else         {             // 그 외 브라우저             // 브라우저 다운로드시 한글 깨짐 처리             // 8859-1 &lt; EUC-KR &lt; MS949 &lt; UTF-8             // -&gt; 방향으로 갈수록 인코딩 범위가 커짐 (한글처리할 수 있는 범위가 늘어남)             fileName = new String(fileName.getBytes(\"utf-8\"), \"iso-8859-1\");         } \t\t         // 브라우저에서 해석되는(미리보기 형태로 바로 볼 수 있는) 파일도 다운로드 형태로 처리가능하게 변경         response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName); \t\t         // 다운로드할 파일 출력         ServletOutputStream out = response.getOutputStream(); \t\t         int data = 0;         // 데이터를 배열을 사용해 배열의 길이만큼 잘라서 data에 저장한다. EOF가 아닐 때까지         while ((data = fis.read(b, 0, b.length)) != -1)         {             // 가져온 data 길이만큼 출력             out.write(b, 0, data);         } \t\t         // ServletOutputStream은 버퍼의 길이가 다 찼을 때에만 데이터를 전달하기 때문에          // flush로 버퍼의 빈 공간을 채워서 전송함         out.flush(); \t\t         out.close();         fis.close(); \t\t         return null;     } }      업로드 된 파일을 클릭하면 파일 다운로드를 처리하는 서블릿으로 이동한다.   다운로드 할 파일의 경로를 설정할 때 Mac OS에서는 파일 경로 구분자를 \"/\"를 사용하는데 Windows OS에서는 \"\\\"를 사용하기 때문에 filePath를 설정하는 부분에서 \"\\\\\"만 쓰면 맥에서 경로를 제대로 못 찾는다.(난 맥북을 쓰는데 수업은 윈도우 기반이라서 처음에 윈도우 버전으로 따라하면서 \"\\\\\" 쓰니까 안 되서 헤멨었음)        그래서 사용자의 OS에 따라 다르게 처리하는 부분을 추가했다.       여기까지 하면 다운로드도 잘 된다.      마감까지     D-4  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-20/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 07 실전문제 2. 부품 찾기",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 07 - 실전문제 2. 부품 찾기     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       동빈이네 전자 매장에는 부품이 N개 있다. 각 부품은 정수 형태의 고유한 번호가 있다. 어느 날 손님이 M개 종류의 부품을 대량으로 구매하겠다며 당일 날 견적서를 요청했다. 동빈이는 때를 놓치지 않고 손님이 문의한 부품 M개 종류를 모두 확인해서 견적서를 작성해야 한다. 이때 가게 안에 부품이 모두 있는지 확인하는 프로그램을 작성해보자.   손님이 요청한 부품 번호의 순서대로 부품을 확인해 부품이 있으면 yes를, 없으면 no를 출력한다. 구분은 공백으로 한다.     입력       첫째 줄에 정수 N이 주어진다. (1 &lt;= N &lt;= 1,000,000)   둘째 줄에는 공백으로 구분하여 N개의 정수가 주어진다. 이때 정수는 1보다 크고 1,000,000 이하이다.   셋째 줄에는 정수 M이 주어진다. (1 &lt;= M &lt;= 100,000)   넷째 줄에는 공백으로 구분하여 M개의 정수가 주어진다. 이때 정수는 1보다 크고 1,000,000 이하이다.     출력       첫째 줄에 공백으로 구분하여 각 부품이 존재하면 yes를, 없으면 no를 출력한다.      👀 풀이       이진탐색으로 풀 수 있는 문제이지만 책에는 이진탐색 외에도 두 가지 방법을 더 사용해 푸는 방법이 나와 있어서 모두 연습해 보았다.   이진탐색으로 풀 경우에는 가게에 있는 부품 배열을 먼저 오름차순으로 정렬한 후에 손님 배열의 원소를 하나씩 이진탐색으로 찾는다.     코드       이진탐색 코드        계수정렬을 사용한 코드        집합 자료형을 사용한 코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BinarySearch","Python"],
        "url": "/boj/CodingTestBook-07-5-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 07 실전문제 3. 떡볶이 떡 만들기",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 07 - 실전문제 3. 떡볶이 떡 만들기     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       오늘 동빈이는 여행 가신 부모님을 대신해서 떡집 일을 하기로 했다. 오늘은 떡볶이 떡을 만드는 날이다. 동빈이네 떡볶이 떡은 재밌게도 떡볶이 떡의 길이가 일정하지 않다. 대신에 한 봉지 안에 들어가는 떡의 총 길이는 절단기로 잘라서 맞춰준다.   절단기에 높이(H)를 지정하면 줄지어진 떡을 한 번에 절단한다. 높이가 H보다 긴 떡은 H 위의 부분이 잘릴 것이고, 낮은 떡은 잘리지 않는다.   예를 들어 높이가 19, 14, 10, 17cm인 떡이 나란히 있고 절단기 높이를 15cm로 지정하면 자른 뒤 떡의 높이는 15, 14, 10, 15cm가 될 것이다. 잘린 떡의 높이는 차례대로 4, 0, 0, 2cm이다. 손님은 6cm만큼의 길이를 가져간다.   손님이 왔을 때 요청한 총 길이가 M일 때 적어도 M만큼의 떡을 얻기 위해 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.     입력       첫째 줄에 떡의 개수 N과 요청한 떡의 길이 M이 주어진다. (1 &lt;= N &lt;= 1,000,000, 1 &lt;= M &lt;= 2,000,000,000)   둘째 줄에는 떡의 개별 높이가 주어진다. 떡 높이의 총합은 항상 M 이상이므로, 손님은 필요한 양만큼 떡을 사갈 수 있다. 높이는 10억보다 작거나 같은 양의 정수 또는 0이다.     출력       적어도 M만큼의 떡을 집에 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.      👀 풀이       이진탐색 문제이자 파라메트릭 서치 문제라고 한다.   이런 유형의 문제는 풀어본 적이 없어서 책에 나와 있는 해설을 보고 풀었다.   자른 떡의 길이가 M과 같아질 때까지 절단기의 위치를 옮겨가면서 적절한 높이(H)를 찾는다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BinarySearch","Python"],
        "url": "/boj/CodingTestBook-07-8-py/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 21 - 게시물에 첨부된 이미지와 파일 다른 경로에 저장하기",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시물에 이미지를 첨부하고 볼 수 있는 기능을 추가했다.   한 게시물에 이미지와 일반 파일을 함께 업로드 할 수 있게 했다. 그래서 이미지와 일반 파일을 다른 경로에 업로드할 것이다.   COS 라이브러리를 사용했다.   COS 라이브러리 다운로드 및 설치     http://www.servlets.com/   위 사이트에 접속해서 하단에 Download 탭에 있는 압축파일을 다운로드 한다.   다운받은 파일 압축을 푼 후 cos.jar 파일을 WEB-INF/lib 폴더에 넣는다.   boardWrite.jsp   &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;     \t&lt;h2&gt;게시글 작성&lt;/h2&gt;     \t&lt;form name=\"write\" action=\"./BoardWriteAction.bo\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return finalCheck();\"&gt;     \t&lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;제목 &lt;/label&gt;&lt;input type=\"text\" name=\"title\" id=\"title\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_MsgField\"&gt;내용 &lt;/label&gt;           &lt;textarea id=\"MOD_TEXTFORM_MsgField\" name=\"content\"&gt;&lt;/textarea&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;이미지 등록 &lt;/label&gt;&lt;input type=\"file\" name=\"image\" id=\"image\" oninput=\"formatCheck();\"&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;파일 등록 &lt;/label&gt;&lt;input type=\"file\" name=\"file\" id=\"file\"&gt;         &lt;/div&gt;         &lt;button type=\"submit\" class=\"btn\"&gt;글 등록&lt;/button&gt;       &lt;/form&gt;       &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      이미지 파일 등록도 input 태그의 file 속성을 사용한다.   BoardContent.js   function formatCheck() {     // 확장자 확인할 정규식     var regex = new RegExp(\"(.*?)\\.(jpg|jpeg|png|gif)\");     var maxSize = 10 * 1024 * 1024; \t     var fileSize = $('#image')[0].files[0].size;     if (fileSize &gt; maxSize)     {         alert('5MB 이하만 첨부 가능합니다.');         crossBrowsing();     } \t     if (!regex.test($('#image').val()))     {         alert('확장자가 jpeg, jpg, png, gif인 이미지 파일만 등록 가능합니다.');         crossBrowsing();     } }  function crossBrowsing() {     var agent = navigator.userAgent.toLowerCase(); \t     // 크로스 브라우징 처리     // IE일 때     if (navigator.appName == 'Netscape' &amp;&amp; navigator.userAgent.search('Trident') != -1 || agent.indexOf(\"msie\") != -1)         $('#image').replaceWith($('#image').clone(true));     else // 그 외 브라우저         $('#image').val('');\t }      이미지 파일 업로드를 시도하면 파일 크기와 확장자 확인을 통해 유효한 파일만 등록할 수 있게 한다.   BoardWriteAction.java   package com.project.cafe.board.action;  import java.io.File;  import javax.servlet.ServletContext; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.oreilly.servlet.multipart.FilePart; import com.oreilly.servlet.multipart.MultipartParser; import com.oreilly.servlet.multipart.ParamPart; import com.oreilly.servlet.multipart.Part; import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardWriteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardWriteAction - execute() 호출\"); \t\t         request.setCharacterEncoding(\"utf-8\"); \t\t         BoardDTO dto = new BoardDTO(); \t\t         ServletContext ctx = request.getServletContext(); \t\t         // 파일의 저장크기         int maxSize = 10 * 1024 * 1024; // 10MB \t\t         MultipartParser mp = new MultipartParser(request, maxSize);         mp.setEncoding(\"utf-8\");         Part part; \t\t         while ((part = mp.readNextPart()) != null)         {             // form 태그로 저장된 파라미터를 읽어옴             String name = part.getName(); \t\t\t             if (part.isParam())             {                 // 파일이 아닐 때                 ParamPart param = (ParamPart)part;                 String value = param.getStringValue(); \t\t\t\t                 System.out.println(\"param name :\" + name + \" value : \" + value); \t\t\t\t                 // 각 파라미터에 맞춰 dto에 저장                 if (name.equals(\"id\"))                     dto.setId(value);                 else if (name.equals(\"title\"))                     dto.setTitle(value);                 else if (name.equals(\"content\"))                     dto.setContent(value);             }             else if (part.isFile() &amp;&amp; name.equals(\"image\"))             {                 // 이미지 파일일 때                 // 이미지 저장 경로 지정                 File dir = new File(ctx.getRealPath(\"/images\")); \t\t\t\t                 // 경로가 없으면 생성                 if (!dir.isDirectory()) dir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 String file = filePart.getFileName();                 if (file != null)                 {                     // 지정한 경로에 파일 쓰기                     filePart.writeTo(dir);                     dto.setImage(file);                     System.out.println(\"img name: \"+file);                 }                 else                      System.out.println(\"image; name: \" + name + \"; EMPTY\");             }             else if (part.isFile() &amp;&amp; name.equals(\"file\"))             {                 // 일반 파일일 때                 File dir = new File(ctx.getRealPath(\"/upload\")); \t\t\t\t                 // 경로 없으면 생성                 if (!dir.isDirectory()) dir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 String file = filePart.getFileName();                 if (file != null)                 {                     filePart.writeTo(dir); // 지정한 경로에 파일 쓰기                     dto.setFile(file);                     System.out.println(\"file name: \"+file);                 }                 else                     System.out.println(\"file; name: \" + name + \"; EMPTY\");             }         } \t\t         // 사용자 ip주소 저장         dto.setIp(request.getRemoteAddr());         System.out.println(\"M : \"+dto); \t\t         // DB에 DTO 보내서 저장         BoardDAO dao = new BoardDAO();         dao.insertPost(dto); \t\t         // 완료되면 글 목록 페이지로 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./BoardList.bo\");         forward.setRedirect(true); \t\t         return forward;     } }      한 게시물에서 이미지와 일반파일 두 개가 업로드 되는데 파일 종류별로 경로를 나눠서 저장하고 싶었다.   한 폴더에 들어 있으면 정신없기도 하지만 종류별로 구분해 놓으면 이미지를 불러올 땐 이미지만 저장된 폴더에서 찾아서 가져오면 되니까 한꺼번에 섞인 폴더에서 찾아오는 것 보다는 빠르게 찾아올 수 있을 것이라 생각했기 때문이다.   그래서 MultipartParser를 사용해서 파라미터 이름별로 업로드 경로를 구분해서 파일을 업로드 한다.   boardContent.jsp   &lt;tbody&gt;   &lt;tr&gt;     &lt;td colspan=\"5\" style=\"white-space:pre-wrap; word-wrap:break-word; word-break: break-all;\"&gt;&lt;%=dto.getContent() %&gt;&lt;br&gt;&lt;br&gt;       &lt;%if (dto.getImage() != null &amp;&amp; !dto.getImage().equals(\"없음\")) { %&gt;         &lt;img src=\"./BoardImgAction.bo?img_name=&lt;%=dto.getImage() %&gt;\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/td&gt;       &lt;% } %&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td colspan=\"2\"&gt;첨부파일&lt;/td&gt;     &lt;td colspan=\"3\"&gt;       &lt;!-- 첨부파일이 있을 때에만 하이퍼링크 연결 --&gt;       &lt;%if (dto.getFile() == null || dto.getFile().equals(\"없음\")) { %&gt;         &lt;%=dto.getFile() %&gt;       &lt;% }         else { %&gt;         &lt;a href=\"./BoardFileDownloadAction.bo?file_name=&lt;%=dto.getFile() %&gt;\"&gt;&lt;%=dto.getFile() %&gt;&lt;/a&gt;       &lt;% } %&gt;     &lt;/td&gt;   &lt;/tr&gt; &lt;/tbody&gt;      게시글 본문 페이지에 들어오면 첨부된 이미지가 있을 때에만 이미지를 불러온다.   BoardImgAction.java   package com.project.cafe.board.action;  import java.io.FileInputStream; import java.net.URLEncoder;  import javax.servlet.ServletContext; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardImgAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardImgAction - execute() 호출\"); \t\t         // 전달된 이미지 파일 이름 저장         String imgName = request.getParameter(\"img_name\"); \t\t         // 서버에 업로드 된 폴더 찾기         String savePath = \"images\"; \t\t         // 서버에 업로드 된 파일 위치 계산         ServletContext ctx = request.getServletContext();         String downloadPath = ctx.getRealPath(savePath);         System.out.println(\"download path: \"+downloadPath); \t\t         // 다운로드 할 이미지의 전체 경로 계산         // 사용자 OS에 따라 연결자 구분         String imgPath = null;         String agent = request.getHeader(\"User-Agent\");         if (agent.indexOf(\"Windows\") != -1)             imgPath = downloadPath + \"\\\\\" + imgName;         else              imgPath = downloadPath + \"/\" + imgName; \t\t         System.out.println(\"imgPath: \"+imgPath); \t\t         // 파일 저장 배열         byte[] b = new byte[4096]; \t\t         // 데이터 주고받을 통로 생성         FileInputStream fis = new FileInputStream(imgPath); \t\t         // MIME 타입 정보 얻어오기         String mimeType = ctx.getMimeType(imgPath);         System.out.println(\"MIME type: \"+mimeType); \t\t         if (mimeType == null)             mimeType = \"application/octet-stream\"; \t\t         // 전달받은 MIME 타입으로 브라우저 정보 설정         response.setContentType(mimeType); \t\t         // 인터넷 익스플로러 일 때 구분해서 처리         boolean ieBrowser = (agent.indexOf(\"MISE\") &gt; -1 || agent.indexOf(\"Trident\") &gt; -1);         if (ieBrowser)             imgName = URLEncoder.encode(imgName, \"utf-8\").replaceAll(\"\\\\+\", \"%20\");         else              imgName = new String(imgName.getBytes(\"utf-8\"), \"iso-8859-1\"); \t\t         // 응답정보 설정         response.setHeader(\"Content-Disposition\", mimeType); \t\t         // 출력스트림 생성         ServletOutputStream out = response.getOutputStream(); \t\t         int data = 0;         while ((data = fis.read(b, 0, b.length)) != -1)             out.write(b, 0, data); \t\t         out.flush(); \t\t         out.close();         fis.close(); \t\t         return null;     } }      여기까지 하면 게시글에 입장했을 때 업로드 한 이미지가 출력된다.      출처     [JAVA] MultipartParser 파일 저장경로를 파라메터로 받아서 업로드하기   Java 각각 다른 경로로 File Upload       마감까지     D-4  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-21/",
        "teaser": null
      },{
        "title": "MySQL) 다른 데이터베이스로 테이블 이동, 복사 및 변경하기",
        "excerpt":"다른 데이터베이스로 테이블을 이동하고 싶을 때     테이블 이름을 변경하는 명령어는 다음과 같다.   mysql&gt; alter table 테이블명 rename 새 테이블명;         이걸 이용해서 테이블을 다른 데이터베이스로 옮길 수 있다.   mysql&gt; alter table 데이터베이스A.테이블명 rename 데이터베이스B.테이블명;        테이블 복사   mysql&gt; create table 새 테이블명 like 복사할 테이블명;         이걸 이용해서 다른 데이터베이스에 있는 테이블을 복사할 수 있다.   mysql&gt; create table 데이터베이스A.테이블명 like 데이터베이스B.테이블명;         insert 구문을 이용한 방법   mysql&gt; insert into 새 테이블명 select * from 원본테이블명;         insert 구문을 이용해서 다른 데이터베이스에 있는 테이블 복사   mysql&gt; insert into 데이터베이스B.테이블명 select * from 데이터베이스A.테이블명;  ","categories": ["MySQL"],
        "tags": ["MySQL","alterTable"],
        "url": "/mysql/mysql-alter-table/",
        "teaser": null
      },{
        "title": "OS) Memory Management",
        "excerpt":"👀 논리적 주소와 물리적 주소          데이터가 메모리에 위치하고 있는 곳을 가리키는 주소는 논리적 주소와 물리적 주소로 나뉜다.       Logical address (= virtual address)            프로세스마다 독립적으로 가지는 주소 공간       각 프로세스마다 0번지부터 시작       CPU가 보는 주소는 logical address임       왜냐면 코드상의 주소가 logical address인데 이게 물리적 주소로 바뀐다 해서 코드상의 주소도 물리적 주소로 바뀌는 것은 아니다. 만약 바뀐다면 컴파일을 새로 해야 하는데 이러면 이상하다. 그래서 CPU는 논리적 주소를 참고하게 된다.           Physical address            메모리에 실제로 올라가는 위치           CPU가 instruction을 수행하다가 메모리에 있는 데이터에 접근할 필요가 있으면 그 데이터가 위치하고 있는 주소를 알아야 한다.   이때 코드에 물리적 주소가 항상 명시되어 있어서 바로 그 위치로 가서 읽어오면 서로 편하겠지만 프로그램이 실행되는 컴퓨터와 환경에 따라 항상 같은 물리적 주소를 사용할 수 있다는 보장이 없다.   그래서 코드에는 논리적 주소를 사용해 각 프로세스별로 전용 주소공간을 사용할 수 있게 하고 그 논리적 주소를 이용해 메모리에 실제로 올려져 있는 위치를 참고할 수 있도록 하는 것이다.   CPU는 메모리에 접근할 필요가 있으면 먼저 논리적 주소를 물리적 주소로 변환한 뒤 해당 위치에 접근해서 데이터를 읽어온다.   주소 바인딩(Address Binding)     논리적 주소를 물리적 주소로 변환하는 것   하지만 주소변환은 CPU가 하는 것이 아닌 하드웨어적으로 이루어진다.   주소변환이 필요할 때마다 CPU가 필요하면 그 때마다 interrupt가 일어나게 될 것이고 그건 굉장히 비효율적일 것이다.   주소 바인딩 시점에 따른 분류     Compile time binding            컴파일될 때 물리적 주소가 결정된다.       시작위치가 변경되면 재컴파일       컴파일러는 절대 코드(absolute code) 생성       옛날에 많이 쓰다가 지금은 잘 안 쓴다.           Load time binding            Loader의 책임하에 물리적 메모리 주소 부여       프로그램이 메모리에 로드될 때 물리적 주소가 결정된다.       컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우 가능           Execution time binding (= Run time binding)            수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있다.       CPU가 주소를 참조할 때마다 binding 점검 (address mapping table)       하드웨어에서 지원해야 가능하다.       최근 시스템에서 사용하는 방식           Memory-Management Unit (MMU)     주소 변환을 위한 하드웨어   논리적 주소를 물리적 주소로 매핑해 준다.   실제 물리적 주소의 시작점에서 논리적 주소의 offset만큼을 더해서 물리적 주소를 알려준다.   Limit register : 만약 프로세스가 자기 범위를 넘어가는 위치에 있는 데이터에 접근을 요구하면 다른 프로세스의 중요 데이터에 접근하게 될 수 있다. 그래서 주소를 변환할 때 프로세스가 가질 수 있는 주소의 최대 크기를 먼저 제한해놓고 그 범위 안에서만 변환할 수 있도록 한다.     메모리 로드 기법들  Dynamic Loading     프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것   memory utilization이 향상됨   가끔씩 사용되는 코드가 많을 때 유용하다.            자주 사용되는 부분이 한정적인데 전체를 올리면 비효율적이다.       예 : 오류 처리 루틴           운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능)   Dynamic Linking     Linking을 실행시간(execution time)`까지 미루는 기법   Static linking            라이브러리가 프로그램의 실행 파일 코드에 포함됨       실행 파일의 크기가 커짐       동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비가 생긴다.(예: printf함수의 라이브러리 코드)           Overlays            메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림       이렇게 보면 Dynamic loading과 비슷해 보이지만 프로그래머가 수작업으로 구현해야 한다는 점에서 다르다. 작은 공간의 메모리를 사용하던 초창기 시스템에서 사용하던 방식으로 프로그래밍이 매우 복잡하다.       프로세스의 크기가 메모리보다 클 때 유용       운영체제의 지원 없이 사용자에 의해 구현           Dynamic linking            라이브러리가 실행시 연결된다.       라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둔다.       라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴       운영체제의 도움 필요           Swapping            프로세스를 일시적으로 메모리에서 backing store(하드디스크)로 쫓아내는 것       Backing store : 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간       일반적으로 중기 스케줄러(swapper)에 의해 swap in/out될 프로세스가 선정된다.       프로세스의 우선순위에 따라 swap이 이루어진다.       Compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in해야 함       Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있다.       swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)이다.           Allocation of Physical Memory          메모리는 일반적으로 두 영역으로 나뉘어 사용된다.       OS 상주 영역 : interrupt vector와 함께 낮은 주소 영역 사용   사용자 프로세스 영역 : 높은 주소 영역 사용   사용자 프로세스 영역의 할당 방법     Contiguous allocation            각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것           Noncontiguous allocation            하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있다.       현대 운영체제에서 사용           Contiguous Allocation     고정분할 (Fixed partition) 방식            물리적 메모리를 몇 개의 영구적 분할로 나눔       분할의 크기가 모두 동일한 방식과 서로 다른 방식 존재       분할당 하나의 프로그램 적재       동시에 메모리에 로드되는 프로그램의 수가 고정됨       최대 수행 가능 프로그램 크기 제한       internal fragmentation(내부 조각), external fragmentation(외부 조각) 발생           가변분할 (Variable partition) 방식            프로그램의 크기를 고려해서 할당       분할의 크기, 개수가 동적으로 변함       기술적 관리 기법 필요       external fragmentation(외부 조각) 발생           External fragmentation(외부 조각)            프로그램 크기보다 분할 크기가 작을 때 생김       아무 프로그램에도 배정되지 않은 빈 공간이지만 프로그램이 올라갈 수 없는 작은 공간           Internal fragmentation(내부 조각)            프로그램 크기보다 분할 크기가 글 때 생김       하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각       특정 프로그램에 배정되었지만 사용되지 않는 공간           Hole            가용 메모리 공간       다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있다.       프로세스가 도착하면 수용가능한 hole을 할당       운영체제는 다음의 정보 유지 - 할당공간, 가용공간           Dynamic Storage-Allocation Problem                     가변 분할 방식에서 size = n 인 요청을 만족하는 가장 적절한 hole을 찾는 문제               First-fit                    사이즈가 n 이상인 것 중 최초로 찾아지는 hole에 할당                       Best-fit                    사이즈가 n 이상인 가장 작은 hole을 찾아서 할당           hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole 리스트를 탐색해야 함           많은 수의 아주 작은 hole들이 생성됨                       Wost-fit                    가장 큰 hole에 할당           모든 리스트를 탐색해야 함           상대적으로 아주 큰 hole들이 생성됨                       First-fit과 Best-fit이 Wost-fit보다 속도와 공간 이용률 측면에서 효과적           Compaction            external fragmentation(외부 조각) 문제를 해결하는 한 가지 방법       사용 중인 메모리 영역을 한 군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것       이렇게 보면 Windows의 디스크 조각 모음과 비슷해 보이지만 디스크 모음은 디스크에 있는 조각들을 모으는 것인데 반해 Compaction은 실행 중인 메모리의 조각들을 모으는 것이라는 점에서 다르다.       비용이 매우 많이 든다.       최소한의 메모리 이동으로 Compaction하는 방법이 있지만 매우 복잡하다.       프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있다. 런타임 바인딩이 지원될 때에만 사용 가능           Paging     프로세스의 virtual memory를 동일한 사이즈의 page로 나눈다.   virtual memory의 내용이 page 단위로 비연속적으로 저장된다.   일부는 backing storage에, 일부는 physical memory에 저장        각 페이지마다 논리적 - 물리적 주소 매핑 정보(페이징 테이블)가 필요하다.       physical memory를 동일한 크기의 frame으로 나눔   logical memory를 동일 크기의 page로 나눔(frame과 같은 크기)   모든 가용 frame들을 관리   page table을 사용하여 논리적 주소를 물리적 주소로 바꾼다.        외부조각이 발생하지 않지만 페이징한 프로세스의 마지막 조각은 페이지 크기보다 작을 수 있기 때문에 내부조각은 발생할 수 있다.       속도 향상을 위해 TLB(Translation Look-aside Buffer)라는 하드웨어를 사용한다.            일종의 캐시로 논리적 - 물리적 주소 쌍을 가지고 있다.           페이지 갯수만큼 페이징 테이블이 필요하기 때문에 공간이 많이 필요하다.   Two-Level Page Table     페이지 테이블 공간을 줄이기 위해 사용한다. (속도 향상적인 측면에서는 별 효과 없음)   페이지 테이블 자체를 페이지로 구성해서 페이지 안에 페이지가 또 있는 형태이다.   사용되지 않는 페이지 영역은 안쪽 페이지 테이블을 안 만들고 포인터를 NULL로 두기 때문에 공간을 절약할 수 있다.   주소 공간이 더 커지면 다단계 페이지 테이블을 사용할 수도 있다.   Memory Protection          페이지 테이블 각 entry마다 bit를 둔다.       Protection bit            페이지에 대한 접근 권한 설정(read/write/read-only 등 연산에 대한 접근 권한)           Valid-invalid bit            valid : 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함(접근 허용)       invalid : 해당 주소의 frame에 유효한 내용이 없음 (접근 불허)                    프로세스가 그 주소 부분을 사용하지 않는 경우           해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우                           Inverted Page Table     페이지 갯수가 많아짐에 따라 페이지 테이블이 커지는 문제를 줄여보려고 사용하는 테이블   프로세스별로 페이지 테이블을 두는 것이 아닌 페이지 프레임 하나당 페이지 테이블에 하나의 entry를 둔 것   각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시   물리적 주소를 보고 논리적 주소를 알 수 있는 테이블이라 할 수 있다.   Shared Page     Shared code            공유가 가능한 코드는 read-only로 한 frame에만 올리는 것       모든 프로세스의 logical address space에서 동일한 위치에 있어야 함           Private code and data            각 프로세스들은 독자적으로 메모리에 올림       private data는 logical address space 아무 곳에 와도 무방함           Segmentation     프로그램은 의미 단위인 여러 개의 segment로 구성   작게는 프로그램을 구성하는 함수 하나하나에서 크게는 프로그램 전체까지도 가능   일반적으로는 code, data, stack 부분이 하나씩의 세그먼트로 정의됨            main(), function, global variables, stack, symbol table, arrays           논리적 주소는 segment-number, offest 쌍으로 구성된다.   세그먼트별 주소 변환 정보를 담고 있는 segment table이 필요하다.   segment-number로부터 offest만큼 떨어진 위치에 접근하는 방식   각 세그먼트별로 protection bit 설정하기가 용이하다.   의미 단위이기 때문에 공유와 보안에 있어 페이징 기법보다 훨씬 효과적이다.(페이징은 한 페이지 안에 한 종류만 들어있지 않을 수 있기 때문에 종류별로 보안 설정을 다르게 해 줘야 한다)   페이징 기법보다는 테이블 크기가 작다.   외부조각 발생   할당은 first fit / best fit 방식으로 이루어지며 세그먼트의 길이가 동일하지 않기 때문에 가변분할에서와 동일한 문제점이 발생한다.   Segmentation with Paging     세그먼트 하나가 여러개의 페이지로 구성된다. 둘을 섞은 것   훨씬 효율적이라 많이 쓰는 방식이다.   메모리에 올라갈 땐 페이지 단위로 올라가고 공유는 세그먼트 단위에서 이루어진다.      출처     운영체제 - 이화여자대학교 KOCW 공개강의  ","categories": ["Operating System"],
        "tags": ["CS","OS","Process","MemoryManagement"],
        "url": "/operating%20system/OS-08-Memory-Management/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 22 - 게시판 이미지 썸네일 보여주는 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     게시글에 첨부된 이미지가 있으면 메인 화면에서 게시글 내용을 미리보기로 보여줄 때 이미지도 함께 보여주는 기능을 추가했다.   원본 이미지로 썸네일용 이미지를 만들어주는 Thumbnailator 라이브러리를 사용했다.   Thumbnailator 라이브러리 다운로드 및 설치     https://search.maven.org/artifact/net.coobird/thumbnailator/0.4.17/jar   위 사이트에 접속해서 오른쪽 상단에 보이는 Download 버튼을 눌러 jar파일을 다운로드 한다.   다운받은 thumbnailator-0.4.17.jar 파일을 WEB-INF/lib 폴더에 넣는다.   BoardWriteAction.java   package com.project.cafe.board.action;  import java.io.File;  import javax.servlet.ServletContext; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.oreilly.servlet.multipart.FilePart; import com.oreilly.servlet.multipart.MultipartParser; import com.oreilly.servlet.multipart.ParamPart; import com.oreilly.servlet.multipart.Part; import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  import net.coobird.thumbnailator.Thumbnails; import net.coobird.thumbnailator.name.Rename;  public class BoardWriteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         // .. 생략 \t\t         while ((part = mp.readNextPart()) != null)         {             //.. 생략                          else if (part.isFile() &amp;&amp; name.equals(\"image\"))             {                 // 이미지 파일일 때                 // 이미지 저장 경로 지정                 File dir = new File(ctx.getRealPath(\"/images\"));                 File originDir = new File(dir + File.separator + \"origins\"); // 원본 이미지 저장 경로                 File thumbnailDir = new File(dir + File.separator + \"thumbnails\"); // 썸네일 저장 경로 \t\t\t\t                 // 경로가 없으면 생성                 if (!dir.isDirectory()) dir.mkdir();                 if (!originDir.isDirectory()) originDir.mkdir();                 if (!thumbnailDir.isDirectory()) thumbnailDir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 String file = filePart.getFileName();                 if (file != null)                 {                     // 지정한 경로에 원본 이미지 파일 쓰기                     filePart.writeTo(originDir);                     dto.setImage(file); \t\t\t\t\t                     // 원본 이미지 파일을 이용해서 썸네일을 만들어 저장                     // 크기 지정 후 지정 경로에 저장                     Thumbnails.of(new File(originDir.getPath() + File.separator + file))                         .size(300, 400)                         .toFiles(thumbnailDir, Rename.NO_CHANGE); \t\t\t\t\t                     System.out.println(\"img name: \"+file);                 }                 else                      System.out.println(\"image; name: \" + name + \"; EMPTY\");             }             // .. 생략         } \t\t         // .. 생략 \t\t         return forward;     } }      새 게시글을 작성하는 서블릿에서 원본 이미지 외에도 썸네일을 만들어 저장하는 코드를 추가했다.   원본 이미지와 썸네일을 저장할 폴더를 각각 구분해서 업로드한다.   BoardImgAction.java   package com.project.cafe.board.action;  import java.awt.image.renderable.ParameterBlock; import java.io.File; import java.io.FileInputStream; import java.net.URLEncoder;  import javax.servlet.ServletContext; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward;  public class BoardImgAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardImgAction - execute() 호출\"); \t\t         // 전달된 이미지 파일 이름 저장         String originImgName = request.getParameter(\"img_name\");         String thumbnailName = request.getParameter(\"thumbnail\");         String imgName = null; \t\t         // 서버에 업로드 된 폴더 찾기         String savePath = null;         if (originImgName != null)         {             savePath = \"images/origins\";             imgName = originImgName;         }         else          {             savePath = \"images/thumbnails\";             imgName = thumbnailName;         } \t\t         // 서버에 업로드 된 파일 위치 계산         ServletContext ctx = request.getServletContext();         String downloadPath = ctx.getRealPath(savePath);         System.out.println(\"download path: \"+downloadPath); \t\t         // 다운로드 할 이미지의 전체 경로 계산         // 사용자 OS에 따라 연결자 구분         String imgPath = downloadPath + File.separator + imgName;         System.out.println(\"imgPath: \"+imgPath); \t\t         //.. 이하 생략     } }      썸네일을 불러오는 로직 또한 기존에 만들었던 이미지 로드 로직과 같기 때문에 기존 함수를 약간 수정했다.   파라미터로 받은 값에 따라 원본 이미지가 있는 폴더와 썸네일이 있는 폴더에 각각 접근해서 이미지를 불러온다.   하략한 코드는 JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 21 - 게시물에 첨부된 이미지와 파일 다른 경로에 저장하기 에서 확인할 수 있다.   main.jsp   &lt;section data-theme=\"_bgp\"&gt;   &lt;div data-layout=\"_r\" class=\"MOD_ARTICLEBLOCKS1\"&gt;     &lt;div data-layout=\"al16 ec8\" class=\"MOD_ARTICLEBLOCKS1_Cont\"&gt;     &lt;h2&gt;최신글&lt;/h2&gt;       &lt;a href=\"\" class=\"MOD_ARTICLEBLOCKS1_BlockLarge\" id=\"mainHref1\"&gt;         &lt;!-- 썸네일 보여주는 부분 --&gt;         &lt;img id=\"thumbnail1\" src=\"\" class=\"MOD_ARTICLEBLOCKS1_Img\" role=\"img\" aria-label=\"alt text\"&gt;         &lt;div class=\"MOD_ARTICLEBLOCKS1_Txt\"&gt;           &lt;h3 class=\"MOD_ARTICLEBLOCKS1_Title\" id=\"mainTitle1\"&gt;Article Title&lt;/h3&gt;           &lt;p class=\"MOD_ARTICLEBLOCKS1_Category\" id=\"mainContent1\"&gt;Category&lt;/p&gt;         &lt;/div&gt;       &lt;/a&gt;     &lt;/div&gt;     &lt;div data-layout=\"al16 ch8 ec4\" class=\"MOD_ARTICLEBLOCKS1_Cont\"&gt;       &lt;a href=\"\" class=\"MOD_ARTICLEBLOCKS1_BlockSmall\" id=\"mainHref2\"&gt;         &lt;!-- 썸네일 보여주는 부분 --&gt;         &lt;img id=\"thumbnail2\" src=\"\" class=\"MOD_ARTICLEBLOCKS1_Img\" role=\"img\" aria-label=\"alt text\"&gt;         &lt;div class=\"MOD_ARTICLEBLOCKS1_Txt\"&gt;           &lt;h3 class=\"MOD_ARTICLEBLOCKS1_Title\" id=\"mainTitle2\"&gt;Article Title&lt;/h3&gt;           &lt;p class=\"MOD_ARTICLEBLOCKS1_Category\" id=\"mainContent2\"&gt;Category&lt;/p&gt;         &lt;/div&gt;       &lt;/a&gt;     &lt;/div&gt;     &lt;div data-layout=\"al16 ch8 ec4\" class=\"MOD_ARTICLEBLOCKS1_Cont\"&gt;       &lt;a href=\"#\" class=\"MOD_ARTICLEBLOCKS1_BlockSmall\" id=\"mainHref3\"&gt;         &lt;!-- 썸네일 보여주는 부분 --&gt;         &lt;img id=\"thumbnail3\" src=\"\" class=\"MOD_ARTICLEBLOCKS1_Img\" role=\"img\" aria-label=\"alt text\"&gt;         &lt;div class=\"MOD_ARTICLEBLOCKS1_Txt\"&gt;           &lt;h3 class=\"MOD_ARTICLEBLOCKS1_Title\" id=\"mainTitle3\"&gt;Article Title&lt;/h3&gt;           &lt;p class=\"MOD_ARTICLEBLOCKS1_Category\" id=\"mainContent3\"&gt;Category&lt;/p&gt;         &lt;/div&gt;       &lt;/a&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      img 태그에 각각 thumbnail1, 2, 3 형식으로 id를 설정해 자바스크립트로 src를 세팅해 줄 것이다.   main.js   $(document).ready(function() {     getFeeds(); });  function getFeeds() {     $.ajax({         type: 'POST',         async: false,         url: './GetFeed.bo',         dataType: 'json',         data: {             'cnt': 3,             'len': 70         },         success: function(data) {             if (data != null)             {                 for (var i = 0; i &lt; data.length; i++)                 {                     var titleId = '#mainTitle';                     titleId += (i + 1);                     $(titleId).html(data[i].title);                      var contentId = '#mainContent';                     contentId += (i + 1);                     $(contentId).html(data[i].content);                      var hrefId = '#mainHref';                     hrefId += (i + 1);                     $(hrefId).attr('href', './BoardContent.bo?num='+data[i].num+'&amp;pageNum=1'); \t\t\t\t\t                     var thumbnailId = '#thumbnail';                     thumbnailId += (i + 1);                     if (data[i].image == '없음')                         $(thumbnailId).attr('src', '');                     else                          $(thumbnailId).attr('src', './BoardImgAction.bo?thumbnail='+data[i].image);                 }             }         }     }); }      GetFeed.java에서 가져온 데이터 중 이미지 정보가 있을 때에만 썸네일 이미지를 출력한다.   GetFeed.java   package com.project.cafe.board.action;  import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import org.json.simple.JSONArray; import org.json.simple.JSONObject;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class GetFeed implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"ajax 시작_GetFeed - execute() 호출\"); \t\t         BoardDAO dao = new BoardDAO();         ArrayList&lt;BoardDTO&gt; list = dao.getPosts             (Integer.parseInt(request.getParameter(\"cnt\")), Integer.parseInt(request.getParameter(\"len\"))); \t\t         // DB에서 가져온 데이터들을 json에 저장         JSONArray feedList = new JSONArray();         for (int i = 0; i &lt; list.size(); i++)         {             JSONObject feed = new JSONObject();             feed.put(\"num\", list.get(i).getNum());             feed.put(\"title\", list.get(i).getTitle());             feed.put(\"content\", list.get(i).getContent());             feed.put(\"image\", list.get(i).getImage()); \t\t\t             feedList.add(feed);         } \t\t         // 클라이언트에게 데이터 보내기         // 한글처리         response.setCharacterEncoding(\"UTF-8\");         // json 데이터 넘김         response.getWriter().print(feedList.toJSONString());         response.getWriter().close(); \t\t         return null;     } }      GetFeed.java에서는 json데이터를 넘긴다.           완성! 👏   첨부된 이미지가 있을 때에만 썸네일을 출력하고 없을 때엔 출력하지 않는다.     출처     [JAVA] 이미지 리사이즈, 썸네일 만들기 - Thumbnails.of      마감까지     마감 기한이 늘어났다.   D-5  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-22/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) TCP와 UDP",
        "excerpt":"👀 Transport Layer     응용 계층 바로 아래에 있는 계층   대표적인 서비스는 프로세스들 간의 논리적 연결   하나의 컴퓨터 안에서는 여러 프로세스가 동시에 기동되고 있다.   전송 계층 바로 아래에 있는 네트워크 계층에서는 IP를 이용해 상대 호스트를 찾아가는데 이것 만으로는 상대방의 어떤 프로세스에게 전달해야 하는지 알 수 없다.   그래서 전송 계층에서 여러 프로세스들 중에서 어떤 프로세스에게 전달해야 할 지 알려주는 정보를 제공하는 것이다.   전송 계층의 보내는 쪽에서는 보내고자 하는 메세지(파일 등)를 분할한 다음에 세그먼트에 담아서 전송한다.   그러면 받는 쪽에서 분할되어 온 세그먼트들을 합친 후에 응용 계층으로 전달한다.   이때 사용하는 프로토콜은 TCP와 UDP 두 가지가 대표적으로 사용된다.     TCP     신뢰성 있는 전송   보낸 순서대로 전송이 되는데 사실 데이터가 도착하는 순서는 제각각이다. 그걸 순서대로 도착한 것처럼 보이게 만들어서 응용 계층으로 보내는 것이 TCP가 하는 일이다.   데이터를 주고받기 전에 먼저 connection을 설정한 뒤 둘 사이에 흐르는 데이터들의 에러나 속도를 제어해서 전체적으로 안정적인 서비스를 제공한다.     UDP     신뢰성 없는 전송   TCP에서 제공하는 connection과 순서 보장 등을 제공하지 않고 전송 계층에서 제공해야 하는 가장 기본적인 서비스만 제공하고 나머지는 아래 계층에 넘기는 방식   그래서 TCP보다는 속도가 빠르다.      출처     컴퓨터 네트워킹 - 부산대학교 K-MOOC 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network","Transport"],
        "url": "/computer%20network/computer-network-tcp-udp/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 23 - 댓글 달기 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     게시글에 달린 댓글을 볼 수 있는 기능을 추가했다.   boardList.jsp   &lt;tbody&gt; &lt;%     if (null != postList) {         for (int i = 0; i &lt; postList.size(); i++)          {             BoardDTO dto = postList.get(i); %&gt;   &lt;tr&gt;     &lt;th scope=\"row\"&gt;&lt;%=dto.getNum() %&gt;&lt;/th&gt;     &lt;td&gt; &lt;%             int width = 0;             if (0 &lt; dto.getRe_lev()) // 답글일 때             {                 width = 10 * dto.getRe_lev(); %&gt;       &lt;img class=\"reImg\" src=\"./contents/level.gif\" width=\"&lt;%=width%&gt;\" height=\"15\"&gt;       &lt;img class=\"reImg\" src=\"./contents/re.gif\"&gt; &lt;%             } %&gt;       &lt;a href=\"./BoardContent.bo?num=&lt;%=dto.getNum()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\"&gt;&lt;%=dto.getTitle() %&gt; (&lt;%=dto.getComment_count() %&gt;)&lt;/a&gt;     &lt;/td&gt;     &lt;td&gt;&lt;%=dto.getId() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=dto.getDate() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=dto.getReadcount() %&gt;&lt;/td&gt;   &lt;/tr&gt; &lt;%}} %&gt; &lt;/tbody&gt;      게시글 목록에서 댓글이 달린 갯수를 확인할 수 있게 수정했다.   BoardDAO.java - getPostList(startRow, pageSize)   public ArrayList&lt;BoardDTO&gt; getPostList(int startRow, int pageSize) {     ArrayList&lt;BoardDTO&gt; postList = new ArrayList&lt;BoardDTO&gt;(); \t\t     try {         con = getCon(); \t\t\t         // 글 자르기 : limit 시작행-1, 갯수         // 시작행-1부터 x개 만큼 가져온다.         // 정렬 : re_ref(내림차순) / re_seq(오름차순)         sql = \"select * from cafe_board order by re_ref desc, re_seq asc limit ?,?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, startRow - 1); // 시작행 - 1         pstmt.setInt(2, pageSize); // 갯수 \t\t\t         rs = pstmt.executeQuery(); \t\t\t         while (rs.next())         {             // 글 1개의 정보(dto)에 저장한 후 배열에 저장             BoardDTO dto = new BoardDTO(); \t\t\t\t             dto.setContent(rs.getString(\"content\"));             dto.setDate(rs.getDate(\"date\"));             dto.setFile(rs.getString(\"file\"));             dto.setId(rs.getString(\"id\"));             dto.setIp(rs.getString(\"ip\"));             dto.setNum(rs.getInt(\"num\"));             dto.setRe_lev(rs.getInt(\"re_lev\"));             dto.setRe_ref(rs.getInt(\"re_ref\"));             dto.setRe_seq(rs.getInt(\"re_seq\"));             dto.setReadcount(rs.getInt(\"readcount\"));             dto.setTitle(rs.getString(\"title\"));             dto.setComment_count(rs.getInt(\"comment_count\")); \t\t\t\t             postList.add(dto);         } \t\t\t         System.out.println(\"DAO : 글 정보 저장 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return postList; }      게시글 목록을 불러올 때 댓글의 갯수도 함께 저장하도록 수정했다.   물론 테이블에도 댓글 갯수 컬럼을 추가했다.      boardContent.jsp   &lt;%     String id = (String)session.getAttribute(\"id\"); \t     boolean isLogin = false;     if (null == id) isLogin = false;     else isLogin = true; \t     BoardDTO dto = (BoardDTO)request.getAttribute(\"dto\");     String pageNum = (String)request.getAttribute(\"pageNum\");     ArrayList&lt;CommentDTO&gt; coList = (ArrayList&lt;CommentDTO&gt;)request.getAttribute(\"coList\"); %&gt;  &lt;!-- 게시글 본문 영역 --&gt;  &lt;!-- 댓글 영역 --&gt;   &lt;div class=\"comments\"&gt;   &lt;h3&gt;댓글&lt;/h3&gt;   &lt;input type=\"hidden\" id=\"postNum\" value=\"&lt;%=dto.getNum()%&gt;\"&gt;   &lt;p&gt;     &lt;%if (!coList.isEmpty()) {         for (int i = 0; i &lt; coList.size(); i++) {              CommentDTO coDto = coList.get(i); %&gt;     &lt;span class=\"comId\"&gt;       &lt;%=coDto.getId() %&gt;&amp;nbsp;\t\t     &lt;/span&gt;     &lt;span class=\"comDate\"&gt;       &lt;%=coDto.getCommentedDate() %&gt;&amp;nbsp;     &lt;/span&gt;     &lt;span&gt;       &lt;a href=\"#\"&gt;수정&amp;nbsp;&lt;/a&gt;     &lt;/span&gt;     &lt;span&gt;       &lt;a href=\"#\"&gt;삭제&amp;nbsp;&lt;/a&gt;     &lt;/span&gt;   &lt;/p&gt;   &lt;p class=\"comContent\"&gt;     &lt;%=coDto.getContent() %&gt;   &lt;/p&gt;&lt;br&gt;   &lt;% }} %&gt; &lt;/div&gt; &lt;!-- 댓글 영역 --&gt;  &lt;!-- 하단 버튼 영역 --&gt;      게시글 본문 페이지에 작성된 댓글들을 볼 수 있는 공간을 추가했다.   게시글 본문을 불러오는 서블릿에서 댓글 목록도 함께 불러와서 출력한다.   BoardContentAction.java   package com.project.cafe.board.action;  import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO; import com.project.cafe.board.db.CommentDTO;  public class BoardContentAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardContentAction - execute() 호출\"); \t\t         // 전달받은 파라메터(글 번호, 페이지정보) 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         String pageNum = request.getParameter(\"pageNum\"); // 페이지번호는 DB 처리할 때 사용하진 않아서 형변환 필요 X \t\t         // DAO 객체 생성         BoardDAO dao = new BoardDAO();          // 글 조회수 1 증가         dao.updateReadCount(num); \t\t         // 글 정보 불러오기         BoardDTO dto = dao.getPost(num);                  // 해당 글에 달린 댓글 정보 불러오기         ArrayList&lt;CommentDTO&gt; coList = dao.getComments(num); \t\t         // request 영역에 글 정보랑 페이지정보, 댓글목록 저장         request.setAttribute(\"dto\", dto);         request.setAttribute(\"pageNum\", pageNum);         request.setAttribute(\"coList\", coList); \t\t         // 페이지 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./contents/boardContent.jsp\");         forward.setRedirect(false); \t\t         return forward;     } }      게시글 내용을 불러올 때 해당 글에 달린 댓글 정보도 함께 불러온다.   BoardDAO.java - getComments(num)   public ArrayList&lt;CommentDTO&gt; getComments(int num) {     ArrayList&lt;CommentDTO&gt; list = new ArrayList&lt;CommentDTO&gt;(); \t\t     try {         con = getCon(); \t\t\t         sql = \"select * from cafe_comment where post_num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, num); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         while (rs.next())         {             CommentDTO dto = new CommentDTO(); \t\t\t\t             dto.setCommentedDate(rs.getDate(\"commented_date\"));             dto.setContent(rs.getString(\"content\"));             dto.setId(rs.getString(\"id\"));             dto.setIp(rs.getString(\"ip\"));             dto.setNum(rs.getInt(\"num\"));             dto.setPost_num(rs.getInt(\"post_num\"));             dto.setRe_lev(rs.getInt(\"re_lev\"));             dto.setRe_ref(rs.getInt(\"re_ref\"));             dto.setRe_seq(rs.getInt(\"re_seq\")); \t\t\t\t             list.add(dto);         } \t\t\t         System.out.println(\"DAO : 댓글 목록 저장 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return list; }      게시글 번호를 매개변수로 받아서 해당 글에 달린 댓글들만 불러온다.           작성된 댓글이 없을 때엔 불러오지 않는다.     진행상황 2     게시글에 댓글을 다는 기능을 추가했다.   boardContent.jsp   &lt;!-- 게시글 본문 영역 --&gt;  &lt;!-- 댓글 영역 --&gt;   &lt;form action=\"./CommentWriteAction.bo?post_num=&lt;%=dto.getNum() %&gt;&amp;pageNum=&lt;%=pageNum %&gt;\" method=\"post\" onsubmit=\"return writeComment();\"&gt;   &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;   &lt;input type=\"text\" id=\"comment\" name=\"comment\" placeholder=\"댓글 달기\". maxlength=\"500\"&gt;   &lt;button type=\"submit\" class=\"btn\" id=\"commentBtn\"&gt;입력&lt;/button&gt; &lt;/form&gt;&lt;br&gt;&lt;br&gt; &lt;div class=\"comments\"&gt;   &lt;h3&gt;댓글&lt;/h3&gt;   &lt;input type=\"hidden\" id=\"postNum\" value=\"&lt;%=dto.getNum()%&gt;\"&gt;   &lt;p&gt;     &lt;%if (!coList.isEmpty()) {         for (int i = 0; i &lt; coList.size(); i++) {              CommentDTO coDto = coList.get(i); %&gt;     &lt;span class=\"comId\"&gt;       &lt;%=coDto.getId() %&gt;&amp;nbsp;\t\t     &lt;/span&gt;     &lt;span class=\"comDate\"&gt;       &lt;%=coDto.getCommentedDate() %&gt;&amp;nbsp;     &lt;/span&gt;     &lt;span&gt;       &lt;a href=\"#\"&gt;수정&amp;nbsp;&lt;/a&gt;     &lt;/span&gt;     &lt;span&gt;       &lt;a href=\"#\"&gt;삭제&amp;nbsp;&lt;/a&gt;     &lt;/span&gt;   &lt;/p&gt;   &lt;p class=\"comContent\"&gt;     &lt;%=coDto.getContent() %&gt;   &lt;/p&gt;&lt;br&gt;   &lt;% }} %&gt; &lt;/div&gt; &lt;!-- 댓글 영역 --&gt;  &lt;!-- 하단 버튼 영역 --&gt;      작성한 댓글을 전송할 폼태그를 추가했다.   boardContent.js   function writeComment() {     if ($('#comment').val().length &lt;= 0)     {         alert('내용을 입력하세요.');         return false;     }     else         return true; }      댓글 작성 서블릿으로 이동하기 전에 댓글이 작성된 것을 확인한 후 서블릿으로 이동한다.   CommentWriteAction.java   package com.project.cafe.board.action;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.CommentDTO;  public class CommentWriteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : CommentWriteAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"utf-8\"); \t\t         // 파라메터 저장         String id = request.getParameter(\"id\");         String comment = request.getParameter(\"comment\");         int postNum = Integer.parseInt(request.getParameter(\"post_num\"));         String pageNum = request.getParameter(\"pageNum\"); \t\t         CommentDTO dto = new CommentDTO();         dto.setContent(comment);         dto.setId(id);         dto.setIp(request.getRemoteAddr());         dto.setPost_num(postNum); \t\t         // DB 연결해서 댓글 저장         BoardDAO dao = new BoardDAO();         dao.insertComment(dto); \t\t         // 페이지 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./BoardContent.bo?num=\"+postNum+\"&amp;pageNum=\"+pageNum);         forward.setRedirect(true); \t\t         return forward;     } }      컨트롤러를 통해 댓글 작성 동작을 수행하는 서블릿으로 이동한다.   게시글을 작성할 때와 마찬가지로 폼태그로 받아온 파라메터들을 저장한 후 DB에 접속해서 insert 동작을 수행한다.   게시글 본문 페이지에서 게시글 번호와 페이지 번호 정보를 필요로 하기 때문에 get방식으로 함께 넘겨준다.   BoardDAO.java - insertComment(dto)   public void insertComment(CommentDTO dto) {     int lastNum = 0;      try {         con = getCon();                  // 게시글의 댓글 갯수 증가         sql = \"update cafe_board set comment_count = comment_count + 1 where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.executeUpdate(); \t\t\t         System.out.println(\"DAO : 댓글 갯수 증가 완료\"); \t\t\t         // 새 글 번호 찾기         sql = \"select max(num) from cafe_comment\";         pstmt = con.prepareStatement(sql); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())             lastNum = rs.getInt(1) + 1; \t\t\t         // 댓글 삽입         sql = \"insert into cafe_comment(num, post_num, id, content, commented_date, re_ref, re_lev, re_seq, ip)\"                 + \" values(?,?,?,?,now(),?,?,?,?)\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, lastNum);         pstmt.setInt(2, dto.getPost_num());         pstmt.setString(3, dto.getId());         pstmt.setString(4, dto.getContent());         pstmt.setInt(5, lastNum);         pstmt.setInt(6, 0);         pstmt.setInt(7, 0);         pstmt.setString(8, dto.getIp()); \t\t\t         pstmt.executeUpdate(); \t\t\t         System.out.println(\"DAO : 댓글 삽입 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } }      게시글 삽입 때와 마찬가지로 삽입 연산을 수행한다.   댓글이 달릴 게시글의 댓글 갯수를 증가시킨다.           댓글 삽입 연산이 완료된 후 다시 게시글 본문 페이지로 이동하면 새로 작성된 댓글을 확인할 수 있다.      마감까지     마감 기한이 늘어났다.   D-5  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-23/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 24 - 댓글 수정 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     게시글에 달린 댓글을 수정하는 기능을 추가했다.   boardContent.jsp   &lt;!-- 본인 글 일때만 수정/삭제 가능 --&gt; &lt;span&gt; &lt;%if (id != null &amp;&amp; id.equals(coList.get(i).getId())) { %&gt;   &lt;a href=\"javascript:void(0);\" onclick=\"showCommentBox(&lt;%=i %&gt;);\" id=\"modify\"&gt;수정&amp;nbsp;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;   &lt;a href=\"#\"&gt;삭제&amp;nbsp;&lt;/a&gt; &lt;/span&gt; &lt;% } %&gt;      로그인 정보를 확인 후 본인 글 일때만 수정과 삭제를 할 수 있는 버튼이 보인다.   boardContent.js   function showCommentBox(idx) {     var con = document.getElementById('modify' + idx);     var comBlock = document.getElementById('modifyComment' + idx);     if (comBlock.style.display == 'none')     {         comBlock.style.display = 'inline-block';         con.innerHTML = '취소';     }     else      {         comBlock.style.display = 'none';         con.innerHTML = '수정';     } }      수정 버튼을 누르면 댓글을 수정할 수 있는 창을 보여주거나 숨김 수 있게 제어한다.   boardContent.jsp   &lt;p class=\"comContent\" id=\"comContent&lt;%=i%&gt;\"&gt;   &lt;%=coList.get(i).getContent() %&gt; &lt;/p&gt; &lt;div style=\"display: none;\" id=\"modifyComment&lt;%=i%&gt;\"&gt;   &lt;form action=\"./CommentModifyAction.bo?num=&lt;%=coList.get(i).getNum()%&gt;&amp;post_num=&lt;%=coList.get(i).getPost_num()%&gt;&amp;pageNum=&lt;%=pageNum%&gt;\" method=\"post\" onsubmit=\"return writeComment();\"&gt;     &lt;input type=\"hidden\" name=\"id\" value=\"&lt;%=id%&gt;\"&gt;     &lt;textarea id=\"comment\" name=\"comment\" rows=\"10\" cols=\"80\" maxlength=\"500\"&gt;&lt;%=coList.get(i).getContent() %&gt;&lt;/textarea&gt;     &lt;button type=\"submit\" class=\"btn\" id=\"commentBtn\"&gt;입력&lt;/button&gt;   &lt;/form&gt;&lt;br&gt; &lt;/div&gt;&lt;br&gt;      수정 버튼을 누르면 댓글 수정창이 나타나고 한 번 더 누르면 댓글 수정창이 사라진다.   댓글 수정 내용과 함께 댓글 번호와 게시글 정보도 함께 전달한다.   CommentModifyAction.java   package com.project.cafe.board.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.CommentDTO;  public class CommentModifyAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : CommentModifyAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"utf-8\"); \t\t         // 파라메터 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         int post_num = Integer.parseInt(request.getParameter(\"post_num\"));         String pageNum = request.getParameter(\"pageNum\");         String comment = request.getParameter(\"comment\"); \t\t         CommentDTO dto = new CommentDTO();         dto.setNum(num);         dto.setPost_num(post_num);         dto.setContent(comment); \t\t         System.out.println(\"M : commentDTO: \"+dto); \t\t         // DB 접속 및 update 실행         BoardDAO dao = new BoardDAO();         int result = dao.updateComment(dto); \t\t         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter();         if (1 != result)         {             out.print(\"&lt;script&gt;\");             out.print(\"alert('잘못된 접근');\");             out.print(\"history.back();\");             out.print(\"&lt;/script&gt;\");         } \t\t         out.print(\"&lt;script&gt;\");         out.print(\"location.href='./BoardContent.bo?num=\"+post_num+\"&amp;pageNum=\"+pageNum+\";'\");         out.print(\"&lt;/script&gt;\"); \t\t         return null;     } }      DB에 접속해서 댓글 수정 동작을 수행한 뒤 결과에 따라 페이지를 이동한다.   로그인 한 본인만 수정할 수 있기 때문에 접근한 사람이 본인이 아닌 경우는 없을 것이라 생각하지만 혹시 모르니까  예외처리를 해 주었다.   BoardDAO.java - updateComment(dto)   public int updateComment(CommentDTO dto) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         sql = \"select * from cafe_comment where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, dto.getNum()); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             // 댓글이 존재하면 수정             sql = \"update cafe_comment set content=? where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setString(1, dto.getContent());             pstmt.setInt(2, dto.getNum()); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 댓글 수정 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }      댓글이 존재하는지 확인한 후 수정한다.   모든 동작이 완료된 후 다시 게시글 본문 페이지로 이동하면 수정된 댓글을 확인할 수 있다.      마감까지     마감 기한이 늘어났다.   D-3  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-24/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 25 - 댓글 삭제 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     게시글에 달린 댓글을 삭제하는 기능을 추가했다.   boardContent.jsp   &lt;!-- 본인 글 일때만 수정/삭제 가능 --&gt; &lt;span&gt; &lt;%if (id != null &amp;&amp; id.equals(coList.get(i).getId())) { %&gt;   &lt;a href=\"javascript:void(0);\" onclick=\"showCommentBox(&lt;%=i %&gt;);\" id=\"modify\"&gt;수정&amp;nbsp;&lt;/a&gt; &lt;/span&gt; &lt;span&gt;   &lt;a href=\"javascript:void(0);\" onclick=\"confirmDelete(&lt;%=coList.get(i).getNum()%&gt;, &lt;%=coList.get(i).getPost_num()%&gt;, &lt;%=pageNum%&gt;);\"&gt;삭제&amp;nbsp;&lt;/a&gt; &lt;/span&gt; &lt;% } %&gt;      로그인 정보를 확인 후 본인 글 일때만 수정과 삭제를 할 수 있는 버튼이 보인다.   boardContent.js   function confirmDelete(num, postNum, pageNum) {     if (confirm('정말 삭제 하시겠습니까?'))         location.href = './CommentDeleteAction.bo?num='+num+'&amp;post_num='+postNum+'&amp;pageNum='+pageNum; }      삭제 버튼을 누르면 확인창을 띄워서 최종 확인한 뒤 삭제 서블릿으로 이동한다.   CommentDeleteAction.java   package com.project.cafe.board.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO;  public class CommentDeleteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : CommentDeleteAction - execute() 호출\"); \t\t         // 파라메터 저장         int num = Integer.parseInt(request.getParameter(\"num\"));         int post_num = Integer.parseInt(request.getParameter(\"post_num\"));         String pageNum = request.getParameter(\"pageNum\"); \t\t         // DB 접속해서 삭제 연산 수행         BoardDAO dao = new BoardDAO();         int result = dao.deleteComment(num); \t\t         // 페이지 이동         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter();         if (1 != result)         {             out.print(\"&lt;script&gt;\");             out.print(\"alert('잘못된 접근');\");             out.print(\"history.back();\");             out.print(\"&lt;/script&gt;\");         } \t\t         out.print(\"&lt;script&gt;\");         out.print(\"alert('댓글 삭제 완료!');\");         out.print(\"location.href='./BoardContent.bo?num=\"+post_num+\"&amp;pageNum=\"+pageNum+\"';\");         out.print(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      DB에 접속해서 댓글 삭제 동작을 수행한 뒤 결과에 따라 페이지를 이동한다.   로그인 한 본인만 삭제할 수 있기 때문에 접근한 사람이 본인이 아닌 경우는 없을 것이라 생각하지만 혹시 모르니까  예외처리를 해 주었다.   BoardDAO.java - deleteComment(num)   public int deleteComment(int num) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         sql = \"select * from cafe_comment where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, num); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             // 게시글의 댓글 갯수 감소             sql = \"update cafe_board set comment_count = comment_count - 1 where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setInt(1, rs.getInt(\"post_num\"));                          pstmt.executeUpdate(); \t\t\t\t             // 댓글 삭제             sql = \"delete from cafe_comment where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setInt(1, num); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 댓글 삭제 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }      댓글이 존재하는지 확인한 후 삭제한다.   댓글이 달렸던 게시글에서도 갯수를 감소시킨다.   모든 동작이 완료된 후 다시 게시글 본문 페이지로 이동하면 댓글이 삭제된 것과 댓글의 갯수도 줄어든 것을 확인할 수 있다.      마감까지     마감 기한이 늘어났다.   D-3  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-25/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 26 - 관리자 페이지 + 회원 관리 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     관리자 페이지를 추가했다.   관리자 아이디인 admin으로 로그인 했을 때에만 접근할 수 있다.   top.jsp   &lt;p class=\"MOD_HEADER1_Phone\"&gt; &lt;%     String id = (String)session.getAttribute(\"id\"); \t\t     if (null == id)     {         %&gt;           &lt;a href=\"./login.me\"&gt;로그인&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;           &lt;a href=\"./join.me\"&gt;회원가입&lt;/a&gt;         &lt;%     }     else      {         %&gt;           &lt;a href=\"./logout.me\"&gt;로그아웃&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;         &lt;%         if (id.equals(\"admin\"))         {             %&gt;               &lt;a href=\"./admin.me\"&gt;관리자 페이지&lt;/a&gt;             &lt;%         }         else         {             %&gt;               &lt;a href=\"./checkPass.me\"&gt;마이페이지&lt;/a&gt;             &lt;%         }     } %&gt; &lt;/p&gt;      세션에 저장된 아이디 정보가 admin일 때만 관리자 페이지 버튼이 활성화된다.   admin.jsp   &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/adminLeftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h3&gt;관리자 페이지&lt;/h3&gt;&lt;br&gt;       &lt;%       \tString id = (String) session.getAttribute(\"id\");       \tif (null == id)             response.sendRedirect(\"./login.me\");       \telse        \t{             if (!id.equals(\"admin\"))             {                 // 관리자 계정이 아니면 쫓아내기                 session.invalidate();                 response.sendRedirect(\"./login.me\");             }       \t}       %&gt;       &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;관리자님 환영합니다. &lt;/label&gt;         &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      관리자로 로그인하면 관리자 전용 페이지에 접근할 수 있으며 만약 관리자가 아닌 사용자가 접근하면 세션 정보를 초기화하고 쫓아낸다.   adminLeftNav.jsp   &lt;div data-layout=\"al16 al-o2 de-o1 de6 ec4\"&gt;   &lt;nav class=\"MOD_SUBNAVIGATION1_Menu\" data-theme=\"_bo2\"&gt;     &lt;p class=\"MOD_SUBNAVIGATION1_Menutitle\" data-theme=\"_bgs\"&gt;Menu&lt;/p&gt;     &lt;ul&gt;       &lt;li&gt;&lt;a href=\"./MemberListAction.me\"&gt;회원관리&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a href=\"#\"&gt;게시글 관리&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/nav&gt; &lt;/div&gt;      관리자 메뉴용 사이드 메뉴도 따로 만들었다.           회원관리 메뉴를 누르면 먼저 회원 전체 정보를 불러오기 위해서 해당 동작을 수행할 서블릿으로 이동한다.   MemberListAction.java   package com.project.cafe.member.action;  import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class MemberListAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : MemberListAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"utf-8\"); \t\t         // DB에서 전체 회원 목록 불러오기         MemberDAO dao = new MemberDAO();         ArrayList&lt;MemberDTO&gt; memberList = dao.getMemberList(); \t\t         // request에 저장         request.setAttribute(\"memberList\", memberList); \t\t         // 페이지 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./admin/memberManagement.jsp\");         forward.setRedirect(false); \t\t         return forward;     } }      회원 전체 목록을 세션에 저장한 후 회원관리 페이지로 이동한다.   MemberDAO.java - getMemberList()   public ArrayList&lt;MemberDTO&gt; getMemberList() {     ArrayList&lt;MemberDTO&gt; memberList = new ArrayList&lt;MemberDTO&gt;(); \t\t     try {         con = getCon(); \t\t\t         sql = \"select * from cafe_members where id != 'admin'\";         pstmt = con.prepareStatement(sql); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         while (rs.next())         {             MemberDTO dto = new MemberDTO(); \t\t\t\t             dto.setAddress(rs.getString(\"address\"));             dto.setAge(rs.getInt(\"age\"));             dto.setBirth(rs.getDate(\"birth\"));             dto.setEmail(rs.getString(\"email\"));             dto.setGender(rs.getString(\"gender\"));             dto.setId(rs.getString(\"id\"));             dto.setMemberNum(rs.getInt(\"member_num\"));             dto.setName(rs.getString(\"name\"));             dto.setPhone(rs.getString(\"phone\"));             dto.setPostalcode(rs.getInt(\"postalcode\"));             dto.setRegdate(rs.getTimestamp(\"regdate\")); \t\t\t\t             memberList.add(dto);         } \t\t\t         System.out.println(\"DAO : 회원 전체 목록 저장 완료\");     }     catch (Exception e) {         e.printStackTrace();     }     finally {         CloseDB();     } \t\t     return memberList; }      전체 회원 정보를 불러온다.   하지만 관리자 정보는 보여줄 필요가 없기 때문에 제외하고 불러온다.   memberManagement.jsp   &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/adminLeftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h3&gt;회원관리 페이지&lt;/h3&gt;&lt;br&gt;       &lt;%       \tString id = (String) session.getAttribute(\"id\");       \tif (null == id)             response.sendRedirect(\"./login.me\");       \telse        \t{             if (!id.equals(\"admin\"))             {                 // 관리자 계정이 아니면 쫓아내기                 session.invalidate();                 response.sendRedirect(\"./login.me\");             }       \t}       \t       \tArrayList&lt;MemberDTO&gt; memberList = (ArrayList&lt;MemberDTO&gt;)request.getAttribute(\"memberList\");       %&gt;       &lt;form action=\"./AdminDeleteAction.me\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;         &lt;table class=\"type09\"&gt;           &lt;tbody&gt;             &lt;colgroup&gt;               &lt;col width=\"5%\"&gt;               &lt;col width=\"10%\"&gt;               &lt;col width=\"10%\"&gt;               &lt;col width=\"35%\"&gt;               &lt;col width=\"\"&gt;             &lt;/colgroup&gt;             &lt;tr&gt;               &lt;th&gt;&lt;input type=\"checkbox\" id=\"selectAll\"&gt;&lt;/th&gt;               &lt;th&gt;아이디&lt;/th&gt;               &lt;th&gt;이름&lt;/th&gt;               &lt;th&gt;이메일&lt;/th&gt;               &lt;th&gt;가입일&lt;/th&gt;             &lt;/tr&gt;             &lt;%if (!memberList.isEmpty())               {                 for (int i = 0; i &lt; memberList.size(); i++)                   { %&gt;             &lt;tr&gt;               &lt;td&gt;&lt;input type=\"checkbox\" name=\"member\" value=\"&lt;%=memberList.get(i).getId() %&gt;\"&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=memberList.get(i).getId() %&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=memberList.get(i).getName() %&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=memberList.get(i).getEmail() %&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=memberList.get(i).getRegdate() %&gt;&lt;/td&gt;             &lt;/tr&gt;             &lt;% }} %&gt;           &lt;/tbody&gt;         &lt;/table&gt;&lt;br&gt;         &lt;button type=\"submit\" class=\"btn\"&gt;회원 삭제&lt;/button&gt;       &lt;/form&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      아까 세션에 저장했던 회원목록을 토대로 회원들을 출력해서 보여준다.         회원 삭제 동작을 테스트 한다고 좀 삭제했더니 회원이 많이 줄었다. 😅   memberManagement.js   $(document).ready(function() {     selectAll(); });  function selectAll() {     // 전체 선택 / 해제     $('#selectAll').change(function()     {\t\t         if ($('#selectAll').is(':checked'))             $('input:checkbox[name=member]').prop('checked', true);         else              $('input:checkbox[name=member]').prop('checked', false);     }); }  function finalCheck() {     if ($('input:checkbox[name=member]:checked').length &lt;= 0)     {         // 선택된 엘리먼트가 없으면 삭제할 회원이 없음         alert('선택된 회원이 없습니다!');         return false;     }     else      {         // 선택된 회원이 있을 때         if (confirm('선택한 회원들을 탈퇴 시키겠습니까?'))             return true;         else              return false;     } }      테이블의 맨 위에 있는 체크박스를 누르면 전체 선택과 헤재가 가능하다.   삭제 버튼을 눌렀을 때엔 finalCheck() 메서드를 통해 동작 분기를 나누었다.     진행상황 2     관리자가 회원을 일괄 삭제할 수 있는 기능을 추가했다.   AdminDeleteAction.java   package com.project.cafe.member.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.member.db.MemberDAO;  public class AdminDeleteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : AdminDeleteAction - execute() 호출\"); \t\t         // 파라미터 저장         String[] members = request.getParameterValues(\"member\");         System.out.println(\"members size: \"+members.length); \t\t         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter(); \t\t         // DB 접속해서 삭제 연산         MemberDAO dao = new MemberDAO();         for (String id : members)          {             System.out.println(\"id: \"+id);             int result = dao.deleteMember(id);             if (result != 1)             {                 out.print(\"&lt;script&gt;\");                 out.print(\"alert('잘못된 접근!');\");                 out.print(\"history.back();\");                 out.print(\"&lt;/script&gt;\"); \t\t\t\t                 out.close(); \t\t\t\t                 return null;             }         } \t\t         // 페이지 이동         out.print(\"&lt;script&gt;\");         out.print(\"alert('선택한 회원 탈퇴가 완료 되었습니다.');\");         out.print(\"location.href='./MemberListAction.me';\");         out.print(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      체크박스로 선택한 회원들의 아이디를 받아서 그 갯수만큼 삭제 연산을 반복한다.   기존에 만들었던 회원 한 명을 삭제하는 메소드가 있긴 했는데 회원의 아이디와 비밀번호를 함께 확인한 후 삭제 동작을 수행하는 메서드라 목적에 좀 맞지 않아서 오버로딩해서 하나 더 만들었다.   MemberDAO.java - deleteMember(id)   public int deleteMember(String id) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         sql = \"select * from cafe_members where id=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setString(1, id); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             sql = \"delete from cafe_members where id=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setString(1, id); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 운영자가 회원정보 삭제 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         CloseDB();     } \t\t     return ret; }      아이디를 매개변수로 받아 일치하는 회원 한 명의 정보를 삭제한다.   여기까지 수행하고 아까전에 있던 회원관리 페이지로 돌아가면 업데이트 된 회원 목록을 볼 수 있다.      마감까지     마감 기한이 늘어났다.   D-3  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-26/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 27 - 관리자 페이지에서 회원 상세정보 보기 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     관리자 페이지에서 회원 한 명의 상세 정보를 확인하고 거기에서 삭제할 수 있는 기능을 추가했다.   memberManagement.jsp   &lt;%if (!memberList.isEmpty())   {     for (int i = 0; i &lt; memberList.size(); i++)     { %&gt;   &lt;tr&gt;     &lt;td&gt;&lt;input type=\"checkbox\" name=\"member\" value=\"&lt;%=memberList.get(i).getId() %&gt;\"&gt;&lt;/td&gt;     &lt;td&gt;&lt;a href=\"./MemberInfoAction.me?id=&lt;%=memberList.get(i).getId()%&gt;\"&gt;&lt;%=memberList.get(i).getId() %&gt;&lt;/a&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=memberList.get(i).getName() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=memberList.get(i).getEmail() %&gt;&lt;/td&gt;     &lt;td&gt;&lt;%=memberList.get(i).getRegdate() %&gt;&lt;/td&gt;   &lt;/tr&gt; &lt;% }} %&gt;      회원 목록을 보는 페이지에서 아이디를 클릭하면 해당 회원의 정보를 가져오는 서블릿으로 이동한다.   MemberInfoAction.java   package com.project.cafe.member.action;  import java.io.PrintWriter;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.member.db.MemberDAO; import com.project.cafe.member.db.MemberDTO;  public class MemberInfoAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : MemberInfoAction - execute() 호출\"); \t\t         // 파라메터 저장         String memberId = request.getParameter(\"id\"); \t\t         // DB 접속해서 회원 정보 가져오기         MemberDAO dao = new MemberDAO();         MemberDTO dto = dao.getMember(memberId); \t\t         // 회원정보 저장         request.setAttribute(\"dto\", dto);          // 회원 상세 정보 페이지로 이동         ActionForward forward = new ActionForward();         forward.setPath(\"./admin/memberInfo.jsp\");         forward.setRedirect(false); \t\t         return forward;     } }      회원 한 명의 정보를 가져온 뒤 request 영역에 저장한다.   그 다음 회원 상세 정보 페이지로 이동한다.   memberInfo.jsp   &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/leftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h3&gt;회원 상세 정보&lt;/h3&gt;&lt;br&gt;       &lt;%       \tString id = (String) session.getAttribute(\"id\");       \tif (null == id)       \t\tresponse.sendRedirect(\"./login.me\");       \t       \tMemberDTO dto = (MemberDTO)request.getAttribute(\"dto\");       \t       \tString[] regdate = dto.getRegdate().toString().split(\" \");       %&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;회원번호 &lt;/label&gt;&lt;input type=\"text\" name=\"memberNum\" id=\"memberNum\" value=\"&lt;%=dto.getMemberNum() %&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;아이디 &lt;/label&gt;&lt;input type=\"text\" name=\"id\" id=\"id\" value=\"&lt;%=dto.getId() %&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;이름 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"name\" class=\"name\" value=\"&lt;%=dto.getName()%&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;생년월일 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"date\" name=\"birth\" class=\"birth\" value=\"&lt;%=dto.getBirth()%&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;나이 &lt;/label&gt;&lt;input id=\"MOD_TEXTFORM_NameField\" type=\"text\" name=\"age\" class=\"age\" value=\"&lt;%=dto.getAge()%&gt;\" disabled&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;성별 &lt;/label&gt;&lt;input class=\"radio\" type=\"radio\" name=\"gender\" id=\"gender\" value=\"남\"           &lt;%if (dto.getGender().equals(\"남\")) { %&gt;            checked           &lt;%} %&gt; readonly&gt;&lt;label class=\"radioText\"&gt;남&lt;/label&gt;            &lt;input class=\"radio\" id=\"gender\" type=\"radio\" name=\"gender\" value=\"여\"           &lt;%if (dto.getGender().equals(\"여\")) { %&gt;           checked           &lt;%} %&gt; readonly&gt;&lt;label class=\"radioText\"&gt;여&lt;/label&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;우편번호 &lt;/label&gt;           &lt;label class=\"phone\"&gt;             &lt;input type=\"text\" name=\"postalcode\" id=\"postalcode\" value=\"&lt;%=dto.getPostalcode() %&gt;\" readonly&gt;           &lt;/label&gt;         &lt;/div&gt;         &lt;span id=\"guide\" style=\"color:#999;display:none\"&gt;&lt;/span&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;도로명 주소 &lt;/label&gt;           &lt;input type=\"text\" id=\"roadAddress\" name=\"roadAddress\" value=\"&lt;%=dto.getRoad_address() %&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;상세 주소 &lt;/label&gt; \t\t  &lt;input type=\"text\" id=\"detailAddress\" name=\"detailAddress\" value=\"&lt;%=dto.getDetail_address()%&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div class=\"formRow\" id=\"phoneArea\"&gt;           &lt;label for=\"MOD_TEXTFORM_TelField\"&gt;휴대폰 번호 &lt;/label&gt;           &lt;label class=\"phone\"&gt;           &lt;input id=\"phone1\" type=\"tel\" name=\"phone1\" size=\"1\" maxlength=\"3\" value=\"&lt;%=dto.getPhone().substring(0, 3) %&gt;\" oninput=\"tabCursor(1)\" readonly&gt; -            &lt;input id=\"phone2\" type=\"tel\" name=\"phone2\" size=\"3\" maxlength=\"4\" value=\"&lt;%=dto.getPhone().substring(3, 7) %&gt;\" oninput=\"tabCursor(2)\" readonly&gt; -            &lt;input id=\"phone3\" type=\"tel\" name=\"phone3\" size=\"3\" maxlength=\"4\" value=\"&lt;%=dto.getPhone().substring(7, 11) %&gt;\" readonly&gt;           &lt;/label&gt;         &lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_EmailField\"&gt;이메일 &lt;/label&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" value=\"&lt;%=dto.getEmail()%&gt;\" readonly&gt;         &lt;/div&gt;         &lt;div id=\"emailMsg\"&gt;&lt;/div&gt;         &lt;div class=\"formRow\"&gt;           &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;가입일 &lt;/label&gt;&lt;input type=\"text\" name=\"regdate\" id=\"regdate\" value=\"&lt;%=regdate[0] %&gt;\" readonly&gt;         &lt;/div&gt;       &lt;form action=\"./AdminDeleteAction.me\" method=\"post\"&gt;         &lt;input type=\"hidden\" name=\"member\" value=\"&lt;%=dto.getId()%&gt;\"&gt;         &lt;button type=\"submit\" class=\"btn\"&gt;회원삭제&lt;/button&gt;       &lt;/form&gt;&lt;br&gt;       &lt;button class=\"btn\" onclick=\"history.back();\"&gt;회원 목록 보기&lt;/button&gt;       &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      회원 상세 정보 페이지는 마이페이지와 동일한 레이아웃이되, 각 정보를 관리자가 수정할 필요는 없기 때문에 모두 readonly를 걸었다.   하단에 있는 회원삭제 버튼을 누르면 해당 회원을 삭제할 수 있다. 삭제 로직은 이전 일지에서 만들었던 것과 동일하다.   참고 : JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 26 - 관리자 페이지 + 회원 관리 기능 추가   회원 목록 보기 버튼을 누르면 이전 페이지로 되돌아 간다.      마감까지     마감 기한이 늘어났다.   D-2  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-27/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 28 - 관리자 페이지에서 게시글 관리 기능 추가",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황 1     관리자 페이지에서 전체 게시글 목록을 확인하고 여러 개를 선택해서 삭제할 수 있는 기능을 추가했다.   boardManagement.jsp   &lt;section class=\"MOD_SUBNAVIGATION1\"&gt;   &lt;div data-layout=\"_r\"&gt;     &lt;jsp:include page=\"../inc/adminLeftNav.jsp\"&gt;&lt;/jsp:include&gt;     &lt;div data-layout=\"al-o1 de-o2 de10\" class=\"MOD_SUBNAVIGATION1_Page\"&gt;       &lt;h3&gt;게시글 관리 페이지&lt;/h3&gt;       &lt;p style=\"font-size: medium;\"&gt;글 제목을 클릭하면 내용을 볼 수 있습니다.&lt;/p&gt;&lt;br&gt;       &lt;%       \tString id = (String) session.getAttribute(\"id\");       \tif (null == id)             response.sendRedirect(\"./login.me\");       \telse        \t{             if (!id.equals(\"admin\"))             {                 // 관리자 계정이 아니면 쫓아내기                 session.invalidate();                 response.sendRedirect(\"./login.me\");             }       \t}       \t         int postCnt = (int)request.getAttribute(\"postCnt\");         ArrayList&lt;BoardDTO&gt; postList = (ArrayList&lt;BoardDTO&gt;)request.getAttribute(\"postList\");     \t         String pageNum = (String)request.getAttribute(\"pageNum\");         int pageCnt = (int)request.getAttribute(\"pageCnt\");         int pageBlockCnt = (int)request.getAttribute(\"pageBlockCnt\");         int startBlock = (int)request.getAttribute(\"startBlock\");         int endBlock = (int)request.getAttribute(\"endBlock\");       %&gt;       &lt;form action=\"./AdminDeleteAction.bo\" method=\"post\" onsubmit=\"return finalCheck();\"&gt;         &lt;table class=\"type09\"&gt;           &lt;tbody&gt;             &lt;colgroup&gt;               &lt;col width=\"5%\"&gt;               &lt;col width=\"10%\"&gt;               &lt;col width=\"40%\"&gt;               &lt;col width=\"15%\"&gt;               &lt;col width=\"\"&gt;             &lt;/colgroup&gt;             &lt;tr&gt;               &lt;th&gt;&lt;input type=\"checkbox\" id=\"selectAll\"&gt;&lt;/th&gt;               &lt;th&gt;글번호&lt;/th&gt;               &lt;th&gt;글제목&lt;/th&gt;               &lt;th&gt;글쓴이&lt;/th&gt;               &lt;th&gt;작성일&lt;/th&gt;             &lt;/tr&gt;             &lt;%if (!boardList.isEmpty())               {                 for (int i = 0; i &lt; boardList.size(); i++)                   { %&gt;             &lt;tr&gt;               &lt;td&gt;&lt;input type=\"checkbox\" name=\"post\" value=\"&lt;%=postList.get(i).getNum() %&gt;\"&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=postList.get(i).getNum() %&gt;&lt;/td&gt;               &lt;td&gt;&lt;a href=\"./BoardContent.bo?num=&lt;%=postList.get(i).getNum()%&gt;&amp;pageNum=1\"&gt;&lt;%=postList.get(i).getTitle() %&gt;&lt;/a&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=postList.get(i).getId() %&gt;&lt;/td&gt;               &lt;td&gt;&lt;%=postList.get(i).getDate() %&gt;&lt;/td&gt;             &lt;/tr&gt;             &lt;% }} %&gt;           &lt;/tbody&gt;         &lt;/table&gt;&lt;br&gt;         &lt;div id=\"boardPage\"&gt;           &lt;%if (startBlock &gt; pageBlockCnt) { %&gt;             &lt;a href=\"./BoardList.bo?flag=a&amp;pageNum=&lt;%=startBlock - pageBlockCnt%&gt;\"&gt;[이전]&lt;/a&gt;           &lt;%} %&gt; \t\t\t           &lt;%for (int i = startBlock; i &lt;= endBlock; i++) { %&gt;             &lt;a href=\"./BoardList.bo?flag=a&amp;pageNum=&lt;%=i%&gt;\"&gt;[&lt;%=i %&gt;]&lt;/a&gt;           &lt;%} %&gt; \t\t\t           &lt;%if (endBlock &gt; pageBlockCnt) { %&gt;             &lt;a href=\"./BoardList.bo?flag=a&amp;pageNum=&lt;%=startBlock + pageBlockCnt%&gt;\"&gt;[다음]&lt;/a&gt;           &lt;%} %&gt; \t\t&lt;/div&gt;         &lt;button type=\"submit\" class=\"btn\"&gt;게시글 삭제&lt;/button&gt;       &lt;/form&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/section&gt;      전체 회원 목록을 보는 페이지의 레이아웃을 약간 수정해서 만들었다.   선택해서 삭제하는 기능이 동일하기 때문에 javascript 코드는 회원 목록 페이지의 코드를 그대로 썼다.   기존에 만들었던 자유게시판의 페이징 기능을 그대로 쓸 것이기 때문에 스크립틀릿의 코드도 게시글 목록을 보여주는 페이지의 코드를 그대로 썼다.   adminLeftNav.jsp   &lt;div data-layout=\"al16 al-o2 de-o1 de6 ec4\"&gt;   &lt;nav class=\"MOD_SUBNAVIGATION1_Menu\" data-theme=\"_bo2\"&gt;     &lt;p class=\"MOD_SUBNAVIGATION1_Menutitle\" data-theme=\"_bgs\"&gt;Menu&lt;/p&gt;     &lt;ul&gt;       &lt;li&gt;&lt;a href=\"./MemberListAction.me\"&gt;회원관리&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a href=\"./BoardList.bo?flag=a\"&gt;게시글 관리&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/nav&gt; &lt;/div&gt;      게시글 관리 메뉴를 클릭하면 게시글 전체 목록을 불러오는 서블릿으로 이동한다.   기존에 만들었던 게시글 목록을 불러오는 서블릿을 재활용 할 것이기 때문에 파라미터로 함께 보내는 flag로 최종적으로 이동할 뷰 페이지를 결정한다.   BoardManagementAction.java   package com.project.cafe.board.action;  import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO; import com.project.cafe.board.db.BoardDTO;  public class BoardListAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardListAction - execute() 호출\"); \t\t         // 어디로 이동할 지 결정하는 정보 받아오기         // a : 관리자용 게시글 관리 페이지         // n : 일반 게시판         String flag = request.getParameter(\"flag\"); \t\t         // .. 중간 생략 \t\t         // 페이지 이동         ActionForward forward = new ActionForward(); \t\t         if (flag.equals(\"a\"))         {             forward.setPath(\"./admin/boardManagement.jsp\");             forward.setRedirect(false);         }         else          {             forward.setPath(\"./contents/boardList.jsp\");             forward.setRedirect(false);\t\t\t         } \t\t         return forward;     } }      게시글 목록을 불러오는 부분은 자유게시판에서 사용했던 것을 조금 수정해서 재활용했다.   매핑된 주소로 이동할 때 함께 받아온 flag 값으로 이동할 뷰 페이지를 구분한 뒤 자유게시판과 관리자용 게시글 관리 페이지로 이동한다.        생략한 코드는 JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 12 - 게시판 글쓰기 기능 만들기 에서 확인할 수 있다.       게시글 목록을 모두 불러오고 나면 게시글 관리 페이지로 이동한다.          진행상황 2     선택한 게시글을 일괄 삭제할 수 있는 기능을 추가했다.   삭제할 게시글들을 선택한 다음 게시글 관리 페이지 하단의 게시글 삭제 버튼을 누르면 일괄 삭제 동작을 수행할 서블릿으로 이동한다.   AdminDeleteAction.java   package com.project.cafe.board.action;  import java.io.PrintWriter; import java.util.ArrayList;  import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import com.project.cafe.action.Action; import com.project.cafe.action.ActionForward; import com.project.cafe.board.db.BoardDAO;  public class AdminDeleteAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : AdminDeleteAction - execute() 호출\"); \t\t         // 파라메터 받기         String[] params = request.getParameterValues(\"post\"); \t\t         ArrayList&lt;Integer&gt; postNums = new ArrayList&lt;Integer&gt;();         for (String p : params)             postNums.add(Integer.parseInt(p)); \t\t         response.setContentType(\"text/html; charset=utf-8\");         PrintWriter out = response.getWriter();         out.print(\"&lt;script&gt;\"); \t\t         // DB 접속해서 선택된 글들 삭제         BoardDAO dao = new BoardDAO();         for (int p : postNums)         {             int result = dao.deletePost(p);             if (result != 1)             {                 out.print(\"alert('잘못된 접근!');\");                 out.print(\"history.back()\");                 out.print(\"&lt;/script&gt;\"); \t\t\t\t                 out.close(); \t\t\t\t                 return null;             }         } \t\t         // 게시글 관리 페이지로 이동         out.print(\"alert('선택한 게시글 삭제가 완료 되었습니다.');\");         out.print(\"location.href='./BoardList.bo?flag=a';\");         out.print(\"&lt;/script&gt;\"); \t\t         out.close(); \t\t         return null;     } }      회원과 관련된 클래스들과 게시글과 관련된 클래스들을 각각 다른 패키지로 모아놓았기 때문에 클래스명은 회원 관리할 때 썼던 것과 같이 썼다.   게시글 관리 페이지로 돌아오면 업데이트 된 목록을 볼 수 있다.     진행상황 3     게시글 하나의 내용을 확인하고 삭제할 수 있는 기능을 추가했다.   boardManagement.jsp   &lt;%if (!boardList.isEmpty())   {     for (int i = 0; i &lt; boardList.size(); i++)     { %&gt;       &lt;tr&gt;         &lt;td&gt;&lt;input type=\"checkbox\" name=\"post\" value=\"&lt;%=boardList.get(i).getNum() %&gt;\"&gt;&lt;/td&gt;         &lt;td&gt;&lt;%=boardList.get(i).getNum() %&gt;&lt;/td&gt;         &lt;td&gt;&lt;a href=\"./BoardContent.bo?num=&lt;%=boardList.get(i).getNum()%&gt;&amp;pageNum=1\"&gt;&lt;%=boardList.get(i).getTitle() %&gt;&lt;/a&gt;&lt;/td&gt;         &lt;td&gt;&lt;%=boardList.get(i).getId() %&gt;&lt;/td&gt;         &lt;td&gt;&lt;%=boardList.get(i).getDate() %&gt;&lt;/td&gt;       &lt;/tr&gt; &lt;% }} %&gt;      게시글 제목을 클릭하면 게시글 본문으로 이동하는 링크를 걸어주었다.   boardContent.jsp   &lt;!-- 본인 글 일때만 수정/삭제 가능 --&gt; &lt;!-- 관리자는 삭제만 가능 --&gt; &lt;%if ((id != null &amp;&amp; id.equals(coList.get(i).getId())) || (id != null &amp;&amp; id.equals(\"admin\")))    {     if (id.equals(coList.get(i).getId())) { %&gt;       &lt;span&gt;         &lt;a href=\"javascript:void(0);\" onclick=\"showCommentBox(&lt;%=i %&gt;);\" id=\"modify\"&gt;수정&amp;nbsp;&lt;/a&gt;       &lt;/span&gt; &lt;% } %&gt;     &lt;span&gt;       &lt;a href=\"javascript:void(0);\" onclick=\"confirmDelete(&lt;%=coList.get(i).getNum()%&gt;, &lt;%=coList.get(i).getPost_num()%&gt;, &lt;%=pageNum%&gt;);\"&gt;삭제&amp;nbsp;&lt;/a&gt;     &lt;/span&gt; &lt;% } %&gt;      관리자는 삭제만 할 수 있도록 조건 제한을 해 주었다.      마감까지     마감 기한이 늘어났다.   D-2  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-28/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 29 - 파일업로드 기능 수정(중복파일명 처리)",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     기존에 만들었던 파일업로드 기능에 수정이 필요했다.   처음에 만들었던 형태는 단순한 업로드와 다운로드 기능만 있었기 때문에 첨부파일을 수정하거나 삭제했을 때 해당 부분을 반영하는 로직이 없었고 중복 파일명을 처리하는 부분도 없었다. 그래서 중복파일명 처리와 수정/삭제 처리를 추가했다.   관련 내용은 에러해결 Log) JAVA JSP Servlet 글 내용 수정할 때 첨부파일이 사라지는 문제 에서도 확인할 수 있다.   FileUpload.java     먼저 DB 테이블에서 실제 파일명을 저장할 필드도 만들었다.   package com.project.cafe.board.action;  import java.io.File;  import javax.servlet.ServletContext; import javax.servlet.http.HttpServletRequest;  import com.oreilly.servlet.multipart.DefaultFileRenamePolicy; import com.oreilly.servlet.multipart.FilePart; import com.oreilly.servlet.multipart.MultipartParser; import com.oreilly.servlet.multipart.ParamPart; import com.oreilly.servlet.multipart.Part; import com.project.cafe.board.db.BoardDTO;  import net.coobird.thumbnailator.Thumbnails; import net.coobird.thumbnailator.name.Rename;  public class FileUpload  {     public BoardDTO upload(HttpServletRequest request) throws Exception     {         System.out.println(\"upload() 호출 \"); \t\t         BoardDTO dto = new BoardDTO(); \t\t         ServletContext ctx = request.getServletContext(); \t\t         // 파일의 저장크기         int maxSize = 10 * 1024 * 1024; // 10MB \t\t         MultipartParser mp = new MultipartParser(request, maxSize);         mp.setEncoding(\"utf-8\");         Part part;          // 기존에 저장되 있던 파일 정보를 저장할 변수         String imgUploadStatus = null;         String oldImgPath = null;         String oldImgName = null; \t\t         String fileUploadStatus = null;         String oldFilePath = null;         String oldFileName = null; \t\t         while ((part = mp.readNextPart()) != null)         {             // form 태그로 저장된 파라미터를 읽어옴             String name = part.getName(); \t\t\t             if (part.isParam())             {                 // 파일이 아닐 때                 ParamPart param = (ParamPart)part;                 String value = param.getStringValue(); \t\t\t\t                 System.out.println(\"param name :\" + name + \" value : \" + value); \t\t\t\t                 // 각 파라미터에 맞춰 dto에 저장                 if (name.equals(\"id\"))                     dto.setId(value);                 else if (name.equals(\"title\"))                     dto.setTitle(value);                 else if (name.equals(\"content\"))                     dto.setContent(value);                 else if (name.equals(\"num\"))                     dto.setNum(Integer.parseInt(value));                 else if (name.equals(\"re_lev\"))                     dto.setRe_lev(Integer.parseInt(value));                 else if (name.equals(\"re_ref\"))                     dto.setRe_ref(Integer.parseInt(value));                 else if (name.equals(\"re_seq\"))                     dto.setRe_seq(Integer.parseInt(value));                 else if (name.equals(\"oldImgName\"))                     oldImgName = value;                 else if (name.equals(\"oldFileName\"))                     oldFileName = value;                 else if (name.equals(\"fileUploadStatus\"))                     fileUploadStatus = value;                 else if (name.equals(\"imgUploadStatus\"))                     imgUploadStatus = value;                 else if (name.equals(\"oldImgPath\"))                     oldImgPath = value;                 else if (name.equals(\"oldFilePath\"))                     oldFilePath = value;             }             else if (part.isFile() &amp;&amp; name.equals(\"image\"))             {                 // 이미지 파일일 때                 // 이미지 저장 경로 지정                 File dir = new File(ctx.getRealPath(\"/images\"));                 File originDir = new File(dir + File.separator + \"origins\"); // 원본 이미지 저장 경로                 File thumbnailDir = new File(dir + File.separator + \"thumbnails\"); // 썸네일 저장 경로 \t\t\t\t                 // 경로가 없으면 생성                 if (!dir.isDirectory()) dir.mkdir();                 if (!originDir.isDirectory()) originDir.mkdir();                 if (!thumbnailDir.isDirectory()) thumbnailDir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 if (filePart.getFileName() != null)                 {                     // 중복 파일명 처리 - 실제 참고할 파일은 rename된 파일이름 쓰기                     filePart.setRenamePolicy(new DefaultFileRenamePolicy());                      // 지정한 경로에 파일 쓰기                     String file = filePart.getFileName();                     filePart.writeTo(originDir);                     dto.setImage(file);                     dto.setImage_uid(filePart.getFileName()); \t\t\t\t\t                     // 원본 이미지 파일을 이용해서 썸네일을 만들어 저장                     // 크기 지정 후 지정 경로에 저장                     // 썸네일 파일명은 중복처리된 파일명과 같게 만든다.                     Thumbnails.of(new File(originDir.getPath() + File.separator + filePart.getFileName()))                         .size(300, 400)                         .toFiles(thumbnailDir, Rename.NO_CHANGE);                 }                 else                     System.out.println(\"img empty!\");             }             else if (part.isFile() &amp;&amp; name.equals(\"file\"))             {                 // 일반 파일일 때                 File dir = new File(ctx.getRealPath(\"/upload\")); \t\t\t\t                 // 경로 없으면 생성                 if (!dir.isDirectory()) dir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 String file = filePart.getFileName();                 if (file != null)                 {                     filePart.setRenamePolicy(new DefaultFileRenamePolicy());                     filePart.writeTo(dir); // 지정한 경로에 파일 쓰기                     dto.setFile(file);                     dto.setFile_uid(filePart.getFileName());                 }                 else                     System.out.println(\"file empty!\");             }         } \t\t         // 사용자 ip주소 저장         dto.setIp(request.getRemoteAddr());                  if (imgUploadStatus != null)         {             if (imgUploadStatus.equals(\"false\"))             {                 // 등록된 이미지를 삭제하는 경우                 dto.setImage(\"없음\");                 File oldImg = new File(oldImgPath);                 if (oldImg.exists()) oldImg.delete(); \t\t\t\t                 // 썸네일도 삭제한다.                 File oldThumbnail = new File(ctx.getRealPath(\"/thumbnail\") + File.separator + oldImgName);                 if (oldThumbnail.exists()) oldThumbnail.delete();             }             else              {                 // 삭제하지 않는 경우                 // 만약 dto의 파일명 필드가 비어 있으면 기존 파일명을 저장한다.                 if (dto.getImage() == null)                     dto.setImage(oldImgName);             }         } \t\t         if (fileUploadStatus != null)         {             if (fileUploadStatus.equals(\"false\"))             {                 dto.setFile(\"없음\");                 File oldFile = new File(oldFilePath);                 if (oldFile.exists()) oldFile.delete();             }             else              {                 if (dto.getFile() == null)                     dto.setFile(oldFileName);             }         } \t\t         return dto;     } }      파일명의 중복처리를 지정해 준 다음 업로드되면 중복처리된 파일명을 받아온다.   게시글에서 사용자에게 보여줄 파일명과 서버에서 다운로드 할 때 참고할 파일명을 따로 저장한다.   실제 다운로드가 이루어질 땐 서버에 업로드 된 파일명인 image_uid, file_uid를 참고할 것이다.   boardContent.jsp   &lt;tr&gt;   &lt;td colspan=\"5\" style=\"white-space:pre-wrap; word-wrap:break-word; word-break: break-all;\"&gt;&lt;%=dto.getContent() %&gt;&lt;br&gt;&lt;br&gt;   &lt;%if (dto.getImage_uid() != null &amp;&amp; !dto.getImage_uid().equals(\"없음\")) { %&gt;     &lt;!-- 실제 서버에 업로드 된 파일명이 중복되면 이름이 바뀌기 때문에 바뀐 파일명을 참조해야 한다. --&gt;     &lt;img src=\"./BoardImgAction.bo?img_name=&lt;%=dto.getImage_uid(). %&gt;\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/td&gt;   &lt;%} %&gt; &lt;/tr&gt; &lt;tr&gt;   &lt;td colspan=\"2\"&gt;첨부파일&lt;/td&gt;   &lt;td colspan=\"3\"&gt;   &lt;!-- 첨부파일이 있을 때에만 하이퍼링크 연결 --&gt;   &lt;%if (dto.getFile_uid() == null || dto.getFile_uid().equals(\"없음\")) { %&gt;       없음   &lt;% }     else { %&gt;       &lt;a href=\"./BoardFileDownloadAction.bo?file_name=&lt;%=dto.getFile_uid() %&gt;\"&gt;&lt;%=dto.getFile() %&gt;&lt;/a&gt;   &lt;%} %&gt;   &lt;/td&gt; &lt;/tr&gt;      사용자에게 보여주는 파일명은 사용자가 업로드했던 파일명 그대로 쓰지만 실제 참조할 파일명은 중복처리된 파일명을 사용한다.         업로드 되는 폴더에 중복처리되어 들어가는 것을 확인할 수 있다.   이제 내일이 발표니까 발표자료 만들어야겠다…      마감까지     내일이 발표네…   D-1  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-29/",
        "teaser": null
      },{
        "title": "에러해결 Log) JAVA JSP Servlet 글 내용 수정할 때 첨부파일이 사라지는 문제",
        "excerpt":"사용환경     MacBook Air (M1, 2020) 16GB   JDK 8   Eclipse 2021-12   tomcat 8.5      에러의 발생     요즘 JAVA와 JSP, Servlet으로 게시판을 만들던 중 파일 업로드 기능을 추가했다. 그런데 게시글을 수정하면 등록되 있던 이미지와 첨부파일이 삭제되는 것이었다. 🥲 DB에 등록되 있던 파일명 자체가 null이 되어버림…   구글 검색을 시도해보니 업로드 한 파일의 수정이 필요할 땐 업로드 했던 파일을 삭제하고 다시 첨부해야 한다는 내용이 많아서 그렇게 해 보았는데 여전히 문제 해결에는 도움이 되지 않았다.   그래서 좀 더 생각해 보니 업로드 된 파일을 삭제하는 코드를 쓴 적 없었기 때문에 업로드 되는 파일들이 저장되는 경로에 가서 확인해 보니 역시 파일들은 그대로 있었다. 내가 짠 로직은 DB에는 업로드 한 파일명만 저장하고 게시글을 불러올 때 서버에 업로드 되는 경로로 찾아가서 해당 파일들을 불러오는 것이라서 DB에서 업데이트 될 때 파일명만 잘 보존해 주면 문제를 해결할 수 있는 것이었다.   게시글 작성 및 수정시 폼태그의 enctype=\"multipart/form-data\" 속성을 사용해서 전송 하기 때문에 파라미터를 받을 때 Multipart 객체를 사용해서 받아야 하는데 이 과정에서 실제로 받은 파일이 없다보니 파일명을 추출하는 과정이 생략되었고, DB 업로드용 DTO 객체를 생성하는 과정에서 파일명에 대한 정보가 누락된 것이었다…!! 그리고 DB 접속해서 업데이트 동작을 수행하는 과정에서 null이 입력되게 된다…   그러면 file 타입 input 태그의 value 값을 기존에 저장되어 있던 파일명으로 넣어놓으면 되지 않나 싶었다. 그런데 안 됨   구글링 해 보니 file 타입은 readonly라서 파일을 직접 등록할 때가 아니면 임의로 value값을 넣어줄 수 없다고 한다. value 수정이 가능한 경우는 value값이 있을 때 그 값을 지울 때 뿐이었음. 그래서 다른 방법을 찾아야 했다.     문제 해결   boardModify.jsp   &lt;%     String imgPath = request.getServletContext().getRealPath(\"/images\") + File.separator + \"origins\" + File.separator + dto.getImage();     System.out.println(\"imgPath: \"+imgPath); %&gt; &lt;form name=\"write\" action=\"./BoardModifyPro.bo\" method=\"post\" enctype=\"multipart/form-data\" onsubmit=\"return finalCheck();\"&gt;   &lt;div class=\"formRow\"&gt;     &lt;label for=\"MOD_TEXTFORM_NameField\"&gt;이미지 등록 &lt;/label&gt;&lt;input type=\"file\" name=\"image\" id=\"image\" oninput=\"formatCheck();\"&gt;     &lt;input type=\"hidden\" name=\"oldImgPath\" value=\"&lt;%=imgPath%&gt;\"&gt;     &lt;input type=\"hidden\" name=\"oldImgName\" value=\"&lt;%=dto.getImage()%&gt;\"&gt;     &lt;input type=\"hidden\" name=\"imgUploadStatus\" value=\"true\"&gt;   &lt;/div&gt; &lt;div&gt;등록된 이미지 : &lt;span id=\"imgName\"&gt; &lt;%=dto.getImage() %&gt; &lt;/span&gt;&amp;nbsp; &lt;a href=\"javascript:void(0);\" onclick=\"removeImg();\"&gt;삭제&lt;/a&gt;&lt;/div&gt;&lt;br&gt; &lt;/form&gt;      글 수정 페이지의 폼태그 안에서 hidden 타입 input 태그를 써서 기존에 저장되어 있던 파일명을 저장해 두었다 함께 전송했다.   만약 삭제 버튼을 누르면 onclick 이벤트를 통해 imgUploadStatus를 false로 바꿔 기존에 등록했던 파일을 삭제할 것임을 알린다.   BoardModifyProAction.java   public class BoardModifyProAction implements Action  {     @Override     public ActionForward execute(HttpServletRequest request, HttpServletResponse response) throws Exception      {         System.out.println(\"M : BoardModifyProAction - execute() 호출\"); \t\t         // 한글처리         request.setCharacterEncoding(\"UTF-8\"); \t\t         // DB에서 기존 글 정보를 찾은 다음 새 내용으로 수정         FileUpload fu = new FileUpload();         BoardDTO dto = fu.upload(request);            // .. 하략     } }      글 수정 동작을 수행하는 서블릿으로 오면 파일 업로드 처리를 위한 클래스인 FileUpload로 이동한다.   FileUpload.java   BoardDTO dto = new BoardDTO();  // 기존에 저장되 있던 파일 정보를 저장할 변수 String imgUploadStatus = null; String oldImgPath = null; String oldImgName = null;  ...   else if (name.equals(\"oldImgName\"))     oldImgName = value; else if (name.equals(\"imgUploadStatus\"))     imgUploadStatus = value; else if (name.equals(\"oldImgPath\"))     oldImgPath = value;      서블릿으로 오면 Multipart 객체에서 기존 파일과 관련된 부분이 있으면 저장한다.   수정모드에서 새로운 파일 첨부를 하지 않고 여기로 오게 되면 업로드 된 파일이 없으니 파일 등록 과정을 거치지 않고 내려올 것이다. BoardDTO 객체의 이미지 파일명 정보는 null인 상태     if (imgUploadStatus != null) {     if (imgUploadStatus.equals(\"false\"))     {         // 등록된 이미지를 삭제하는 경우         dto.setImage(\"없음\");         File oldImg = new File(oldImgPath);         if (oldImg.exists()) oldImg.delete();     }     else      {         // 삭제하지 않는 경우         if (dto.getImage() == null)             dto.setImage(oldImgName);     } }      기존 이미지 파일 정보가 있어서 그것을 어떻게 처리해라는 지시사항이 있으면 그에 맞게 처리하는 분기로 이동한다.   등록된 이미지를 삭제하는 경우에는 파일명을 지우고 서버에서도 해당 파일을 지운다.   삭제하지 않는 경우인데 만약 BoardDTO의 파일명 필드가 비어 있으면 기존 파일명을 저장한다.        이제 BoardDTO를 DB로 보내 업데이트 동작을 수행하면 파일명 필드가 null이 되지 않고 잘 남아있게 된다.       아래는 FileUpload 클래스의 전체 코드이다.   package com.project.cafe.board.action;  import java.io.File;  import javax.servlet.ServletContext; import javax.servlet.http.HttpServletRequest;  import com.oreilly.servlet.multipart.DefaultFileRenamePolicy; import com.oreilly.servlet.multipart.FilePart; import com.oreilly.servlet.multipart.MultipartParser; import com.oreilly.servlet.multipart.ParamPart; import com.oreilly.servlet.multipart.Part; import com.project.cafe.board.db.BoardDTO;  import net.coobird.thumbnailator.Thumbnails; import net.coobird.thumbnailator.name.Rename;  public class FileUpload  {     public BoardDTO upload(HttpServletRequest request) throws Exception     {         System.out.println(\"upload() 호출 \"); \t\t         BoardDTO dto = new BoardDTO(); \t\t         ServletContext ctx = request.getServletContext(); \t\t         // 파일의 저장크기         int maxSize = 10 * 1024 * 1024; // 10MB \t\t         MultipartParser mp = new MultipartParser(request, maxSize);         mp.setEncoding(\"utf-8\");         Part part; \t\t         // 기존에 저장되 있던 파일 정보를 저장할 변수         String imgUploadStatus = null;         String oldImgPath = null;         String oldImgName = null; \t\t         String fileUploadStatus = null;         String oldFilePath = null;         String oldFileName = null; \t\t         while ((part = mp.readNextPart()) != null)         {             // form 태그로 저장된 파라미터를 읽어옴             String name = part.getName(); \t\t\t             if (part.isParam())             {                 // 파일이 아닐 때                 ParamPart param = (ParamPart)part;                 String value = param.getStringValue(); \t\t\t\t                 System.out.println(\"param name :\" + name + \" value : \" + value); \t\t\t\t                 // 각 파라미터에 맞춰 dto에 저장                 if (name.equals(\"id\"))                     dto.setId(value);                 else if (name.equals(\"title\"))                     dto.setTitle(value);                 else if (name.equals(\"content\"))                     dto.setContent(value);                 else if (name.equals(\"num\"))                     dto.setNum(Integer.parseInt(value));                 else if (name.equals(\"re_lev\"))                     dto.setRe_lev(Integer.parseInt(value));                 else if (name.equals(\"re_ref\"))                     dto.setRe_ref(Integer.parseInt(value));                 else if (name.equals(\"re_seq\"))                     dto.setRe_seq(Integer.parseInt(value));                 else if (name.equals(\"oldImgName\"))                     oldImgName = value;                 else if (name.equals(\"oldFileName\"))                     oldFileName = value;                 else if (name.equals(\"fileUploadStatus\"))                     fileUploadStatus = value;                 else if (name.equals(\"imgUploadStatus\"))                     imgUploadStatus = value;                 else if (name.equals(\"oldImgPath\"))                     oldImgPath = value;                 else if (name.equals(\"oldFilePath\"))                     oldFilePath = value;             }             else if (part.isFile() &amp;&amp; name.equals(\"image\"))             {                 // 이미지 파일일 때                 // 이미지 저장 경로 지정                 File dir = new File(ctx.getRealPath(\"/images\"));                 File originDir = new File(dir + File.separator + \"origins\"); // 원본 이미지 저장 경로                 File thumbnailDir = new File(dir + File.separator + \"thumbnails\"); // 썸네일 저장 경로 \t\t\t\t                 // 경로가 없으면 생성                 if (!dir.isDirectory()) dir.mkdir();                 if (!originDir.isDirectory()) originDir.mkdir();                 if (!thumbnailDir.isDirectory()) thumbnailDir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 if (filePart.getFileName() != null)                 {                     filePart.setRenamePolicy(new DefaultFileRenamePolicy());                      // 지정한 경로에 파일 쓰기                     String file = filePart.getFileName();                     filePart.writeTo(originDir);                     dto.setImage(file);                     // 중복 파일명을 처리할 부분                     dto.setImage_uid(filePart.getFileName()); \t\t\t\t\t                     // 원본 이미지 파일을 이용해서 썸네일을 만들어 저장                     // 크기 지정 후 지정 경로에 저장                     Thumbnails.of(new File(originDir.getPath() + File.separator + file)) \t\t\t\t\t\t.size(300, 400) \t\t\t\t\t\t.toFiles(thumbnailDir, Rename.NO_CHANGE);                 }                 else                     System.out.println(\"img empty!\");             }             else if (part.isFile() &amp;&amp; name.equals(\"file\"))             {                 // 일반 파일일 때                 File dir = new File(ctx.getRealPath(\"/upload\")); \t\t\t\t                 // 경로 없으면 생성                 if (!dir.isDirectory()) dir.mkdir(); \t\t\t\t                 FilePart filePart = (FilePart) part;                 String file = filePart.getFileName();                 if (file != null)                 {                     filePart.writeTo(dir); // 지정한 경로에 파일 쓰기                     dto.setFile(file);                     dto.setFile_uid(filePart.getFileName());                 }                 else                     System.out.println(\"file empty!\");             }         } \t\t         // 사용자 ip주소 저장         dto.setIp(request.getRemoteAddr()); \t\t         if (imgUploadStatus != null)         {             if (imgUploadStatus.equals(\"false\"))             {                 // 등록된 이미지를 삭제하는 경우                 dto.setImage(\"없음\");                 File oldImg = new File(oldImgPath);                 if (oldImg.exists()) oldImg.delete();             }             else              {                 // 삭제하지 않는 경우                 // 만약 dto의 파일명 필드가 비어 있으면 기존 파일명을 저장한다.                 if (dto.getImage() == null)                     dto.setImage(oldImgName);             }         } \t\t         if (fileUploadStatus != null)         {             if (fileUploadStatus.equals(\"false\"))             {                 dto.setFile(\"없음\");                 File oldFile = new File(oldFilePath);                 if (oldFile.exists()) oldFile.delete();             }             else              {                 if (dto.getFile() == null)                     dto.setFile(oldFileName);             }         } \t\t         return dto;     } }      해결~!!  ","categories": ["ErrorLog"],
        "tags": ["Error","Solve","Log"],
        "url": "/errorlog/warning-log-04/",
        "teaser": null
      },{
        "title": "에러해결 Log) JAVA JSP Servlet 글 내용 수정할 때 첨부파일이 사라지는 문제2",
        "excerpt":"사용환경     MacBook Air (M1, 2020) 16GB   JDK 8   Eclipse 2021-12   tomcat 8.5      에러의 발생     무슨 버그가 수정을 해도해도 계속 나오는지… 얼렁뚱땅 돌아가는 느낌이다 🥲   게시글을 수정할 때 첨부파일이 사라지는 버그를 해결했다고 생각했는데 완벽히 해결되지 않았다.   여전히 일부 케이스에서 제대로 처리가 되지 않아 DB 상에서의 파일명이 null로 바뀌는 문제가 존재했다.   그래서 좀 더 근본적인 원인을 떠올려 보았다… 게시글을 수정하며 파일 업로드 단계를 거치는 과정에서 DTO 생성 시 파일명이 지정되지 않아 null로 남아있는 것이 DB 수정 동작 때 넘어와서 문제라면 DB에 접근하는 메서드를 수정하는 것이 빠르지 않을까…   문제 해결     기존에 작성했던 게시글 수정 메서드   public int modifyPost(BoardDTO dto) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         // 번호로 해당 글 찾기         sql = \"select * from cafe_board where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, dto.getNum()); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             // update 동작 수행             sql = \"update cafe_board set title=?, image=?, image_uid=?, file=?, file_uid=? content=? where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setString(1, dto.getTitle());             pstmt.setString(2, dto.getContent());             pstmt.setString(3, dto.getImage());             pstmt.setString(4, dto.getImage_uid());             pstmt.setString(5, dto.getFile());             pstmt.setString(6, dto.getFile_uid());             pstmt.setInt(7, dto.getNum()); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 글 수정 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }      매개변수로 받은 DTO를 그대로 받아서 바로 업데이트 동작을 수행한다.        이러니 DTO의 파일명 필드가 null로 넘어와도 아무 필터링 없이 DB에 null이 저장되는 것이었다.          수정한 메서드   public int modifyPost(BoardDTO dto) {     int ret = -1; \t\t     try {         con = getCon(); \t\t\t         // 번호로 해당 글 찾기         sql = \"select * from cafe_board where num=?\";         pstmt = con.prepareStatement(sql); \t\t\t         pstmt.setInt(1, dto.getNum()); \t\t\t         rs = pstmt.executeQuery(); \t\t\t         if (rs.next())         {             // update 동작 수행             // 새로 수정한 글에서 파일 정보가 있으면 그걸로 수정 / 없으면 그대로 놔둠             if (dto.getImage() != null &amp;&amp; dto.getImage_uid() != null)             {                 sql = \"update cafe_board set image=?, image_uid=? where num=?\";                 pstmt = con.prepareStatement(sql); \t\t\t\t\t                 pstmt.setString(1, dto.getImage());                 pstmt.setString(2, dto.getImage_uid());                 pstmt.setInt(3, dto.getNum()); \t\t\t\t\t                 pstmt.executeUpdate();             } \t\t\t\t             if (dto.getFile() != null &amp;&amp; dto.getFile_uid() != null)             {                 sql = \"update cafe_board set file=?, file_uid=? where num=?\";                 pstmt = con.prepareStatement(sql); \t\t\t\t\t                 pstmt.setString(1, dto.getFile());                 pstmt.setString(2, dto.getFile_uid());                 pstmt.setInt(3, dto.getNum()); \t\t\t\t\t                 pstmt.executeUpdate();             } \t\t\t\t             sql = \"update cafe_board set title=?, content=? where num=?\";             pstmt = con.prepareStatement(sql); \t\t\t\t             pstmt.setString(1, dto.getTitle());             pstmt.setString(2, dto.getContent());             pstmt.setInt(3, dto.getNum()); \t\t\t\t             ret = pstmt.executeUpdate(); \t\t\t\t             System.out.println(\"DAO : 글 수정 완료\");         }     }     catch (Exception e) {         e.printStackTrace();     }     finally {         closeDB();     } \t\t     return ret; }      전달되어 온 DTO에 파일명 정보가 있을 때에만 업데이트가 되도록 수정했다.   이렇게 하니까 그동안 고민했던 문제들이 싹 해결되었다.        역시 근본적인 원인을 제거했어야…       이렇게 문제 해결~!! 👏  ","categories": ["ErrorLog"],
        "tags": ["Error","Solve","Log"],
        "url": "/errorlog/warning-log-05/",
        "teaser": null
      },{
        "title": "개발자 GitHub 포트폴리오 사이트 만들기 01 - 내가 코딩한 일수 자동 계산하기",
        "excerpt":"제작목적     웹 개발을 공부하며 첫 번째 프로젝트를 끝내고 나니까 이걸 잘 포장해서 보여줘야 할 필요가 생겼다. 즉 포트폴리오 문서가 필요해진 것!   포트폴리오 문서는 서류 형식으로도 만들 것이지만 나는 웹 개발을 공부하고 있으니까 나의 포트폴리오를 보여줄 웹 사이트도 만들기로 결정했다. 기본적인 기능이 다 구현되어 있는 무료 템플릿을 쓰겠지만 그걸 나에게 맞게 수정하는 과정에서도 배울 점이 많을 것이다.   진행상황     템플릿은 GiHhub 레포지토리에 무료로 공개되어 있는 congchu님의 템플릿을 사용했다.   https://github.com/congchu/web-porfolio   GitHub을 써 보았다면 fork에서 로컬 저장소에 다운받기까지는 쉽게 할 수 있다. 몰라도 Readme에 친절하게 설명되어 있다.     index.html - 내가 코딩한 일수 수정     가장 먼저 이름을 수정하고 쭉 보다보니 내가 코딩한 일수를 기록하는 란이 있었다.      &lt;div class=\"text\"&gt;   &lt;strong id=\"codingDays\" class=\"number\" data-number=\"365\"&gt;0&lt;/strong&gt;     &lt;span&gt;코딩한 일수&lt;/span&gt; &lt;/div&gt;      코드 상의 기본 데이터는 365로 설정되어 있다.   이걸 내가 코딩한 날짜로 바꿔주면 되는데 이걸 일일이 계산하는 것은 정말 번거로운 작업이다.   날짜 하나를 정해서 박아놓으면 수동으로 업데이트 해 줘야 하는데 귀찮고 손이 많이 가니까… 고등 교육을 받은 현대인이니까 시간이 흐름에 따라 알아서 업데이트 되게 해 줄 것이다.     &lt;script src=\"js/main.js\"&gt;&lt;/script&gt;      밑에 내려 보니까 main.js 파일을 수정하면 될 거 같아서 여기로 이동했다.   main.js   function countDate() {     var startDate = new Date(2020, 11, 14); // 시작일     var today = new Date(); // 오늘     var total = new Date(); // 경과시간     total.setTime((today.getTime() - startDate.getTime()) / 1000 / 60 / 60 / 24);     $('#codingDays').attr('data-number', total.getTime()); }      시작일로부터 오늘까지 경과한 일수를 계산하는 함수를 작성했다. 간단해 보이지만 자바스크립트로 날짜 계산하는 함수를 쓴 지 오래되서 구글링을 열심히 해야했다…ㅎ   (function($) {      \"use strict\";      $(window).stellar({     responsive: true,     parallaxBackgrounds: true,     parallaxElements: true,     horizontalScrolling: false,     hideDistantElements: false,     scrollProperty: 'scroll'   });      countDate(); }      그리고 jQuery 시작 함수 안에서 호출하면 끝!         계산 잘 된다! 😄        ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/make-portfolio-01/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 09 실전문제 2. 미래 도시",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 09 - 실전문제 2. 미래 도시     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       방문 판매원 A는 많은 회사가 모여 있는 공중 미래 도시에 있다. 공중 미래 도시에는 1번부터 N번까지의 회사가 있는데 특정 회사끼리는 서로 도로를 통해 연결되어 있다. 방문 판매원 A는 현재 1번 회사에 위치해 있으며, X번 회사에 방문해 물건을 판매하고자 한다.   공중 미래 도시에서 특정 회사에 도착하기 위한 방법은 회사끼리 연결되어 있는 도로를 이용하는 방법이 유일하다. 또한 연결된 2개의 회사는 양방향으로 이동할 수 있다. 공중 미래 도시에서의 도로는 마하의 속도로 사람을 이동시켜주기 때문에 특정 회사와 다른 회사가 도로로 연결되어 있다면, 정확히 1만큼의 시간으로 이동할 수 있다.   또한 오늘 방문 판매원 A는 기대하던 소개팅에도 참석하고자 한다. 소개팅의 상대는 K번 회사에 존재한다. 방문 판매원 A는 X번 회사에 가서 물건을 판매하기 전에 먼저 소개팅 상대의 회사에 찾아 가서 함께 커피를 마실 예정이다. 따라서 방문 판매원 A는 1번 회사에서 출발하여 K번 회사를 방문한 뒤에 X번 회사로 가는 것이 목표다. 이때 방문 판매원 A는 가능한 한 빠르게 이동하고자 한다. 방문 판매원이 회사 사이를 이동하게 되는 최소 시간을 계산하는 프로그램을 작성하시오. 이때 소개팅의 상대방과 커피를 마시는 시간 등은 고려하지 않는다고 가정한다.     입력       첫째 줄에 전체 회사의 개수 N과 경로의 개수 M이 공백으로 구분되어 차례대로 주어진다.(1 &lt;= N, M &lt;= 100)   둘째 줄부터 M+1번째 줄에는 연결된 두 회사의 번호가 공백으로 구분되어 주어진다.   M+2번째 줄에는 X와 K가 공백으로 구분되어 차례대로 주어진다.(1 &lt;= K &lt;= 100)     출력       첫째 줄에 방문 판매원 A가 K번 회사를 거쳐 X번 회사로 가는 최소 이동 시간을 출력한다.   만약 X번 회사에 도착할 수 없다면 -1을 출력한다.      👀 풀이       N의 범위가 100 이하로 매우 작기 때문에 비교적 간단한 워셜 플로이드 알고리즘으로 풀 수 있다.   확실히 다익스트라에 비하면 워셜이 구현하기 쉬워서 손이 가게 되는 것 같다.   서로 연결된 회사의 거리는 1이라고 했으니 입력 받으면서 연결된 회사의 거리는 1로 초기화한다.   다음엔 워셜 플로이드 알고리즘으로 i번째 회사에서 j번째 회사로 가는 거리와 k번째 회사를 거쳐 가는 거리 중 더 짧은 거리로 갱신한다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Graph","Python"],
        "url": "/boj/CodingTestBook-09-4-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 09 실전문제 3. 전보",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 09 - 실전문제 3. 전보     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       어떤 나라에는 N개의 도시가 있다. 그리고 각 도시는 보내고자 하는 메시지가 있는 경우, 다른 도시로 전보를 보내서 다른 도시로 해당 메시지를 전송할 수 있다. 하지만 X라는 도시에서 Y라는 도시로 전보를 보내고자 한다면, 도시 X에서 도시 Y로 향하는 통로가 설치되어 있어야 한다. 예를 들어 X에서 Y로 향하는 통로는 있지만, Y에서 X로 향하는 통로가 없다면 Y는 X로 메시지를 보낼 수 없다. 또한 통로를 거쳐 메시지를 보낼 때에는 일정 시간이 소요된다.   어느 날 C라는 도시에서 위급 상황이 발생했다. 그래서 최대한 많은 도시로 메시지를 보내고자 한다. 메시지는 도시 C에서 출발하여 각 도시 사이에 설치된 통로를 거쳐, 최대한 많이 퍼져나갈 것이다. 각 도시의 번호와 통로가 설치되어 있는 정보가 주어졌을 때, 도시 C에서 보낸 메시지를 받게 되는 도시의 개수는 총 몇 개이며 도시들이 모두 메시지를 받는 데까지 걸리는 시간은 얼마인지 계산하는 프로그램을 작성하시오.     입력       첫째 줄에 도시의 개수 N, 통로의 개수 M, 메시지를 보내고자 하는 도시 C가 주어진다.(1 &lt;= N &lt;= 30,000, 1 &lt;= M &lt;= 200,000, 1 &lt;= C &lt;= N)   둘째 줄부터 M + 1번째 줄에 걸쳐서 통로에 대한 정보 X, Y, Z가 주어진다. 이는 특정 도시 X에서 다른 특정 도시 Y로 이어지는 통로가 있으며, 메시지가 전달되는 시간이 Z라는 의미이다.(1 &lt;= X, Y &lt;= N, 1 &lt;= Z &lt;= 1,000)     출력       첫째 줄에 도시 C에서 보낸 메시지를 받는 도시의 총 개수와 총 걸리는 시간을 공백으로 구분하여 출력한다.      👀 풀이       시작점이 정해져 있고 N의 범위가 꽤 커서 워셜 플로이드 보다는 다익스트라가 적합하다고 생각했고, 또 우선순위 큐를 사용하는 다익스트라를 쓰는 것이 좋겠다고 생각했다.   다익스트라 알고리즘으로 C 도시에서 다른 도시들로 이동하는 최단 거리를 찾아서 갱신한다.   마지막에 출력할 때 최단거리 테이블의 값이 무한대가 아닌 인덱스의 개수를 세고, 그 중에서 가장 먼 도시의 최단 거리를 출력하면 된다.   그런데 문제는 총 걸리는 시간을 출력하라고 되어 있어서 도착 가능한 도시들의 최단 거리의 합인가 싶어서 처음에는 저렇게 출력하니까 틀렸었다. 문제 설명 좀 명확했으면 좋겠다.   이동 가능한 도시의 개수를 셀 때엔 자기 자신도 포함되기 때문에 마지막 출력 시에는 1을 빼고 출력해야 한다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Graph","Python"],
        "url": "/boj/CodingTestBook-09-5-py/",
        "teaser": null
      },{
        "title": "깃허브 블로그(Github Blog) minimal-mistakes 테마 게시글 날짜 출력하기",
        "excerpt":"🎬 시작     네이버 블로그를 오래 했었는데 네이버 블로그는 게시글 제목 옆에 작성한 날짜를 보여준다. 그런데 GitHub으로 이사오고 minimal-mistakes 테마를 쓰다 보니… 왜 작성한 날짜 보기가 이렇게 어렵지? 외국인들은 날짜에 연연하지 않나…   기본 설정은 게시글 제목 근처에 표시되지 않고 게시글 본문의 맨 아래로 내려야 작성 날짜를 볼 수 있다.   그래서 이걸 바꿀 것이다.   GitHub Pages 기타 설정   [jekyll] jekyll 블로그 포스팅 시간 출력하기        두 블로그 글들을 참고했는데 난 설정 페이지의 코드가 약간 달라서 같은 방법을 적용할 수 없었다. 같은 테마 파일을 다운 받았을텐데 난 왜 남들 다 있는 코드가 없었을까…       그래서 결정적으로는 https://github.com/devinlife/devinlife.github.io/commit/c6a8fe5a2f2a6f208b4ad90528074842e5c3ee66 이 커밋에 달린 댓글에 있는 방법으로 해결할 수 있었다.     수정 시도     위의 두 블로그처럼 _inclues/archive-single.html이랑 _layouts/single.html을 수정해 봤는데 적용이 되지 않았다. 아마 남들은 다 있는 코드가 나에겐 없었던 이유가 저 분들처럼 만들어 줄 파일이 존재하지 않아서였던 것이 아닐까… 로컬 서버를 실행시켜서 미리보기로 봤을 때엔 잘 되고 commit까지도 잘 됐는데 push를 시도하니까 참고를 찾을 수 없다는 내용의 에러가 뜨면서 적용이 되지 않았다.         그러다 이 댓글을 보고 _config.yml을 수정해 봤는데 미리보기 상에서는 적용이 되지 않았다.   그래서 처음엔 난 안 되는 줄 알고 계속 _inclues/archive-single.html과 _layouts/single.html 파일을 수정해보다가 마지막에 밑지는 느낌으로 해 봤는데 push도 잘 되고 조금 기다리니까 블로그에 적용도 잘 되었다.   # Defaults defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: false # false로 변경       show_date: true # 원래 없어서 생성 후 true로 설정       comments: true       share: true       related: true         잘 나오네!  ","categories": ["Story"],
        "tags": ["story"],
        "url": "/story/making-github-blog-02/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 10 실전문제 2. 팀 결성",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 10 - 실전문제 2. 팀 결성     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       학교에서 학생들에게 0번부터 N번까지의 번호를 부여했다. 처음에는 모든 학생이 서로 다른 팀으로 구분되어, 총 N + 1개의 팀이 존재한다. 이때 선생님은 ‘팀 합치기’ 연산과 ‘같은 팀 여부 확인’ 연산을 사용할 수 있다.            ‘팀 합치기’ 연산은 두 팀을 합치는 연산이다.       ‘같은 팀 여부 확인’ 연산은 특정한 두 학생이 같은 팀에 속하는지를 확인하는 연산이다.           선생님이 M개의 연산을 수행할 수 있을 때, ‘같은 팀 여부 확인’ 연산에 대한 연산 결과를 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 N, M이 주어진다. M은 입력으로 주어지는 연산의 개수이다.(1 &lt;= N, M &lt;= 100,000)   다음 M개의 줄에는 각각의 연산이 주어진다.   ‘팀 합치기’연산은 0 a b 형태로 주어진다. 이는 a번 학생이 속한 팀과 b번 학생이 속한 팀을 합친다는 의미이다.   ‘같은 팀 여부 확인’연산은 1 a b 형태로 주어진다. 이는 a번 학생과 b번 학생이 같은 팀에 속해 있는지를 확인하는 연산이다.   a와 b는 N 이하의 양의 정수이다.     출력       ‘같은 팀 여부 확인’연산에 대하여 한 줄에 하나씩 YES 혹은 NO로 결과를 출력한다.      👀 풀이       유니온 파인드 연습문제다.   팀 합치기 함수와 루트 노드를 찾는 함수를 작성한 다음에 연산에 따라 호출했다.   ‘같은 팀 여부 확인’연산 수행 시 부모가 같은지 확인한 후 결과를 출력하면 된다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Graph","Python"],
        "url": "/boj/CodingTestBook-10-02-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 10 실전문제 4. 커리큘럼",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 10 - 실전문제 4. 커리큘럼     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제       동빈이는 온라인으로 컴퓨터공학 강의를 듣고 있다. 이때 각 온라인 강의는 선수 강의가 있을 수 있는데, 선수 강의가 있는 강의는 선수 강의를 먼저 들어야만 해당 강의를 들을 수 있다. 예를 들어 ‘알고리즘’강의의 선수 강의로 ‘자료구조’와 ‘컴퓨터 기초’가 존재한다면, ‘자료구조’와 ‘컴퓨터 기초’를 모두 들은 이후에 ‘알고리즘’ 강의를 들을 수 있다.   동빈이는 총 N개의 강의를 듣고자 한다. 모든 강의는 1번부터 N번까지의 번호를 가진다. 또한 동시에 여러 개의 강의를 들을 수 있다고 가정한다.   동빈이가 듣고자 하는 N개의 강의 정보가 주어졌을 때, N개의 강의에 대하여 수강하기까지 걸리는 최소 시간을 각각 출력하는 프로그램을 작성하시오.     입력       첫째 줄에 동빈이가 듣고자 하는 강의의 수 N(1 &lt;= N &lt;= 500)이 주어진다.   다음 N개의 줄에는 각 강의의 강의 시간과 그 강의를 듣기 위해 먼저 들어야 하는 강의들이 번호가 자연수로 주어지며, 각 자연수는 공백으로 구분한다. 이때 강의 시간은 100,000 이하의 자연수이다.   각 강의 번호는 1부터 N까지로 구성되며, 각 줄은 -1로 끝난다.     출력       N개의 강의에 대하여 수강하기까지 걸리는 최소 시간을 한 줄에 하나씩 출력한다.      👀 풀이       위상정렬 응용 문제이다.   차수를 하나씩 벗겨가면서 마지막 강의까지 가면 되는데, 지금 강의와 다음 강의를 들었을 때 누적 시간을 구하면서 가야 한다.   이를 위해 각 강의별 최소 시간을 저장할 리스트를 만든 뒤 위상 정렬을 수행하면서 이 리스트를 갱신한다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Graph","Python"],
        "url": "/boj/CodingTestBook-10-04-py/",
        "teaser": null
      },{
        "title": "Python) BOJ 1647. 도시 분할 계획",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1647     제한       시간 제한 : 2 초   메모리 제한 : 256 MB     문제            동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지고 있었다.            마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 각 길마다 길을 유지하는데 드는 유지비가 있다.            마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.            그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.         입력       첫째 줄에 집의 개수 N, 길의 개수 M이 주어진다. N은 2이상 100,000이하인 정수이고, M은 1이상 1,000,000이하인 정수이다. 그 다음 줄부터 M줄에 걸쳐 길의 정보가 A B C 세 개의 정수로 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C (1 ≤ C ≤ 1,000)라는 뜻이다.     출력       첫째 줄에 없애고 남은 길 유지비의 합의 최솟값을 출력한다.      👀 풀이       최소 신장 트리 문제인 것 까지는 알겠는데 2개로 쪼개는 걸 어떻게 해야하나 싶었다.   그래서 책 보니까 최소 신장 트리를 찾은 후에 가장 비싼 비용을 빼면 2개로 분할된다고 하는 것이었다…😦 생각해 보니까 진짜 간단하면서 맞는 말이었다.        최소 신장 트리를 구하는 코드까지는 금방 썼지만 가장 비싼 비용을 빼는 과정에서 어렵게 생까해서 헤멨는데 그냥 최소 신장 트리의 합을 구한 다음 마지막에 가장 비싼 비용을 빼 주면 되었다.       첫 제출때엔 시간초과가 났는데 입력 받는 부분을 sys.stdin.readline으로 바꿔주니까 통과할 수 있었다. 잊지말자… 입력 속도는 빠르게…     결과       시간 : 4076 ms   메모리 : 197288 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1647","Graph","Python"],
        "url": "/boj/boj1647-py/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 30 - AWS로 프로젝트 배포하기 1. war파일 배포",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황          프로젝트 제작 기한이 끝나고 발표도 다 하고 과제물도 다 제출했지만 마지막으로 요즘 대세인 AWS로 배포도 해 보고 싶었다! 그래서 구글링 가이드를 따라가며 하고 있는데 마냥 쉽지는 않군       https://m.blog.naver.com/scw0531/221438323697   전체적인 세팅 방법은 이 블로그 글을 참고했다.   회원가입         AWS가 어떤 것인지 맛보기 용이니까 무료 플랜 선택                그리고 재수 없게(?) 과금 경험을 하신 분들이 결제 알림 설정을 꼭 해 놓으라 그래서 알림 설정도 했다.            그 후로는 위에 첨부한 블로그 글대로 쭉 따라갔는데 위 글과는 다른 자바 버전을 쓰려고 자바 설치 과정만 좀 다르게 했다.       open jdk11 설치     https://codechacha.com/ko/ubuntu-install-open-jdk11/   open jdk 설치는 이 블로그 글을 참고했다.   Tomcat8 설치 그리고…     자바를 설치한 후에 다시 처음에 참고하던 블로그 글로 돌아와서 Tomcat8도 설치하고 잘 따라가고 있었는데 안타깝게도 톰캣을 어떻게 실행하라는 설명이 없었다..(아직 잘 모름…ㅎ)   그래서 구글링 해 보니까 설치된 폴더로 이동한 후 ./startup.sh로 실행을 하는 것이라 해서 해 보았다. 그런데 안 됨 ㅠ.ㅠ     차갑다...      암튼 그래서 에러 메시지로 구글링을 하다가 https://rimkongs.tistory.com/241 이 블로그 글을 참고해서 원인을 알 수 있었다.   sudo apt-get 방식으로 설치한 톰캣은 ./startup.sh이걸로 실행할 수 없었다.   sudo /etc/init.d/tomcat8 start 이걸 써야 했음…     실행 성공!         이제 톰캣 서버가 잘 돌아가고 있는지 웹사이트로 접속해 봐야 하는데 원래 참고하고 있던 블로그 글에서 그 주소에 대한 언급 또한 없어서… 처음에 좀 헤멨다. 당췌 어디로 접속해서 It works를 확인하란 것인지…         알고 보니 퍼블릭 IPv4 DNS 주소의 맨 뒤에 :8080을 붙이면 접속할 수 있는 것이었다.         접속 안 될까봐 좀 조마조마 했는데 다행히 잘 된다.   FileZilla 설치              FileZilla를 설치해야 했는데 이거 또한 클라이언트 설치인지 서버 설치인지 언급되어 있지 않아서 둘 다 깔아봤는데 클라이언트를 설치하는 것이었다.            근데 새 사이트 관리자를 만들어서 접속에 성공한 것 같은데 나는 또 저분과 다르게 폴더가 쭈루루 뜨지 않는 것이었다. 😟 머선 일이고… 맞게 접속한 거 같긴 한데             ? 떠 있는 폴더들을 누르니까 하나씩 로드가 되었다.           근데 war 파일 업로드를 하려니까 권한이 없다면서 업로드가 되지 않았다.   https://threeidiotscoding.tistory.com/14   이 글을 참고해서 권한 설정을 해 준 뒤 업로드를 할 수 있었다.   배포된 프로젝트 사이트에 접속하기     war 파일이 정상적으로 업로드 되고 프로젝트 폴더도 추출되어서 잘 만들어진 것을 확인했는데 8080으로 접속하면 계속 It works 페이만 뜨는 것이었다. 머선 일이고…2   https://gdtbgl93.tistory.com/m/99 이 글을 참고해서 또 문제를 알았다.   8080 뒤에 /프로젝트명을 붙여줘야 했던 것이었다. 글고보니 폴더가 따로 생성이 되는데 넘 당황해서 저기까지 생각을 못 했었네…ㅎ         이제 진짜로 접속이 잘 되는 것을 확인했다. 신기해!   프로젝트 배포가 잘 되는지만 확인하려고 기본 세팅만 진행했기 때문에 DB연결은 아직 하지 않았다. 내 사이트가 제대로 동작하는지 확인하려면 DB 연결을 해 봐야 하는데 오늘은 시간이 늦어서 내일 마저 해야겠다.  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-30/",
        "teaser": null
      },{
        "title": "컴퓨터 네트워크) Transmission Control Protocol",
        "excerpt":"👀 Transmission Control Protocol     TCP에서 데이터 송수신 시 연결과 흐름 제어 동작을 수행하기 위해 사용되는 프로토콜   UDP에 비해 긴 헤더로 구성되어 있으며 Sequence number와 Acknowledgment number를 이용해 데이터가 전송되었는지 확인하고 흐름을 제어한다.   Sequence number     전송된 세그먼트의 순서로 전체 메세지에서 어느 부분에 해당하는지 구분하는 번호   1, 2, 3, … 순서로 세그먼트가 전송된다고 하면 Sequence number를 통해 지금 받고 있는 부분이 어디쯤인지 알 수 있다.   Acknowledgment number     receiver가 다음에 받아야 하는 Sequence number   receiver가 세그먼트를 받고 나서 다음에 몇 번 세그먼트를 받아야 하는지 sender에게 알려줄 때 사용하는 번호        sender는 receiver로부터 온 Acknowledgment number를 보고 어떤 세그먼트를 보내야 하는지 알 수 있다.       TCP 프로토콜에서 데이터의 송수신은 sequence number와 ACK의 확인으로 이루어지며 중간에 데이터가 누락되었다면 ACK를 통해 몇 번이 누락되었는지 확인하고 재전송 할 수 있다.   flow control     receiver가 수용할 수 있는 속도보다 훨씬 빠른 속도로 보내는 것을 막기 위해 사용된다.   데이터를 보낼 때 데이터를 받을 버퍼의 크기를 미리 제한한 뒤 그만큼씩 보내는 것이다.     Congestion Control     트래픽의 양이 늘어나면 전송 가능한 양이 점점 줄어들어서 나중에는 하나도 보내지 못 하게 된다.   그래서 지속 가능한 서비스를 할 수 있도록 네트워크 상에서 전송되는 데이터의 총량을 제한하는 것이다.   end-to-end와 network-assisted 방식이 있는데 end-to-end의 대표적인 방식은 TCP가 있고 network-assisted에는 ATM이 있다.   AIMD     혼잡이 생기면 congestion window의 크기를 갑자기 줄여서 혼잡을 해결한 후에 다시 크기를 서서히 증가시키는 것   Congestion Window(cwnd)     네트워크가 congestion을 일으키지 않는 한도 내에서 ACK를 받지 않고 보낼 수 있는 데이터의 양   cwnd의 크기는 네트워크 상황에 따라서 유동적으로 조절된다.     한 번 더 비교해보는 TCP vs UDP  TCP     데이터를 주고받을 당사자 간에 연결을 먼저 수립한 다음에 데이터의 송수신을 시작하고 데이터가 정확하게 도착하게 하기 위해서 흐름 제어 동작을 수행하기 때문에 UDP에 비해서는 느리다. 그만큼 데이터가 중간에 누락되지 않고 정확하게 도착하는 것을 보장할 수 있다.   데이터의 정확한 송수신을 요구하는 Email, Web browsing에서 주로 사용된다.   UDP     연결과 흐름 제어를 위한 동작을 수행하지 않고 받은 대로 그냥 보내기 때문에 TCP에 비해서는 빠른 속도를 보여준다. 그만큼 데이터가 정확하게 도착한다는 보장이 없다.   중간에 데이터가 좀 누락되어도 괜찮고 속도가 빠른 것이 더 중시되는 실시간 스트리밍 서비스에서 주로 사용된다.      출처     컴퓨터 네트워킹 - 부산대학교 K-MOOC 공개강의  ","categories": ["Computer Network"],
        "tags": ["CS","Network","Transport"],
        "url": "/computer%20network/computer-network-transmission-control/",
        "teaser": null
      },{
        "title": "JAVA Servlet 프로젝트) Cafe(웹 사이트) 만들기 31 - AWS로 프로젝트 배포하기 2. RDS 연결",
        "excerpt":"개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Eclipse 2021-12   tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.3.4 ~ 2022.4.6      주제     웹 백엔드 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.   회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 한 달   나는 다음 카페를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.   평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.      진행상황     AWA RDS를 사용해서 어제 업로드 했던 war파일과 DB를 연동했다.   MySQL 데이터베이스 생성 및 연결   AWS 웹사이트에 있는 공식 가이드를 따라서 만들었다.(프리티어 버전)   처음에는 어제 만들었던 EC2에 MySQL을 깔아야 하나 했는데 그럴 필요 없이 공식 가이드대로 하니까 내 로컬 MySQL Workbench에서 RDS의 MySQL Workbench로 접속이 되었다. 완전 간편!   EC2에서 RDS에 접근할 수 있도록 보안그룹 설정     https://m.blog.naver.com/scw0531/221440516899   이 글을 참고해서 새로 생성한 RDS의 인바운드 규칙을 설정했다.   어제 만들었던 EC2의 보안그룹 ID를 새 인바운드 규칙으로 추가해 주었다.   DB 데이터 불러오기     프로젝트를 진행하며 만들었던 데이터가 있으니까 이 데이터들을 그대로 넘기기로 했다.   cafedb라는 이름으로 기본 데이터베이스만 하나 생성한 뒤 상단 메뉴의 Server - Date Import에서 내 로컬 컴퓨터에 있는 DB 백업 파일을 선택한 뒤 import 시키니까 바로 들어갔다. 가상 PC에 백업 파일을 옮겨줄 필요도 없고 정말 편하네!      context.xml 수정     어제 배포했던 프로젝트의 DB 연결 정보를 수정해 주었다.   로컬호스트에서 테스트하던 url과 계정정보로 작성되어 있었기 때문에 RDS와 연결이 되지 않았기 때문이다.   FileZilla로 EC2에 접속해 context.xml만 로컬로 다운받은 다음에 접속 정보를 수정해서 다시 업로드 했다.   url은 jdbc:mysql://엔드포인트 이름:3306/cafedb   username과 password는 RDS를 만들면서 설정했던 ID와 비밀번호로 설정했다.      내 프로젝트 사이트 접속해서 확인!         메인 페이지에서 최신글 3개를 보여주는 기능을 만들었는데 내 사이트에 접속하니까 로드가 잘 된다! 감격스러워…   첨부된 이미지가 있으면 썸네일도 보여주도록 했는데 썸네일도 잘 나온다.           게시글 작성도 잘 되고 게시글 첨부파일 다운로드도 잘 되고… 하 정말 감격스럽다! 😭   탄력적 IP 연결     https://jiwontip.tistory.com/43        마지막으로 여기를 참고해서 탄력적 IP도 생성한 후 연결해 주었다.          이렇게 AWS 배포도 끝! 정말 좋은 경험이었다.  ","categories": ["Project Log"],
        "tags": ["Project","Cafe","Log"],
        "url": "/project%20log/cafe-project-31/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 11 그리디 1. 모험가 길드",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 11 - 그리디 1. 모험가 길드     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       한 마을에 모험가가 N명 있다. 모험가 길드에서는 N명의 모험가를 대상으로 ‘공포도’를 측정했는데, ‘공포도’가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다. 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했다.   N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하시오.     입력       첫째 줄에 모험가의 수 N이 주어진다.(1 &lt;= N &lt;= 100,000)   둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분한다.     출력       여행을 떠날 수 있는 그룹 수의 최댓값을 출력한다.      👀 풀이       입력으로 주어지는 배열을 오름차순으로 정렬한 뒤 각 원소의 크기만큼 팀원을 구성할 수 있으면 정답 카운트를 늘리면 된다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Graph","Python"],
        "url": "/boj/CodingTestBook-11-01-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 11 그리디 2. 곱하기 혹은 더하기",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 11 - 그리디 2. 곱하기 혹은 더하기     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 ‘X’ 혹은 ‘+’ 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오. 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정한다.     입력       첫째 줄에 여러 개의 숫자로 구성된 하나의 문자열 S가 주어진다.(1 &lt;= S의 길이 &lt;= 20)     출력       첫째 줄에 만들어질 수 있는 가장 큰 수를 출력한다.      👀 풀이       처음에는 연산에 참여하는 두 수 중 하나라도 0이라면 더하기 연산을 수행하고 나머지는 모두 곱하기 연산을 수행하게 짰다.   책에 나와 있는 예제는 맞았지만 정답 코드를 보니까 두 수 중 하나가 1인 경우를 고려하지 않은 코드였다.   1일 때엔 더하는 것이 곱하는 것보다 더 크기 때문이다.   그래서 최종 수정한 코드는 연산에 참여하는 두 수 중 하나라도 1 이하라면 더하기 연산을 수행하고 나머지는 모두 곱하기 연산을 수행하도록 했다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Graph","Python"],
        "url": "/boj/CodingTestBook-11-02-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 11 그리디 4. 만들 수 없는 금액",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 11 - 그리디 4. 만들 수 없는 금액     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       동네 편의점의 주인인 동빈이는 N개의 동전을 가지고 있다. 이때 N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램을 작성하시오.   예를 들어 N = 3이고, 각 동전이 각각 3원, 5원, 7원짜리 동전이라고 가정하면 만들 수 없는 양의 정수 금액 중 최솟값은 1원이다.     입력       첫째 줄에는 동전의 개수를 나타내는 양의 정수 N이 주어진다.(1 &lt;= N &lt;= 1,000)   둘째 줄에는 각 동전의 화폐 단위를 나타내는 N개의 자연수가 주어지며, 각 자연수는 공백으로 구분한다. 이때 각 화폐 단위는 1,000,000 이하의 자연수이다.     출력       첫째 줄에 주어진 동전들로 만들 수 없는 양의 정수 금액 중 최솟값을 출력한다.      👀 풀이       처음에는 bool 배열을 만들어서 N개의 동전들로 가능한 조합들을 구한 다음 그 조합들의 누적합을 각각 구해서 만들 수 있는 숫자를 체크했다. 그러면 부분 집합에서 생기지 않은 합의 인덱스에는 체크가 되지 않았을 것이니까 해당 인덱스는 false로 남아있을 것이다. false인 인덱스 중에서 가장 작은 값을 출력했다.           근데 이렇게 작성하고 디버깅을 해 보니까 중복되는 조합이 넘 많이 만들어져서 같은 숫자가 나오는 연산이 반복되었다. 그래서 좀 비효율적인 것 같아서 정답코드를 참고했다.   책에 있는 정답 풀이는 target이 될 숫자를 정한 다음 해당 숫자를 만들 수 있다면 target값을 업데이트하고 그렇지 않다면 마지막에 구한 target값이 정답이 되는 것이다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Greedy","Python"],
        "url": "/boj/CodingTestBook-11-04-py/",
        "teaser": null
      },{
        "title": "Python) BOJ 1439. 뒤집기",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1439     제한       시간 제한 : 2 초   메모리 제한 : 128 MB     문제            다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.            예를 들어 S=0001100 일 때,       전체를 뒤집으면 1110011이 된다.   4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.        하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.       문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.     입력       첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.     출력       첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.      👀 풀이       0과 1이 연속된 덩어리가 각각 몇 개인지 센 다음에 더 적은 덩어리의 갯수를 출력한다.     결과       시간 : 72 ms   메모리 : 30840 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1439","Greedy","Python"],
        "url": "/boj/boj1439-py/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 11 그리디 5. 볼링공 고르기",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 11 - 그리디 5. 볼링공 고르기     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       A, B 두 사람이 볼링을 치고 있다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 한다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여된다. 또한 같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주한다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재한다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하시오.     입력       첫째 줄에 볼링공의 개수 N, 공의 최대 무게 M이 공백으로 구분되어 각각 자연수 형태로 주어진다.(1 &lt;= N &lt;= 1,000, 1 &lt;= M &lt;= 10)   둘째 줄에 각 볼링공의 무게 K가 공백으로 구분되어 순서대로 자연수 형태로 주어진다.(1 &lt;= K &lt;= M)     출력       첫째 줄에 두 사람이 볼링공을 고르는 경우의 수를 출력한다.      👀 풀이       처음에는 조합을 구하는 재귀함수를 구현해서 경우의 수를 세는 등 이상하게 코드를 짜다가 안 되서 해설을 봤다.   나의 접근법은 완전히 잘못 되었었다…   같은 무게의 공을 고를 수 없기 때문에 A가 고르는 공의 무게에 따라 B가 고를 수 있는 공의 종류가 달라진다. 게다가 순열이 아닌 조합을 고르는 것이기 때문에 중복되는 조합은 제외시켜가며 경우의 수를 구해야 한다.   그렇기 때문에 입력받은 공의 무게가 각각 몇 개인지 기록해 둔 다음 (A가 고를 수 있는 특정 공의 개수 * 특정 공을 제외한 B가 고를 수 있는 나머지 공의 개수)들을 더해주어야 한다.     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Greedy","Python"],
        "url": "/boj/CodingTestBook-11-05-py/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 무지의 먹방 라이브",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/42891     문제            평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.            그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.       회전판에 먹어야 할 N 개의 음식이 있다.   각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.        무지는 다음과 같은 방법으로 음식을 섭취한다.       무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.   마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.   무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.   다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.   회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.   무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.   무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.   각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.     제한     food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.   k 는 방송이 중단된 시간을 나타낸다.   만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다.   입력       food_times 의 길이는 1 이상 2,000 이하이다.   food_times 의 원소는 1 이상 1,000 이하의 자연수이다.   k는 1 이상 2,000,000 이하의 자연수이다.   food_times 의 길이는 1 이상 200,000 이하이다.   food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다.   k는 1 이상 2 x 10^13 이하의 자연수이다.      👀 풀이       적절한 풀이가 떠오르지 않아서 해설을 참고했다.   모든 음식을 시간 기준으로 오름차순 정렬한 뒤에 시간이 적게 걸리는 음식부터 제거해 나가는 것이 기본 아이디어     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","Programmers","Greedy","Python"],
        "url": "/boj/programmers-muziMukbang-py/",
        "teaser": null
      },{
        "title": "JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 1 - 주제 선정과 역할 분배",
        "excerpt":"   작성일 : 2022.04.14   작성자 : 황유진   팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진   GitHub Repository : https://github.com/miro7923/uno-mas      개발환경     MacBook Air (M1, 2020)   OpenJDK 11   Spring Tool Suite 4.14.0   Tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.4.13 ~ 2022.5.20      주제     웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.   조건은 Spring 기반으로 웹 사이트를 제작하는 것이다.   총 팀원은 7명이며, 우리 팀은 1인 가구를 위한 쇼핑몰을 주제로 정했다.      진행상황  역할 분배     팀장 : 황유진   부팀장 : 오성은   서기 : 반현빈   마감 기한     5/20 으로 정했다.   6월 첫째주에 발표가 예정되어 있지만 발표 전에 강사님들께 최종 점검을 받을 기간이 필요하다고 판단되어서 발표일 보다는 조금 일찍 완성하는 것을 목표로 세웠다.   주제 선정     쇼핑몰과 영화 예매 사이트가 제시되었다.   그 중에서 1인 가구를 위한 쇼핑몰로 최종 결정되었다.   사이트 이름 선정     싱글마켓, 혼자 잘 먹고 잘 사는 방법, 피투피(Person to Person), One Together, Uno más(스페인어로 하나 더) 등이 제시되었다.   Uno más가 최종 선정되었다.   팀 이름 선정     4월에 시작해서 April이 제시되었다. 이 외에 추가적으로 제시된 이름이 아직 없어서 아이디어가 더 나오면 의견 조율해서 최종 결정할 예정이다.   변수명 및 코드 작성 규칙     변수명은 기본적으로 카멜 표기법(codeCode) 형식으로 쓰되, CSS 적용을 위한 선택자를 지정할 때엔 스네이크 표기법(code_code)을 사용하기로 했다.   이렇게 정한 이유는 CSS 파일에서 카멜 표기법으로 선택자를 작성했을 때엔 알아보기 어려웠다는 의견이 있었기 때문이다.   추가로 무의미한 변수명과 지나친 축약어로 만든 변수명은 사용은 하지 않기로 했다. 만약 정말 변수명을 못 정하겠다면 https://www.curioustore.com/#!/ 여기를 참고할 것   코드 작성 시 다른 팀원이 보다 쉽게 알아볼 수 있게 주석으로 작성의도를 작성하기로 했다.   GitHub Repository 생성 및 개발일지 작성     형상관리를 위해 GitHub을 사용하기로 했다.   추후 프로젝트 진행 결과 정리 및 발표 자료를 만들 때 참고하기 위해서 기능을 구현할 때마다 개발 일지를 작성하기로 했다.   본인이 구현한 내용은 꼭 정확하게 그때그때 기록해 놓기!!!   TDD 주도 개발     수업시간에 TDD 코드 작성 방법을 배웠기 때문에 기능 구현 전에 테스트 코드 작성을 통해 구현하고자 하는 기능의 테스트 후 본 코드를 작성할 것이다.   필요 기능 정의서     제작자 : 박승지         무료로 사용할 수 있는 쇼핑몰 템플릿을 이 기능 명세서에 맞게 변형해서 사용하기로 했다.   https://freemiumdownload.com/demo?theme=fashi   https://technext.github.io/ogani/index.html   DB 테이블 설계     설계자 : 오성은, 황유진   4/17 까지 설계를 마친 후 4/17 오후 10시에 모든 팀원들이 온라인 미팅으로 모여서 검토하고 최종 결정할 것이다.   때문에 회원가입과 게시판 등 DB 테이블이 필요한 기능은 DB 테이블이 최종 결정되면 진행하고 그 외의 기능들은 지금부터 진행하기로 했다.   1차 구현 기능 분배     목표 : 5/22 까지 구현 후 5/22 저녁에 리뷰   메인 페이지 디자인 : 반현빈, 박승지   회원가입/로그인/로그아웃/탈퇴 기능 구현 : 오은현, 오성은   메인 페이지에서 상품 상세 페이지 연결 및 상세 페이지의 세부 기능 구현(수량 증감, 상품 설명 디스플레이, 후기/문의 게시판) : 황유진, 박승지   고객센터 페이지의 게시판 구현(공지사항, 자주하는 질문, 1:1 문의) : 김진영, 윤정환   글쓰기 페이지 디자인 : 윤정환   헤더와 푸터 구성 및 클릭 시 해당 페이지로 연결 : 반현빈      마감까지     D-36  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/uno-mas-dev-log-01/",
        "teaser": null
      },{
        "title": "Python) 이것이 취업을 위한 코딩테스트다 12 구현문제 8. 문자열 재정렬",
        "excerpt":"문제 출처       이것이 취업을 위한 코딩테스트다 with 파이썬   Chapter 12 - 구현문제 8. 문자열 재정렬     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제       알파벳 대문자와 숫자(0 ~ 9)로만 구성된 문자열이 입력으로 주어진다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력한다.     입력       첫째 줄에 하나의 문자열 S가 주어진다. (1 &lt;= S의 길이 &lt;= 10,000)     출력       첫째 줄에 문제에서 요구하는 정답을 출력한다.      👀 풀이       입력받은 문자열을 순회하면서 숫자와 문자를 따로 저장한다.   문자를 따로 저장한 문자열 뒤에 숫자들의 합을 더해서 출력하면 정답을 만들 수 있다.     코드      ","categories": ["AlgorithmStudy"],
        "tags": ["Algorithm","Implementation","Python"],
        "url": "/algorithmstudy/CodingTestBook-12-08-py/",
        "teaser": null
      },{
        "title": "Python) BOJ 18406. 럭키 스트레이트",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/18406     제한       시간 제한 : 1 초   메모리 제한 : 256 MB     문제            어떤 게임의 아웃복서 캐릭터에게는 럭키 스트레이트라는 기술이 존재한다. 이 기술은 매우 강력한 대신에 항상 사용할 수는 없으며, 현재 게임 내에서 점수가 특정 조건을 만족할 때만 사용할 수 있다.            특정 조건이란 현재 캐릭터의 점수를 N이라고 할 때 점수 N을 자릿수를 기준으로 반으로 나누어 왼쪽 부분의 각 자릿수의 합과 오른쪽 부분의 각 자릿수의 합을 더한 값이 동일한 상황을 의미한다. 예를 들어 현재 점수가 123,402라면 왼쪽 부분의 각 자릿수의 합은 1+2+3, 오른쪽 부분의 각 자릿수의 합은 4+0+2이므로 두 합이 6으로 동일하여 럭키 스트레이트를 사용할 수 있다.            현재 점수 N이 주어졌을 때, 럭키 스트레이트를 사용할 수 있는 상태인지 아닌지를 알려주는 프로그램을 작성하시오. 럭키 스트레이트를 사용할 수 있다면 “LUCKY”를, 사용할 수 없다면 “READY”라는 단어를 출력한다. 또한 점수 N의 자릿수는 항상 짝수 형태로만 주어진다. 예를 들어 자릿수가 5인 12,345와 같은 수는 입력으로 들어오지 않는다.         입력       첫째 줄에 점수 N이 정수로 주어진다. (10 ≤ N ≤ 99,999,999) 단, 점수 N의 자릿수는 항상 짝수 형태로만 주어진다.     출력       첫째 줄에 럭키 스트레이트를 사용할 수 있다면 “LUCKY”를, 사용할 수 없다면 “READY”라는 단어를 출력한다.      👀 풀이       점수를 문자열로 입력받아서 앞부분과 뒷부분을 나눠서 따로 계산한 다음 변수에 각각 저장했다. 두 변수의 값이 같으면 LUCKY를 출력하고 아니라면 READY를 출력한다.     결과       시간 : 72 ms   메모리 : 30840 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No18406","Implementation","Python"],
        "url": "/boj/boj18406-py/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 문자열 압축",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/60057     문제       데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.        간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.            예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.            다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.       압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.     제한       s의 길이는 1 이상 1,000 이하입니다.   s는 알파벳 소문자로만 이루어져 있습니다.      👀 풀이       옛날에 C++로 풀었던 문제인데 풀이가 기억나지 않아서… 옛날 코드를 참고했다.   1) 문자열의 처음부터 한 글자씩 늘려가면서 비교 대상이 될 부분 문자열을 구한다.   2) 위에서 구한 문자열의 다음 문자부터 위의 문자열과 같은 길이만큼 부분 문자열을 구한 다음에 둘을 비교한다.   둘이 같다면 카운트를 증가시키고 아니라면 현재까지 증가된 카운트를 압축된 문자열에 더한다. 그 뒤에 1)에서 구한 부분 문자열을 더한다. 그 다음엔 1)에서 구한 비교 대상 부분 문자열을 2)에서 구한 부분 문자열로 교체한다. 카운트를 1로 초기화 시킨다.   마지막 문자까지 비교가 끝나면 최종적으로 압축된 문자열을 구할 수 있다. 원래 문자열 길이와 최종 압축된 문자열의 길이 중 더 짧은 것을 정답으로 저장한다.   이 과정을 1)의 부분 문자열의 길이가 원본의 절반이 될 때까지 반복한다.   절반까지만 반복하는 이유는 1)의 부분 문자열의 길이가 절반을 넘어가면 어차피 압축할 수 없기 때문이다. 그래서 절반을 초과해서 반복문을 돌리는 것은 의미가 없다.     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Implementation","Python"],
        "url": "/programmers/programmers-compress-str-py/",
        "teaser": null
      },{
        "title": "Python) 파이썬에서 문자열 내의 문자 정렬",
        "excerpt":"이 글을 작성하게 된 이유     평화롭게 알고리즘 문제를 풀다가 문자열 내부의 문자들을 정렬해야 하는 경우가 생겼는데 sorted()로 정렬이 되지 않았다. 그래서 구글 검색!     파이썬에서의 정렬 함수     파이썬에서 정렬하려면 sort()와 sorted() 두 가지 함수를 이용할 수 있다.   그 중에서도 sort()는 리스트의 멤버함수이기 때문에 리스트를 정렬하고자 하는 경우에는 arr.sort()를 사용하면 간편하게 정렬할 수 있다.   리스트가 아닌 iterable을 정렬할 때엔 sorted() 함수를 쓰면 되는데 dabc와 같은 문자열 안에 있는 문자들을 정렬해서 abcd로 만들려고 할 때에는 그냥 sorted()를 쓰면 정렬이 안 된다.     문자열 내의 문자 정렬하기     그러면 어떻게 해야 할까? 파이썬에서의 string 멤버함수에는 sort()가 없다.   왜냐면 string의 경우 문자열 첫 글자로 주소값으로 참조를 하기 때문에 원본이 변경되면 해당 문자열을 찾을 수 없게 된다.   s1 = sorted(s)      대신 sorted(s)를 사용할 수 있는데 sorted()의 반환형이 list이기 때문에 정렬된 결과를 보려면 위와 같이 다른 변수에 대입하는 식을 써야 한다.   하지만 나는 처음에 그냥 sorted(s) 라고만 쓰고 다른 변수에 저장조차 하지 않았기 때문에 정렬된 결과를 볼 수 없는 것이었다.😅   이것을 하나의 문자열로 만들기 위해서는 str = ''.join(sorted(s))와 같이 쓰면 된다.      출처     파이썬 문자열 정렬, 문자열 리스트 정렬, anagram 찾기  ","categories": ["Python"],
        "tags": ["Python","Sorting"],
        "url": "/python/python-sort-string/",
        "teaser": null
      },{
        "title": "Python) BOJ 3190. 뱀",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/3190     제한       시간 제한 : 1 초   메모리 제한 : 128 MB     문제            ‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.            게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.            뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.       먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.   만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.   만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.   사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.     입력            첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)            다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.            다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)            다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 ‘L’) 또는 오른쪽(C가 ‘D’)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.         출력       첫째 줄에 게임이 몇 초에 끝나는지 출력한다.      👀 풀이       풀이 과정에서 여러 시행착오를 겪었는데, 가장 큰 것은 문제 이해를 잘못 한 것이었다.   게임은 뱀이 벽에 부딪힐 때나 몸에 부딪혔을 때 끝나고 입력으로 주어지는 방향 정보는 방향을 전환한 시간과 방향값만 주어지지 언제 벽에 부딪혔다는 정보는 주지 않는다. 즉 방향 정보가 끝나도 뱀은 계속 이동하고 있어야 한다. 하지만 처음에는 방향 정보 개수 L만큼만 반복문을 돌렸기 때문에 항상 방향 정보로 주어지는 시간의 최대값 안에서 끝이 났다. 이것 때문에 시간을 많이 썼다.🥲   그렇기 때문에 뱀은 무한루프 속에서 이동해야 하며 종료 조건일 때에만 반복문을 탈출하도록 해야 한다.   플레이 중에는 방향을 전환하는 시간 전 까지는 같은 방향으로 이동하면서 뱀을 이동시켜 주고 방향을 전환하는 시간이 되면 방향을 바꾼 후 이동을 반복한다.     결과       시간 : 76 ms   메모리 : 30840 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No3190","Implementation","Python"],
        "url": "/boj/boj3190-py/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 자물쇠와 열쇠",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/60059     문제            고고학자인 “튜브”는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다.            잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다.            자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.            열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.         제한       key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.   lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.   M은 항상 N 이하입니다.   key와 lock의 원소는 0 또는 1로 이루어져 있습니다.   0은 홈 부분, 1은 돌기 부분을 나타냅니다.      👀 풀이       입력 배열의 크기가 작아서 완전탐색으로 찾으면 될 거 같은데 구체적인 방법이 떠오르지 않아서 책(이것이 취업을 위한 코딩테스트다)에 있는 해설을 봤다.   내가 고민했던 것은 열쇠를 회전만 하는 것이 아니라 상하좌우로 움직일 수 있는 것을 어떻게 구현하느냐 였다.   답은 간단했는데 자물쇠 배열을 3배로 확장한 후 반복문으로 열쇠를 확장한 배열의 처음부터 끝까지 한 칸씩 이동시키면서 자물쇠가 채워지는지 보는 것이었다. 이렇게 하면 회전시키는 것 뿐만 아니라 상하좌우로 이동시키는 것도 간단하게 구현할 수 있다.   자물쇠와 열쇠에서 채워진 곳은 1, 빈 곳은 0으로 표시되기 때문에 자물쇠 영역이 모두 1로만 채워진다면 True를 반환하고 하나라도 0이 있거나 2가 있으면 풀 수 없는 자물쇠이기 때문에 False를 반환하면 된다.     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Implementation","Python"],
        "url": "/programmers/programmers-lock-and-key-py/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 기둥과 보 설치",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/60061     문제       빙하가 깨지면서 스노우타운에 떠내려 온 “죠르디”는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. “죠르디”는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다.        프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다.       기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.   보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.        단, 바닥은 벽면의 맨 아래 지면을 말합니다.       2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다.              예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다.       (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다.   (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다.   (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다.   (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다.        만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다.       벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.     제한       n은 5 이상 100 이하인 자연수입니다.   build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.   build_frame의 가로(열) 길이는 4입니다.   build_frame의 원소는 [x, y, a, b]형태입니다.   x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.   a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.   b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.   벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.   바닥에 보를 설치 하는 경우는 없습니다.   구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.   구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.   최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.   return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.   return 하는 배열의 원소는 [x, y, a] 형식입니다.   x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.   기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.   a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.   return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.   x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.      👀 풀이       처음엔 설치와 삭제를 할 때 주변 상황이 조건에 맞는지 확인한 후 동작을 수행하려 했다. 그런데 그렇게 하니까 코드 작성이 까다로워지고 내가 헷갈렸다. 그래서 해설을 참고했다.   풀이는 의외로 아주 간단했는데 입력의 수가 1,000개로 비교적 적고 시간 제한이 5초로 넉넉한 편이라 O(M^3) 알고리즘으로도 풀이가 가능했다. 바로 설치와 삭제를 할 때마다 일단 동작을 수행한 후에 전체 구조물을 검사해서 가능한 구조물이면 넘어가고 그렇지 않으면 수행했던 동작을 취소하는 것이다. 이걸 어렵게 생각하다니…🥲     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Implementation","Python"],
        "url": "/programmers/programmers-pillar-and-plate-py/",
        "teaser": null
      },{
        "title": "GitHub로 팀 프로젝트 관리하는 방법",
        "excerpt":"   작성자 : 황유진        글 작성 도움 : 오은현       GitHub로 팀 프로젝트를 처음 진행할 때의 막막함을 덜고 나 스스로도 사용법을 정리하기 위해 작성한 글이다.   함께 참고하면 좋은 글   Feature Branch Workflow     🎬 시작 전에 팀장이 할 일       새 프로젝트용 레포지토리 생성 후 함께 할 팀원들의 GitHub 메일 주소를 Collaborator에 추가한다.     팀원들이 팀 레포지토리에 참여하기     메일로 Collaborator 초대를 받은 뒤 Accept invitation을 눌러 수락하면 내 레포지토리 목록에 자동으로 추가된다.   [Git]GitHub Collaborator 추가하기        그림과 함께 보고 싶으면 위 링크 참고       ❗️ 참고로 Collaborator로 참여하면 내 레포지토리 목록에는 보이지 않는다.         팀장의 레포지토리 상단에서 pin을 클릭하면 즐겨찾기에 추가된다.         내 GitHub 프로필 메인으로 가면 아까 pin했던 레포지토리 목록을 볼 수 있다. 이걸로 원격저장소에 찾아오면 된다.   원격저장소는 하나만 존재하고 이걸 내 컴퓨터로 다운받아서 로컬저장소에서 각자 작업한 후에 원격저장소로 합치는 개념이다.        [맥 OS 기준] 레포지토리를 다운받을 폴더를 선택한 뒤 폴더에서 새로운 터미널 열기를 선택하거나   [윈도우 OS 기준] 윈도우 탐색기를 열어서 다운받을 폴더로 이동한 뒤 해당 폴더의 주소를 복사한다. 그 다음 cmd(명령 프롬프트)를 켜서   cd 아까 복사한 폴더 경로      위 명령어를 입력한 후 엔터를 누르면 해당 폴더로 이동할 수 있다.   이제 아까전에 자동으로 복사되었던 레포지토리로 다시 돌아간다.        원격저장소에 있는 레포지토리를 내 로컬 컴퓨터로 다운받아야 한다.   초록색 Code 버튼을 클릭하면 이 레포지토리의 주소를 볼 수 있다.        주소를 복사한다.      git clone 복사한 레포지토리 주소     위 사진처럼 명령어를 입력하고 복사한 주소를 붙여넣은 뒤 엔터를 누르면 내 컴퓨터로 레포지토리가 다운로드 된다.   이제 내 컴퓨터에서 작업한 파일을 레포지토리 폴더에 넣은 다음 명령어 몇 가지만 입력하면 GitHub 사이트에 있는 레포지토리(원격 저장소)로 업로드 할 수 있다.     나의 작업물을 원격 저장소에 업로드 하기     작업이 끝나고 나면 결과물을 합쳐야 한다.        브랜치는 같은 저장소에서 만들어진 소규모 공간이라고 생각하면 편하다. 그 중에서 대표 공간이 main 브랜치이다. 우리의 완성물은 main 브랜치에만 존재하게 할 것이다.   내 작업물을 내 컴퓨터에 있는 레포지토리 폴더(로컬저장소)에 넣은 다음 main 브랜치로 push하면 내 작업물을 합칠 수 있는데 main 브랜치에는 완성물만 있어야 하기 때문에 그냥 합치면 안 되고 작업물에 문제가 없다는 것이 확인되었을 때 main 브랜치로 합쳐야 한다.   그런데 그 전까지 각자 컴퓨터에 작업물을 가지고 있으면 다른 팀원과 함께 확인하는 것이 굉장히 불편하다. 내가 쓴 코드를 카톡이나 메일로 공유하지 않고 편할 때 접속할 수 있는 GitHub의 원격 저장소에서 확인할 수 있으면 훨씬 편할 것이다. 이 때 새로운 브랜치를 하나 만들어서 거기에다 push하는 것이다.(줌에서 소회의실 만들어서 몇 명씩 모여 회의하는 느낌으로…)        그러면 다른 사람들도 새로 생긴 브랜치에 push된 내용을 GitHub의 원격 저장소에서 확인하고 코드에 댓글도 달 수 있다. 여기서 문제가 없는 것이 확인되면 main 브랜치로 merge 요청을 하면 된다. 팀장이 승낙하면 main 브랜치로 합쳐진다.       이걸 하려면 먼저 내 로컬저장소가 main 브랜치의 최신 버전과 동기화가 되어 있어야 한다.   내 로컬저장소 최신버전으로 업데이트   git checkout main   // main branch로 이동 git pull            // 내 로컬저장소의 main 브랜치를 최신버전으로 업데이트      원격 저장소에 업로드하기 전에 꼭 이 과정을 먼저 거친 후에 다음 과정을 진행해야 한다.   안 그러면 과거 버전과 충돌해서 업로드가 제대로 되지 않을 수 있다. 이렇게 되면 고치기 좀 복잡해지니까… 꼭 main 브랜치 최신버전 업데이트부터 하고 시작하자!   개인용 브랜치 생성   git checkout main             // main 브랜치로 이동 git checkout -b 새 브랜치 이름    // 새 브랜치 생성 후 그 브랜치로 이동         새 브랜치가 생성되고 바꿨다고 하는데 터미널 환경이라 이게 제대로 된건지 아닌지 알쏭달쏭할 수 있다.   git branch -a   // 로컬저장소(내 컴퓨터)에 생성되어 있는 브랜치 확인         위 명령어를 입력해 보면 현재 내 로컬저장소에 생성된 브랜치들을 확인할 수 있다.   초록색 별 표시된 것이 현재 사용 중인 브랜치라는 뜻   git branch -r   // 원격저장소(GitHub)에 생성되어 있는 브랜치 확인         원격저장소에 생성되어 있는 브랜치를 확인하고 싶으면 위 명령어를 입력하면 된다.   아직 commit과 push를 진행하지 않았기 때문에 원격저장소에는 아까 만든 브랜치가 없다.   git branch --set-upstream-to origin/main         새 브랜치를 만들었으면 이걸 사용해서 원격저장소에 업로드를 하겠다고 알려줘야 한다. 위 명령어를 입력하면 GitHub이 OK 하고 새 브랜치를 등록시켜 준다.   새 브랜치를 만들었을 때 한 번만 하면 된다.   git checkout 내 브랜치 이름      다음부터는 위 명령어만 입력해서 내 개인 브랜치로 바꾸면 된다.   작업물 업로드하기     작업물 업로드 전에   git checkout 내 브랜치 이름      이걸 입력해서 꼭 개인 브랜치로 바꾼 후에 업로드 하자!!!         이런 식으로 로컬저장소에 들어있는 파일을 수정하거나 새로 생성하면 내 로컬저장소에 있는 GitHub 폴더가 자동으로 알아차린다.   git status  // 현재 로컬저장소 상태 보기         위 명령어를 입력하면 새롭게 추가되거나 변경된 파일 목록을 보여준다.   git add .   // 로컬저장소에 있는 모든 파일 추가 git commit -m \"[yujin] README 수정\"  // 방금 추가한 파일들 업로드 준비 - 누가 어떤 내용을 수정/추가해서 올리는지 작성         위 명령어들을 입력하면 원격저장소에 업로드 될 준비가 완료된다.   git push origin 내 브랜치 이름         위 명령어를 입력하면 드디어 원격저장소에 업로드가 된다!         원격저장소로 와서 보면 아깐 없었던 브랜치가 생긴 것을 볼 수 있다. 그리고 아까 수정했던 리드미 파일의 변경사항도 적용되지 않았다.         새로 만든 브랜치로 와 보면 아까 수정했던 내용이 적용된 것을 볼 수 있다. 브랜치를 이용하면 이런 식으로 같은 공간에서 버전을 나누어서 관리할 수 있다.      다른 팀원 코드 확인하고 피드백 댓글달기     팀원이 어떤 코드를 추가하고 삭제했는지 확인하고 거기에 댓글을 달 수 있다.   댓글을 작성하면 해당 팀원에게 댓글이 달렸다는 알림 메일이 발송된다.         작업물을 확인할 팀원의 브랜치로 이동한 후 commit 메세지를 클릭하면 가장 최근 commit 내역으로 이동할 수 있다.         파란색 +가 보이는 자리에 마우스 오버하면 저 버튼이 생긴다. 클릭하면 댓글창이 나온다.         혹은 맨 아래에 있는 댓글창을 이용해서 댓글을 작성할 수도 있다.   각 작업물에 이렇게 피드백을 해 주자.   여기서 이상 없는 것이 확인 되었으면 main 브랜치로 합치면 된다.     main 브랜치로 작업물 합치기         내 개인 브랜치로 push를 하고 나면 상단에 Compare &amp; pull request 버튼이 생긴 것을 볼 수 있다.         브랜치 화살표 방향 잘 확인한 다음 Create pull request 버튼을 클릭한다. 추가로 작성할 메시지가 있다면 작성하면 된다.         그러면 이렇게 pull request가 작성된다. 팀장이 확인 후 merge를 최종 수락하면 합치는 것이 완료된다.                     짠! merge 후 main 브랜치에 최종 반영된 것을 볼 수 있다.            이후에 또 새로운 작업물을 업로드 해야 하면 내 로컬저장소 최신버전으로 업데이트부터 반복하면 된다.          출처     [ 깃허브 ] github 브랜치 만들고 업로드 하기   [pintOS] github으로 팀프로젝트 관리하기 (pintOS 팀플 맞춤)   [Git]GitHub Collaborator 추가하기   Feature Branch Workflow  ","categories": ["Uno mas"],
        "tags": ["Log","Project","UnoMas"],
        "url": "/uno%20mas/teamwork-by-github/",
        "teaser": null
      },{
        "title": "Python) BOJ 15686. 치킨 배달",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/15686     제한       시간 제한 : 1 초   메모리 제한 : 512 MB     문제            크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.            이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 “치킨 거리”라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.                                       임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는           r1-r2           +           c1-c2           로 구한다.                                예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.       0 2 0 1 0   1 0 1 0 0   0 0 0 0 0   0 0 0 1 1   0 0 0 1 2        0은 빈 칸, 1은 집, 2는 치킨집이다.                                       (2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는           2-1           +           1-2           = 2, (5, 5)에 있는 치킨집과의 거리는           2-5           +           1-5           = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.                                                           (5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는           5-1           +           4-2           = 6, (5, 5)에 있는 치킨집과의 거리는           5-5           +           4-5           = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.                                이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.       도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.     입력            첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.            둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.            도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.         출력       첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.      👀 풀이       치킨집을 최대 M개를 선택하다는 말 때문에 1개 이상 M개까지 선택할 수 있다는 말인 줄 알고(최종적으로 선택 가능한 치킨집의 개수가 변하는 것…) 그걸 다 어떻게 처리하느냐는 고민에 빠졌었다. 알고보니 쓸데 없는 고민이었다…   전체 치킨집 중에서 그냥 M개를 선택하는 것으로 X개의 치킨집 중에서 M개의 치킨을 고르는 경우의 수를 구하는 것이었다. 즉 xCr 조합을 구하면 되는 것이었다.   그 다음엔 조합들을 대상으로 각 집들의 치킨거리를 구해 치킨거리의 합을 구한다. 그 중에서 최솟값을 출력하면 정답이다.     결과       시간 : 440 ms   메모리 : 30840 KB     코드      ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No15686","Implementation","Python"],
        "url": "/boj/boj15686-py/",
        "teaser": null
      },{
        "title": "JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 2 - Spring Legacy 프로젝트를 위한 .gitignore 설정",
        "excerpt":"   작성일 : 2022.04.20   작성자 : 황유진   팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진   GitHub Repository : https://github.com/miro7923/Uno-Mas      개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Spring Tool Suite 4.14.0   Spring framework 4.3.1.RELEASE   Tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.4.13 ~ 2022.5.20      주제     웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.   조건은 Spring 기반으로 웹 사이트를 제작하는 것이다.   총 팀원은 7명이며, 우리 팀은 1인 가구를 위한 쇼핑몰을 주제로 정했다.      진행상황     Spring Legacy Project로 프로젝트를 진행하게 됨에 따라 GitHub 원격저장소에서 파일을 공유할 때 시스템 환경설정 파일은 함께 공유 되지 않아야 할 필요가 있었다.   하지만 아무 처리를 하지 않으면 각종 시스템 환경설정파일이 함께 업로드 되기 때문에 .gitignore 설정을 해줘야 했는데 유명한 .gitignore를 만들어주는 사이트에서 만드는 버전으로는 좀 한계가 있었다. STS에서 커밋을 하려고 할 때 .classpath같은 파일들이 제외되지 않았기 때문이다.   .gitignore 1차 설정     https://lsjsj92.tistory.com/566   처음엔 위 글을 참고하여 https://www.toptal.com/developers/gitignore 이 사이트에서 만들었는데 좀 부족했다.   STS에서 커밋을 하려고 하니 .classpath, MINIFEST.MF와 같은 파일들이 제외되지 않았기 때문이다. 나 혼자 하는 프로젝트면 알아서 걸러내고 하면 되겠지만 팀으로 하는 프로젝트이기 때문에 누군가는 저 파일들을 실수로 업로드를 할 것이다. 그렇기 때문에 저것들이 처음부터 제외되도록 .gitignore를 수정해야 했다.   .gitignore 2차 설정     Spring Legacy 프로젝트에서 사용한 .gitignore 파일   위 글을 참고하여 gitignore를 다시 한 번 설정했다.   나는 맥 OS를 쓰지만 나머지 팀원들은 모두 윈도우 OS를 사용하기 때문에 각각 운영체제의 환경설정 파일도 제외하는 코드를 추가했다.   # Created by https://www.toptal.com/developers/gitignore/api/windows,macos,eclipse,java # Edit at https://www.toptal.com/developers/gitignore?templates=windows,macos,eclipse,java  mybatis-config.xml log4j.xml  lecture target pom.properties .classpath MANIFEST.MF  ### Eclipse ### .metadata bin/ tmp/ *.tmp *.bak *.swp *~.nib local.properties .settings/ .loadpath .recommenders  # External tool builders .externalToolBuilders/  # Locally stored \"Eclipse launch configurations\" *.launch  # PyDev specific (Python IDE for Eclipse) *.pydevproject  # CDT-specific (C/C++ Development Tooling) .cproject  # CDT- autotools .autotools  # Java annotation processor (APT) .factorypath  # PDT-specific (PHP Development Tools) .buildpath  # sbteclipse plugin .target  # Tern plugin .tern-project  # TeXlipse plugin .texlipse  # STS (Spring Tool Suite) .springBeans  # Code Recommenders .recommenders/  # Annotation Processing .apt_generated/ .apt_generated_test/  # Scala IDE specific (Scala &amp; Java development for Eclipse) .cache-main .scala_dependencies .worksheet  # Uncomment this line if you wish to ignore the project description file. # Typically, this file would be tracked if it contains build/dependency configurations: #.project  ### Eclipse Patch ### # Spring Boot Tooling .sts4-cache/  # Eclipse Core .project  # IDT-specific (Eclipse Java Development Tools) .classpath  ### Java ### # Compiled class file *.class  # Log file *.log  # BlueJ files *.ctxt  # Mobile Tools for Java (J2ME) .mtj.tmp/  # Package Files # *.jar *.war *.nar *.ear *.zip *.tar.gz *.rar  # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml hs_err_pid* replay_pid*  ### macOS ### # General .DS_Store .AppleDouble .LSOverride  # Icon must end with two \\r Icon   # Thumbnails ._*  # Files that might appear in the root of a volume .DocumentRevisions-V100 .fseventsd .Spotlight-V100 .TemporaryItems .Trashes .VolumeIcon.icns .com.apple.timemachine.donotpresent  # Directories potentially created on remote AFP share .AppleDB .AppleDesktop Network Trash Folder Temporary Items .apdisk  ### macOS Patch ### # iCloud generated files *.icloud  ### Windows ### # Windows thumbnail cache files Thumbs.db Thumbs.db:encryptable ehthumbs.db ehthumbs_vista.db  # Dump file *.stackdump  # Folder config file [Dd]esktop.ini  # Recycle Bin used on file shares $RECYCLE.BIN/  # Windows Installer files *.cab *.msi *.msix *.msm *.msp  # Windows shortcuts *.lnk  # End of https://www.toptal.com/developers/gitignore/api/windows,macos,eclipse,java      이렇게 수정하고 STS에서 다시 커밋을 시도해 보니까 소스파일만 깔끔하게 Staging 목록에 나타난다.       출처     https://lsjsj92.tistory.com/566   Spring Legacy 프로젝트에서 사용한 .gitignore 파일      마감까지     D-30  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/uno-mas-dev-log-02/",
        "teaser": null
      },{
        "title": "JSP & Servlet) 영역객체(Scope) - Page, Request, Session, Application 차이",
        "excerpt":"   👀 영역객체(Scope)란?     JSP 내장객체로 특정 공간(Scope)에 정보를 저장하고, 저장된 정보(Attribute)를 공유할 수 있는 객체           4가지 영역별 차이     Page : 페이지 내에서만 지역 변수처럼 사용할 수 있다.   Request : 한 페이지에서 다른 페이지로 전달해서 사용할 수 있다.   Session : 웹 브라우저의 상태가 유지되는 동안 사용 가능하다.   Application : 웹 어플리케이션에 있는 모든 대상이 사용 가능하다.   Page     Page 영역 안에서만 사용 가능. 지역 변수 개념   영역객체 : pageContext   사용범위 : 해당 JSP 페이지 (다른 페이지로 넘겨줄 수 없다)   JSP에서 pageScope에 값을 저장한 후 해당 값을 EL표기법, JSTL에서 사용할 때 사용된다.   Request     어떤 페이지에 있는 값을 서블릿이나 다른 페이지로 넘겨주고 싶을 때 사용할 수 있다.   영역객체 : JSP 페이지) request / 서블릿) HttpServletRequest   사용범위 : 클라이언트 요청이 처리되는 페이지   값을 저장할 때엔 request.setAttribute(\"속성명\", 값) 메서드를 사용한다.   저장된 값을 꺼내올 때엔 request.getAttribute(\"속성명\") 메서드를 사용한다.   GET/POST 방식으로 날아온 데이터를 가져올 때엔 getParameter(\"파라미터 이름\") 메서드를 사용한다.   forward시 값을 유지하고자 사용한다.   Session     로그인 한 회원의 상태유지와 같이 웹 브라우저에서 상태가 지속적으로 유지되어야 할 필요가 있을 때 사용한다.   영역객체 : JSP 페이지) session / 서블릿) HttpServletRequest의 getSession() 메서드를 사용해 얻음   사용범위 : 세션이 유지되는 동안   값을 저장할 때엔 session.setAttribute(\"속성명\", 값) 메서드를 사용한다.   저장된 값을 꺼내올 때엔 session.getAttribute(\"속성명\") 메서드를 사용한다.   session 지속시간이 만료되거나 웹 브라우저가 종료되면 사라진다.   웹 브라우저의 탭 간에는 공유되기 때문에 각각의 탭에서 같은 세션 정보를 사용할 수 있다.   Application     웹 어플리케이션이 시작되고 종료되는 동안 사용할 수 있다.   영역객체 : JSP 페이지) application / 서블릿) getServletContext() 메서드를 사용해 얻음   사용범위 : 웹 애플리케이션(서버)이 실행되는 동안   값을 저장할 때엔 application.setAttribute(\"속성명\", 값) 메서드를 사용한다.   저장된 값을 꺼내올 때엔 application.getAttribute(\"속성명\") 메서드를 사용한다.   모든 클라이언트가 공통으로 사용해야 할 값이 있을 때 사용한다. (클라이언트가 바뀌어도 누적된다)      참고     Scope - Page, Request, Session, Application  ","categories": ["JSP"],
        "tags": ["JSP","Servlet","Scope"],
        "url": "/jsp/JSP-servlet-scope/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 외벽 점검",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/60062     문제            레스토랑을 운영하고 있는 “스카피”는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.            레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.            외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.         제한       n은 1 이상 200 이하인 자연수입니다.   weak의 길이는 1 이상 15 이하입니다.   서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.   취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.   weak의 원소는 0 이상 n - 1 이하인 정수입니다.   dist의 길이는 1 이상 8 이하입니다.   dist의 원소는 1 이상 100 이하인 자연수입니다.   친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.      👀 풀이       처음엔 수리지점 한 군데에서 시계방향과 반시계방향으로 돌았을 때 더 짧은 거리를 찾아서 거리배열에서 그 거리와 합이 같거나 커지는 원소들의 개수를 찾으려 했다. 하지만 2번 예제에서만 통하고 1번 예제에서는 통하지 않았음…   그리하여 참고한 해설은 일단 외벽 배열을 원형탐색할 수 있게 확장한 다음 거리배열의 순열을 구해서 각 경우마다 몇 명을 보내면 외벽 수리를 마칠 수 있는지 확인하는 것이다. 원형배열로 확장하는 부분에 대한 아이디어가 없어서 헤멨는데 이걸 알고 나니까 조금 이해가 수월했다.   순열을 구하는 함수는 재귀로 직접 구현한 함수와 itertools에서 제공되는 함수 둘 다 써 봤는데 이 문제에서는 재귀로 직접 구현한 함수가 더 빨랐다.     코드    재귀로 순열 함수 구현한 코드     itertools의 순열 함수 사용한 코드     ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Implementation","Python"],
        "url": "/programmers/programmers-maintenance-wall/",
        "teaser": null
      },{
        "title": "Spring MVC Project) css, js 파일 경로 설정",
        "excerpt":"      Spring MVC 프로젝트를 배우면서 기존에 사용하던 JAVA JSP 프로젝트와는 약간 달라져서 헷갈리는 것이 많았는데 그 중 하나가 css와 js 파일 경로 설정이었다.      Overview         한 줄 요약하자면 css와 js 같은 리소스 파일들은     src/main/webapp/resources                경로에 있어야 하고       html/jsp와 같은 view 파일들은     src/main/webapp/WEB-INF/views           경로에 존재해야 한다.   servlet-context.xml  &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory --&gt; &lt;resources mapping=\"/resources/**\" location=\"/resources/\" /&gt;  &lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt; &lt;beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;     &lt;beans:property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt;     &lt;beans:property name=\"suffix\" value=\".jsp\" /&gt; &lt;/beans:bean&gt;      해당 내용은 servlet-context.xml 파일에서도 확인할 수 있었다. 경로 문제를 겪기 전엔 봐도 모르다가 겪고 나서 알게 되니까 그제서야 눈에 들어오는 매직…       참고     SpringMVC 자바스트립트, CSS 파일 적용하기  ","categories": ["Spring"],
        "tags": ["Spring","Log"],
        "url": "/spring/spring-mvc-01/",
        "teaser": null
      },{
        "title": "JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 3 - Spring Legacy 프로젝트와 GitHub 원격저장소 연결하고 사이트 템플릿 초기설정",
        "excerpt":"   작성일 : 2022.04.21   작성자 : 황유진   팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진   GitHub Repository : https://github.com/miro7923/Uno-Mas      개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Spring Tool Suite 4.14.0   Spring framework 4.3.1.RELEASE   Tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.4.13 ~ 2022.5.20      주제     웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.   조건은 Spring 기반으로 웹 사이트를 제작하는 것이다.   총 팀원은 7명이며, 우리 팀은 1인 가구를 위한 쇼핑몰을 주제로 정했다.   팀 이름으로 정해진 Uno más는 스페인어로 하나 더라는 뜻이다.       진행상황 1     .gitignore 때문에 제법 많은 시간을 쓴 프로젝트와 GitHub 원격저장소 연결… 다음에 또 같은 상황을 맞이하게 되었을 때 참고하기 위해서 글을 작성했다.   GitHub 원격저장소 초기화(생성)     아직 팀 프로젝트를 위한 원격저장소가 없다면 새로 생성하면 되는데 우리 팀 같은 경우에는 기존에 테스트용으로 만들었던 원격저장소가 있었는데 기존에 쓸모 없이 업로드 되어 있던 파일들이 좀 있었던 터라 그대로 쓰기에는 적절하지 않았다. 그래서 초기화 후 다시 진행하기로 했다.   초기화 하는 방법에는 git으로 github repository 초기화 하기 이 글처럼 로컬 저장소에 숨김처리 되어 있는 .git 폴더를 삭제한 후 강제 리모트해서 푸시 하는 방법이 있는데 해 보니까 merge 내역이 엉켜서 그런 것인지 되지 않아서 그냥 로컬저장소에 추가 되었던 내용물을 삭제한 후 빈 폴더를 origin으로 push해서 원격저장소를 초기화 했다. 그리고 로컬저장소를 삭제한 다음 원격저장소에서 다시 클론했다.   .gitignore 작성     그간은 혼자 GitHub 원격저장소를 사용했기 때문에 시스템 환경설정 버튼이 함께 업로드 되는 것을 신경쓰지 않고 살았는데 팀 프로젝트를 하면서 공유하게 되니까 저것들이 신경쓰였다. 그래서 업로드에 앞서 .gitignore 설정을 가장 먼저 했다.   JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 2 - Spring Legacy 프로젝트를 위한 .gitignore 설정   클릭하면 .gitignore작성문을 참고할 수 있다.   Spring Legacy Project와 GitHub 원격저장소 연결     [Git] 이클립스(STS)에서 깃허브 연동 방법 정리   전체적인 진행은 위 글을 참고했다.   로컬저장소는 새로 생성하지 않고 아까 클론했던 폴더를 사용했다. 여기까지는 순조로웠다.   그런데 커밋을 하려 하니까 Unstating 목록에서 Staging 목록으로 파일들이 옮겨지지 않았다. 무슨 일… 그래서 클론했던 로컬저장소 폴더를 삭제하고 다른 경로로 클론한 뒤 프로젝트의 로컬저장소 경로도 거기로 설정해 주니까 첫 번째 commit과 push까지는 정상 작동하긴 했다.         그런데 원격저장소에 업로드가 잘 된 것을 확인했는데 STS상에서는 여전히 commit할 파일이 한가득이라고 뜨는 것이었다… 당시 캡쳐본이 없어서 글로 대신하지만 아까전에 commit했던 내역이 Unstaged 칸에 그대로 남아 있었다.   그래서 한 번 더 commit &amp; push를 시도했는데, 결과는 성공했는데 원격저장소의 프로젝트 파일이 모두 삭제된 것이었다. 환장….🥲 로컬 STS상에서는 커밋할 것이 있다는 표시도 나오지 않았다.   그래서 다시 한 번… 원격저장소의 클론부터 새 프로젝트 생성 및 원격저장소 연결까지 반복했다.         마지막 시도에서 드디어 커밋까지는 잘 되었는데 push 하는 과정에서 충돌이 생긴다며 reject 되었다.   https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&amp;blogId=sim4858&amp;logNo=220924984480   여기를 참고해서 해결할 수 있었다. 첫 번째 글을 작성했던 분이 마치 이 상황까지 예상한 듯이 게시글의 하단에 참고 링크를 올려 놓으셨다… 아마 레포지토리를 새로 생성한 직후가 아닌 기존에 사용하던 것을 재활용하다보니 병합 과정에서 충돌이 생긴 것 같았다.              그리고 드디어 최종 업로드에 성공했다.       이 과정을 겪으며 알게 된 것은 .gitignore를 사전에 잘 만들어두고 시작해야 한다는 것과 gitignore가 꼭 원격저장소에 push되어 있지 않고 로컬저장소에만 있어도 적용이 된다는 것이었다.   왜냐면 처음엔 .gitignore가 원격저장소에 push되어 있어야만 적용이 되는 줄 알고 프로젝트 파일을 push하기 전에 .gitignore만 push하려다가 이상하게 꼬여서 STS에서 commit이 제대로 되지 않는 경우가 많이 생겨서 몇 번이나 처음부터 다시 시작해야 했기 때문이다…   그래도 이제 GitHub으로 팀 프로젝트를 어떻게 시작해야 할 지 조금 알 것 같다.      진행상황 2     홈페이지 디자인으로는 무료 템플릿을 수정해서 사용하기로 했기 때문에 각 html 파일의 소스코드를 수정할 필요가 있었다.         모든 헤더 부분이 이렇게 되어 있었기 때문에 헤더만 따로 파일을 만들어서 각 html페이지의 헤더 부분에 include 해 주어야 했다. 그렇게 하지 않으면 헤더에 변경사항 생기면 모든 페이지의 헤더 부분을 수정해줘야 하니까… 헤더 페이지 하나만 수정하면 다른 페이지에도 일괄 적용되게 하고 싶었다.   그렇게 하기 위해서는 jsp 액션태그를 사용해야 해서 모든 html 페이지를 jsp 페이지로 바꿨다.   top.jsp   &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"     pageEncoding=\"UTF-8\"%&gt; &lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;c:set var=\"path\" value=\"${pageContext.request.contextPath}\"&gt;&lt;/c:set&gt;  &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;     &lt;meta name=\"description\" content=\"Fashi Template\"&gt;     &lt;meta name=\"keywords\" content=\"Fashi, unica, creative, html\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;     &lt;title&gt;Uno más | Template&lt;/title&gt;      &lt;!-- Google Font --&gt;     &lt;link href=\"https://fonts.googleapis.com/css?family=Muli:300,400,500,600,700,800,900&amp;display=swap\" rel=\"stylesheet\"&gt;      &lt;!-- Css Styles --&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/bootstrap.min.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/font-awesome.min.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/themify-icons.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/elegant-icons.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/owl.carousel.min.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/nice-select.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/jquery-ui.min.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/slicknav.min.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/style.css\" type=\"text/css\"&gt;     &lt;link rel=\"stylesheet\" href=\"${path}/resources/css/headerFooter.css\" type=\"text/css\"&gt; &lt;/head&gt;      이런 식으로 &lt;head&gt;태그에 들어갈 것만 따로 분리한 jsp 페이지를 만든 다음에   index.jsp   &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"     pageEncoding=\"UTF-8\"%&gt; &lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; &lt;c:set var=\"path\" value=\"${pageContext.request.contextPath}\"&gt;&lt;/c:set&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;!-- Start header --&gt; &lt;jsp:include page=\"inc/top.jsp\"&gt;&lt;/jsp:include&gt; &lt;!-- Start header --&gt;  &lt;body&gt;     &lt;!-- Header Section Begin --&gt; \t&lt;jsp:include page=\"inc/header.jsp\"&gt;&lt;/jsp:include&gt;     &lt;!-- Header End --&gt;           각 페이지의 상단에 &lt;head&gt; 태그가 들어가는 부분에는 top.jsp 파일을 include하고 헤더 부분에는 header.jsp 파일을 include 해 주었다.       각 페이지 하단 부분       &lt;!-- Footer Section Begin --&gt;   &lt;jsp:include page=\"inc/bottom.jsp\"&gt;&lt;/jsp:include&gt;   &lt;!-- Footer Section End --&gt;           bottom.jsp 파일을 만들어서 하단 부분에 include 해 주었다.   이제 헤더와 푸터 부분에서 수정사항이 생기면 header.jsp와 bottom.jsp 파일만 수정하면 된다.      참고     [Git] 이클립스(STS)에서 깃허브 연동 방법 정리   https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&amp;blogId=sim4858&amp;logNo=220924984480      마감까지     D-29  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/uno-mas-dev-log-03/",
        "teaser": null
      },{
        "title": "에러해결 Log) Spring Tool Suite4 Java compiler level does not match the version of the installed Java project facet",
        "excerpt":"사용환경     MacBook Air (M1, 2020) 16GB   JDK 8   Spring Tool Suite 4.14.0   tomcat 8.5      에러의 발생         Spring framework를 배우기 시작하면서 Spring Legacy Project로 진행하고 있는데 프로젝트의 자바 컴파일러 버전을 맞춰 주었는데도 저 에러 메시지가 계속 뜨는 것이었다. 실행하는데 문제가 없긴 했지만 신경쓰였다… 알고보니 컴파일러 뿐만 아니라 Project facets의 자바 버전도 맞춰 주어야 했다.      문제 해결         프로젝트 이름 위에서 마우스 우클릭하면 위와 같은 메뉴를 볼 수 있다. 맨 아래에 있는 Properties를 선택한다.         메뉴 중에서 Project Facets라는 메뉴를 선택한다. 그러면 옆에 현재 프로젝트에 설정되어 있는 자바 버전을 볼 수 있다.         현재 사용하고 있는 자바 컴파일러 버전과 맞춰 준다. 난 8 버전을 사용하고 있어서 1.8로 맞춰주었다.         에러 해결! 👏      참고     [문제해결] Java compiler level does not match the version of the installed Java project facet.  ","categories": ["ErrorLog"],
        "tags": ["Error","Solve","Log"],
        "url": "/errorlog/warning-log-06/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 거리두기 확인하기",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/81302     문제            개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.       코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼   아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.      대기실은 5개이며, 각 대기실은 5x5 크기입니다.   거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.   단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.      5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.     제한       places의 행 길이(대기실 개수) = 5   places의 각 행은 하나의 대기실 구조를 나타냅니다.   places의 열 길이(대기실 세로 길이) = 5   places의 원소는 P,O,X로 이루어진 문자열입니다.   places 원소의 길이(대기실 가로 길이) = 5   P는 응시자가 앉아있는 자리를 의미합니다.   O는 빈 테이블을 의미합니다.   X는 파티션을 의미합니다.   입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다.   return 값 형식   1차원 정수 배열에 5개의 원소를 담아서 return 합니다.   places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다.   각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.      👀 풀이    1차 시도     입력 배열에서 응시자들의 좌표를 따로 리스트에 저장한 뒤 응시자 한 명마다 다른 응시자들과의 거리를 구하려 했다.   그런데 거리는 구한다 해도 그 사이에 있는 파티션과 빈 칸의 좌표를 계산하는 것이 좀 복잡하게 느껴져서 다른 방법을 찾았다.   2차 시도     문제를 계속 보다 보니 맵 크기가 그렇게 크지 않아서 전체를 스캔하면 되겠다는 생각이 들었다.   그래서 이중 for문으로 [i][j]번째 칸이 응시자일 때 주변에 뭐가 있는지 확인한 후 분기처리를 하려 했다.   그런데 경우를 하나하나 쓰다 보니 코드가 굉장히 지저분해지고 몇몇 테케는 통과가 되지 않음 🥲 (이때 82점 받음)   그래서 질문 게시판을 찾아봤다.   3차 시도     생각보다 쉽게 접근해도 풀리긴 하네요..?   그런데 이렇게 쉽게 생각한 분이 있는 것이었다…!   그대로 구현하니까 100점으로 통과되었다.   오늘의 교훈은 문제의 조건을 최대한 단순화 시켜보자!     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Implementation","Python"],
        "url": "/programmers/programmers-social-distance-py/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 표 편집",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/81303     문제            [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]            업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다            한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.       “U X”: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.   “D X”: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.   “C” : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.        “Z” : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다.       처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요.     제한       5 ≤ n ≤ 1,000,000   0 ≤ k &lt; n   1 ≤ cmd의 원소 개수 ≤ 200,000   cmd의 각 원소는 “U X”, “D X”, “C”, “Z” 중 하나입니다.   X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.   X가 나타내는 자연수에 ‘,’ 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.   cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.   표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.   본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 “이름” 열을 사용하였으나, “이름”열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. “이름”열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.   표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.   원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) “Z”가 명령어로 주어지는 경우는 없습니다.   정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.      👀 풀이    1차 시도     파이썬의 리스트가 링크드 리스트와 같다고 오해하고 있었다. 그래서 배열의 중간 삽입/삭제 연산을 수행하는 데 시간이 오래 걸리지 않을 것이라 생각하고 실제 remove와 insert가 이루어지도록 코드를 짰다.   정확성 테스트는 통과했지만 효율성 테스트를 통과하지 못 했다.   2차 시도     효율성 테스트에서 계속 시간초과가 나서 구글링 해 보니까 리스트를 사용해서 푸는 것이 아니었다… 내가 파이썬의 리스트를 오해하고 있었던 것이었다… 링크드 리스트를 만들어야 했다.   그런데 해설 중에 dictionary로 링크드 리스트를 구현해 푼 분이 계셨다.   https://kjhoon0330.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%91%9C-%ED%8E%B8%EC%A7%91-Python   이 풀이를 참고해서 삭제/삽입 연산을 수정하니까 효율성 테스트도 통과할 수 있었다.   언어별 배열의 특정을 잘 파악하고 적절한 자료구조를 사용하고 구현할 수 있게 하자!     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","LinkedList","Python"],
        "url": "/programmers/programmers-edit-table-py/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 수식 최대화",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/67257     문제       IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.   이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.   해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.   단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.        만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.            예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.            “100-200*300-500+20”       일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.   대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.   수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.        반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.       참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.     제한       expression은 길이가 3 이상 100 이하인 문자열입니다.   expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.   즉, “402+-561*“처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.   expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.   즉, “100-2145*458+12”처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.   “-56+100”처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.   expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.   연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.   같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.      👀 풀이       아이디어가 떠오르지 않아서 질문 게시판을 참고했다.            숫자와 연산자를 각각 분리한다. 1-1. 숫자 분리시 replace() 메서드를 사용해 연산자들을 동일한 문자로 바꾼 뒤 최종적으로 split()을 사용해 분리한 리스트를 저장한다. 1-2. 연산자 분리시 expression 문자열의 원소들을 순회하며 isdecimal() 메서드로 숫자가 아닌 것만 리스트에 저장하면 된다.                   연산자가 3개 뿐이기 때문에 총 6개의 경우의 수가 나온다. 6가지 경우의 조합을 만들어서 각 경우에 따른 우선순위대로 계산을 시작하면 되는데 나는 itertools의 순열 메서드로 순열을 만들어 사용했다. 최대 경우의 수가 6이라서 하나씩 손으로 써서 사용한 사람도 많았다.            2에서 구한 각 우선순위 케이스를 이용해 계산을 시작하면 되는데 이 때 스택을 사용한다. 숫자 스택과 연산자 스택 두 개를 만든 다음 1에서 구한 숫자와 연산자 리스트에서 숫자와 연산자를 하나씩 뽑아서 각각 스택에 저장한다. 방금 저장한 연산자가 현재 우선적으로 사용해야 하는 연산자라면 스택에서 꺼내고 연산에 사용할 숫자 2개도 스택에서 꺼내서 연산한 다음 숫자 스택에 다시 넣는다. 이것을 1에서 구한 연산자 분리 리스트의 길이만큼 반복한다.            3에서 구한 결과값의 절대값을 정답에 저장된 값과 대조하여 최대값을 찾는다. 2에서 구한 케이스가 모두 끝날 때까지 반복한다.         코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Stack","Python"],
        "url": "/programmers/programmers-maximize-calc-py/",
        "teaser": null
      },{
        "title": "JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 4 - 상품 상세 페이지, 리뷰 작성 페이지, 문의 작성 페이지 제작",
        "excerpt":"   작성일 : 2022.04.25   작성자 : 황유진   팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진   GitHub Repository : https://github.com/miro7923/Uno-Mas      개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Spring Tool Suite 4.14.0   Spring framework 4.3.1.RELEASE   Tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.4.13 ~ 2022.5.20      주제     웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.   조건은 Spring 기반으로 웹 사이트를 제작하는 것이다.   총 팀원은 7명이며, 우리 팀은 1인 가구를 위한 쇼핑몰을 주제로 정했다.   팀 이름으로 정해진 Uno más는 스페인어로 하나 더라는 뜻이다.       진행상황 1 - 상품 상세 페이지 frontend  productDetail.jsp     메인으로 사용하기로 한 템플릿을 약간 수정해서 상품 상세 정보를 보여주는 페이지를 만들었다.   메인 이미지와 요약 정보 출력 부분   &lt;section class=\"product-shop spad page-details\"&gt;     &lt;div class=\"container\"&gt;         &lt;div class=\"row\"&gt;             &lt;div class=\"col-lg-12\"&gt;                 &lt;div class=\"row\"&gt;                     &lt;div class=\"col-lg-6\"&gt;                         &lt;div class=\"product-pic-zoom\"&gt;                             &lt;img class=\"product-big-img\"                                 src=\"${path}/resources/img/product-single/product_vegi01.jpeg\" \t\t\t\t\t\t\t\t\talt=\"\"&gt;                         &lt;/div&gt;                     &lt;/div&gt;                     &lt;div class=\"col-lg-6\"&gt;                         &lt;div class=\"product-details\"&gt;                             &lt;div class=\"pd-title\"&gt;                                 &lt;h3&gt;청경채&lt;/h3&gt;                             &lt;/div&gt;                             &lt;div class=\"pd-desc\"&gt;                                 &lt;p&gt;아삭하고 부드러운&lt;/p&gt;                             &lt;/div&gt;                             &lt;div class=\"pd-desc\"&gt;                                 &lt;h5 class=\"priceText top\"&gt;                                     &lt;span id=\"price\"&gt;2,190&lt;/span&gt; 원                                 &lt;/h5&gt;                                 &lt;p class=\"memberInfo\"&gt;로그인 후, 적립혜택이 제공됩니다.&lt;/p&gt;                             &lt;/div&gt;                             &lt;div class=\"pd-tags\"&gt;                                 &lt;dl class=\"list first\"&gt;                                     &lt;dt class=\"title\"&gt;판매단위&lt;/dt&gt;                                     &lt;dd class=\"description\"&gt;1팩&lt;/dd&gt;                                 &lt;/dl&gt;                                 &lt;dl class=\"list\"&gt;                                     &lt;dt class=\"title\"&gt;중량/용량&lt;/dt&gt;                                     &lt;dd class=\"description\"&gt;300g&lt;/dd&gt;                                 &lt;/dl&gt;                                 &lt;hr&gt;                                 &lt;dl class=\"list\"&gt;                                     &lt;dt class=\"title\"&gt;배송구분&lt;/dt&gt;                                     &lt;dd class=\"description\"&gt;택배배송&lt;/dd&gt;                                 &lt;/dl&gt;                                 &lt;hr&gt;                                 &lt;dl class=\"list\"&gt;                                     &lt;dt class=\"title\"&gt;원산지&lt;/dt&gt;                                     &lt;dd class=\"description\"&gt;국산&lt;/dd&gt;                                 &lt;/dl&gt;                                 &lt;hr&gt;                                 &lt;dl class=\"list\"&gt;                                     &lt;dt class=\"title\"&gt;포장타입&lt;/dt&gt;                                     &lt;dd class=\"description\"&gt;냉장/스티로품&lt;/dd&gt;                                 &lt;/dl&gt;                                 &lt;hr&gt;                                 &lt;dl class=\"list\"&gt;                                     &lt;div class=\"quantity\"&gt;                                         &lt;dt class=\"title\"&gt;구매수량&lt;/dt&gt;                                         &lt;div class=\"pro-qty\"&gt;                                             &lt;input type=\"text\" value=\"1\"&gt;                                         &lt;/div&gt;                                         &lt;br&gt;                                     &lt;/div&gt;                                 &lt;/dl&gt;                             &lt;/div&gt;                             &lt;div class=\"pd-desc\"&gt;                                 &lt;h5 class=\"priceText\"&gt;                                     총 상품금액 : &lt;span id=\"price\"&gt;2,190&lt;/span&gt; 원                                 &lt;/h5&gt;                             &lt;/div&gt;                             &lt;div class=\"quantity\"&gt;                                 &lt;!-- 회원의 위시리스트에 이 상품번호가 추가되어 있으면 까만 하트가 기본값 --&gt;                                 &lt;!-- @@ 클릭시 ajax로 DB 통신해서 위시리스트 추가하고 알림창 띄운 뒤 화면 새로고침 @@ --&gt;                                 &lt;%if (isInWishlist) { %&gt;                                     &lt;button class=\"icon_heart\" id=\"wishlistBtnFull\"                                          onclick=\"toggleWishlistBtn();\"&gt;&lt;/button&gt;                                 &lt;% }                                     else { %&gt;                                     &lt;button class=\"icon_heart_alt\" id=\"wishlistBtnEmpty\"                                          onclick=\"toggleWishlistBtn();\"&gt;&lt;/button&gt;                                 &lt;% } %&gt;                                 &lt;a href=\"shopping-cart\" class=\"primary-btn pd-cart\"&gt;장바구니 담기&lt;/a&gt;                             &lt;/div&gt;                         &lt;/div&gt;                     &lt;/div&gt;                 &lt;/div&gt;      전체적인 디자인은 마켓컬리의 상품 상세 페이지 디자인을 참고했다.      상품 설명 출력 부분   &lt;div class=\"product-tab\"&gt;     &lt;div class=\"tab-item\"&gt;         &lt;ul class=\"nav\" role=\"tablist\"&gt;             &lt;li&gt;&lt;a class=\"active\" data-toggle=\"tab\" href=\"#tab-1\"                    role=\"tab\"&gt;상품설명&lt;/a&gt;&lt;/li&gt;             &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#tab-2\" role=\"tab\"&gt;상세정보&lt;/a&gt;&lt;/li&gt;             &lt;!-- @@ 후기 개수에 따라 () 안에 숫자 출력하기 @@ --&gt;             &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#tab-3\" role=\"tab\" onclick=\"toggleReview(0);\"&gt;후기(02)&lt;/a&gt;&lt;/li&gt;             &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#tab-4\" role=\"tab\" onclick=\"toggleQna(0);\"&gt;문의&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;     &lt;/div&gt;     &lt;div class=\"tab-item-content\"&gt;         &lt;div class=\"tab-content\"&gt;             &lt;div class=\"tab-pane fade-in active\" id=\"tab-1\" role=\"tabpanel\"&gt;                 &lt;div class=\"product-content\"&gt;                     &lt;div class=\"col-lg-12\"&gt;                         &lt;img src=\"${path}/resources/img/product-single/product_vegi02.webp\" alt=\"\"&gt;                     &lt;/div&gt;                     &lt;br&gt; &lt;br&gt;                     &lt;div class=\"row\"&gt;                         &lt;div class=\"text-center col-lg-12\"&gt;                             &lt;!-- id 선택자 지정된 부분만 디비에서 불러와서 채우면 됨 --&gt;                             &lt;h3 class=\"detailSubTitle\" id=\"detailSubTitle\"&gt;아삭하고 부드러운&lt;/h3&gt;                             &lt;h1 class=\"detailTitle\" id=\"detailTitle\"&gt;청경채&lt;/h1&gt;                             &lt;br&gt;                             &lt;hr&gt;                             &lt;p class=\"detailMainContent\" id=\"detailMainContent\"&gt;청경채는 잎과 줄기가 붙어 자라는 한 포기 쌈채소에요. 아삭하면서도 싱그러운 식감이 매력적이지만, 살짝 데치거나 볶아주면 새로운 풍미를 선사해요. 신선한 청경채를 Uno más를 통해 만나보세요.&lt;/p&gt;                             &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;                             &lt;hr&gt;                             &lt;h3 class=\"detailOtherTitle\"&gt;재료와 성분&lt;/h3&gt;                             &lt;p class=\"detailOtherContent\" id=\"ingredient\"&gt;비타민 C, 칼륨, 칼슘 풍부&lt;/p&gt;                             &lt;h3 class=\"detailOtherTitle\"&gt;활용법&lt;/h3&gt;                             &lt;ul class=\"recomendation\"&gt;                                 &lt;!-- 추후 DB에서 불러와 상품별로 다르게 출력 --&gt;                                 &lt;li class=\"detailOtherContent\" id=\"recomendation1\"&gt;중화풍 요리, 샤브샤브 재료로 활용&lt;/li&gt;                                 &lt;li class=\"detailOtherContent\" id=\"recomendation2\"&gt;다양한 볶음, 무침으로 만들어도 OK&lt;/li&gt;                                 &lt;li class=\"detailOtherContent\" id=\"recomendation3\"&gt;1인 가구도 부담없이 사용하기 좋은 양&lt;/li&gt;                             &lt;/ul&gt;                             &lt;h3 class=\"detailOtherTitle\"&gt;보관법&lt;/h3&gt;                             &lt;p class=\"detailOtherContent\" id=\"ingredient\"&gt;세척하지 않은 상태로 비닐 팩에 담은 뒤, 냉장고 채소칸에 보관하세요.&lt;/p&gt;                             &lt;h3 class=\"detailOtherTitle\"&gt;세척법&lt;/h3&gt;                             &lt;p class=\"detailOtherContent\" id=\"ingredient\"&gt;사용할 만큼만 꺼내 흐르는 물로 깨끗이 세척하세요.&lt;/p&gt;                         &lt;/div&gt;                     &lt;/div&gt;                     &lt;br&gt; &lt;br&gt;                 &lt;/div&gt;             &lt;/div&gt;      상세 설명란은 기본 템플릿이 탭 형식으로 제작되어 있었기 때문에 그대로 활용했다.   리뷰 게시판   &lt;div class=\"tab-pane fade\" id=\"tab-3\" role=\"tabpanel\"&gt;     &lt;div class=\"customer-review-option\"&gt;         &lt;h4&gt;PRODUCT REVIEW&lt;/h4&gt;         &lt;ul class=\"productReivewTitle\"&gt;             &lt;li&gt;&lt;span data-icon=\"&amp;#x5e\"&gt;&lt;/span&gt; 상품에 대한 후기를 남기는                     공간입니다. 해당 게시판의 성격과 다른 글은 사전동의 없이 담당 게시판으로 이동될 수 있습니다.&lt;/li&gt;             &lt;li&gt;&lt;span data-icon=\"&amp;#x5e\"&gt;&lt;/span&gt; 배송관련, 주문(취소/교환/환불)관련                     문의 및 요청사항은 마이페이지 내 &lt;!-- @@ 1:1 문의글 작성 페이지 링크로 수정 @@ --&gt; &lt;span                                 onclick=\"window.parent.location.href = '/mypage/my_QnA'\"                                 class=\"personalInquiry\"&gt;1:1 문의&lt;/span&gt;에 남겨주세요.&lt;/li&gt;         &lt;/ul&gt;         &lt;div class=\"comment-option\"&gt;             &lt;table class=\"reviewTable\" width=\"100%\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"&gt;                 &lt;caption style=\"display: none\"&gt;구매후기 제목&lt;/caption&gt;                 &lt;colgroup&gt;                     &lt;col style=\"width: 110px;\"&gt;                     &lt;col style=\"width: auto;\"&gt;                     &lt;col style=\"width: 77px;\"&gt;                     &lt;col style=\"width: 100px;\"&gt;                     &lt;col style=\"width: 50px;\"&gt;                     &lt;col style=\"width: 80px;\"&gt;                 &lt;/colgroup&gt;                 &lt;tbody&gt;                     &lt;tr&gt;                         &lt;th&gt;번호&lt;/th&gt;                         &lt;th&gt;제목&lt;/th&gt;                         &lt;th align=\"left\"&gt;작성자&lt;/th&gt;                         &lt;th&gt;작성일&lt;/th&gt;                         &lt;th&gt;좋아요&lt;/th&gt;                         &lt;th&gt;조회&lt;/th&gt;                     &lt;/tr&gt;                 &lt;/tbody&gt;             &lt;/table&gt;             &lt;!-- 반복문으로 리뷰글 출력 부분 --&gt;             &lt;%                 for (int i = 0; i &lt; 7; i++) {             %&gt;             &lt;table class=\"reviewTable\" width=\"100%\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"&gt;                 &lt;caption style=\"display: none\"&gt;구매후기 제목&lt;/caption&gt;                 &lt;colgroup&gt;                     &lt;col style=\"width: 110px;\"&gt;                     &lt;col style=\"width: auto;\"&gt;                     &lt;col style=\"width: 77px;\"&gt;                     &lt;col style=\"width: 100px;\"&gt;                     &lt;col style=\"width: 50px;\"&gt;                     &lt;col style=\"width: 80px;\"&gt;                 &lt;/colgroup&gt;                 &lt;tbody&gt;                     &lt;tr onmouseover=\"this.style.background='#f0f0f0'\"                         onmouseout=\"this.style.background='white'\"&gt;                         &lt;td&gt;&lt;%=i + 1%&gt;&lt;/td&gt;                         &lt;td align=\"left\" class=\"reviewTitle\"                             onclick=\"toggleReview(&lt;%=i+1%&gt;);\"&gt;리뷰 &lt;%=i + 1%&gt;&lt;/td&gt;                         &lt;td align=\"left\"&gt;UnoMas&lt;/td&gt;                         &lt;td&gt;2022-04-22&lt;/td&gt;                         &lt;td&gt;0&lt;/td&gt;                         &lt;td&gt;0&lt;/td&gt;                     &lt;/tr&gt;                 &lt;/tbody&gt;             &lt;/table&gt;             &lt;div class=\"reviewContent\" id=\"reviewContent&lt;%=i+1%&gt;\"&gt;                 &lt;p&gt;평점 : &lt;span&gt;&lt;%=scores[i] %&gt; / 5.0&lt;/span&gt;&lt;/p&gt;             &lt;/div&gt;             &lt;%                 }             %&gt;             &lt;div class=\"col-lg-12 reviewBtnArea\"&gt;                 &lt;button type=\"submit\" class=\"site-btn\" onclick=\"location.href='review_writing_form';\"&gt;                     후기쓰기                 &lt;/button&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt;      리뷰 게시판과 문의 게시판은 이런 형식으로 만들었다.         아직 DB 테이블을 생성하지 않았기 때문에 나중에 연결 후 게시글 목록을 불러오면 그것을 바탕으로 출력하도록 반복문 형태만 만들어 놓았다. 추후 DB 테이블 생성 후 백엔드 작업에 들어가면 수정할 예정이다.     진행상황 2 - 리뷰 작성 페이지     처음에 계획을 짤 때엔 리뷰 작성 페이지를 생각하지 못 했는데 상품 상세 페이지를 만들다 보니 필요함을 깨달았다.   &lt;% // @@ 상품번호를 파라메터로 받아와서 상단에 해당 상품명 노출하기 @@ String prodName = \"청경채\"; int prodNum = 1; %&gt; &lt;body&gt;     &lt;!-- Header Section Begin --&gt;     &lt;jsp:include page=\"../inc/header.jsp\"&gt;&lt;/jsp:include&gt;     &lt;!-- Header End --&gt;      &lt;section class=\"product-shop spad page-details\"&gt;       &lt;div class=\"container\"&gt;         &lt;div class=\"customer-review-option\"&gt;           &lt;div class=\"comment-option\"&gt;             &lt;div class=\"leave-comment\"&gt;               &lt;h4&gt;후기쓰기&lt;/h4&gt;               &lt;form action=\"#\" class=\"comment-form\"&gt;                 &lt;div class=\"row\"&gt;                   &lt;div class=\"col-lg-12\"&gt;                     &lt;!-- @@ DB 전송시 파라미터로 넘겨줘서 해당 번호 상품에 등록되도록 하기 --&gt;                     &lt;input type=\"hidden\" value=\"&lt;%=prodNum%&gt;\" name=\"prodNum\"&gt;                     &lt;p class=\"productName\"&gt;                       상품명 : &lt;%=prodName%&gt;&lt;/p&gt;                   &lt;/div&gt;                 &lt;/div&gt;                 &lt;div class=\"row\"&gt;                   &lt;div class=\"col-lg-2\"&gt;제목&lt;/div&gt;                     &lt;div class=\"col-lg-10\"&gt;                       &lt;input type=\"text\" class=\"title\" placeholder=\"제목을 입력해주세요.\" maxlength=\"40\"&gt;                     &lt;/div&gt;                   &lt;/div&gt;                 &lt;div class=\"row\"&gt;                 &lt;div class=\"col-lg-2\"&gt;내용&lt;/div&gt;                   &lt;div class=\"col-lg-10\"&gt;                     &lt;textarea class=\"reviewTextarea\"                       placeholder=\"자세한 후기는 다른 고객의 구매에 많은 도움이 되며, 일반식품의 효능이나 효과 등에 오해의 소지가 있는 내용을 작성시 검토 후 비공개 조치될 수 있습니다. 반품/환불 문의는 1:1문의로 가능합니다.\"&gt;&lt;/textarea&gt;                   &lt;/div&gt;                 &lt;/div&gt;                 &lt;br&gt;                 &lt;div class=\"row\"&gt;                   &lt;div class=\"col-lg-2\"&gt;사진등록&lt;/div&gt;                     &lt;div class=\"col-lg-10\"&gt;                       &lt;input class=\"uploadImgName\" id=\"uploadImgName\" value=\"이미지 선택\" disabled=\"disabled\"&gt;                        &lt;label class=\"site-btn\" for=\"uploadImg\" id=\"uploadBtn\"&gt;업로드&lt;/label&gt;                       &lt;button type=\"button\" class=\"site-btn\" onclick=\"removeImg();\"&gt;삭제&lt;/button&gt;                       &lt;input type=\"file\" id=\"uploadImg\" oninput=\"checkFileName();\"&gt;                       &lt;p&gt;구매한 상품이 아니거나 캡쳐 사진을 첨부할 경우, 통보없이 삭제 및 적립 혜택이 취소됩니다.&lt;/p&gt;                     &lt;/div&gt;                   &lt;/div&gt;                   &lt;div class=\"row\"&gt;                     &lt;div class=\"col-lg-12\"&gt;                       &lt;button type=\"button\" class=\"site-btn\" id=\"writeBtn\" onclick=\"history.back();\"&gt;취소&lt;/button&gt;                       &lt;button type=\"submit\" class=\"site-btn\" id=\"writeBtn\"&gt;등록&lt;/button&gt;                   &lt;/div&gt;                 &lt;/div&gt;               &lt;/form&gt;             &lt;/div&gt;           &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/section&gt;      리뷰 작성 페이지에서는 제목과 텍스트, 이미지 파일 하나를 첨부할 수 있게 했다.   어떤 상품에 대한 리뷰를 쓰고 있는지 확인할 수 있도록 상단에는 해당 상품명을 노출하도록 했다. 이것 또한 추후 DB를 연결하면 정보를 받아와서 출력하는 방식으로 수정할 것이다.         전체적인 디자인 틀은 부트스트랩을 이용해 잡았다.   문의글 작성 페이지도 동일하게 만들었으며 이미지 업로드란만 제거했다.     작업 중 새로 알게 된 점과 어려웠던 점     세 페이지들을 작업하면서 새로 배운 부분은 input 태그의 file 타입의 UI를 바꾸는 것이었다.   처음엔 다른 태그들과 마찬가지로 css로 쉽게 바꿀 수 있는 것인 줄 알았다.   하지만 알고 보니 브라우저 고유 UI로 고정되어 있어 변경 불가였다. 그래서 구글링을 해 보니 우회해서 변경하는 방안들이 제시되고 있었다.        그 중에서도 폼 필드(input type=”file”) 디자인 #4 이 글을 참고해서 만들었다.       그리고 이 세 개의 페이지들을 작업하는 내내 날 괴롭혔던 것이 margin이었는데… 처음부터 내가 만든 것이 아닌, 만들어져 있는 템플릿을 가져다 쓰다 보니 기본 css파일에 설정된 여백 정보가 참 많았다.   처음엔 템플릿에 익숙하지 않으니까 원치 않는 여백이 잡혀 있는데 무엇 때문인지 찾는 것이 쉽지 않았다. 한 번은 테이블 &lt;td&gt; 태그에 생겨 있는 여백 원인 찾느라고 한 시간 넘게 썼던 것 같다…   의도치 않은 여백의 대부분은 기본 css 파일에서 설정되어 있었는데 저 파일이 모든 뷰 페이지에서 공유되고 있었기 때문에 막 수정하면 다른 페이지에도 영향을 미쳐서 다른 사람들의 작업물에 혼동을 줄 것 같았다. 그래서 내가 작업하는 JSP 페이지별로 CSS 파일을 따로 만들어서 수정된 스타일을 적용했다.      참고     폼 필드(input type=”file”) 디자인 #4       마감까지     D-25  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/uno-mas-dev-log-04/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 보석 쇼핑",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/67258     문제            [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]       개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.   어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.   어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.        진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매       진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.   가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.     제한       gems 배열의 크기는 1 이상 100,000 이하입니다.            gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.       gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.       gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.              👀 풀이       처음 문제를 봤을 때엔 이분탐색을 하는건가? 근데 뭘 기준으로 가야하는 거지? 와 같은 고민을 하다가 카카오 공식 해설을 참고했다.(코드 없이 말로만 설명된 해설 보고 그대로 구현해서 통과하기는 처음이다…)      전체 보석의 가짓수를 알 수 있게 gems 배열을 set으로 바꾼 배열을 임시 변수에 저장한다.   {보석 : 등장횟수} 페어로 딕셔너리를 생성한다. 현재 범위 내의 보석의 가짓수와 개수를 셀 것이다.   시작 포인터 l과 끝 포인터 r을 1번 진열대에 위치시킨다.   무한루프를 돌리는데 l과 r의 범위가 gems 배열 범위를 벗어나면 중단하고 무한루프를 탈출한다.   5-1. 2에서 만든 딕셔너리의 길이가 1에서 만든 set의 길이보다 짧으면 r을 1 증가시키고 현재 범위 내의 보석에 r번째 보석이 있으면 개수를 1 증가시키고 없으면 key를 새로 생성하고 value는 1을 할당한다.  5-2. 2에서 만든 딕셔너리의 길이가 1에서 만든 set의 길이와 같아지면 정답 조건에 가까운지 검사한다. 검사해서 더 가까운 값을 정답 배열에 저장했다면 l을 1 증가시킨다. 그리고 딕셔너리에서 l-1번째에 있는 보석의 개수를 1 줄인다. 만약 개수가 0이 된다면 해당 key를 삭제한다.      위 과정을 반복하다 보면 양쪽 포인터가 gems 배열 범위를 벗어나면서 반복문을 탈출하게 된다. 그리고 정답을 구할 수 있다.     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","TwoPointer","Python"],
        "url": "/programmers/programmers-jewel-shopping-py/",
        "teaser": null
      },{
        "title": "JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 5 - 카테고리별 상품 목록 페이지, 신상품 목록 페이지, 특가 목록 페이지 제작",
        "excerpt":"   작성일 : 2022.04.26   작성자 : 황유진   팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진   GitHub Repository : https://github.com/miro7923/Uno-Mas      개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Spring Tool Suite 4.14.0   Spring framework 4.3.1.RELEASE   Tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.4.13 ~ 2022.5.20      주제     웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.   조건은 Spring 기반으로 웹 사이트를 제작하는 것이다.   총 팀원은 7명이며, 우리 팀은 1인 가구를 위한 쇼핑몰을 주제로 정했다.   팀 이름으로 정해진 Uno más는 스페인어로 하나 더라는 뜻이다.       진행상황 1 - 상품 목록 페이지 frontend  productList.jsp     사용자 입장에서 전체 상품 목록을 볼 수 있는 페이지를 만들었다.   상단 카테고리 노출      &lt;div class=\"categoryBox\"&gt;     &lt;h3 class=\"title\"&gt;&lt;%=category%&gt;&lt;/h3&gt;     &lt;ul class=\"categoryList\"&gt;         &lt;% for (int i = 0; i &lt; subCategory.length; i++) { %&gt;         &lt;li&gt;&lt;a class=\"category\" id=\"category&lt;%=i%&gt;\" onclick=\"changeSort(&lt;%=i%&gt;, &lt;%=subCategory.length%&gt;);\"&gt; &lt;%=subCategory[i]%&gt;&lt;/a&gt;&lt;/li&gt;         &lt;% } %&gt;     &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"product-show-option\"&gt;     &lt;div class=\"row\"&gt;         &lt;div class=\"col-lg-12 col-md-12 text-right\"&gt;             &lt;p&gt;총 &lt;%=cnt%&gt;개&lt;/p&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/div&gt;      마켓컬리의 상품 목록 페이지를 참고해서 만들었다.   페이지의 상단에서는 카테고리별로 분류해서 볼 수 있도록 했다.   페이지 하나로 여러 카테고리에 돌려쓸 수 있게 상품 카테고리에 따라 페이지 제목을 다르게 출력하도록 틀을 만들었다. 추후 이전 페이지에서 받아온 파라미터로 DB에서 카테고리 정보를 조회해 와서 출력할 것이다.   productList.js   $(document).ready(function() {     $('#category0').css('color', '#dea234');     $('#category0').css('font-weight', 'bold');     $('#page1').css('font-weight', 'bold'); });  function changeSort(num, maxNum) {     var id = '#category' + num;          $(id).css('color', '#dea234');     $(id).css('font-weight', 'bold');          for (var i = 0; i &lt; maxNum; i++) {         if (num == i) continue;                  id = '#category' + i;         $(id).css('color', '#212529');         $(id).css('font-weight', '');     } }      카테고리 클릭시 강조 표시가 바뀌는 것은 자바스크립트로 제어했다.   현재 선택된 id만 강조시키고 그렇지 않은 것들은 강조 표시를 해제하도록 했다.   상품 목록 노출      &lt;div class=\"product-list\"&gt;     &lt;div class=\"row\"&gt;     &lt;% for (int i = 0; i &lt; 9; i++) { %&gt;     &lt;div class=\"col-lg-4 col-sm-6\"&gt;         &lt;div class=\"product-item\" id=\"productItem\"&gt;             &lt;div class=\"pi-pic\"&gt;                 &lt;a href=\"product_detail\"&gt; &lt;img src=\"${path}/resources/img/product-single/product_vegi01.jpeg\" alt=\"\"&gt;&lt;/a&gt;                 &lt;ul&gt;                     &lt;!-- 카트담기 버튼 --&gt;                     &lt;li class=\"w-icon active\"&gt;                         &lt;a href=\"#\"&gt;&lt;i class=\"icon_bag_alt\"&gt;&lt;/i&gt;&lt;/a&gt;                     &lt;/li&gt;                 &lt;/ul&gt;             &lt;/div&gt;             &lt;div class=\"pi-text\"&gt;                 &lt;a href=\"#\"&gt;                     &lt;h5&gt;청경채&lt;/h5&gt;                 &lt;/a&gt;                 &lt;div class=\"product-price\"&gt;                     2,190원                 &lt;/div&gt;                 &lt;div class=\"productSubTitle\"&gt;                     아삭하고 부드러운                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt;     &lt;% } %&gt;     &lt;/div&gt; &lt;/div&gt;      한 줄에 3개씩 3줄 출력하도록 했다.   상품 사진 위에 마우스 오버하면 장바구니 버튼이 노출되는데 이건 템플릿에 있는 것을 그대로 썼다.   하단 페이지 버튼      &lt;div class=\"row\" id=\"pagediv\"&gt;     &lt;div class=\"col-lg-12 text-center\"&gt;         &lt;% if (startBlock &gt; pageBlockCnt) { %&gt;         &lt;a href=\"#\" class=\"arrow_carrot-2left_alt pagingBtn\" id=\"toFirst\"&gt;&lt;/a&gt;          &lt;a href=\"#\" class=\"arrow_carrot-left_alt pagingBtn\" id=\"prev\"&gt;&lt;/a&gt;          &lt;% }             for (int i = startBlock; i &lt;= endBlock; i++) { %&gt;         &lt;span&gt;         &lt;!----&gt; &lt;a class=\"pagingBtn\" id=\"page&lt;%=i%&gt;\" onclick=\"changePageNum(&lt;%=i%&gt;, &lt;%=endBlock%&gt;);\"&gt;&lt;%=i %&gt; &lt;!----&gt;&lt;/a&gt;         &lt;/span&gt;          &lt;% }             if (endBlock &lt; pageBlockCnt) { %&gt;              &lt;a href=\"#\" class=\"arrow_carrot-right_alt pagingBtn\" id=\"next\"&gt;&lt;/a&gt;              &lt;a href=\"#\" class=\"arrow_carrot-2right_alt pagingBtn\" id=\"toLast\"&gt;&lt;/a&gt;         &lt;% } %&gt;     &lt;/div&gt; &lt;/div&gt;      전체 글 개수에 따라 페이지 버튼이 생성되고 누르면 해당 페이지로 이동할 수 있는 틀을 만들었다.   DB 연결되면 추가 수정할 예정   페이지 버튼 또한 클릭하면 강조 표시가 되게 만들었는데 위에서 카테고리를 선택하면 강조 표시가 되는 것과 동일한 로직으로 만들었다.     진행상황 2 - 신상품 목록 페이지         신상품 목록 페이지는 상품 목록 페이지를 복사해서 만들었다. 거기서 상단의 카테고리 출력란만 없앴다.     진행상황 3 - 특가 상품 목록 페이지         특가 상품 목록 페이지는 신상품 목록 페이지를 복사해서 만들었다. 할인하는 상품을 보여주는 페이지이기 때문에 할인율과 가격이 출력되도록 했다.      마감까지     D-24  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/uno-mas-dev-log-05/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 경주로 건설",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/67259     문제       건설회사의 설계사인 죠르디는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다.   제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다.   설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다.   경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.   경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.   이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다.   또한 두 직선 도로가 서로 직각으로 만나는 지점을 코너 라고 부릅니다.   건설 비용을 계산해 보니 직선 도로 하나를 만들 때는 100원이 소요되며, 코너를 하나 만들 때는 500원이 추가로 듭니다.        죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다.       도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요.     제한       board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다.   board 배열의 각 원소의 값은 0 또는 1 입니다.   도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다.   원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다.   board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다.   출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다.      👀 풀이       BSF로 풀 수 있을거 같은데 방향을 어떻게 해야 하는 건가 고민하다가 질문 게시판을 참고했다.      비용을 저장할 테이블, dp 배열을 3차원 배열로 만들면서 무한대(1e9)로 초기화한다. dp[방향][y][x]   시작 지점은 비용이 0이니까 각 방향 인덱스별 시작지점만 0으로 초기화 한다.   BFS에서 사용할 큐를 만든다.(덱 사용)            큐에 들어갈 값은 (y, x, 비용, 방향)           시작 지점에서 오른쪽과 아래로 가는 비용은 100원, 방향은 각각 오른쪽과 아래로 정해져 있다. 두 위치에 벽이 없으면 각각의 비용과 방향을 큐에 추가한다.   BFS로 상하좌우 방향을 탐색하면서 최저 비용으로 갱신한다.   5번 과정이 끝나면 4방향 인덱스를 순회하면서 [n-1][n-1]번째 인덱스의 값 중 가장 작은 값을 구한다.     코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","BFS","Python"],
        "url": "/programmers/programmers-build-road-py/",
        "teaser": null
      },{
        "title": "마이크로서비스 아키텍처(Microservices Architecture, MSA)",
        "excerpt":"👀 마이크로서비스 아키텍처란?     마이크로서비스는 하나의 큰 애플리케이션을 여러 개의 다른 역할을 수행하는 애플리케이션으로 분리하였을 때 각 애플리케이션을 말하며, 마이크로서비스를 분리하여 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 마이크로서비스 아키텍처라 한다.   대규모 소프트웨어 프로젝트를 마이크로 단위의 모듈로 분리하여 결합도를 낮추고(loosley-coupled) API를 통해 통신한다.   이렇게 만들면 기존에 개발했던 부분을 수정하거나 새로운 기능을 추가할 때 그 기능이 실패해도 전체 어플리케이션에 미치는 영향을 최소화 할 수 있다.   모놀리틱(Monolithic) 아키텍처             사진 출처 : https://giljae.medium.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-microservices-architecture-%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-7c45615cfe1a       만약 JAVA를 사용하여 웹 어플리케이션을 개발한다면            사용자에게 보여줄 view 페이지를 구성       요청된 URI에 따라 각 view 페이지를 연결해 줄 컨트롤러       도메인 정의 및 DAO 설계       컨트롤러와 DAO간의 결합도를 낮추기 위해 서비스 계층 구성           등 각 계층간 결합도를 낮추기 위한 설계를 하지만 최종 배포시에는 하나의 war 파일로 배포하게 된다. 즉 모두가 하나로 합쳐지게 되고 이는 유연한 리펙토링을 어렵게 만든다.   서비스의 규모가 작고 개발자의 수도 적다면 큰 문제가 되지 않지만 개발자의 수가 늘어나고 서비스의 규모가 커지면 간단한 기능을 추가할 때에도 수정할 코드가 많아지고 그 수정이 영향을 미치는 부분도 많아졌기 때문에 간단한 변화에도 대규모 통합 테스트가 필요해진다. 이를 모놀리틱(Monolithic) 아키텍처라 한다.   모놀리틱 아키텍처의 특성은 새로운 프레임워크를 사용할 필요가 생겨도 쉽사리 바꾸지 못한다는 점을 만들어 낸다. 왜냐하면 전체 어플리케이션이 하나로 묶여 있다면 그 동안 작성한 코드들을 새로운 언어 또는 프레임워크로 바꿔야 하는데 개발된 코드의 양이 많으면 많을수록 엄두가 안 날 것이다.   마이크로서비스(Microservice) 아키텍처             사진 출처 : https://giljae.medium.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-microservices-architecture-%EC%9D%98-%EC%9E%A5%EC%A0%90%EA%B3%BC-%EB%8B%A8%EC%A0%90-7c45615cfe1a       하지만 마이크로서비스 아키텍처는 서비스가 개별적으로 독립적인 단위의 어플리케이션이기 때문에 변경이 용이하고  그 변경이 다른 어플리케이션에 미치는 영향도 적다.   또한 개별 서비스 단위의 배포가 가능하기 때문에 하루에도 여러 번의 배포가 가능하다. 최근에 진행했던 JAVA &amp; JSP 프로젝트를 AWS EC2로 배포할 때 war 파일로 배포했기 때문에 배포 후 조그만 수정사항이 생겨도 war 파일을 다시 익스포트해야 했기 때문에 좀 불편했다. 프로젝트를 마이크로서비스 아키텍처로 설계하게 되면 그런 수고를 덜 수 있어 좀 더 유연하고 빠른 개발이 가능해 보인다.   하지만 그만큼 개발이 어렵다는 단점이 있다. 마이크로서비스 아키텍처를 적용해 개발하게 되면 view 페이지 하나에서 보여지는 여러 컨텐츠 중 특정 컨텐츠 하나만 제공하는 어플리케이션 단위로 쪼개어서 페이지 로드 시 각 어플리케이션에서 받아오게 된다. 이론적으로는 쉬워 보이지만 실제 구현시에는 각각 마이크로서비스의 호스트 정보 및 통신 프로토콜에 대해 처리해 주어야 하기 때문이라고 한다.   관련글 : 마이크로서비스 아키텍처. 그것이 뭣이 중헌디?      결론     마이크로서비스 아키텍처의 장점들을 보면 무조건 마이크로서비스 아키텍처를 쓰는 것이 좋아보인다. 하지만 아직 서비스의 규모가 작고 마이크로서비스 아키텍처를 적용했을 때 모놀리틱 아키텍처에 비해 오히려 일이 더 늘어나고 생산성이 더 떨어진다면 마이크로서비스보다는 모놀리틱 아키텍처를 적용해 개발하는 것이 더 좋을 수 있다는 결론을 얻을 수 있었다. 나보다 더 전문가이신 분들이 쓴 글에서 깊은 인사이트를 얻을 수 있었기에 공부에 참고했던 링크를 남긴다.      참고     마이크로서비스 아키텍처. 그것이 뭣이 중헌디?   Do Not Use MSA - 마이크로서비스 아키텍처가 꼭 필요한가요?   마이크로서비스 아키텍처(Microservices Architecture)의 장점과 단점  ","categories": ["IT"],
        "tags": ["CS","Architecture","MSA"],
        "url": "/it/msa/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. 신고 결과 받기",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/92334     문제            신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다.       각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다.   신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다.   한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신고 횟수는 1회로 처리됩니다.   k번 이상 신고된 유저는 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송합니다.        유저가 신고한 모든 내용을 취합하여 마지막에 한꺼번에 게시판 이용 정지를 시키면서 정지 메일을 발송합니다.       이용자의 ID가 담긴 문자열 배열 id_list, 각 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열 report, 정지 기준이 되는 신고 횟수 k가 매개변수로 주어질 때, 각 유저별로 처리 결과 메일을 받은 횟수를 배열에 담아 return 하도록 solution 함수를 완성해주세요.     제한       2 ≤ id_list의 길이 ≤ 1,000            1 ≤ id_list의 원소 길이 ≤ 10       id_list의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다.       id_list에는 같은 아이디가 중복해서 들어있지 않습니다.           1 ≤ report의 길이 ≤ 200,000            3 ≤ report의 원소 길이 ≤ 21       report의 원소는 “이용자id 신고한id”형태의 문자열입니다.       예를 들어 “muzi frodo”의 경우 “muzi”가 “frodo”를 신고했다는 의미입니다.       id는 알파벳 소문자로만 이루어져 있습니다.       이용자id와 신고한id는 공백(스페이스)하나로 구분되어 있습니다.       자기 자신을 신고하는 경우는 없습니다.           1 ≤ k ≤ 200, k는 자연수입니다.   return 하는 배열은 id_list에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 담으면 됩니다.      👀 풀이       딕셔너리를 사용해서 풀었다.   이 문제에서 관리되어야 하는 것은 id_list의 원소별로 신고한 id, 각 id별 신고횟수이다.      usersReport = {신고자 id : [신고된 id 리스트]}와 reportCnt = {신고된 id : 횟수} 형태의 딕셔너리를 만든다.   1-1. report를 순회하면서 usersReport에 각 유저별로 신고한 id를 담는다.   1-2. reportCnt에 각 유저별로 신고된 횟수를 저장한다.   1-3. 이때 같은 유저가 동일한 아이디를 여러번 신고하지 않도록 예외처리를 해 주어야 한다.   k번 이상 신고된 아이디를 추출한 리스트 stop = [k번 이상 신고된 id]를 만든다.   2-1. reportCnt를 순회하며 k번 이상 신고된 아이디를 stop에 담는다.    id_list를 순회하며 각 유저별 메일을 받은 횟수를 answer에 담는다.     코드             그런데 이렇게 구구절절 써서 통과하고 보니까 아주 짧은 코드로 통과한 분이 계셨다…   https://programmers.co.kr/learn/courses/30/lessons/92334/solution_groups?language=python3      믓지다…😦 set이 순간 떠오르긴 했으나 어떻게 활용할 지 몰라서 그냥 구구절절 코드를 썼는데 덕분에 하나 배울 수 있었다.  ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Implementation","Python"],
        "url": "/programmers/programmers-report-result-py/",
        "teaser": null
      },{
        "title": "깃허브로 Spring Legacy Project를 사용한 팀 프로젝트 진행시 내 컴퓨터에서 다른 사람 작업물 확인하기",
        "excerpt":"   깃허브를 이용해 팀 프로젝트를 진행하는 중 다른 팀원의 작업물 확인 방법을 자주 잊어버리는 팀원들을 위해서 작성했다.   Pull request 가이드     본인 작업물 먼저 본인이 작업중인 브랜치에 커밋 &amp; 푸시하기 (master 브랜치에 하면 안됨!!!)   sts에서 프로젝트 이름 위에서 마우스 우클릭   Team - Switch to - master 브랜치 선택   master 브랜치로 바꿨으면 Team - pull 선택     ￼      이렇게 뜨면 pull 완료된 것임 근데 브랜치 목록에 바로 보이지는 않아서 세팅 하나 더 필요함      Team - Switch to - Other ￼        check out… 클릭하면 선택창이 하나 뜨는데     ￼     일단 빨간 박스를 선택함   빨간 박스 안에 있는 check out commit을 누르면 내 로컬에는 이 브랜치를 생성하지 않고 보기만 하는 것이고(읽기 전용 모드 느낌)   파란 버튼인 check out as new local branch를 선택하면 내 로컬에도 이 브랜치를 생성하는 것임. 이렇게 하면 이 브랜치 내용을 수정해서 커밋/푸시하는 것이 가능함(근데 merge 완료되면 삭제할 브랜치라 로컬에 굳이 생성할 필요가 없어보여서 그냥 빨간 박스 선택 추천)      브랜치 변경이 완료되면 똑같이 서버 실행한 뒤 HomeController의 매핑 주소를 참고해서 주소창에 입력하면 작업한 페이지를 볼 수 있다.   다 봤으면 다시 본인 브랜치로 바꿔서 계속 작업하면 됨   수정했으면 하는 사항이 있으면 여기서 밑으로 쭉 내려보면 댓글 작성란이 있음. 작성하면 된다.   ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/pull-req-guide/",
        "teaser": null
      },{
        "title": "JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 6 - 주문페이지와 주문완료페이지 제작",
        "excerpt":"   작성일 : 2022.04.28   작성자 : 황유진   팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진   GitHub Repository : https://github.com/miro7923/Uno-Mas      개발환경     MacBook Air (M1, 2020)   OpenJDK 8   Spring Tool Suite 4.14.0   Spring framework 4.3.1.RELEASE   Tomcat 8.5   MySQL Workbench 8.0.19      기간     2022.4.13 ~ 2022.5.20      주제     웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.   조건은 Spring 기반으로 웹 사이트를 제작하는 것이다.   총 팀원은 7명이며, 우리 팀은 1인 가구를 위한 쇼핑몰을 주제로 정했다.   팀 이름으로 정해진 Uno más는 스페인어로 하나 더라는 뜻이다.       진행상황 1 - 주문 페이지 frontend  order.jsp     쇼핑몰에서 사용자가 상품을 주문할 때 보여주는 페이지를 만들었다.   그동안 인터넷 쇼핑몰로 상품 주문은 참 많이 했지만 막상 만들려 하니 좀 막막해서 네이버 쇼핑의 주문 페이지를 참고해서 만들었다.   전체 레이아웃            베이스로 사용하는 템플릿의 레이아웃이 부트스트랩으로 잡혀 있기 때문에 나도 부트스트랩으로 레이아웃을 설계하고 디자인을 구현했다.   지금까지 부트스트랩을 써 본 적이 없어서 이번 프로젝트를 시작할 때에만 해도 부트스트랩에 대해 아는 것이 없었는데, 이번 프로젝트를 시작하고 여러 뷰 페이지들을 제작하면서 부트스트랩의 편리함을 깨닫고 점점 빠져들고 있다. 왜 그렇게 명성이 높은지 알겠다…! 맘처럼 되지 않는 css를 붙잡고 늘어지지 않아도, 부트스트랩의 클래스 선택자 하나면 손쉽게 화면 레이아웃을 구상할 수 있었다. 세세한 부분에서는 개별 css 조절이 필요하지만 전체적인 화면 구성의 틀을 잡을 때엔 부트스트랩이 정말 편리했다.   배송지 정보 입력받는 부분         JavaScript를 이용해 선택한 라디오 버튼에 따라 배송지 입력란을 다르게 출력하도록 했다.   네이버 쇼핑 주문페이지의 배송지 정보 입력란을 참고해서 만들었다.   order.js   $(document).ready(function() {     $('#normalAddr').show();     $('#newAddr').hide();          ...          // 기본배송지와 신규배송지 바꿔서 출력하는 메서드     toggleAddrBox();          ... });  function toggleAddrBox() {     $('input:radio[name=deliverSpot]').change(function() {         if ($(this).val() == 1) {             $('#normalAddr').show();             $('#newAddr').hide();         }         else {             $('#normalAddr').hide();             $('#newAddr').show();          }     }); }      배송지 선택 라디오 버튼 아래 부분을 div태그로 감싼 다음에 id 선택자를 지정해 그것으로 제어한다.   배송지 입력란 외 다른 부분들도 같은 로직이 적용되는 부분이 많아서 이후 다른 라디오 버튼 선택란들도 모두 이와 같은 형태의 메서드를 작성해서 사용했다.   신규배송지 입력시 주소를 입력하는 부분은 다음 우편번호 API를 사용했다. 저번 프로젝트에 이어 두 번째로 사용해 보니까 저번보다 훨씬 쉽게 커스터마이징 해 적용할 수 있었다.   적립금 사용 부분           우리의 쇼핑몰 프로젝트에서는 적립금 제도를 운영할 것이기 때문에 적립금 사용란을 만들었다.   전액사용 버튼을 누르거나 항상 전액 사용에 체크하면 보유한 적립금 전액을 사용할 수 있다.   이것 또한 JavaScript로 제어한다.   order.js   function useAllPoints() {     var curPoint = $('#curPoint').val();     $('#usingPoint').attr('value', curPoint); }  function toggleUseAllPoints() {     $('input:checkbox[name=useAllCheckBox]').change(function() {         if ($(this).is(':checked') == true) {             useAllPoints();         }     }); }      두 가지 메서드를 만들어서 전액사용 버튼에는 onclick 이벤트시 useAllPoints()가 호출되도록 했고   항상 전액 사용에 체크시에는 jQuery로 변경을 감지해 이벤트 메서드가 호출되도록 했다.   백엔드 작업시에는 회원 정보 테이블에 적립금을 전액 사용한다는 상태를 저장할 컬럼이 추가되어야 하고 관련 파라미터 또한 함께 보내야 할 것이다.   하단 페이지 버튼         결제 수단으로는 신용카드와 계좌이체 두 가지만 만들었다.         그런데 지금 생각해 보니 계좌이체가 아니라 무통장 입금으로 하는 것이 더 맞았던 것 같기도 하다. 우리 프로젝트가 상업적인 목적으로 진행하는 것은 아니기 때문에 시험용 결제 모듈 한 가지만 써 보게 될 것 같은데 그것으로는 신용카드 결제 모듈을 생각하고 있었기 때문이다. 이 버전을 이미 마스터 브랜치로 머지를 해 버려서 다음 백엔드 개발을 진행할 때 함께 수정 해야겠다.         현금 결제시에는 현금영수증을 신청할 수 있도록 만들었다. 이것의 출력 또한 JavaScript로 제어했다.   메서드의 로직은 위에서 썼던 배송지 선택 부분과 동일하기 때문에 생략한다.   이 부분을 작업하며 회원정보 테이블에 현금영수증 신청정보 저장 컬럼도 추가되어야 함을 깨달았다.   주문 상품 목록 출력 부분         여기는 반복문으로 주문 페이지로 넘어온 상품 리스트의 개수만큼 출력하도록 했다. 지금은 단순 출력 테스트용으로 더미 데이터를 넣어 놓았지만 벡앤드 작업을 진행하게 되면 실제 상품명을 출력하고, 2개 이상 주문한 상품은 여러 번 출력되지 않고 수량이 하나 더 추가되는 방식으로 출력되게 할 것이다.   가격 텍스트를 정수형 그대로 출력하면 가독성이 떨어져서 JavaScript로 세 자리마다 콤마를 찍도록 했다.   order.js   // jQuery로 화면 로드시 호출 function convertCurrency(cnt) {     for (var i = 0; i &lt; cnt; i++) {         var id = '#prodPrice' + i;         var price = $(id).text();              $(id).text(price.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\"));     }          var deliveryFee = $('#deliveryFee').text();     $('#deliveryFee').text(deliveryFee.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\"));          var totalPrice = $('#totalPrice').text();     $('#totalPrice').text(totalPrice.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\"));          var point = $('#point').text();     $('#point').text(point.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\")); }      HTML페이지에서 가격 콤마를 찍는 방법과 관련해서 구글링하니까 많이 볼 수 있었던 정규식을 사용하는 코드로 구현했다. 주문할 상품의 목록 길이를 매개변수로 받아서 상품들의 가격에 콤마를 찍도록 했다.   &lt;ul class=\"order-table\"&gt;     &lt;li&gt;상품 &lt;span&gt;상품금액&lt;/span&gt;&lt;/li&gt;     &lt;!-- @@ 장바구니 목록 배열 사이즈만큼 출력하기 @@ --&gt;     &lt;!-- @@ 장바구니 목록 로드시 model에 배열 길이 정보 저장해서 자바스크립트에서 읽어오기 @@ --&gt;     &lt;%for (int i = 0; i &lt; 5; i++) { %&gt;     &lt;li class=\"fw-normal\"&gt;Combination x 1 &lt;span id=\"prodPrice&lt;%=i %&gt;\"&gt;&lt;%=prodPrice %&gt;원&lt;/span&gt;&lt;/li&gt;     &lt;% total += prodPrice; } %&gt;     &lt;li class=\"total-price\"&gt;배송비 &lt;span id=\"deliveryFee\"&gt;&lt;%=deliveryFee %&gt;원&lt;/span&gt;&lt;/li&gt;     &lt;li class=\"total-price\"&gt;합계 &lt;span id=\"totalPrice\"&gt;&lt;%=total + deliveryFee %&gt;원&lt;/span&gt;&lt;/li&gt;     &lt;li class=\"total-price\"&gt;적립혜택 &lt;span id=\"point\"&gt;&lt;%=(int)(total * 0.05) %&gt;원&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;      JSP 페이지에서 상품 목록의 id 지정은 이렇게 해 주었다. 내가 생각했을 때 최선인 방법은 이것인 거 같아서 이렇게 짰는데 더 효율적인 방법이 있을까? 로직을 짜는 내내 더 고민해 볼 필요가 있다는 생각을 했다.     진행상황 2 - 결제 완료 페이지         결제 완료 페이지는 최대한 심플하게 구성하고자 했다. 화면을 구성하면서 참고자료 구글링을 해 보니 대체로 간단하게 구성하는 추세였기 때문이다.         페이지 하단에는 배송지 정보와 주문/결제 정보를 표시하도록 했다. 그리고 홈으로 가는 버튼과 마이페이지로 가는 버튼을 만들어 두었다.     참고      라디오 버튼 눌렀을 때 변경 감지해서 다르게 출력   css class 선택자 적용 순서            이번 페이지들을 제작하며 class 선택자의 중첩 사용과 css의 적용 순서에 대해 잘 알게 되었다.           [tip] 가격(숫자 3자리, 천단위)에 자동 콤마 (input or div) 넣기      마감까지     D-22  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","Log"],
        "url": "/uno%20mas/uno-mas-dev-log-06/",
        "teaser": null
      },{
        "title": "Python) 프로그래머스. k진수에서 소수 개수 구하기",
        "excerpt":"문제 링크       https://programmers.co.kr/learn/courses/30/lessons/92335     문제            양의 정수 n이 주어집니다. 이 숫자를 k진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다.       0P0처럼 소수 양쪽에 0이 있는 경우   P0처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우   0P처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우   P처럼 소수 양쪽에 아무것도 없는 경우   단, P는 각 자릿수에 0을 포함하지 않는 소수입니다.   예를 들어, 101은 P가 될 수 없습니다.        예를 들어, 437674을 3진수로 바꾸면 211020101011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 왼쪽부터 순서대로 211, 2, 11이 있으며, 총 3개입니다. (211, 2, 11을 k진법으로 보았을 때가 아닌, 10진법으로 보았을 때 소수여야 한다는 점에 주의합니다.) 211은 P0 형태에서 찾을 수 있으며, 2는 0P0에서, 11은 0P에서 찾을 수 있습니다.       정수 n과 k가 매개변수로 주어집니다. n을 k진수로 바꿨을 때, 변환된 수 안에서 찾을 수 있는 위 조건에 맞는 소수의 개수를 return 하도록 solution 함수를 완성해 주세요.     제한       1 ≤ n ≤ 1,000,000   3 ≤ k ≤ 10      👀 풀이       오랜만에 큰 고민 없이 푼 문제… 다음과 같은 과정을 거쳐서 풀었다.            n을 k진수로 변환한다. 이때 string으로 변환       변환된 k진수를 ‘0’을 기준으로 split한다. 이 과정에서 ‘’ 빈 문자열이 생길 수 있다.       소수 판별 메서드를 만든다.       2에서 얻은 배열을 순회하면서 소수인지 아닌지 판단해서 카운트를 증가시킨다. 2에서 생길 수 있는 빈 문자열에 대한 예외처리를 해 주어야 함!!             코드      ","categories": ["Programmers"],
        "tags": ["Algorithm","Programmers","Math","Python"],
        "url": "/programmers/programmers-get-prime-num-in-kNum-py/",
        "teaser": null
      },{
        "title": "MySQL Workbench에서 EER Diagram model & SQL Script import Guide",
        "excerpt":"   MySQL Workbench에 내장되어 있는 EER 다이어그램 제작툴의 사용법과 SQL 스크립트를 불러와서 테이블 생성하는 법 가이드     EER 다이어그램 모델 불러오기     master 브랜치를 pull한다.   MySQL Workbench 실행     ￼      빨간 박스 선택     ￼      + 눌러서 모델 추가함     ￼      이런 창이 나올 것임. 여기에서 File 메뉴 클릭     ￼      Open Model 클릭     ￼      /Uno-Mas/unomasdb/unomasTable.mwb 경로에 있는 파일 선택하고 Open     ￼      그럼 만들어진 다이어그램 모델 확인 가능!     다이어그램 세부사항 확인     ￼      테이블 사이 관계선 위에 마우스오버하면 외래키로 연결된 컬럼을 표시해 준다.     ￼      테이블 이름이 있는 영역에 마우스오버하면 이 테이블과 관계를 맺고 있는 테이블들을 표시해준다.     ￼      테이블명을 더블클릭하면 세부사항을 확인할 수 있다.     ￼      각 테이블별로 설명도 써 놨으니까 참고하거나 본인이 더 필요하다고 생각되는 메모가 있으면 추가할 수 있다.     ￼      컬럼을 클릭하면 주석문 확인이 가능하다. 존재가 이해 안 되는 컬럼은 여기를 추가하고 본인이 필요하면 아래에 주석문 추가 가능      공유받은 SQL Script로 테이블 생성하기     ￼      스키마 생성한 후 사진상 메뉴로 들어감     ￼      /Uno-Mas/unomasdb/unomasDbTable.sql 경로에 있는 파일 선택     ￼      전체실행 버튼 눌러서 실행하면 테이블 생성됨.     ￼      하단 로그창에 성공적으로 생성됐다는 메시지 뜨면 다 생성된 것임. 안 보이면 테이블 목록 새로고침하면 보일 것임     ￼         참고     MySQL Workbench 로 DB 설계하기  ","categories": ["Uno mas"],
        "tags": ["Project","UnoMas","MySQLWorkbench","Log"],
        "url": "/uno%20mas/db-import-guide/",
        "teaser": null
      }]
