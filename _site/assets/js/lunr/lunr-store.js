var store = [{
        "title": "컴퓨터 사이언스란",
        "excerpt":"컴퓨터 사이언스란?  컴퓨터 사이언스의 기원      컴퓨터 사이언스는 컴퓨터라고 하는 기기에 대한 연구라고 할 수 있다.    컴퓨터 사이언스의 현대적인 기원은 1940년대에 최초로 출현한 디지털 컴퓨터들의 등장과 1930년대에 이와는 별도로 형성된 계산기기들에 대한 적절한 수학적 모델에 있다고 할 수 있다. 컴퓨터는 그 전까지는 수작업으로 하던 덧셈과 뺄셈같은 계산들을 좀 더 빠르면서 정확하게 처리하고자 만든 장치에서 시작되었기 때문이다.      컴퓨터 사이언스의 정의      물리학은 에너지와 많은 관련성을 갖는 학문이다. 반면, 컴퓨터 사이언스는 정보의 표현, 저장, 조작 및 검색과 밀접한 관계를 갖는 학문이다.   물리학이 에너지 변환장치를 이용하는 것처럼, 컴퓨터 사이언스는 정보변환장치를 이용한다.         컴퓨터 사이언스에서는 정보가 중요하고 그것이 차지하는 비중이 크기 때문에 컴퓨터 사이언스를 정보과학(Information Science)이라고도 한다. 컴퓨터 사이언스는 여러 가지 서로 다른 측면에서 정의할 수 있다.      1. 기기 중심      문제를 해결하기 위한 도구로서의 정의. 컴퓨터 기기와 이를 둘러싼 질문들, 즉 컴퓨터를 어떻게 설계하고 분석하고 구축하고 사용할 것인가 하는 것에 초점이 모아진다.     2. 정보 중심      컴퓨터에게 정보(데이터)의 개념과 처리는 중요하다. 정보 중심 관점에서는 데이터의 표현, 저장, 구성, 전송 및 처리에 관한 질문으로 귀결된다.     3. 프로그램 중심      프로그램이란 어떤 문제를 풀기 위한 컴퓨터 명령어들의 집합이다. 프로그램 중심 관점에서 본다면 컴퓨터 사이언스는 프로그래밍에 관한 연구라고 할 수 있다. 그렇기 때문에 이 관점에서는 프로그램 표현을 위한 적절한 언어의 선택, 프로그램의 정확성과 효율성, 프로그램의 실행을 위한 기계, 그리고 프로그래밍 기술 등과 같은 프로그래밍에 관한 문제점들을 강조한다.     4. 알고리즘 중심      알고리즘이란 문제 해결을 위한 작업이 어떻게 수행되는지를 정의하는 단계들의 집합니다. 컴퓨터는 알고리즘을 구현하는 기계이고, 정보는 알고리즘이 만들어내는 대상이며, 프로그래밍은 알고리즘을 기술하는 수단이다. 알고리즘 중심 관점에서 본다면 컴퓨터 사이언스는 알고리즘에 관한 연구라고 할 수 있다.       👉 이와 같이 컴퓨터 사이언스는 컴퓨터의 설계, 컴퓨터 프로그래밍, 정보 처리, 알고리즘 문제 해결, 알고리즘 처리 자체 등과 같은 다양한 분야에 대한 과학적인 기초를 제공하는 학문이라 할 수 있다.     컴퓨터 사이언스의 주요분야      컴퓨터 구조    시스템 소프트웨어    프로그래밍 언어    데이터베이스    데이터통신    컴퓨터 네트워크    인공지능    소프트웨어 공학      컴퓨터 사이언스의 발전   1. 컴퓨터의 멀티미디어화      대용량의 사운드, 그래픽, 비디오 등을 지원하는 멀티미디어 PC가 보편화되면서 이에 따라 주변기기들의 성능도 멀티미디어를 잘 처리할 수 있는 수준으로 고성능화, 고용량화되고 있다.     2. 컴퓨터의 네트워크화      인터넷의 보급으로 클라이언트/서버 환경의 확대가 가속화되고 네트워크를 통한 정보의 교환이 급속히 늘어나면서 네트워크 환경에 알맞은 컴퓨터 기술과 더불어 더욱 고급화, 지능화되는 네트위크 기술의 개발과 연구가 가속화 되고 있다.     3. 모바일 컴퓨팅의 확산      노트북, PDA, 스마트폰 등 휴대할 수 있는 모바일 컴퓨터들이 확산되고 있는 것에 따라 무선 기술 및 관련 컴퓨팅 기술의 개발과 연구가 확대되고 있다.     4. 컴퓨터의 임베드화      컴퓨터 기술과 가전기기가 접합된 시스템을 임베디드(embedded) 시스템이라 한다. TV에 인터넷 접속 기능이 결합된 경우가 대표적이라 할 수 있다.    5. PC의 고성능화      클러스터링 기법을 활용한 병렬처리 컴퓨터 기술이 접합될 경우 지금의 서버 수준을 뛰어 넘는 고성능 PC가 개발될 것이다.    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-01/",
        "teaser": null
      },{
        "title": "컴퓨터는 무엇일까?",
        "excerpt":"컴퓨터는 무엇일까?  컴퓨터의 정의      컴퓨터(Computer)란 지금까지 사람이 해 왔던 기억과 계산 등의 일을 빠르고 정확하게 처리해 주는 기계이며, 사람의 지시에 따라 여러 가지 일을 자동적으로 처리해주는 전자 장치이다.    컴퓨터라는 명칭 자체가 계산하다 라는 뜻인 compute에서 확장된, 계산해주는 사람(혹은 장치)이라는 뜻의 computer에서 유래되었다.    초기의 컴퓨터는 단순 수치 계산을 목적으로 만들어졌지만 오늘날의 컴퓨터는 수치 계산 뿐만 아니라 기억, 분류, 비교하는 것과 같은 여러 가지 일들을 한꺼번에 처리할 수 있다.     외부로부터 입력된 자료를 정의된 방법에 따라 자료를 처리하여 정보를 생성하고, 사용자에게 생성된 정보를 출력해 주는 기능을 가지고 있다.     컴퓨터의 기능   1. 입력 기능      처리할 데이터와 처리 방법 그리고 절차를 지시하는 프로그램을 외부로부터 읽어들여 기억 장치로 전달해 주는 기능     2. 기억 기능      읽어 들인 데이터와 절차를 지시하는 프로그램들과 처리된 결과 등을 기억 장치에 기억시키는 기능     3. 연산 기능      데이터를 기억 장치에 기억된 프로그램을 통해서 산술 연산과 논리 연산을 하여 결과를 만들어 내는 기능     4. 제어 기능      기억된 프로그램들의 명령을 하나씩 읽고 해석하여 컴퓨터 각각의 기능이 유기적으로 동작하도록 장치들을 제어하고 지시하는 기능     5. 출력 기능      컴퓨터 내에 기억된 내용과 처리된 결과를 문자, 도형, 음성 등의 형태로 외부에 보여주는 기능    컴퓨터의 기능 중에서 기억과 제어 그리고 연산 기능은 가장 핵심적인 것으로서 주기억장치(Main Memory)와 중앙처리 장치(Central Processing Unit : CPU)에서 이루어진다.      컴퓨터의 특징   1. 신속성      자료를 주어진 시간 내에 빠르고 신속하게 처리한다.     2. 정확성      계산 시에 에러나 오차를 최소화하고 정확하게 계산하고 판단한다.     3. 자동성      입출력을 비롯한 전체 처리 과정을 자동적으로(프로그램 된 대로) 처리한다.     4. 대량성      대량 데이터의 처리가 가능하고 대량 데이터의 저장이 가능하다.      컴퓨터의 필요성      과학 기술의 발달과 산업 사회의 급격한 변화로 새로운 정보를 신속하게 수집, 분석, 활용할 필요성이 생겼다.    사회 현상이 복잡하고 다양해짐에 따라 처리할 데이터 양이 기하급수적으로 증가하였다.    가상 현실이나 모의 실험을 활용하여 위험 부담을 줄일 수 있기 때문이다.    편리한 생활을 위한 기계 및 전자 장치들을 제어하기 위해 컴퓨터가 필요하게 되었다.    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-02/",
        "teaser": null
      },{
        "title": "컴퓨터의 역사",
        "excerpt":"컴퓨터의 역사   1. 초창기 계산기      학교 다닐 때 배웠던 근대 문학에서 흔히 등장하는 주판이 있다. 주판은 지금 쓰는 전자식 계산기가 보급되기 전 계산을 할 때 쓰던 도구이다.    주판이 규칙에 따라 문제를 풀 수 있는 장치인 것을 알고 있는 중세와 근대의 유럽인들은 이러한 규칙을 기계 장치에 집어넣으면 계산을 자동화할 수 있지 않을까 하는 발상에서 톱니 계산기를 발명하게 된다.    최초의 기계식 계산기는 1642년에 파스칼이 고안한 장치였다. 이 장치는 손잡이와 이에 딸린 톱니바퀴가 일정한 비율로 배열되어 손잡이를 좌우로 돌리는데에 따라 덧셈과 뺄셈이 자동으로 수행되는 장치였다.     이후 라이프니츠가 만든 계산기는 덧셈과 뺄셈 이외에도 곱셈과 나눗셈, 간단한 제곱근까지도 계산이 가능했다고 한다.     2. 근대 계산기      초창기 계산기들은 손으로 수치를 일일이 입력해야 하는 것이 큰 단점이었다. 그래서 19세기 들어 입력 방식을 보완한 근대적 계산기가 탄생하게 된다.    구멍이 뚫려 있는 천공 카드(punched card)를 이용해서 카드에 뚫린 구멍의 순서에 따라 톱니가 물려 입력 순서를 정하게 되는 방식을 이용해 입력 방식을 보완한다.     찰스 바베지는 증기 기관으로 작동되는 수식 계산 기계인 차분 엔진(difference engine)과 업그레이드 판인 해석 엔진(analytical engine)을 설계한다. 하지만 완성하지는 못했다.    찰스 바베지와 함께 프로젝트를 진행했었던 에이다는 세계 최초의 여성 컴퓨터 과학자로 기록되었으며, 병렬 처리 프로그래밍 언어로 유명한 Ada는 그녀의 이름을 딴 것이다.     3. 현대식 컴퓨터      현대식 전자 컴퓨터는 국방 분야에서 자동화를 위해 많은 인력과 자본을 투입해 개발한 것에서 시작되었다.     최초의 전자식 계산기의 토대는 2차 세계대전 기간에 만들어져, 2차 세계대전이 끝나고 1950년대 말부터 일반 사무용으로 보급된다.      1) 0세대      최초의 컴퓨터라 할 수 있는 ENIAC(Electronic Nemerical Integrator And Computer)이 개발되었다.   초당 5번의 곱셈이 가능했지만 지금의 컴퓨터와는 다르게 설계에 따라 한 문제만 풀 수 있었고 다른 문제를 풀게 하려면 진공관 회로의 배치를 바꿔줘야 했다.   당시 컴퓨터는 덩치가 아주 크고 진공관 수는 약 2만여개였기 때문에 배치를 바꾸는 데에 몇 주가 소요되었다. 그리고 전력도 많이 들고 진공관 고장도 잦고 효율적이지 않았기 때문에 현대 컴퓨터의 아버지라 불리는 존 폰 노이만이 새로운 방식을 고안해 낸다.     이 방식이 지금 우리에게 익숙한 소프트웨어 방식이다. 저장 프로그램 개념으로 컴퓨터 프로그램을 처리해야 할 데이터의 일부로 규정하여 이를 기억 장치에 저장해 놓고 반복적으로 이용 가능하도록 한 방식이다.    이 시기에는 0과 1로 이루어진 기계어가 프로그래밍 언어로 사용되었다.     2) 1세대 컴퓨터(1950년대)      0세대 컴퓨터는 연구와 국방 목적으로 이용되었지만 이것을 상업적으로 판매할 수 있을거라 생각한 사람들에게서 1세대 컴퓨터가 시작된다.   최초의 1세대 컴퓨터는 UNIVAC(Universal Automatic Computer)으로 입력 장치로 천공 카드를 이용하고 내부 계산 장치로 진공관을 이용하도록 설계되었다.    하지만 진공관 컴퓨터는 전력을 많이 소모하면서 속도가 느리고 가격이 비쌌다. 그리고 작동시키려면 0과 1로 이루어진 이진법 기계어에 익숙한 전문가가 필요했기 때문에 여전히 대중화되지는 못했다.    이 시기에 들어서면서 기계어를 인간이 인식할 수 있는 문자로 대치해서 쓰는 어셈블리어가 개발되었다.     3) 2세대 컴퓨터(1959년대 말 ~ 1960년대 초)      진공관의 단점인 크기, 전력 소모, 열 발생의 문제들이 해결된 트랜지스터가 개발된다.   트랜지스터를 이용해서 진공관 컴퓨터와 같은 원리로 동작하는 컴퓨터를 만드는 것이 가능했기 때문에 트랜지스터 컴퓨터가 개발되면서 컴퓨터의 처리 속도가 획기적으로 빨라지게 된다. 하지만 여전히 입력 수단으로는 천공 카드를 사용하고 있었는데 천공 카드의 입력 속도가 처리 속도에 비해 느려서 컴퓨터가 벌써 일을 다 끝내고 입력을 하염없이 기다리고 있게 된다.    이를 해결하기 위해            **병렬 처리(parallel processing) 기법** : 여러 개의 프로세서가 입력과 출력 및 연산을 독자적으로 수행하는 것        **멀티프로그래밍(multi-programming) 기법** : 한 개의 프로세서가 서로 다른 여러 개의 프로그램을 번갈아 가면서 처리하는 것    들이 개발되었다.            이 시기에 들어서서 인간이 인식하기 쉬운 언어로 작성한 프로그램을 기계어나 어셈블리어로 번역하는 컴파일러(compiler) 기술이 개발된다. 이에 따라 프로그램을 보다 체계적으로 구성할 필요가 생기면서 구조적 프로그래밍 언어 기법이 도입되었다. 이를 이용해서 우리가 코딩할 때 쓰는 라이브러리 개념이 생긴다.     4) 3세대 컴퓨터(1960년대 중반 ~ 1960년대 말)      3세대 컴퓨터 시기에 들어오면서 트랜지스터와 동일한 원리로 작동되지만 하나의 작은 실리콘 조각 위에 여러 개의 트랜지스터와 전자회로를 포함한 **집적회로(IC : Integrated Circuit) **가 개발된다.   집적회로는 비용을 크게 줄였기 때문에 보다 저렴하면서 강력한 성능을 가진 컴퓨터의 제작이 가능해졌다.    다중 처리와 다중 프로그래밍이 중요해졌으며 시분할 처리 시스템(Time Sharing System)이 생겨난다.     5) 4세대 컴퓨터(1970년대 초 ~ 1980년대 말)      집적회로가 더욱 발전되어 하나의 집적회로에서 연산, 제어, 기억 등의 프로세서의 모든 기능을 단순하게나마 수행할 수 있는 **마이크로프로세서**가 개발된다.   마이크로프로세서를 이용해 만든 개인용 마이크로 컴퓨터가 폭발적인 인기를 끌면서 컴퓨터의 설계는 마이크로프로세서 중심으로 개편된다.    이 시기부터 GUI(Graphical User Interface)가 개발되어 컴퓨터에 대한 지식이 없어도 쉽게 사용할 수 있게 된다.     6) 5세대 컴퓨터(1990년 ~ 현재)      데스크톱 말고도 랩탑과 팜탑 컴퓨터의 출현과 보조 기억 장치(CD-ROM, DVD 등)의 개선과 멀티미디어의 사용, 가상현실 등이 주요 특징이다.    객체지향언어와 프로그래밍이 각광받기 시작했으며 인터넷이 등장했다.     7) 미래의 컴퓨터 기술      병렬 처리 기술이 더욱 두드러지고 대용량의 주변기기들과의 접목을 통해 컴퓨터의 멀티미디어화가 더욱 가속화 될 것이다.    착용식 컴퓨터, 광 컴퓨터, 양자 컴퓨터, 바이오 컴퓨터 등과 같은 새로운 형태의 컴퓨터들이 출현할 것으로 기대된다.    인공지능(AI)이 더욱 발전되어 사람처럼 생각하고 행동하는 소프트웨어가 개발될 것으로 예상된다.    유비쿼터스 컴퓨팅이 보편화 되어 사용자가 네트워크나 컴퓨터를 의식하지 않고 장소에 상관없이 자유롭게 네트워크에 접속할 수 있는 정보통신 환경이 형성됨으로써 컴퓨팅의 사용성을 극대화한 사용자 중심의 중단없는 컴퓨팅 환경이 제공될 것으로 예상된다.   ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-03/",
        "teaser": null
      },{
        "title": "컴퓨터의 분류",
        "excerpt":"컴퓨터의 분류    1. 사용 목적에 따른 분류   1) 특수용 컴퓨터      한 가지 작업만을 처리할 수 있도록 설계되고 만들어진 컴퓨터     2) 범용 컴퓨터      여러 분야에서 다양한 일을 할 수 있도록 설계된 컴퓨터    일반적인 자료 처리는 물론이고 프로그램을 교체하여 다른 작업에 이용할 수 있다.    연구, 기업업무용으로 주로 사용되어 우리가 흔히 아는 개인용 컴퓨터와는 약간 다르다.     3) 개인용 컴퓨터      개인의 업무를 처리하도록 설계된 컴퓨터    우리가 흔히 볼 수 있는 컴퓨터로 교육용, 가정용, 기업용 등으로 널리 보급되어 있다.      2. 데이터 표현 방식에 따른 분류   1) 디지털 컴퓨터      일반적으로 생각하는 컴퓨터    이산적(discrete, 연속적이지 않다)인 형태로 이용한다.    시간에 따른 연속적인 변화량을 정해진 시간에 측정된 수치로 기억한다. 연결된 것처럼 보일만큼 작은 단위로 쪼개서 기억한다고 볼 수 있다.     2) 아날로그 컴퓨터      연속적인 자료를 이용하여 물리적인 유사성으로 변수나 양을 표현하고 이를 수학적으로 분석한 물리적 상태를 흉내 내는 방식으로 작동한다.    거리, 속도, 가속도, 온도, 압력 등의 물리량을 전압이나 전류의 양으로 대치하고 기계적 또는 전자적으로 동등한 회로에서 작동시킨 결과를 이용하는 방식이다.     3) 하이브리드 컴퓨터      변환기를 통해 아날로그 형태로 입력된 데이터를 디지털 형태로 변환하여 처리한 후 결과를 디지털 형태나 다시 아날로그 형태로 변환하여 출력할 수 있다.      3. 처리 용량에 따른 분류      현재는 크기와는 별도로 컴퓨터의 처리 속도에 따른 분류를 주로 사용한다.     1) 슈퍼 컴퓨터      가장 빠르고 가장 가격이 비싼 컴퓨터를 총칭하는 용어이다.    항공 우주, 입자물리와 화학, 전자, 자동차 및 석유 탐사 분야와 기상 예측, 지진 분석, 유전자 분석 등 시간이 오래 걸리는 복잡한 수학 공식을 반복적으로 방대한 분량을 계산하는 과학 기술 분야에서 주로 사용된다.    10기가 플롭스 이상의 속도를 가지고 있는 컴퓨터가 슈퍼 컴퓨터의 범주에 포함된다.     2) 메인프레임 컴퓨터      대규모 회사에서 주로 사용하는 컴퓨터    계산의 양보다는 입력과 출력되는 데이터의 양이 많은 경우에서 주로 사용된다.    다중 사용자(multi-user) 시스템     3) 미니 컴퓨터      메인프레임 컴퓨터보다 저렴하면서 메인프레임 컴퓨터와 유사한 기능을 이용할 수 있는 컴퓨터    약 200명 정도의 동시 사용자를 지원해주는 시스템을 가지고 있다.    메인프레임 컴퓨터의 하위 호완버전이라고 생각하면 된다.    다중 사용자(multi-user) 시스템     4) 워크스테이션과 마이크로 컴퓨터      단일 사용자(single-user) 시스템     4-1) 워크스테이션      * 강력한 계산, 고성능의 그래픽 디스플레이를 필요로 하는 공학자와 건축가, 그 외의 여러 분야의 전문가들의 작업에 적합하도록 설계된 데스크탑 컴퓨터     4-2) 마이크로 컴퓨터      * 우리가 흔히 볼 수 있는 데스크탑 컴퓨터      * 현재 많은 사람들이 사용하는 개인용 컴퓨터(PC)는 마이크로프로세서를 이용한 마이크로 컴퓨터를 뜻한다.     5) 휴대형 컴퓨터   5-1) 랩탑 컴퓨터      * 3~4kg 정도의 무게에 무릎 위에 올려놓고 사용할 수 있는 컴퓨터     5-2) 노트북 컴퓨터      * 우리가 흔히 사용하는 노트북     5-3) 팜탑 컴퓨터      * 처리해야 할 작업의 종류가 다양하지 않고 노트북을 휴대하는 것조차 부담스러운 이용자들을 위해 개발된 컴퓨터      * 대표적인 것이 PDA로 약속 시간 관리 및 전화 번호부, 메모장 등의 용도로 한정되어 있다. 최근에는 무선 및 유선 통신 기능을 추가하여 근로용 단말기로도 이용되고 있다.     5-4) 스마트폰      * 우리가 흔히 사용하는 스마트폰      * 다양한 기능 수용을 위해서 iOS, 안드로이드와 같은 표준화된 전용 운영체제를 갖추고 있다.     5-5) 태플릿 PC      * 아이패드와 같은 태블릿      * 일반 업무용과 개인 멀티미디어 기기로 활용하며, 프레젠테이션, 교육, 모바일 네트워크 기기로 활용    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-04/",
        "teaser": null
      },{
        "title": "데이터의 표현과 연산",
        "excerpt":"데이터의 표현과 연산    1. 컴퓨터의 수 체계      우리는 10진수를 사용하지만 컴퓨터는 0과 1로 모든 것을 판단하기 때문에 2진수를 사용한다.    컴퓨터의 연산과 제어의 기본은 부울대수이며, 컴퓨터가 다루는 데이터를 2진 숫자(Binary digIT)라고 하며 약자로 비트(BIT)라고 한다.    8개의 비트를 한 단위로 하여 1바이트(byte)로 사용한다.    2진수의 최상위 비트를 MSB(most significant bit)라 하고 최하위 비트를 LSB(least significant bit)라 한다.     2. 데이터의 표현   1) BCD 코드      Binary Coded Decimal의 약자로 8421 코드라고도 한다.    BCD 코드는 각 비트 자리가 자리값을 갖는데 1010이라는 4자리 비트가 있다고 했을 때 왼쪽(10진수로 생각할 때 1000의 자리)부터     2^3 = 8    2^2 = 4    2^1 = 2    2^0 = 1    의 값을 가지므로 8421코드라 부른다.     일반적으로 10진수를 2진수로 표현하는 것과 비슷하지만 10이 넘어가면 2진수는 1010이라고 표현하지만 BCD 코드는 0001 0000, 11은 0001 0001 … 와 같은 방식으로 표현한다.     2) 문자 데이터      문자 데이터는 1바이트의 데이터이다. 아스키코드의 문자 ABC를 2진법과 16진법으로 나타낸다면 다음과 같이 된다.                   문자       2진법       16진법                               A       0100 0001       41H                         B       0100 0010       42H                         C       0100 0011       43H                    3) 존(Zone) 형식      언팩(unpack) 형식이라고도 하며, 1바이트에 한 개의 10진수가 저장된다. 1바이트의 왼쪽 4비트를 존(zone) 비트라고 하며 항상 F(16진수)가 들어 있다.                   2진수       1111       0111       1111       0001       1100       0010                               16진수       F       7       F       1       C(양수)       2                      10진수를 712로 표현한다면 위와 같이 표현되는데 마지막 바이트의 왼쪽 4비트를 이용해서 부호를 나타낸다. 위와 같은 경우처럼 마지막 바이트의 왼쪽 4비트가 C라면 양수고                   2진수       1111       0111       1111       0001       1101       0010                               16진수       F       7       F       1       D(음수)       2                      위처럼 D라면 음수로 -712가 된다.     4) 팩(Pack) 형식      수치를 표현하는 4비트의 BCD를 1바이트에 2개를 나타내며 10진수 숫자 2개를 표시한다. 존 형식이 절반으로 줄어든 형태라고 보면 된다.                   2진수       0111       0001       0010       1100                               16진수       7       1       2       C(양수)                                  2진수       0111       0001       0010       1101                               16진수       7       1       2       D(음수)                    5) 고정 소수점 형식      고정 소수점 형식은 소수점 위치가 가장 오른쪽 끝에 고정되어 있다고 가정하는 것으로 전체의 수를 정수로 표현한다. 가장 왼쪽의 비트는 부호를 표시하며 0이면 +양수, 1이면 -음수를 나타낸다. 데이터 길이를 n이라고 했을 때 -(2^n-1 - 1) ~ (2^n-1 - 1)의 범위를 나타낼 수 있다.    고정 소수점은 BCD 코드에 비해서 명령 속도가 빠르다.     6) 부동 소수점 표현      아주 큰 수나 아주 작은 수를 표현한다든지 아니면 높은 정도(precision)로 취급할 때 많이 쓰인다. 유효숫자만을 나타내는 소수부(fraction part)와 소수점의 위치를 나타내는 지수부(exponent part)로 구분한다. 10^-78 ~ 10^74의 범위까지를 나타낼 수 있다.      3. 보수 연산      보수(complement)란 어떤 기준이 되는 수를 설정했을 때 그 수에 모자라는 수를 말한다. x에 대한 9의 보수는 9로부터 x를 뺀 것인데, 6에 대한 9의 보수는 3이고 2에 대한 10의 보수는 8이다.    보수 연산은 뺄셈을 할 때 9의 보수를 사용하는 방법과 1의 보수와 2의 보수를 사용하는 방법 등이 있다.      4. 정보 교환용 코드      정보 교환용 코드는 국제표준화기구(ISO)에 의해 정해지고 이것에 준해서 각국에서 정하여 사용하고 있다. 컴퓨터 대 컴퓨터시스템간의 통신을 단순화하고 표준화하기 위해 만들어졌다.     대표적인 것으로 프로그래밍을 할 때 자주 쓰는 아스키(ASCII)코드가 있다.   산업 표준으로 전세계 모든 문자들을 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 유니코드(Unicode)가 제정되어 사용되고 있다.     ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-05/",
        "teaser": null
      },{
        "title": "부울대수",
        "excerpt":"부울대수    1. 부울대수의 개요      부울대수(Boolean algebra)는 논리적 관계의 문제를 다룰 때 대수 형식으로 표시하며, 여러가지 논리회로를 설계하거나 같은 기능을 갖는 논리 회로를 간략화하는 데 사용된다.   인간의 지식이나 사고를 참, 거짓으로 공식화하고 이를 수학적으로 해석하기 위한 것으로 논리대수라고도 한다.    주로 컴퓨터의 회로 설계 등에 이용되고 있으며 “0”과 “1”의 두 개의 수치만을 사용하여, 연산의 결과는 언제나 0 또는 1로 표한된다.      2. 논리회로      논리회로는 2가지 상태를 다루는 방법으로 컴퓨터에서 사용되는 방법이다. NOT, AND, OR 3가지의 기본논리회로의 조합으로 구성된다.      1) NOT 회로      인버터(inverter)라고도 한다. 입력이 1개로 구성된 것으로 입력신호와 반대되는 출력을 내놓는다.    입력신호가 1이면 출력은 0, 입력신호가 0이면 출력은 1     2) AND 게이트      두 입력이 모두 1일 때 출력이 1이 되고 그 외에는 모두 0이 출력된다.     3) OR 게이트      입력신호 중 어느 하나 또는 두 개가 모두 1일 때 1이 출력된다.     4) 부정논리곱      AND와 NOT 회로를 결합한 것으로 AND의 결과를 반전한 결과를 얻는다.    두 입력이 모두 1일 때에만 0을 출력하고 나머지는 모두 1 출력     5) 부정논리합      OR와 NOT 회로를 결합한 것으로 OR의 출력이 반전된 결과를 얻는다.     두 입력이 모두 0이면 1을 출력하고 나머지는 모두 0 출력     6) 베타논리합(XOR : exclusive-OR)      두 개의 입력조건이 서로 다르면 1이고, 조건이 같으면 0이 된다.     3. 조합 논리 회로      입력 논리치가 정해지면 출력 논리치가 결정되는 논리회로, AND, OR, XOR 등의 논리가 해당된다.     1) 반 가산기(half adder)      1비트의 2진수 2개를 합하여 그 결과를 한 비트의 합과 한 비트의 올림수로 발생시키는 논리회로     2) 전 가산기(full adder)      반 가산기는 자리 올림수를 더해줄 수 없기 때문에 이것을 보완하여 만든 회로    두 개의 입력과 전 단계에서 발생한 자리 올림수를 더할 수 있도록 구성된 회로    여러 자리의 2진수 덧셈을 위해서는 첫 자리의 덧셈은 반 가산기를 이용하고, 다음 단계부터는 자리 올림수를 더해줘야 하기 때문에 전 가산기를 사용한다.     3) 인코더(encoder)      1게의 입력을 다수의 신호로 변환하여 출력을 얻는 회로로 부호기라고도 한다.    0, 1, 2, … 와 같은 하나의 십진수를 4개의 비트를 이용한 2진수 코드로 변환할 때 사용할 수 있다.     4) 디코더(decoder)      인코더와 반대로 다수의 입력신호로서 1개의 출력신호를 얻는 회로이다.    2진수 코드의 정보를 다른 부호로 바꾸어야 할 때 사용하는 회로로 해독기라고도 한다.     5) 멀티플렉서(multiplexer)      n개의 선택입력에 따라 2^n 개의 입력 중 하나를 선택하여 출력하는 회로로 다중기라고도 한다.    데이터통신 장치에 많이 사용된다.      4. 순서 논리 회로      조합 논리 회로가 입력신호의 조합에 따라 출력값이 결정되었다면 순서 논리 회로는 입력신호의 조합뿐만 아니라 논리회로의 내부 상태에 따라 다르게 출력이 나타난다.     입력 신호에 의하여 상태를 바꾸도록 지시할 때까지 계속적으로 컴퓨터 내부에서 0, 1의 값을 가지는 bit을 기억하고 유지하기 위하여 사용된다.    이런 소자를 플립플롭(Flip-Flop)이라 하며, 정보를 기억하는 레지스터 및 카운터 등의 구성소자에서 사용된다.    @레지스터(register)      CPU의 연산장치와 기억장치 중에서 기억장치에서 읽어내는 정보와 연산결과 등을 일시 기억하는 데 사용된다.    1개의 플립플롭은 1비트의 정보가 기억되기 때문에 n개의 플립플롭을 사용하면 n비트의 정보를 기억하는 레지스터가 된다.    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-06/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 구성",
        "excerpt":"컴퓨터 하드웨어 구성      컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다.    하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다.    중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다.    소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.     컴퓨터 하드웨어의 구성   1) 입력 장치      자료를 컴퓨터에 읽어 들이는 기능을 가지고 있다.    디스크 장치, 테이프 장치, 단말기, 카드 판독기 등이 있다.     2) 기억 장치      주기억 장치와 보조 기억 장치로 나누며, 입력된 자료가 처리될 때까지 일시적으로 기억하거나 연산 결과와 출력할 내용 등을 기억한다.     3) 연산 장치      산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)라고도 한다.    제어 장치의 지시에 따라 전송된 자료를 처리하기 위하여 사칙 연산, 논리 연산, 자리 이동 등의 연산을 수행하는 장치이다.     4) 제어 장치      자료를 처리하는 순서를 저장한 프로그램의 명령어를 해독하여 입력 장치, 기억 장치, 연산 장치, 출력 장치 등을 제어한다.     5) 출력 장치      CPU로부터 출력 결과를 받아서 사람이 알 수 있는 형태로 변환하거나 다른 기억 장치(자기 테이프, 자기 디스크 장치 등)로 전송한다.                   중앙 처리 장치(CPU)       주변 장치                       제어 장치       보조 기억 장치                 주기억 장치       입력 장치                 연산 장치       출력 장치          ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-07/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 기억장치",
        "excerpt":"컴퓨터 하드웨어 기억장치    기억 장치      입력 장치에서 읽어 들인 숫자, 문자, 각종 기호 등의 자료들을 저장하는 장치로 주기억 장치와 보조 기억 장치로 나누어진다.     1) 주기억 장치(main memory unit)      컴퓨터 중앙 처리 장치(CPU)에 위치하며 실행하고자 하는 프로그램이나 자료를 기억시키는 장치     2) 보조 기억 장치(auxiliary storage unit)      주변 장치로서(CPU에 속하지 않음!) 주기억 장치에 필요한 프로그램이나 자료를 보낼 수 있고, 처리된 자료 또는 개발된 프로그램 등을 저장할 수 있다.     3) 기억 장치에서 사용되는 단위      최소 단위는 비트(bit : binary digit)이다.     8개의 비트가 모이면 1바이트가 된다.    1바이트는 영문자 1개를 기억하며 한글 1문자를 저장하는 데엔 2바이트가 필요하다.         1킬로 바이트(KB)는 1,024바이트로 구성되며, 1메가 바이트(MB)는 1,024킬로 바이트이고, 1기가 바이트(GB)는 1,024메가 바이트가 된다.         메모리 셀(memory cell)             **한 소자나 전기회로가 하나의 비트를 저장**하는 데 사용된다.        (0 또는 1) 플립플롭, 충전된 커패시터, 자기테이프 또는 디스크 등을 예로 들 수 있다.             메모리 워드(memory word)             메모리에 있는 비트는 몇 가지 형태의 명령이나 데이터로 표현된다.        예를 들면, 8개의 플립플롭으로 구성된 레지스터는 8비트 워드로 저장되는 메모리로 생각할 수 있다.        워드의 용량은 보통 4~8바이트 사이이다.             바이트(byte)             8비트 워드에 대해 사용되는 용어이다.        항상 8비트로 구성된다.        마이크로컴퓨터에서 가장 일반적인 워드 크기이다.             용량(capacity)             비트들을 저장할 수 있는 공간        메모리에 있어 워드수는 대개 1024의 곱이다.        우리가 흔히 보는 하드 용량 몇 GB는 2^10(1,024), 2^20(1,048), … 와 같이 딱 나눠 떨어지는 10의 배수가 아닌 2의 거듭제곱들이다.             주기억 장치   1) 주기억 장치의 구성      주기억 장치는 수많은 바이트로 구성된다.   입력 장치를 통하여 읽어 들은 자료는 1과 0의 상태가 모아져 바이트 단위로 구성되며 순서에 따라 특정한 장소에 저장된다.         자료를 저장하거나 저장된 자료를 읽기 위하여 각 기억 장소는 고유한 주소를 갖는다.          기억부             주어진 프로그램이나 데이터를 기억해 두는 2진 기억 소자(memory cell)들이 2차원 행렬(matrix)로 구성되어 있다.             메모리 주소 레지스터(MAR : Memory Address Register)             프로그램이나 데이터를 입출력하기 위한 번지를 가지고 있다.             메모리 버퍼 레지스터(MBR : Memory Buffer Register)             입출력하고자 하는 프로그램이나 데이터를 임시 보관하는 레지스터             번지 선택 회로             MAR(메모리 주소 레지스터)에 의하여 기억 장소를 선택하는 회로             제어 회로             기억 장치에 저장하라는 Write 신호와 기억 장치로부터 읽어내리는 Read 신호를 발생시키는 회로        칩이나 모듈 개념으로 여러개로 나누어 구성될 경우 칩 선택 신호나 메모리 모듈 선택 신호가 필요하다.             2) 기억 장치에 저장하는 외부 동작의 순서      기억 장치의 위치(번지)를 MAR(메모리 주소 레지스터)에 넣는다.    프로그램이나 데이터의 비트를 MBR(메모리 버퍼 레지스터)에 넣는다.    입력 신호로 MBR(메모리 버퍼 레지스터)의 내용이 메모리에 저장된다.     3) 기억 장치로부터 읽어낼 때 외부 동작 순서      읽어내려는 프로그램이나 데이터 번지를 MAR에 넣은 후 출력신호를 준다.    메모리의 해당 내용이 MBR로 옮겨져 외부로 출력하게 된다.     4) 어드레스(Address)      메모리에서 한 워드의 위치를 식별하는 주소(숫자)    메모리소자 또는 시스템에 저장된 각 워드는 고유의 주소를 갖는다.    주소는 보통 2진수, 8진수, 16진수로 표현되고, 편의를 위해 10진수로 표현되기도 한다.    메모리에 있는 특정 워드의 위치를 언급할 때마다 그것을 식별하기 위해서 그 위치의 주소코드를 사용한다.    !모든 프로그램은 주기억 장치에서만 실행된다!     그래서 주기억 장치(RAM)의 용량이 클수록 더 많은 정보를 기억하고 실행할 수 있기 때문에 비싸다.     ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-08/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 주기억 장치의 종류",
        "excerpt":"주기억 장치의 종류      컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다.     1. 과거의 주기억 장치     초기        처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다.         1960년대 초반 ~ 1970년대 중반        자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.         기억 원리            코어의 링을 통과하는 도선에 전류를 흘려 ‘플레밍의 오른손 법칙’에 따라 자화의 방향을 바꾸어 준다.       자기 코어는 한 번 1 또는 0의 상태가 되면 어떠한 변화를 주지 않는 한 계속 자화 상태를 유지하여 정보를 기억하게 되고, 여러 개의 코어를 코어판(core plane)의 형태로 묶어서 사용하게 된다.             자화(magnetization)            물질을 자기장 속에 놓았을 때 그 물질 전체가 갖는 거시적인 자기(磁氣)모멘트       물질의 자기적 성질은 주로 전자의 자기모멘트에 연유하는데, 전자가 가진 극히 작은 미시적인 자기모멘트가 많이 모여, 그 총합으로 거시적으로 물질이 나타내는 자기모멘트를 자화라고 한다.             플레밍의 오른손 법칙                N극에서 S극 방향으로 자기장이 형성되었을 때 그림처럼 자기장의 방향과 수직으로 도체(금속 막대 등)가 움직이고 있다면 전류는 가운데 손가락 방향으로 흐른다.       엄지손가락 방향 : 도체를 움직이는 힘(속도)의 방향       두번째 손가락 방향 : 자기장의 방향       가운데 손가락 방향 : 전류가 흐르는 방향           2. 현재의 주기억 장치     1960년대 후반부터 반도체 집적 회로(IC : Integrated Circuit) 기술의 개발과 함께 기억 소자로의 적용이 추진된 후, 1968년에는 주기억 장치의 버퍼 메모리로 사용되기 시작했다.   집적 회로는 집적도, 소비 전력, 소형성, 경제성 등으로 코어 메모리를 대체하여 널리 이용되고 있다.     3. 미래의 주기억 장치     현재보다 크기가 작고, 대용량, 고속의 기억 소자가 사용될 것이라 예상된다.   그 중 하나가 조셉슨 소자(Josephson device)인데, 현재의 기억 소자보다 10배 이상 빠르게 나타나고 있으며 대량 생산과 가격 등의 문제점을 해결하고 있다.   ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-09/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 - 반도체 메모리",
        "excerpt":"반도체 메모리     현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.     메모리의 제조기술적인 분류에 따른 특성   1) 밀도(chip당 bit 용량)  2) 속도  3) 소비전력(bit당 mW)  4) bit당 cost(반도체 제조가격 측면)  5) Noise 면역성     읽기동작(read operation)과 쓰기동작     특별한 메모리위치(주소)에 저장되어 있는 2진 워드가 감지되어 다른 소자에 전달되는 동작   만약 100번 주소에 있는 메모리에서 워드 4를 사용하려 한다면 주소 100번에서 읽기동작을 실행해야 한다.   한 워드를 메모리부터 가져오기 때문에 패치(fetch)동작이라고도 한다.     접근 시간(access time)     기억 장치가 출력 신호를 받은 시간부터 데이터가 출력된 때까지의 시간   자기 코어 기억 장치에서는 접근 시간과 복원 시간을 합해서 사이클(cycle) 시간이라 하며, IC 메모리에서는 사이클 시간이 접근 시간과 같다.   메모리소자 동작속도의 측정치로 읽기동작하는 데 필요한 시간이라고도 할 수 있으며, 이는 주소입력 순간으로부터 메모리 내용의 출력순간까지의 시간이다.     랜덤 액세스메모리(RAM)     한 메모리 워드의 실제 물리적 위치가 그 위치로부터 읽거나 쓰는 데 걸리는 시간이 얼마나 걸리는가에는 영향을 받지 않는 메모리이다. 즉 액세스시간이 메모리의 모든 주소에 대해서 같은 메모리이다.   대부분의 반도체메모리와 코어메모리는 RAM이다.            사용 예 : CDP(컴팩트 디스크 플레이어)는 적당한 코드를 입력함으로써 어떤 한 노래를 선택하든간에 같은 시간을 갖는다.              순차 액세스 메모리(SAM)     액세스시간이 일정하지 않고 주소위치에 따라 변하는 메모리의 한 형태이다.   원하는 주소에 도달할 때까지 모든 주소위치를 통하여 저장된 워드를 순차적으로 찾기 때문에 랜덤 액세스메모리보다 더 긴 액세스시간을 갖는다.            사용 예 : 자기테이프, 디스크, 자기버블메모리             읽기전용메모리(ROM)     읽기동작이 쓰기동작보다 매우 많은 응용분야를 위해 설계된 반도체메모리의 종류   기술적으로 (주로 제작자에 의해)단 한 번만 프로그래밍되어 쓸 수 있으며, 이후로는 내용을 수정할 수 없으며 읽기만 가능하다.   모든 ROM은 비휘발성이며 전원이 제거되어도 데이터는 그대로 저장된다.   한 번 이상 쓰기동작을 할 수 있는 메모리 RMM(Read Mostly Memory)도 있는데 읽기동작보다 쓰기동작이 훨씬 복잡하기 때문에 자주 사용되지는 않는다.                ROM의 구성도             ROM은 읽어내기만 하기 때문에 기억부와 번지 해독기, 출력 버퍼만으로 구성된다.     프로그램이나 자료 저장 방법에 따른 ROM 분류     마스크(Mask) ROM : 사용자의 요구에 따라 제작사가 자료를 넣기 때문에 내용을 바꿀 수는 없지만 대량 생산에 적합   PROM(Programmable ROM) : 제작시에 아무런 내용을 넣지 않은 상태로 만들어져서 사용자가 원하는 내용을 저장할 수 있다. 하지만 한 번 기억되면 그 내용을 변경할 수 없다.   EPROM(Erasable ROM) : ROM의 내용을 자외선 삭제 장치로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능   EEPROM(Electrically Erasable PROM) : ROM의 내용을 전기신호로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능     정적 램(static RAM device, SRAM)     전원이 인가되는 동안은 저장된 데이터가 영원히 저장되고, 주기적으로 데이터를 다시 쓸 필요가 없는 반도체 메모리장치   플립플롭 조합으로 구성되어 있다.     동적 램(dynamic RAM device, DRAM)     전원이 인가되어도 저장된 데이터가 영원히 유지되지 못하며, 데이터가 메모리에 주기적으로 다시 쓰여져야 저장된 데이터가 계속 저장되는 반도체메모리   이러한 주기적 동작을 리플레시(refresh)동작이라 한다.     휘발성 메모리(volatile memory)     전원이 제거되면 메모리에 있는 모든 정보가 소실된다.   반도체메모리가 휘발성 메모리에 해당한다.     캐시 메모리(cache memory)     SRAM과 구성이 동일하다.   기억 용량은 작으나 속도가 매우 빠른 버퍼(buffer) 메모리로 주기억 장치와 CPU와의 속도 차이를 줄여서 처리의 효율을 높이기 위해서 사용된다.   캐시 기억 장치의 호출 시간은 주기억 장치의 호출 시간보다 5~10배 정도 빠르다.   전체 기억 장치 시스템의 총 소요 시간을 최소화하면서 가능한 하 높은 평균 액세스 속도를 얻기 위해서 사용한다.      메모리의 연결     컴퓨터 내부메모리는 어드레스(Address) 버스, 데이터(Data) 버스, 제어(Control) 버스라는 세 종류의 버스로 CPU에 연결되는 신호선이 구성된다.     버스   1) 어드레스 버스 : CPU에서 메모리 IC까지 2진 어드레스 출력을 전달하는 단방향 버스  2) 데이터 버스 : CPU와 메모리 IC 사이에 데이터를 옮기는 양방향 버스  3) 제어 버스 : CPU에서 메모리 IC까지 제어신호들 전달     CPU의 쓰기동작 순서   1) CPU가 데이터가 저장될 메모리 위치에 2진 어드레스 공급. 어드레스 버스선에서 이 어드레스를 인가한다.  2) CPU가 데이터 버스선에 저장될 데이터 인가  3) CPU가 메모리 쓰기 동작을 위해 제어신호선 동작시킴  4) 메모리 IC들은 저장될 위치를 선택하기 위해 2진 어드레스 해독  5) 데이터 버스에 있는 데이터가 선택된 메모리 위치로 전송됨     CPU의 읽기동작 순서   1) 어드레스 버스선에 이 어드레스 인가. CPU가 데이터의 메모리 위치의 2진 어드레스 공급  2) CPU가 메모리 읽기동작을 위해 제어신호선 활성화 시킴  3) 메모리 IC중에서 읽기동작이 실행되는 위치를 선택하기 위해, 2진 어드레스를 해독한다.  4) 메모리 IC들은 선택된 메모리 위치로부터 데이터 버스에 데이터 인가. 데이터가 전송되는 곳으로부터 CPU로 데이터 인가     메모리 맵(Memory Map)     원하는 용량 및 워드사이즈에 알맞게 응용하기 위해 메모리칩을 조합하거나 큰 용량을 나누어 쓰는 것     ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-10/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 - 보조 기억 장치",
        "excerpt":"보조 기억 장치     주기억 장치는 적은 자료를 기억하여 고속으로 처리한다.   **그에 반해 많은 양의 자료를 기억시켜 관리하기 위한 장치**를 보조 기억 장치 또는 2차 기억 장치(secondary memory)라 한다.   보조 기억 장치의 자료를 액세스하는 방법에 따라 **순차 액세스**와 **임의 액세스**로 분류할 수 있다.     순차 액세스(sequential access)     물리적으로 저장된 순서에 따라 자료를 검색해 나가기 때문에 일괄 처리(batch processiong)에 적합하다.   그렇기 때문에 빠른 액세스가 요구되는 실시간 처리에는 잘 사용되지 않는다.            사용 예 : 자기 테이프             임의 액세스(random access)     원하는 레코드에 직접 액세스할 수 있는 방식   레코드를 순차적으로 읽지 않기 때문에 원하는 데이터를 빠르게 검색할 수 있다.   주로 실시간 처리 시스템에서 사용된다.            사용 예 : 자기 디스크              보조 기억 장치의 종류  자기 테이프(magnetic tape)     플라스틱 테이프의 표면에 자성 도료를 입혀 제작된 것     1) 특성      녹음 테이프와 비슷하게 생겼는데 폭이 1/2~3/4인지 정도로 넓고 기록 밀도가 높다.       대량의 자료를 반영구적으로 보관할 수 있고 가격이 저렴하다는 장점을 가지고 있다.   하지만 테이프가 릴에 순차적으로 감겨 있기 때문에 자료의 순차적 처리만 가능하다.     2) 기록 밀도      자기 테이프 1릴(reel)의 길이는 보통 800, 1,200, 1,600, 2,400 피트(feet) 등이며, 테이프의 기록 밀도는 테이프 1인치 당 저장될 수 있는 문자(character)의 수 혹은 바이트(byte)의 수로 계산 되고 있다.   이 기록 밀도의 단위를 BPI(Byte Per Inch)라고 하며 800, 1,600, 3,200, 6,250, 20,000BPI 등의 기록 밀도가 있다.   자기 테이프는 최초로부터 4~5m 지점에 BOT(Beginning of Tape) 마커가 있고 끝의 6~7m 앞지점에 EOT(End of Tape) 마커가 있는데, 이 부분에는 자료를 수록할 수 없다.   자기 테이프는 7개 또는 9개의 트랙(track)으로 구성되어 데이터를 표현한다.   자료의 저장은 ASCII 코드나 EBCDIC 코드로 표현된다.   파일의 갱신과 보수를 쉽게 하기 위하여 레이블을 사용하는데 레이블에는 표준 레이블, 비표준 레이블, 레이블이 없는 것 세 가지 종류가 있다.     3) 저장 방법      레코드는 자기 테이프에 순차적으로 기록되고 읽혀진다.   이 때 테이프가 레코드를 읽거나 기록하는 과정에서 테이프를 출발시키거나 멈추게 하는데는 물리적인 가속 및 감속 구간이 필요한데, 이를 IRG(Inter Record Gap)로 나타낸다.   IRG의 길이는 약 0.3~0.75인치로 각 레코드마다 IRG를 두게 되면 그만큼 저장할 수 있는 공간이 줄어들기 때문에 비효율적이다.   따라서 효율성을 위해 몇 개의 레코드를 묶어서 한 개의 물리적 레코드로 만들어 준다.   이것을 블록화라고 하며 하나의 블록에 포함된 논리 레코드의 수를 블록화 인수, 각 블록 사이의 간격을 IBG(Inter Block Gap)라 한다.     4) 자기 테이프의 레코드 형식      고정 길이 비블록 레코드(fixed unblock record)            블록화되지 않은 고정 길이 레코드       물리 레코드와 논리 레코드의 길이가 같다.           고정 길이 블록 레코드(fixed block record)            블록화된 고정 길이 레코드       레코드의 길이가 일정하며 하나의 물리 레코드 내에 2개 이상의 논리 레코드가 존재한다.           가변 길이 비블록 레코드(variable unblock record)            블록화되지 않은 가변 길이 레코드       각 논리 레코드의 길이가 일정하지 않다.           가변 길이 블록 레코드(variable block record)            블록화된 가변 길이 레코드       길이가 일정하지 않은 논리 레코드가 블록화되어 있는 형식이다.           부정 형식 레코드(undefined record)            길이를 나타내는 필드가 없는 가변 길이 레코드       비블록 레코드이다.             자기 디스크 장치         대용량을 저장할 수 있고 임의로 호출이 가능하기 때문에 은행 업무, 좌석 예약 업무 등 실시간 처리가 요구되는 자료 처리에 효율적이다.   처리 속도는 1,200 ~ 3,600 회전/분이며, 기록 밀도는 한 트랙당 3,000 ~ 13,000바이트, 즉 60만 ~ 520만 바이트가 수록된다.   자기 디스크 장치는 여러 디스크가 하나의 축에 연결되어 있는데 이것을 디스크 팩(pack)이라 한다.   그리고 각 면의 트랙을 수직으로 연결한 트랙군을 실린더(cylinder)라 한다.   트랙과 실린더에는 고유 번호인 트랙 번호와 실린더 번호가 있어서 기억 매체상의 주소(address)가 할당되어 있기 때문에 데이터에 직접 액세스 하는 것이 가능하다.     자기 드럼 장치(magnetic drum)         초기에 사용되던 주기억 장치   새로운 기억 장치가 개발되면서 보조 기억 장치로 사용되기 시작했지만 현재는 그마저도 잘 안 쓴다.   직경 20~30cm인 금속 원통의 표면에 자성 물질을 입힌 드럼으로 드럼을 회전시킬 때 표면에 헤드를 접근시켜 기억된 내용을 읽거나 새로운 내용을 기억시킨다.     플로피 디스크 장치(floppy disk)         자기 디스크와 같이 데이터를 직접 액세스하며 가볍고 취급이 간편한 반면, 먼지, 햇볕, 열 또는 자성 물질에 가까이 두지 않는 등 관리상 주의가 필요하다.   기록 방법에 따라 단밀도, 배밀도, 고밀도 등이 있으며, 2D는 양면 배밀도를 뜻하고 2HD는 양면 고밀도를 뜻한다.     하드 디스크(hard disk)         개인용 컴퓨터의 보조 기억 장치로 널리 사용되고 있다.   동작 속도는 ms로 나타내며, 보통 평균 액세스 속도와 트랙간 이동 속도, 최대 이동 거리 속도 등을 표시한다.   평균 속도가 빠를수록 전체적으로 동작이 빠르며 가격도 높아진다.   하드 디스크는 본체에 내장되어 사용되는 것이 보통이나 기억 용량의 증가, 편의성 등으로 외장형 하드 디스크도 사용되고 있다.     광학 디스크(optical disk)      레이저를 이용해서 자료를 기록한다.   레이저가 필요한 표면에 도착하면 표면을 태워서 비트 형태의 데이터를 저장한다.   광학 디스크는 데이터가 잘 지워지지 않는 백업 파일, 역사적 기록 등의 분야에 이용된다.     광 디스크의 종류   1) CD-ROM(Compact Disk-Read Only Memory)         지름이 12cm인 소형 디스크 위에 정보를 기록, 저장 및 검색할 수 있는 형식의 시스템으로 광학 드라이브를 이용해서 읽을 수 있다.   원본에 정보를 기록하기 위해서는 WORM 장치가 사용된다.   오디오 디스크, 비디오 디스크, 각종 상품화된 소프트웨어의 저장에 이용된다.     2) WORM(Write Once Read Memory)      디스크에 단 한 번만 정보를 기록할 수 있고 기록한 후에 지울 수 없고 판독만 할 수 있는데, 그 후에는 드라이브에 있는 데이터가 삭제되지 않도록 보호하는 데이터 저장기술이다.   문서용 파일, 비디오용 파일 등에 이용된다.     3) MO DISK(Magneto Optical Disk)         자기광학 디스크라고도 하며 자기박막의 광자기 효과를 이용하여 자료를 기록하고 읽어낼 수 있는 CD-ROM 형태의 외부 기억 매체   자료를 기록할 때엔 레이저광을 사용하여 자화시키는데 이 자화가 유지되어 정보가 기록된다.   판독시엔 피트(pit : 광자기 디스크 표면의 미세한 홈)에 반사되는 빛의 유무로 데이터를 판독한다.   광자기 디스크는 3.5인치 디스켓보다는 빠르지만 하드 디스크보다는 느리다.   광자기 디스크는 자료 백업용 기억매체로 사용하기 좋으며 이동이 간편하고 신뢰성이 높은 것이 장점이다.   오디오용, 비디오용, 컴퓨터 데이터 파일 등에 이용된다.     4) DVD      CD에서 더 발전한 광학 디스크 기술을 이용하는 저장매체이다.   외형은 CD와 같지만 다른 포맷으로 저장되며 높은 용량을 가지고 있다.   DVD는 MPEG-2 파일과 압축 표준을 사용한다.   MPEG-2 이미지들은 MPEG-1 이미지의 4배 해상도를 가지며, 2개의 필드가 하나의 이미지 프레임을 구성하는 상황에서 초당 60개의 인터레이스드 필드(Interlaced Field)를 전송할 수 있다. (MPEG-1은 초당 30개의 인터레이스되지 않은 프레임을 전송한다)           메모리 계층 구조    ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-11/",
        "teaser": null
      },{
        "title": "컴퓨터 하드웨어 - 산술 논리 연산 장치",
        "excerpt":"산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)     제어 장치의 지시에 따라 실제 자료 처리가 이루어지는 곳   사칙연산, 논리연산, 비교연산, 자리 이동(shift) 등을 수행한다.     산술 논리 연산 장치의 구성     가산기(adder), 레지스터(register), 보수기(complementary) 등으로 구성된다.        1) 누산기(ACC : accumulator)     연산 장치의 중심이 되는 레지스터   초기에는 연산될 데이터의 보관 장소로 사용되며, 연산 후에는 산술 및 논리 연산 결과를 일시적으로 보관한다.            =&gt; 연산 결과값을 일시적으로 기억             2) 데이터 레지스터(data register)     연산에 필요한 데이터가 두 개인 경우, 하나의 데이터를 일시적으로 보관하고 있다가 필요할 때 제공하는 역할을 수행한다.   기억 레지스터(storage register)라고도 한다.            =&gt; 연산에 필요한 데이터를 일시적으로 보관             3) 가산기(adder)     누산기와 데이터 레지스터에 보관된 두 값을 더하여 그 계산 결과를 다시 누산기에 보관한다.     4) 상태 레지스터(status register)     연산 결과가 양(0)인지 음(1)인지, 또는 자리 올림(carry)이나 오버플로우가 발생했는지 등의 연산에 관계되는 상태와 인터럽트(interrupt) 신호를 기억한다.     5) 보수기(complementary)     어떤 수를 보수로 바꾸어 주는 회로로서 뺄셈을 수행할 때 빼는 수를 보수로 바꾸어 가산기에 입력함으로써 감산의 결과를 얻을 수 있다.   보수에는 1의 보수와 2의 보수가 있는데 주로 2의 보수를 많이 사용한다.      산술 연산  1) 10진수 연산     부호가 있는 10진수 수치 자료의 연산을 수행하는 것   가감승제는 팩형 10진수(packed decimal) 형태의 데이터가 사용된다.     2) 2진수 연산     고정 소수점 연산과 부동 소수점 연산으로 나누어진다.   고정 소수점 연산은 일정한 길이의 바이트에 표시된 고정 소수점 수를 연산하는 것으로 10진수 연산보다 처리 속도가 빠르다.   부동 소수점 연산은 부호 비트, 지수부, 소수부로 구성되어 있으며, 부동 소수점 연산을 위해서는 특수 목적을 가진 레지스터가 필요하다.   부동 소수점 연산은 매우 큰 수나 작은 수를 다룰 수 있으며 연산 처리 속도가 고속이다.      논리 연산     사칙연산을 제외한 문자 처리   로드(load), 스토어(store), 분기(branch), NOT, AND, OR 등의 논리 연산과 자리이동(shift), 순환이동(rotate) 등이 있다.   이러한 데이터 처리는 비트나 바이트로 처리된다.            로드 : 기억 장치에서 CPU의 레지스터로 이동하는 것       스토어 : 레지스터에서 기억 장치로 이동하는 것       분기 : 명령의 실행 순서를 변경하는 것. 무조건 분기와 조건 분기가 있다.           ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-12/",
        "teaser": null
      },{
        "title": "적재와 프로그램과 프로세스",
        "excerpt":"🔸 적재(로드 load)     보조기억장치(HDD 등) -&gt; 주기억장치(RAM)로 이동   🔸 프로그램(Program)     하드디스크에 들어있는 상태 (아직 실행은 되지 않은 상태임)   🔸 프로세스(Process)     주기억장치에 로드된 상태의 프로그램(실행되고 있는 프로그램)   ☑️ 실행(load)되면 비로소 프로세스가 된다.     그러므로 인터넷 브라우저를 켜서 쓰고 있다면 인터넷 브라우저 프로세스를 사용하고 있다고 할 수 있다.(인터넷 브라우저 프로그램 사용중이라고 하는거 아님!!)   ","categories": ["Computer Science"],
        "tags": ["CS"],
        "url": "/computer%20science/CS-13/",
        "teaser": null
      },{
        "title": "깃허브 블로그(Github Blog)를 만들기 위한 여정",
        "excerpt":"🎬 시작   개발 공부를 시작하고 기존에 쓰던 티스토리 블로그가 있긴 했는데 뭔가 깃헙을 이용해서 블로그를 꾸미고 여기에 공부한 내용을 올리고 싶어졌습니다. 다른 개발자 분들이 쓰시는 걸 보니까 되게 있어보이기도 하고 만들어져 있는 큰 회사(?)의 블로그를 쓰는 것 보다는 내가 직접 만들어 보면 뭔가 더 공부가 되지 않을까… 하는 생각으로 깃헙 블로그 만들기에 호기롭게 도전하게 되었습니다.    그리고 그것은 엄청난 고생길의 시작이었습니다….ㅎ     0. 시작 전에… Ruby   깃헙 블로그는 보통 jekyll(지킬)이라는 것을 사용해서 꾸미더라고요. 근데 저건 ruby 기반으로 만들어져 있어서 깃헙 블로그를 시작하려면 ruby를 깔아야 합니다. 전 처음에 이것도 모르고 시작했기 때문에 블로그 글을 똑같이 따라해도 안 되었던 것들이 참 많았기 때문에…ㅎ 이 글을 보시는 분들은 시작 전에 꼭 ruby를 깔고 시작하세요!   ruby 설치 관련글은 아래 글과 같이 구글에 검색하시면 많이 보실 수 있을 것입니다.  https://ogaeng.com/jekyll-blog-install/   부디 고통받지 마시고 사전에 루비 설치하고 진행하세요…     +) 그리고…   시작 전에 깃헙 블로그는 터미널에서 명령어를 입력하는 것을 이용해서 만들 것인데 처음 하면 이것도 뭔가 싶으실 수 있습니다.  모든 블로그 글들을 따라하다 보면 터미널에서 무슨 명령어를 입력해라고 할텐데 그냥 터미널을 켜고 명령어를 입력하면 전혀 작동하지 않고 명령어로 실행하고자 하는 파일이 들어있는 위치로 이동한 다음에 해당 명령어를 입력해야 합니다.        그렇기 때문에 블로그 repository가 있는 폴더에서 마우스 우클릭해서 나오는 메뉴에서 ‘폴더에서 새로운 터미널 열기’ 를 선택해서 터미널을 실행하거나    cd /폴더경로  cd 명령어를 이용해 해당 파일이 있는 폴더로 이동해 모든 명령어를 입력해 주어야 합니다.     1. 참고했던 글   https://zeddios.tistory.com/1222   맨 처음에는 이 블로그 글을 참고해서 만들었었습니다.   그런데 똑같이 따라하고 심지어 테마도 똑같은 걸로 받아 썼지만 안 되더라고요… 제 repo에 push도 잘 되는데 정작 제 블로그 페이지에 들어가보면 맨 처음에 기본으로 주는 테마에서 변경이 안 되었습니다. .gitignore 설정이 잘못 되어있나 싶어서 아예 지워도보고 기타등등 별 짓을 다 해봤지만 되질 않아서… 이 글을 따라하며 만들었던 repo를 삭제하고 다시 만들기로 다짐하면서 다른 블로그 글을 찾아 떠나게 됩니다.   만약 이 글대로 하셔서 잘 되시면 거기서 스톱하고 나만의 블로그를 꾸미시면 됩니다. 전 되질 않아서 더 많은 시간을 소비해야만 했거든요…ㅠ    ! 그리고 테마를 설치하다 보면 거의 99% 확률로   `require’: cannot load such file – webrick (LoadError)   이런 메세지를 보게 됩니다. 근데 다른 블로거분들은 이런걸 보신 적이 없는지 이것에 대한 언급이 아무도 없으심 ㅠ.ㅠ  https://junho85.pe.kr/1850   만약 저런 오류 메세지를 보시면 이 글을 참고하여 해결하시면 됩니다.   bundle add webrick  무엇보다도 중요한 명령어… 전 테마를 설치할 때마다 webric을 꼭 추가해 주어야 했습니다.     https://honbabzone.com/jekyll/start-gitHubBlog/   그리고 두번째로 찾은 글  새로운 마음으로 다시 repo를 만들고 테마도 똑같은 걸로 다운받아서 진행했습니다.   이번엔 다행히 잘 되었습니다. 😄👏👏👏   하지만 댓글 기능을 추가하려고 disqus에 들어가 보니까       기본적으로 유료 서비스더라고요… 무료 서비스도 있긴 한데 무겁고 광고가 붙는다고 해서 disqus는 쓰지 않고 오픈소스에다 가벼운 utterances를 쓰기로 했습니다.     2. utterances로 댓글 기능 만들기   사실 영어를 그닥 좋아하지 않아서(^^;) 최대한 한국인이 쓴 글을 구글링 해서 찾는 편이지만 제가 쓰는 테마는 영어를 쓰는 사람이 만들었기 때문에 영어로 된 설명서를 봐야만 했습니다.   https://github.com/apps/utterances   일단 여기로 이동하셔서 utterances를 repo에 설치합니다.         인스톨 버튼을 누르시면         이런 화면을 보실 수 있는데 제가 가진 모든 repo에 댓글 기능을 추가할 필요는 없기 때문에 블로그용으로 쓰는 repo만 선택했습니다. 여기까지 하셨으면 Install을 눌러서 다음으로 진행하시면 됩니다.        다음으로 넘어가면 이런 화면을 보실 수 있는데 configuration 아래 repo를 설정하는 란에 나의 깃헙 블로그 파일들을 저장하는 repository의 경로를 적어주시면 됩니다. 깃헙아이디/깃헙아이디.github.com 혹은 깃헙아이디/깃헙아이디.githun.io 이런 식으로 보통 적으실 것입니다.        밑으로 내려보시면 이런 선택란이 있을텐데 댓글이 작성되는 루트를 어디로 설정해주느냐 선택하는 것이라고 합니다. pathname은 블로그에 올릴 포스트의 파일명으로 깃헙 블로그에 올릴 포스트의 파일 이름 형식은 정해져 있어서(ex. 2022-01-30-title.md) 바꿀 일이 거의 없다고 봐도 되기 때문에 맨 첫번째 것으로 선택했습니다. 다른 분들도 많이 선택하시는 옵션이었습니다.        그리고 또 밑으로 내려보시면 이런 태그를 보실 수 있는데 본인이 쓰시는 테마의 레이아웃에 이걸 설정하는 란이 따로 있다면 저 태그를 복사해서 넣어주시면 되는데 제가 쓰는 테마엔 따로 없어서 저 태그는 필요가 없었습니다.   Theme 아래 화살표가 있는 박스를 눌러보시면 댓글창의 테마를 선택할 수 있으니 맘에 드는 것을 고르시면 되겠습니다.         대신 위 설명처럼 _config.yml 파일에서만 설정해주면 되었습니다.        이런 식으로 provider 이름만 설정해주고 아래 utterances 정보 입력란에서 입력만 해 주니까        짜잔! 댓글창이 생겼습니다!! 😘👏👏  아 행복해… 이거 만든다고 또 한시간 썼었거든요…ㅠ   댓글창 색이 테마랑 좀 안맞는 감이 있지만 이건 천천히 수정하기로 하고.. 여기까지 해서 제 첫 깃헙 블로그를 만들기 위한 여정이 마무리 되었습니다.    혹시 제 블로그 설정 파일이 궁금하시면    https://github.com/miro7923/miro7923.github.com   여기를 참고하세요.    https://github.com/miro7923/miro7923.github.com/blob/main/_config.yml  그 중에서도 _config.yml 파일 내용이 궁금하시면 여기를 참고하시면 됩니다.      3. 그런데.. 열심히 쓴 글이 포스팅 되지 않는다.   드디어 블로그 세팅을 완료하고 설레는 마음으로 첫 글을 썼는데 로컬 서버로 띄워 보면 잘 보이는데 암만 push를 해도 실제 제 블로그에서는 보이질 않는 것이었습니다…! 머선일이고 이게 ㅠㅠ   약 한시간동안 헤멘 끝에   https://devyuseon.github.io//github%20blog/githubblog-post-not-shown/  이 글을 보고 해결할 수 있었습니다.        저는 _config.yml에 future: true 추가하고 게시글 마크다운 파일의 상단 타이틀 쓰는 란에 published: true 를 추가해 주었더니 해결되었습니다.   그리고 네이버나 티스토리처럼 큰 회사 블로그처럼 push 하자마자 블로그가 업데이트 되는 것은 아니고 몇 분 정도 기다려야 변경내용이 완전히 반영이 되더라고요. 외국 회사라 그런가?   하지만 네이버랑 티스토리에 비해서는 손이 가는게 많아서 그런지 포스트 하나를 쓰고 나면 뭔가 엄청 뿌듯하고 그렇습니다.😄 열심히 해야지!     그럼 오늘은 여기까지… 다음 글에서 만나요!!   ","categories": ["Story"],
        "tags": ["story"],
        "url": "/story/making-github-blog/",
        "teaser": null
      },{
        "title": "DB 구동 및 접속",
        "excerpt":"🎬 DB 구동 및 접속    1. Linux 부팅 및 터미널 실행     Windows에서 가상 PC를 실행한 뒤 Linux 부팅 후 로그인한다.   Linux 부팅이 완료되면 마우스 우클릭 - 터미널 열기   2. Listener 시작  $ lsnrctl start     Listener를 시작한다.   Listener는 네트워크를 이용하여 클라이언트에서 오라클 서버로 연결하기 위한 오라클 네트워크 관리자이다.   리스너를 시작하지 않아도 DB 구동엔 문제가 없지만 네트워크를 통한 연결은 모두 리스너가 담당하기 때문에 리스너를 시작하지 않으면 DB에 접속하고자 하는 클라이언트들이 접속할 수 없다.   따라서 터미널이 실행되면 가장 먼저 리스너를 시작한 후 다음 프로세스를 진행한다.     3. SqlPlus 실행  $ sqlplus /nolog   4. Database 접속  $ conn 아이디/비밀번호 as sysdba(권한)  🔸 DB User     sysdba : dba + DB 생성 + DB 시작/종료 권한   system : dba 권한   hr : Object(테이블, 뷰, 시퀀스 등) 생성 및 운영 권한     5. Database 시작  SQL&gt; startup   6. HR 사용자로 DB Login  SQL&gt; conn 아이디/비밀번호   7. 사용자 확인  SQL&gt; show user     HR 사용자로 최종 로그인 되었는지 확인한다.   🔸 User 비밀번호 변경 방법  SQL&gt; alter user 아이디      identified by 새 비밀번호;  ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/DB-start-conn/",
        "teaser": null
      },{
        "title": "DB 기초",
        "excerpt":"🎬 DB란?    🔸 DB를 쓰는 이유     데이터를 오프라인으로 캐비넷에 저장하자니 물리적 저장 공간은 한정되어 있다.   그렇다면 엑셀 파일을 만들어 암호를 걸어 쓰는 방법이 있는데 만약 암호가 유출된다면 그 엑셀 파일 안에 저장된 정보도 모두 유출된다. 따라서 이것도 안전한 방법은 아니다.   그래서 서버에 데이터베이스를 구축하고 거기에 고객 정보를 저정하고 관리하는 것이다.            데이터베이스엔 애초에 허가받은 사용자만 접근할 수 있고 허가받은 권한 만큼만 데이터에 접근할 수 있다.             🔸 DBMS     데이터베이스 관리 시스템   DB에서 필요한 데이터를 검색하거나 삽입, 수정, 삭제하기 위한 프로그램   ORACLE, MySQL등이 있으며 이것들이 DB 자체를 의미하는 것은 아니다.            DB를 다루기 위한 수단으로서 MySQL을 사용하면 MySQL을 사용한 DB 프로그램인 것이다.             🔸 RDBMS     관계형 DBMS   시중에 나와있는 대부분의 DBMS라고 보면 된다.     🔸 SQL     데이터 액세스를 위해 ORACLE server와 통신하는 언어로 DB와 소통하기 위한 언어   모든 DBMS에서 사용하는 공용언어     🔸 TABLE     DB에서 사용하는 대표 객체(오브젝트)   테이블을 사용해서 데이터를 분류한다.        세로는 열(column), 가로는 행(row)!!   column과 row가 만나는 곳은 Field(Record)값이라고 부른다.   ","categories": ["Database"],
        "tags": ["DB"],
        "url": "/database/DB-start/",
        "teaser": null
      },{
        "title": "HTTP 프로토콜(HyperText Transfer Protocol)",
        "excerpt":"🎬 HTTP 프로토콜이란?     실제 사용자와 연결된 최상위 계층의 프로토콜로 가장 대표적인 웹브라우저의 통신에 관한 프로토콜     🔸 프로토콜(Protocol)     네트워크상에서 데이터를 주고 받는 규칙   컴퓨터 상호간의 대화에 필요한 통신 규약      1. HTTP 프로토콜의 구조     요청(Request)과 응답(Response) 형태로 이루어졌다.   사용자가 웹 페이지의 링크를 클릭하면 브라우저는 HTTP 프로토콜의 요청 형태로 HTTP 메시지를 작성하여 웹 서버에 전송한다.   웹 서버에서는 지금 받은 HTTP 메시지가 요청(Request) 메시지임을 판단하고 그 데이터를 분석해서 HTTP 프로토콜의 응답(Response) 형태로 메시지를 작성하여 브라우저로 보내게 되면 브라우저는 메시지를 받아서 사용자의 화면에 표시하게 된다.        각 HTTP 메시지는 지금 작성 된 메시지가 요청인지, 응답인지와 요청 URL 등 기본적인 정보가 담겨있는 시작 라인과 수행 날짜, 서버 정보, 브라우저 버전 등 부가적인 정보를 담는 헤더 그리고 요청이나 응답에 필요한 내용을 담고 있는 본문(Body)으로 구성된다.      2. HTTP 요청(Request) 메시지     기본적으로 HTTP 메소드(Method)와 접근할 주소(URL) 정보 그리고 서버에 전달할 데이터인 폼 파라미터로 구성된다.   HTTP 메소드(Method)는 클라이언트가 웹 서버가 해야 할 행동을 정해주는 정보로 GET 메소드와 POST 메소드가 있다.   GET 메소드를 사용하는 요청 메시지를 GET 방식의 요청, POST 메소드를 사용하는 요청 메시지를 POST 방식의 요청이라고 한다.     🔸 GET 방식     전송할 파라미터 값들을 시작 라인의 URL 정보에 붙여서 같이 전송한다.   파라미터의 길이는 256바이트를 넘을 수 없다.   본문(Body)이 필요없기 때문에 전송 속도가 POST 방식에 비해 빠르다.   전송해야 할 데이터가 적을 때 유용하다.   파라미터가 URL뒤에 붙어서 전송되므로 사용자가 브라우저의 주소 창에서 전송되는 파라미터를 실제로 확인할 수 있다.     🔸 POST 방식     전송할 파라미터 값들을 요청 메시지 본문(Body)에 담아서 전송한다.   따라서 전송할 수 있는 데이터의 양에 제한이 없으며 주소창에서 전송되는 파라미터 확인이 불가능하다.   GET 방식에 비해 보안상 더 유용하다.           3. HTTP 응답(Response) 메시지     요쳥에 대한 서버의 처리 성공 여부를 표시하는 상태 코드(HTTP 404, 500 등) 번호와 웹 서버가 응답해주는 콘텐츠의 타입 정보(텍스트/HTML, 이미지 등), 콘텐츠의 내용으로 구성된다.   실제적으로 서블릿 클래스가 요청을 처리해 생성하는 페이지는 웹 서버에서 응답 메시지의 형태로 작성되어 사용자의 브라우저에 전송된다.  ","categories": ["JSP"],
        "tags": ["WEB","JSP","HTTP"],
        "url": "/jsp/JSP-http-protocol/",
        "teaser": null
      },{
        "title": "서블릿의 동작 원리",
        "excerpt":"1. 사용자의 URL 요청     웹 서버가 배포 서술자를 통해 지금 받은 요청이 서블릿 요청이라는 것을 알게 되면 서블릿을 담당하는 웹 컨테이너로 그 요청을 전달한다.     🔸 배포 서술자(Deployment Descriptor)       사전에 웹 서버측에 URL과 서블릿 클래스를 미리 매핑시켜놓은 것     2. request, response 객체 생성     웹 컨테이너는 받은 요청을 처리하기 위해 HTTP 요청을 처리하기 위한 request 객체와 HTTP 응답을 위한 response 객체를 생성한다.     3. 서블릿 인스턴스와 스레드 생성     request, response 객체가 생성된 뒤 사용자의 URL 요청이 어떤 서블릿 클래스를 필요로 하는지 배포 서술자를 통해 알아낸다.   그 클래스가 한 번도 실행된 적이 없거나 현재 메모리에 인스턴스(프로세스)가 없으면 새로 생성한 뒤 스레드를 하나 생성하고 이미 인스턴스가 존재한다면 기존의 인스턴스에 스레드만 하나 새로 생성한다.   각 서블릿 클래스는 웹 컨테이너당 하나만 존재한다.     4. service() 메소드 호출과 서블릿 클래스 실행     스레드가 생성되면 각 스레드에서 service() 메소드가 호출된다.   service() 메소드가 호출되면 HTTP 요청 방식이 GET 방식이면 doGet() 메소드가, POST 방식이면 doPost() 메소드가 request, response 객체를 인자로 자동으로 호출된다.   개발자가 실제로 동적인 웹 페이지 생성을 할 수 있는 코드를 만들어야 하는 부분이 doGet()과 doPost() 메소드 부분이다.     5. 응답과 스레드의 소멸     사용자의 요청에 따른 동적인 웹 페이지를 생성한 결과물이 담긴 response 객체를 웹 컨테이너가 HTTP 응답 형태로 바꾸어 웹 서버로 전송한다.   사용이 끝난 request와 response 객체를 소멸시키고 스레드를 종료한다.   웹 서버는 전송 받은 HTTP 응답 메시지를 사용자의 브라우저로 전송하게 되고 사용자는 브라우저를 통해 동적으로 생성된 페이지를 받아보게 된다.     ","categories": ["JSP"],
        "tags": ["WEB","JSP","HTTP","Servlet"],
        "url": "/jsp/JSP-servlet-process/",
        "teaser": null
      },{
        "title": "웹페이지 기초",
        "excerpt":"🔸 웹페이지에는 정적데이터와 동적데이터가 있다.      네이버 홈페이지에 접속하면 보이는 이미지 데이터들은 정적데이터        HTML, CSS, JavaScript, … =&gt; WEB 서버에서 처리         신문 기사, 날씨, 코스피 지수 등 변하는 값들은 동적데이터   DB에 저장되어 있는 데이터 =&gt; WAS(Web Application Server - web에 application이 추가된 것)서버에서 처리            예) 톰캣이라는 서버에서 자바 애플리케이션이 실행되고 있는 것             🔸 웹페이지 동작     [클라이언트/사용자]가 naver에 요청 ➡️ [naver - WEB서버]가 판단해서 요청한 데이터가 정적데이터만 있다면 바로 실행하게 만듦 ➡️ [클라이언트/사용자]에게 naver가 응답(정적데이터)        👉 이 결과로 사용자는 naver 페이지를 볼 수 있게 된다.         하지만 동적데이터도 있다면…   naver가 [naver서버 - WAS서버]에 동적데이터를 요청한다.        그러면 [Database서버]에 데이터를 요청해서 사용자에게 보여준다.            +) .com, .co.kr 과 같은 도메인은 비싸다.   .ar 같은 도메인들은 무료   🔸 DNS     도메인 네임서버   IP주소를 도메인 주소로 바꾼 것   숫자로 된 IP주소는 외우기 힘드니까 좀 더 읽기 쉬운 문자형 주소로 바꾸는 것  ","categories": ["JSP"],
        "tags": ["WEB","JSP"],
        "url": "/jsp/JSP-web-beginning/",
        "teaser": null
      },{
        "title": "웹 컨테이너",
        "excerpt":"🎬 웹 컨테이너란?     JSP와 서블릿을 사용한 웹 서버는 크게 URL 주소의 해석을 담당하는 HTTP 서버와 서블릿 클래스 또는 JSP 파일의 실행 요청을 처리해주는 웹 컨테이너(Web Container)로 구성된다.   HTTP 서버는 단순히 어떤 주소(URL) 요청이 들어왔을 경우 그 주소에 미리 매핑되어 있는 콘텐츠(HTML 파일이나 이미지 등)를 사용자의 브라우저에 응답 형태로 전송하는 역할을 한다.   이 때 요청된 URL이 서블릿 클래스 또는 JSP 파일일 경우 HTTP 서버는 이를 웹 컨테이너에서 처리하도록 클라이언트의 요청을 넘겨준다.   웹 컨테이너에서는 요청된 URL에 맞는(미리 설정된) 서블릿 클래스 또는 JSP 파일을 실행하여 결과를 HTTP 서버에 넘겨주게 되고 이는 응답 메시지의 형태로 사용자의 브라우저에 전송된다.     👉 즉 웹 컨테이너란 웹 서버 내부에서 서블릿 클래스 또는 JSP 파일을 실행하기 위한 실행 환경을 제공하는 역할을 한다.       서블릿 클래스에 대한 웹 컨테이너를 서블릿 컨테이너   JSP 파일에 대한 웹 컨테이너를 JSP 컨테이너     대표적으로 아파치 톰캣, 웹로직, Resin 등이 있다.  ","categories": ["JSP"],
        "tags": ["WEB","JSP","HTTP"],
        "url": "/jsp/JSP-web-container/",
        "teaser": null
      },{
        "title": "웹 프로그래밍 언어 종류",
        "excerpt":"1. CGI(Common Gateway Interface)     응용 프로그램과 웹 서버 사이의 정보를 주고받는 방식이나 규약들을 정해 놓은 것   단순한 HTML 방식으로는 동적인 웹 페이지를 만들기가 어렵기 때문에 서버측에서 동적인 데이터를 처리해 클라이언트에 HTML 문서로 전송해 줄 수 있는 응용 프로그램(웹 프로그램)이 필요해져서 만들어졌다.   현재 웹 프로그래밍은 대부분 ASP, PHP, JSP를 이용한 것이 대부분인데, DBMS와의 간편한 연동, 객체 지향적인 특성, 편한 개발 환경 등 강력한 기능을 갖추었기 때문이다.     🔸 DBMS(Database Management System)     데이터베이스 관리자라고도 불리며 다수의 컴퓨터 사용자들이 데이터베이스 안에 데이터를 기록하거나 접근할 수 있게 해주는 프로그램   DBMS는 데이터베이스 내의 정보를 검색하거나, 데이터베이스에 정보를 저장하기 편리하고 효율적인 환경을 제공하며, 응용 소프트웨어별로 흩어져 있는 자료들을 통합하고 통합된 자료들을 각 응용 소프트웨어가 공유하여 정보의 체계적인 활용을 가능하게 한다.   일반적인 형태의 DBMS는 관계형 데이터베이스 관리 시스템(RDBMS)인데, RDBMS의 표준화된 사용자 및 프로그램 인터페이스를 SQL(Strutured Query Language)이라고 한다.   RDBMS로는 오라클(Oracle), 사이베이스(Sybase), 인포믹스(Infomix)등이 쓰인다.     🔸 인터페이스(Interface)     사물과 사물간의 소통이 가능하도록 만들어진 매개체 또는 규약   웹 프로그래밍에서는 서버와 응용 프로그램 간의 원활한 통신이 가능하도록 만들어진 규약을 말한다.     🔸 스크립트 언어(Script Language)     C와 같은 일반적인 프로그래밍 언어는 컴파일러에 의해 컴파일 되어 2진수로 되어있는 기계어로 변환되어야지만 컴퓨터 상에서 실행될 수 있다.   이와는 달리 컴파일이 필요 없이 해석기(인터프리터)에 의해 즉시 실행될 수 있는 프로그램 언어를 스크립트 언어라고 한다.   대표적으로 브라우저에 의해 해석되어 실행되는 JavaScript가 있으며, Unix의 쉘 스크립트, 윈도우의 Batch 파일도 스크립트 언어라 할 수 있다.      2. ASP(Active Server Page)     C#(.Net)과 유사하다.   동적인 웹 페이지의 구현을 위해 Visual Basic 언어를 기반으로 만들어진 VBScript라는 스크립트 언어를 사용해서 구성된 웹 프로그래밍 기술   쉬운 문법을 가지고 있어 빠르고 쉽게 개발할 수 있고 Active-X 및 DDL 컴포넌트를 사용하여 어느 정도의 확장성도 갖추었지만 웹 서버로 오직 Windows 기반의 IIS(Internet Information Server)만을 사용할 수 있기 때문에 플랫폼에 비독립적이라는 큰 단점을 가디고 있다.   또한 Java 기반의 JSP에 비해 시스템 자원의 효율성과 확장성이 떨어진다.      3. PHP(Personal Hypertext Preprocessor)     ASP와 유사한 스크립트 기반의 언어이지만 C를 기반으로 만들어져서 빠른 속도를 가지고 있다.   다양한 플랫폼에서 사용 가능하며 100% 무료로 사용할 수 있다.   하지만 서버측의 지원 인프라가 매우 부족하여 확장성이 떨어지고, 기업형의 복잡한 시스템 구조에 적용하기가 힘들고 보안상의 약점을 가지고 있다.      4. JSP     Java를 기반으로 만들어진 서블릿(Servlet)이라는 동적 웹 구현 기술이 개발된다.   서블릿은 객체지향적이며 플랫폼 독립적인 자바의 장점을 그대로 웹에서 구현할 수 있었으며 스레드(Thread) 기반의 요청 처리 방식을 채택했기에 사용자가 많을수록 효율적으로 동작하는 기술이었다.   하지만 익히기가 쉽지 않은 편이었기 때문에 유저인터페이스의 구현이 쉬운 ASP의 장점을 수용하여 JSP가 개발된다.   JSP 또한 스크립트 기반으로 개발되어 훨씬 쉽게 작성할 수 있었고 서블릿과 함께 구동함으로써 서블릿의 기능을 그대로 사용할 수 있고 자바빈즈(JavaBeans), EJB같은 기술로 보다 강력한 객체지향적 지원이 가능해졌다.   또한 JSTL을 지원하게 되면서 웹 프로그램의 가독성이 좋아지고 유지 및 보수가 훨씬 쉬워지는 장점을 가지게 되었다.   이러한 장점들은 대규모 프로젝트에서 유용하기 때문에 최근에는 일정 규모 이상의 웹사이트를 개발할 때에는 주로 JSP를 사용한다.     🔸 프로세스(Process)     실행 중인 프로그램을 나타내는 말로 태스크(Task)라고도 한다.   윈도우와 같이 멀티태스킹을 지원하는 운영체제에서는 동시에 실행되고 있는 여러 개의 프로세스에 대하여 CPU와 메모리 자원을 안정되게 분배해 주어야 하며 이러한 역할은 그 운영체제의 성능을 결정하는 데 있어 아주 중요한 요소이다.   그런데 운영체제는 똑같은 프로그램이 두 개 이상 실행되면 같은 프로그램이라 하더라도 서로 다른 자원을 할당해 두 개 이상의 프로세스를 만든다.   이는 실행되는 프로그램의 수가 늘어날수록 할당해야 하는 자원이 늘어나게 되어 굉장히 비효율적이고 성능의 하락을 가져올 것이다.   이러한 단점을 극복하기 위해 개발된 것이 스레드(Thread)이다.     🔸 스레드(Thread)     하나의 프로세스 내에서 해당 프로세스가 할당받은 자원을 공유하며 실행되는 독립적인 작업단위   프로세스의 자원을 참조할 뿐 새로 할당받을 필요가 없기 때문에 프로세스를 생성하는 것보다 훨씬 빠른 생성 속도를 가진다.   ","categories": ["JSP"],
        "tags": ["WEB","JSP"],
        "url": "/jsp/JSP-web-programming-languages/",
        "teaser": null
      },{
        "title": "SELECT 구문을 사용한 데이터 검색",
        "excerpt":"🎬 SQL 문법은 기본적으로 대소문자를 구분하지 않는다.     ☑️ 문법  SELECT * | {[DISTINCT] column | expression [alias], ...} FROM   table;   1. 테이블 구조 조회  DESCRIBE employees       2. 테이블로부터 데이터 검색  1) SELECT 구문  SELECT * FROM   department;     ‘*‘은 모든 것을 보여달라고 할 때 사용한다.   SQL 구문 또한 세미콜론(;)을 사용해서 문장이 끝났다는 것을 표시하기 때문에 명령어를 실행하려면 마지막에 세미콜론을 꼭 찍어줘야 한다.    SELECT department_id, location_id FORM   departments;     SELECT 뒤에 컬럼명을 지정하면 해당 컬럼에 해당하는 내용들만 보여달라는 뜻이 된다.    SELECT last_name, salary, 12*salary+100 FROM   employees;     12*salary+100 처럼 내가 원하는 계산을 한 결과를 출력하게 할 수도 있다.     🔸 입력한 명령어 수정 (마지막으로 쓴 명령어와 비슷한 명령어를 또 써야 할 때 유용하다)     SQL에서는 가장 마지막에 입력한 구문 하나만 버퍼에 저장되어서 이것을 수정할 수 있다.     ed           위 명령어를 입력하고 엔터를 치면 버퍼를 수정할 수 있는 모드에 들어갈 수 있다.     i           를 누르면 하단에 –INTSERT–가 표시되며 버퍼에 저장된 명령어를 수정할 수 있다.   이 때 구문의 마지막에 세미콜론을 입력하면 안 된다!!!   모든 수정이 끝나면 ESC를 눌러 수정을 종료한 뒤     :wq           위 명령어를 입력하면 버퍼 수정 모드를 빠져나온다.     / + ENTER           ’/’를 입력하고 엔터를 누르면 버퍼에 저장된 명령어를 실행하는 동작이다. 모든 수정을 마치고 나와서 ‘/’ + 엔터를 실행해주면 아까 수정했던 명령어가 실행되는 것을 볼 수 있다.     2) null값이란?     사용할 수 없는 값, 알려지지 않은 값, 할당받지 못한 값, 모르는 값, 아직 정의되지 않은 값 등…   null은 0(zero)이나 공백과는 다른 특수한 값으로 모든 데이터타입에 사용 가능하다.     3) Column Alias     컬럼명에 별명을 붙이는 것   원래 정해져 있는 컬럼명을 사용자가 보기에 좀 더 알아보기 쉽게 표시하고 싶을 때 사용한다.     1️⃣  컬럼명 AS alias      2️⃣  컬럼명 alias      3️⃣  컬럼명 [AS] “Alias” =&gt; 대소문자 구분, 공백 포함, 특수문자 포함을 원하는 경우      SELECT last_name AS name, commission_pct comm FORM   employees;                  SELECT last_name \"Name\", salary*12 \"Annual Salary\" FROM   employees;                   4) 연결 연산자 (||)  SELECT last_name || job_id AS \"Employees\" FROM   employees;                                                 로 연결된 컬럼들을 묶어서 한 컬럼에 표시해 준다. 이것 또한 Alias 지정이 가능하다.                             5) 리터럴 문자     리터럴 문자란 쿼리 구문에 포함된 일반 문자, 숫자, 날짜 값   문자나 날짜 리터럴은 작은 따옴표로 묶어서 작성해야 함     SELECT last_name || ' is a ' || job_id      AS \"Employee Details\" FROM   employees;           Alias를 지정하지 않았다면 ‘last_name is a job_id’ 라는 컬럼명으로 표시된다.     6) DISTINCT 키워드     중복된 값을 자동으로 제거해 주는 키워드     SELECT DISTINCT department_id FROM   employees;               ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-SELECT/",
        "teaser": null
      },{
        "title": "WHERE(조건문)절과 ORDER BY(정렬)절",
        "excerpt":"☑️ 문법  SELECT * | {[DISTINCT] column | expression [alias], ...} FROM   table [WHERE condition(s)] [ORDER BY {column, expr, alias} [ASC | DESC]];   1) 1. WHERE절     WHERE절을 사용해서 특정 칼럼에서 어떤 값을 가진 필드값만 찾아달라고 할 수 있다.     SELECT employee_id, last_name, job_id, department_id FROM   employees WHERE  department_id = 90;           employee_id, last_name, job_id, department_id 컬럼을 출력하는데 department_id가 90인 필드만 출력해라       SELECT last_name, job_id, department_id FROM   employees WHERE  last_name = 'Whalen';           last_name, job_id, department_id 컬럼을 출력하는데 last_name이 ‘Whalen’인 필드만 출력해라       SELECT last_name FROM   employees WHERE  hire_date = '17-FEB-96';           last_name 컬럼을 출력하는데 hire_date가 96년 2월 17일인 필드를 출력해라   날짜를 쓸 때엔 ‘DD-MM-YY’형식으로 쓴다.     SELECT last_name, salary FROM   employees WHERE  salary &lt;= 3000;     last_name, salary 컬럼을 출력하는데 salary가 3000 이하인 필드를 출력해라       SELECT last_name, salary FROM   employees WHERE  salary BETWEEN 2500 AND 3500;           last_name, salary 컬럼을 출력하는데 salary가 2500 ~ 3500 사이인 필드를 출력해라       SELECT employee_id, last_name, salary, manager_id FROM   employees WHERE  manager_id IN (100, 101, 201);           employee_id, last_name, salary, manager_id 컬럼을 출력하는데 manager_id가 100이거나 101이거나 201인 필드를 출력해라(or과 같은 역할)       SELECT last_name FROM   employees WHERE  last_name LIKE '_O%';           last_name 컬럼을 출력하는데 last_name의 두번째 문자가 o인 필드를 출력해라     🔸 LIKE 비교연산자       % : 0 char 또는 여러개 char   _ : 반드시 1 char            a로 시작되는 문자열 : ‘a%’       a가 포함된 문자열 : ‘%a%’       a로 끝나는 문자열 : ‘%a’       두번째 문자가 a인 문자열 : ‘_a%’       끝에서 세번째 문자가 a인 문자열 : ‘%a__‘             SELECT last_name, manager_id FROM   employees WHERE  manager_id IS NULL;     last_name, manager_id 컬럼을 출력하는데 manager_id가 null인 필드를 출력해라     SELECT employee_id, last_name, job_id, salary FROM   employees WHERE  salary &gt;= 10000 AND    job_id LIKE '%MAN%';     employee_id, last_name, job_id, salary 컬럼을 출력하는데 salary가 10000 이상이고 job_id에 MAN이 포함되는 필드를 출력해라     SELECT employee_id, last_name, job_id, salary FROM   employees WHERE  salary &gt;= 10000 OR     job_id LIKE '%MAN%';     employee_id, last_name, job_id, salary 컬럼을 출력하는데 salary가 10000 이상이거나 job_id에 MAN이 포함되는 필드를 출력해라     🔸 비교연산자에 NOT(논리연산자)이 조합으로 사용된 경우       2. ORDER BY절     ORDER BY절을 사용해서 특정 조건에 따라 필드값을 정렬해서 볼 수 있다.   ASC : Ascending order, default 오름차순   DESC : Descending order 내림차순     SELECT last_name, job_id, department_id, hire_date FROM   employees ORDER BY hire_date DESC;           last_name, job_id, department_id, hire_date 컬럼을 출력하는데 hire_date의 내림차순으로 정렬해라     SELECT employee_id, last_name, salary*12 annsal FROM   employees ORDER BY annsal;     employee_id, last_name, salary12 annsal 컬럼을 출력하는데 salary12은 annsal이라는 Alias로 출력하고 annsal의 오름차순으로 정렬해라     SELECT last_name, job_id, department_id, hire_date FROM   employees ORDER BY 3;     last_name, job_id, department_id, hire_date 컬럼을 출력하는데 3번째 컬럼(department_id)의 오름차순으로 정렬해라   하지만 숫자로 표시하면 알아보기 힘들어서 추천하는 방법은 아니다.     SELECT last_name, department_id, salary FROM   employees ORDER BY department_id, salary DESC;     last_name, department_id, salary 컬럼을 출력하는데 department_id, salary 컬럼의 내림차순으로 정렬해라    ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-WHERE-ORDER-BY/",
        "teaser": null
      },{
        "title": "단일 행 함수",
        "excerpt":"1. 함수란?       2. SQL 함수의 두가지 유형       3. 단일 행 함수       1) 문자함수     문자 입력을 받아 들이며 문자 및 숫자값을 모두 반환할 수 있다.        1️⃣ 대소문자 변환 함수                      함수       결과       기능                               LOWER(‘SQL Course’)       sql course       모두 소문자로 변환                         UPPER(‘SQL Course’)       SQL COURSE       모두 대문자로 변환                         INITCAP(‘SQL Course’)       sql Course       단어의 첫 글자만 대문자로 변환                   SELECT employee_id, last_name, department_id FROM   employees WHERE  LOWER(last_name) = 'higgins';       2️⃣ 문자 조작 함수                  함수       결과       기능                               CONCAT(‘Hello’, ‘World’)       HelloWorld       파라미터 두개를 연결(사용 가능 파라미터는 두개로 제한)                         SUBSTR(‘HelloWorld’, 1, 5)       Hello       지정된 범위의 문자열 추출                         LENGTH(‘HelloWorld’)       10       문자열 길이 리턴                         INSTR(‘HelloWorld’, ‘W’)       6       문자열에서 지정된 문자의 숫자 위치를 찾음                         LPAD(salary, 10, ‘@’)       @@@@@24000       길이가 n이 되도록 왼쪽부터 문자식으로 채운 표현식 리턴                         RPAD(salary, 10, ‘@’)       24000@@@@@       길이가 n이 되도록 오른쪽부터 문자식으로 채운 표현식 리턴                         REPLACE(‘JACK and JUE’, ‘J’, ‘BL’)       BLACK and BLUE       1번 파라미터에서 2번 파리미터로 입력한 값을 3번 파라미터로 변경                         TRIM(‘H’ FROM ‘HelloWorld’)       elloWorld       문자열에서 선행문자나 후행문자를 자름                   SELECT employee_id, CONCAT(first_name, last_name) NAME,        job_id, LENGTH(last_name),        INSTR(last_name, 'a') \"Contains 'a'\" FROM   employees WHERE  SUBSTR(job_id, 4) = 'REP';        2) 숫자함수     숫자 입력을 받아 들이고 숫자값을 반환한다.                   함수       결과       기능                               ROUND(45.926, 2)       45.93       지정된 소수점 자릿수로 반올림                         TRUNC(45.926, 2)       45.92       지정된 소수점 자릿수로 버림                         MOD(1600, 300)       100       나눈 나머지 반환                   🔸 DUAL 테이블     SYS 소유   함수 및 계산 결과를 볼 때 사용하는 공용 테이블   DUMMY라는 하나의 열과 값이 X인 하나의 행을 포함            이걸 쓰는 이유는 컬럼을 출력할 필요가 없이 어떤 값을 계산한 결과만 보고 싶어도 FROM절에 테이블명을 꼭 써야 함       이 때 employees 처럼 실제 데이터가 들은 테이블을 호출하면 비효율적이니까 아무것도 없는 빈 테이블을 DUAL 테이블이라 지정하고 계산 결과만 볼 때에 호출하는 것         SELECT ROUND(45.923, 2), ROUND(45.923, 0), ROUND(45.923, -1) FROM   DUAL;                                       3) 날짜함수     DATE 데이터 유형의 값에 대해 실행된다.   1️⃣ SYSDATE 함수     현재 데이터베이스 서버 날짜 및 시간을 반환하는 함수     SELECT sysdate FROM   dual;                   2️⃣ 날짜를 사용한 산술 연산                   연산       결과       설명                               날짜 + 숫자       날짜       날짜에 일 수를 더한다.                         날짜 - 숫자       날짜       날짜에서 일 수를 뺀다.                         날짜 - 날짜       일 수       한 날짜를 다른 날짜에서 뺀다.                         날짜 + 숫자 / 24       날짜       날짜에 시간 수를 더한다.                   SELECT last_name, (SYSDATE - hire_date) / 7 AS WEEKS FROM   employees WHERE  department_id = 90;  3️⃣ 날짜 조작 함수                   함수       결과                               MONTHS_BETWEEN       두 날짜 간의 월 수                         ADD_MONTHS       날짜에 월 추가                         NEXT_DAY       지정된 날짜의 다음 날                         LAST_DAY       월의 마지막 날                         ROUND       날짜 반올림                         TRUNC       날짜 버림                                  함수       결과                               MONTHS_BETWEEN(‘01-SEP-95’, ‘11-JAN-94’)       19.6774194                         ADD_MONTHS(‘31-JAN-96’, 1)       ‘29-FEB-96’                         NEXT_DAY(‘01-SEP-95’, ‘FRIDAY’)       ‘08-SEP-95’                         LAST_DAY(‘01-FEB-95’)       ‘28-FEB-95’                   🔸 ROUND와 TRUNC의 활용                   함수       결과                               ROUND(SYSDATE, ‘MONTH’)       01-AUG-03                         ROUND(SYSDATE, ‘YEAR’)       01-JAN-04                         TRUNC(SYSDATE, ‘MONTH’)       01-JUL-03                         TRUNC(SYSDATE, ‘YEAR’)       01-JAN-03                   4) 변환함수         값의 데이터유형을 변환한다.     1️⃣ TO_CHAR 함수(DATE ➡️ CHAR)      🔸 문법      TO_CHAR(date, 'format_model')           🔸 날짜 형식 요소                  요소       결과                               YYYY       숫자로 된 전체 연도                         YEAR       영어 철자로 표기된 연도                         MM       월의 2자리 값                         MONTH       전체 월 이름                         MON       월의 3자 약어                         DY       3문자로 된 요일 약어                         DAY       요일의 전체 이름                         DD       숫자 형식의 월간 일                           시간 요소는 날짜에서 시간 부분의 형식을 지정한다.  HH24:MI:SS AM ➡️ 15:45:32 PM            문자열은 큰 따옴표로 묶어 추가한다.  DD “of” MONTH ➡️ 12 of OCTOBER       숫자 접미어는 숫자를 영어 철자로 표기한다.  ddspth ➡️ fourtheenth   sp라 쓰면 약간 잘라서 약자로 표현함     2️⃣ TO_CHAR 함수(NUMBER ➡️ CHAR)  🔸 문법  TO_CHAR(number, 'format_model')      🔸 숫자 형식 요소                  요소       결과                               9       숫자를 나타냄(0 ~ 9)                         0       0이 표시되도록 강제 적용(0만 표시됨)                         $       부동 달러 기호 배치                         L       부동 로컬 통화 기호 사용                         .       소수점 출력                         ,       천단위 표시자로 쉼표 출력                   SELECT TO_CHAR(salary, '$99,999.00') SALARY FROM   employees WHERE  last_name = 'Ernst';     TO_CHAR(salary, ‘$99,999.00’) 에서 ‘$99,999.00’를 통해 출력할 수 있는 자리수는 최대 6자리이다.   만약 자리수를 초과하면 ####으로 출력되고 숫자 자체가 출력되지 않는다. =&gt; 그러니까 자리수를 넉넉히 쓰자     3️⃣ TO_NUMBER 함수(CHAR ➡️ NUMBER)  🔸 문법  TO_NUMBER(char[, 'format_model'])     문자를 숫자로 바꿔주는 함수인데 쓸 일이 거의 없다.   salary 같은 컬럼을 $3,000이라 저장하면 조회할 때 보기에는 편하지만 필드값을 계산에 사용하려고 하면 $가 없는 숫자로 바꿔줘야 해서 번거롭다.   그래서 보통 3000 숫자 자체만 저장해놓기 때문에 TO_NUMBER 함수를 쓸 일이 없다.     4️⃣ TO_DATE 함수(CHAR ➡️ DATE)  🔸 문법  TO_DATE(char[, 'format_model'])     내가 원하는대로 날짜값을 출력해주는 함수     SELECT employee_id, last_name, salary, hire_date FROM   employees WHERE  hire_date &lt; to_date('2004/08/09', 'YYYY/MM/DD');                   5) 일반함수     모든 데이터타입에 사용가능하다.                   함수                               NVL(expr1, expr2)                         NVL2(expr1, expr2, expr3)                         NULLIF(expr1, expr2)                         COALESCE(expr1, expr2, …, exprn)                   1️⃣ NVL 함수     null 값을 실제 값으로 변환   사용할 수 있는 데이터 유형은 날짜, 문자 및 숫자   데이터 유형이 일치해야 함            NVL(commission_pct, 0)       NVL(hire_date, ‘01-JAN-97’)       NVL(job_id, ‘No Job Yet’)           산술식에 null이 들어가면 결과값은 null이다.     SELECT last_name, salary, NVL(commission_pct, 0),       (salary*12) + (salary*12*NVL(commission_pct, 0)) AN_SAL FROM   employees;                   2️⃣ NVL2 함수     첫번째 표현식을 검사해서 null이 아니면 두번째 표현식을 반환하고 또 null이면 세번째 반환     SELECT last_name, salary, commission_pct,       NVL2(commission_pct, 'SAL+COMM', 'SAL') income FROM   employees WHERE  department_id IN (50, 80);                   3️⃣ NULLIF 함수     expr1과 expr2를 비교해서 두 표현식이 같으면 null을 반환하고 두 표현식이 다르면 expr1 반환     SELECT first_name, LENGTH(first_name) \"expr1\",      last_name, LENGTH(last_name) \"expr2\",      NULLIF(LENGTH(first_name), LENGTH(last_name)) result FROM   employees;                   4️⃣ COALESCE 함수     NVL 함수보다 여러 대체값을 가질 수 있음   null이 아닌 첫번째 표현식 반환   파라미터들의 자료형이 모두 같아야 한다.     SELECT last_name, employee_id,       COALESCE(TO_CHAR(commission_pct), TO_CHAR(manager_id),       'No commission and no manager') FROM   employees;           ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-single-func/",
        "teaser": null
      },{
        "title": "쿼리구문에 큰 따옴표 사용 문법",
        "excerpt":"쿼리구문에 큰 따옴표(“ “)가 사용되는 경우     컬럼명 [AS] “Alias”            대소문자 구분       특수문자 포함       공백 포함하는 경우              TO_CHAR(sysdate, 'YYYY-MM-DD \"Time\" HH24:MI')            사용자 형식 내 문자열 포함 시           =&gt; 긴가민가하면 작은 따옴표를 쓰자  ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-use-quotes-in-query/",
        "teaser": null
      },{
        "title": "깃허브 프로필(Github Profile) 꾸미기",
        "excerpt":"🎬 시작   드디어 깃헙 블로그를 만들고… 다른 깃헙들을 구경하다 보니까 깃헙 메인 화면 자체를 예쁘게 꾸며놓으신 분들이 많더라고요!      이렇게요!   되게 좋아 보이잖아요?ㅎㅎㅎ 그래서 저도 꾸며보기로 했습니다.     1. New Repository 만들기      먼저 내 아이디와 같은 이름으로 새로운 레포지토리를 만들어 줍니다.  처음 깃헙 블로그를 만들 때 봤을 때엔 깃헙 프로필 페이지 자체를 꾸밀 수 있다는 것을 몰라서 뭔 소린가 했는데 이런 뜻이었네요…        만들 때엔 add a readme에 꼭 체크해 주세요! readme로 프로필 페이지를 꾸며야 하거든요.     2. README.md 편집하기      새로 만든 레포로 들어오면 아무것도 없어서 휑한 모습을 볼 수 있습니다. 전 까먹고 스샷을 좀 늦게 찍었더니 어느정도 꾸미기를 진행한 상태였네요 😅   여기서 리드미 파일 상단의 연필 그림을 누르거나 오른쪽에 보이는 초록색 edit readme 버튼을 눌러서 웹상에서 바로 편집을 진행하셔도 되고 로컬로 다운받아서 편집한 다음에 푸시하셔도 됩니다.     🔸 markdown 미리보기   혹은 https://dillinger.io/     라는 사이트가 있는데 여기에서는 마크다운으로 작성하는 파일을 실시간으로 미리볼 수 있는 서비스를 제공하고 있습니다.  보통 마크다운 파일을 편집할 땐 미리보기가 가능하지 않으니까 여러번 커밋과 푸시를 하게 되어서 좀 귀찮은데 이 사이트에서는 실시간으로 확인하면서 작성한 다음에 복붙해서 한 번에 커밋할 수 있어서 꽤 편합니다.   하지만 전 쓸 게 그렇게 많지는 않아서 여기 쓰려다가 안 쓰고 그냥 레포에서 바로 수정했습니다…😅     🔸 배지 만들기      다른 분들 보니까 이런식으로 c++같은 프로그래밍 언어들을 그냥 텍스트로 쓰지 않고 배지 그림으로 달아 놓으셨더라고요. 저도 좋아보이는 건 다 해보고 싶어서 배지 이미지를 만들어 주는 사이트에서 만들었습니다.     ▪️ 배지 : https://shields.io/  ▪️ 언어 로고 : https://simpleicons.org/   위 사이트들에 가면 저런 폼나는 아이콘들을 얻을 수 있습니다.     배지를 만드시려면      이런식으로 넣고 싶은 문구를 입력하고 세번째 칸의 화살표를 눌러서 색상을 선택하거나 직접 입력하시고 나서 오른쪽의 Make Badge 버튼을 누르시면       이렇게 배지를 만들어 줍니다. 여기서 주소를 복사하세요.    &lt;img src=\"https://img.shields.io/badge/-TechBlog-brightgreen\"&gt;  위 태그를 리드미에 입력하시면 우리가 만든 배지를 불러옵니다. 하지만 이렇게만 작성하면 단순히 그림만 불러오고 이 그림을 눌렀을 때 어디로 이동할지는 정해주지 않았기 때문에 그냥 새 창에서 그림이 호출될 것이어요…     &lt;a href=\"https://miro7923.github.io/\"&gt; &lt;img src=\"https://img.shields.io/badge/-TechBlog-brightgreen\"&gt;  그렇기 때문에 이런식으로 a 태그를 이용해 하이퍼링크를 걸어주시면 우리가 만든 배지 그림을 눌렀을 때 나의 블로그로 이동하게 됩니다.     일반화한다면    &lt;img src=\"https://img.shields.io/badge/라벨-메세지-색상\"&gt;  이렇게 작성하시면 됩니다.     만약 이메일 주소도 추가하고 싶으시면    &lt;a href=\"mailto:miro7923@gmail.com\"&gt;  mailto를 이용해 메일주소를 적어주세요!     🔸 프로그래밍 언어 로고 만들기   &lt;img src=\"https://img.shields.io/badge/C++-00599C?style=flat-square&amp;logo=C%2B%2B&amp;logoColor=white\"/&gt;&lt;/a&gt;&amp;nbsp   프로그래밍 언어 로고는 위와 같이 태그를 입력하면 되는데 이것을 일반화하면   &lt;img src=\"https://img.shields.io/badge/언어-색상?style=flat-square&amp;logo=simpleicons에서 로고 이름&amp;logoColor=white\"/&gt;&lt;/a&gt;&amp;nbsp   위와 같은 형태로 만들 수 있습니다.      simpleicons 사이트에서 원하는 언어를 검색해서 그 언어의 이름과 색상을 넣어준 다음 simpleicons 사이트에서 표시되어 있는 언어의 이름을 넣어주시면 됩니다.      단, c++을 쓸 때에만 좀 주의하면 되는데 simpleicons 사이트에는 단순히 C++이라 나와있지만 이걸 그대로 쓰면 적용이 안 되고 C%2B%2B라고 적어주어야 적용이 된다고 합니다. %2B가 +에 대응된다고 합니다.   c#은 C Sharp 이라는 이름으로 등록되어 있었습니다.        대략 이렇게 태그들을 쓴 다음에         커밋 버튼 눌러서 마무리!     3. 최종 완성      짠 👏 커밋 버튼을 눌러서 나오면 이렇게 완성된 리드미를 볼 수 있습니다.        그리고 제 깃헙 프로필 메인 페이지를 확인해보면 이렇게 있어보이게 바꼈습니다! 😄 뿌듯~~!!   이렇게 보니까 할 줄 아는거 되게 많네요! ㅎㅎ 더 뿌듯하다…     앞으로 공부 더 열심히 해야겠습니다. 그럼 다음 글에서 만나요! 👋   ","categories": ["Story"],
        "tags": ["story"],
        "url": "/story/decorate-github-profile/",
        "teaser": null
      },{
        "title": "CSS 기초",
        "excerpt":"👀 CSS란?     Cascading Style Sheets의 약자로 HTML로 만든 웹 문서 뼈대에 디자인을 적용하기 위한 것   🔸 적용 방법     태그에 바로 스타일 적용 - 잘 안씀    head 안에서 스타일 적용    외부파일로 스타일 적용      👀 기본 문법  태그 대상 {     속성: 값;     속성: 값; ... }  * {     HTML 내용 전체 선택 }  h2 {     color: blue;     background-color: skyblue;     모든 h2 태그에 적용 }   #p1 {     id=\"p1\" 인 id 모두 선택 }  .p2 {     class=\"p2\" 인 class 모두 선택 }  #footer p {     footer 안에 있는 p 태그에만 적용 }  /* 하이퍼링크 태그에만 부분적으로 적용하는 것도 가능하다 */ a:link, a:visited { \t/* 하이퍼링크색, 방문한 하이퍼링크색 변경 */ \tcolor: black; }  a:hover { \t/* 하이퍼링크에 마우스를 올리면 */ \tcolor: white; \tbackground-color: black; }      &lt;p id=\"p1\"&gt;, &lt;span class=\"p2\"&gt; 와 같이 지정하며 id는 넓은 영역을 지정할 때 주로 사용하고 class는 좁은 영역을 지정할 때 주로 사용한다고 한다.      👀 CSS 꾸미기 속성들   p { \t/* 배치 */ \tdisplay: block; 전체영역(문단영역) : 블록레벨 \tdisplay: inline; 요소영역 : 인라인 레벨(가로로 붙음) \tdisplay: inline-block; 메뉴 만들땐 인라인 블록이 편하다 \tdisplay: inline-block;      \t/* 박스크기 계산 box-sizing */     /* 웹 페이지의 내용물들을 배치할 때 박스크기 계산한 것을 바탕으로 배치하는 것이 좋다 */ \tbox-sizing: border-box; 내용 안여백 테두리선 포함해서 크기 계산 \tbox-sizing: content-box; 내용(기본값)물만 포함해서 크기 계산      \t/* 너비 */ \twidth: 600px; \t \t/* 높이 */ \theight: 50%;       /* 안 여백 10px */ \tpadding: 10px; \t \t/* 밖 여백 */ \tmargin: 50px;      \t/* 배경색 */ \tbackground-color: silver; \tbackground-color: #0000ff; \tbackground-color: rgb(255, 0, 0);          color: rgba(255, 0, 0, 0.5);     color: #ff0000;          font-family: \"바탕\";          font-size: 20px;     font-size: 3em;     /* 절대크기(지정된 크기) : 상대크기(상대적인 글자크기) */     /* 포인트 pt, 픽셀 px, em 대문자를 기준으로 비율값 적용, rem 1em 비율값 적용, ex 소문자를 기준으로 적용 */          font-style: italic;          font-weight: bold;          /* 글자 가운데 정렬 */     text-align: center;          line-height: 100%;          text-decoration: overline;          /* 그림자 효과 */     text-shadow: 5px 5px 3px black;           /* 글자 하나사이 간격*/     letter-spacing: 0.5em;           /* 단어 사이 간격 */     word-spacing: 50px;           /* 목록 들여쓰기 내어쓰기 inside/outside */     list-style-position: outside;          /* 목록 점(불릿) 대신 이미지 사용 */     list-style-image: url(\"1.jpeg\");          /* 표 제목 위치 지정 caption-side: top/bottom; */ \tcaption-side: top;      \t/* 표 테두리선 그려주기 border: 테두리선 두께 테두리선 모양 테두리선 색 */ \tborder: 1px solid black;     border-style: dotted; \tborder-color: blue;      \t/* 셀(칸) 사이에 여백 */ \tborder-spacing: 10px; \t \t/* 표와 셀 테두리 합치기 */ \tborder-collapse: collapse;          /* 모서리 둥글게 */ \tborder-radius: 50%;          /* 박스 그림자 (12시부터 시계방향으로) 색상 */ \tbox-shadow: 5px 5px 15px 5px green;   \t/* 어울림 배치하는 법 */ \tfloat: left; /* 이미지를 왼쪽으로 기준으로 글자 어울림 배치 */ \tfloat: right; /* 이미지 오른쪽으로 기준으로 글자 어울림 배치 */   \t/* 어울림 배치 해제 */ \t/* 아까 설정한 방향 중 해제하고 싶은 방향을 입력해줌 */ \tclear: left; \tclear: right; \tclear: both;            /* 배경 이미지 삽입 */ \t/* 이미지 태그에서 안보이면 스타일시트에서 이미지를 넣은 것이다. */ \tbackground-image: url(\"dot.png\"); \tbackground-repeat: repeat; /* 이미지 바둑판 모양으로 반복 */ \tbackground-repeat: repeat-x; /* x축만 반복 */ \tbackground-repeat: repeat-y; /* y축만 반복 */ \tbackground-repeat: no-repeat; /* 반복 안함 */  \tbackground-position: center; /* 문단 가운데로 정렬 */ \tbackground-position: bottom right; /* 두개 넣으면 오른쪽 아래와 같이 정렬됨 */ \tbackground-position: top left; \tbackground-size: 50px 50px; }      ☑️ CSS 꾸미기 시작은  * { \t/* body 영역엔 기본적인 여백이 조금씩 있는데 이걸 다 0으로 만들고 시작한다. */ \tmargin: 0px; \tpadding: 0px; \t \t/* 테두리포함 너비 계산하기 */ \tbox-sizing: border-box; }      위와 같이 초기화하고 시작하는 것이 좋다.  ","categories": ["HTML"],
        "tags": ["HTML","Front-end","CSS"],
        "url": "/html/CSS-beginning/",
        "teaser": null
      },{
        "title": "HTML 문법",
        "excerpt":"👀 시작 전에     HTML 문서는 크게 &lt;head&gt; 부분과 &lt;body&gt; 부분으로 나누어져 있다.   크롬 탭에서 보이는 제목을 지정하고 싶으면 &lt;head&gt; 부분에 &lt;title&gt; 태그를 이용해 제목을 적어준다.   &lt;body&gt; 부분에 본격적인 웹 페이지 내용을 작성한다.     🔸 HTML 주석문   &lt;!-- 주석 --&gt;      HTML에서의 주석문은 다른 프로그래밍 언어와는 다르게 위와 같이 쓴다.   🔸 제목 태그   &lt;h1&gt;제목&lt;/h1&gt; &lt;h2&gt;제목2&lt;/h2&gt; &lt;h3&gt;제목3&lt;/h3&gt; &lt;h4&gt;제목4&lt;/h4&gt; &lt;h5&gt;제목5&lt;/h5&gt; &lt;h6&gt;제목6&lt;/h6&gt;      제목 태그에는 6가지가 있다.   1번이 글씨 크기가 가장 크고 숫자가 커질수록 글씨 크기가 작아진다.   🔸 문단 태그   &lt;p&gt;문단 내용&lt;/p&gt;      아래위로 공백이 약간 생기면서 한 문단을 만드는 것과 같은 효과를 줄 수 있다.   🔸 글씨 꾸미기 태그   &lt;b&gt;진하게&lt;/b&gt; &lt;strong&gt;진하게&lt;/strong&gt; &lt;i&gt;기울이기(이탤릭체)&lt;/i&gt; &lt;em&gt;기울이기&lt;/em&gt; &lt;small&gt;작게&lt;/small&gt; &lt;u&gt;밑줄&lt;/u&gt; &lt;sup&gt;위 첨자&lt;/sup&gt; &lt;sub&gt;아래 첨자&lt;/sub&gt; &lt;del&gt;취소선 긋기&lt;/del&gt;  &lt;blockquote&gt;인용문 들여쓰기 효과&lt;/blockquote&gt;  &lt;hr&gt; &lt;!-- 수평선 긋는 태그 --&gt;  &lt;pre&gt;     원하는  \t\t모양대로 \t\t\t\t출력 \t\t\t이 가능한 태그 &lt;/pre&gt;      &lt;b&gt; 태그를 쓰면 글씨를 진하게 표현할 수 있고 &lt;i&gt; 태그를 쓰면 글씨를 옆으로 기울일 수 있다.   🔸 줄바꿈 태그  안녕하세요!&lt;br&gt; Hello!      HTML에서는 단순히 엔터를 치는 것으로는 줄을 바꿀 수 없다.   줄을 바꾸고 싶은 곳에서 &lt;br&gt; 태그를 적어줘야 줄바꿈이 적용된다.   🔸 하이퍼링크 태그  &lt;a href=\"http://www.naver.com\"&gt; 네이버 하이퍼링크 &lt;/a&gt;&lt;br&gt; &lt;a href=\"test1.html\"&gt; test1.html 문서 하이퍼링크 &lt;/a&gt;&lt;br&gt; &lt;a href=\"4.jpeg\" download=\"\"&gt; 이미지 다운로드 &lt;/a&gt;&lt;br&gt; &lt;a href=\"ex4.html\" target=\"_blank\"&gt;새 창에서 연결&lt;/a&gt;&lt;br&gt;      웹 페이지 링크를 걸 수도 있고 내가 만든 HTML 페이지를 링크로 걸 수도 있다.   웹 페이지 링크를 작성할 땐 http://도 꼭 써주어야 제대로 동작한다.   ☑️ 문서 내에서 하이퍼링크  &lt;a href=\"#content1\" id=\"menu\"&gt;메뉴1&lt;/a&gt; &lt;a href=\"#content2\"&gt;메뉴2&lt;/a&gt; &lt;a href=\"#content3\"&gt;메뉴3&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;  &lt;a id=\"content1\"&gt;메뉴1 문서&lt;/a&gt; &lt;a href=\"#menu\"&gt;메뉴 위로 이동&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;  &lt;a id=\"content2\"&gt;메뉴2 문서&lt;/a&gt; &lt;a href=\"#menu\"&gt;메뉴 위로 이동&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;  &lt;a id=\"content3\"&gt;메뉴3 문서&lt;/a&gt; &lt;a href=\"#menu\"&gt;메뉴 위로 이동&lt;/a&gt;   🔸 이미지 삽입 태그  &lt;img src=\"1.jpeg\"&gt;&lt;br&gt; &lt;img src=\"2.gif\"&gt;&lt;br&gt; &lt;img alt=\"3번이미지\" src=\"./3.png\" width=\"50%\" height=\"50%\" border=\"5\"&gt;      이미지를 삽입할 때엔 닫는 태그가 없어도 된다.   이미지 파일은 삽입하고자 하는 HTML 파일과 동일한 위치에 있어야 경로지정 없이 삽입할 수 있다.   같은 위치에 없다면 경로지정을 해 주어야 하는데            . : 현재폴더(생략가능)       .. : 상위폴더       상대참조 : 현재 페이지를 기준으로 상대적 파일을 찾는 방법       절대참조 : /(root) 기준으로 파일 경로를 찾아가는 방법           ☑️ img 태그 속성     src : 원본(그림) 파일   alt : 원본이 안 보일 때 표시할 그림 설명   width : 이미지 너비(픽셀) 지정            px : 이미지 크기를 픽셀 단위로 지정. 고정값       % : 이미지 크기가 브라우저 크기에 따라 변동됨           ☑️ 픽셀(Pixel)     화면을 이루는 빛(하나의 점)   ☑️ 해상도     화면을 이루는 점(빛)의 개수   ☑️ 웹에서 사용하는 이미지 형식     .jpg : 사진형태. 색상과 명암을 다양하게 표현   .gif : 256색상 사용. 작은 아이콘, 작은 이미지 사용. 움직이는 이미지   .png : 색상 다양하게 표현. 투명한 배경색 가능. 웹에서 많이 사용   🔸 목록 만드는 태그  순서 있는 목록  &lt;ol&gt;   &lt;li&gt; 항목1 &lt;/li&gt;   &lt;li&gt; 항목2 &lt;/li&gt; &lt;/ol&gt;      1부터 차례대로 순서가 매겨지면서 목록이 만들어진다.   &lt;ol type=\"i\"&gt;   &lt;li&gt;항목1&lt;/li&gt;   &lt;li&gt;항목2&lt;/li&gt; &lt;/ol&gt;      type에 1, a, A, i, I(이탤릭)들을 사용해 순서를 매길 포맷을 지정해 줄 수 있다.   순서 없는 목록  &lt;ul&gt;   &lt;li&gt;항목1&lt;/li&gt;   &lt;li&gt;항목2&lt;/li&gt; &lt;/ul&gt;      순서가 없이 점만 찍히는 목록이 만들어진다.   &lt;ul type=\"circle\"&gt;   &lt;li&gt;항목1&lt;/li&gt;   &lt;li&gt;항목2&lt;/li&gt; &lt;/ul&gt;      마찬가지로 disc, square, circle 점 모양 속성을 지정해 줄 수 있다.   🔸 표 만드는 태그  &lt;table border=\"1\"&gt;   &lt;caption&gt;표제목&lt;/caption&gt;   &lt;tr&gt;&lt;td&gt;1행1열&lt;/td&gt;&lt;td&gt;1행2열&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td&gt;2행1열&lt;/td&gt;&lt;td&gt;2행2열&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;      &lt;table&gt; 태그를 이용해 틀을 만든 다음 &lt;tr&gt;을 사용해 가로로 줄을 그어 칸을 만들고 &lt;td&gt; 태그로 세로로 줄을 그어 칸을 만들 수 있다.   &lt;thead&gt; &lt;!-- 코드 상에서 영역 나눠서 작업할 때 사용 --&gt; &lt;tr&gt;&lt;th&gt;제목1&lt;/th&gt;&lt;th&gt;제목2&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt;  &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;내용1&lt;/td&gt;&lt;td&gt;내용2&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;  &lt;tfoot&gt; &lt;tr&gt;&lt;td&gt;내용3&lt;/td&gt;&lt;td&gt;내용4&lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt;   표 합치기  &lt;table border=\"1\" width=\"500\" height=\"300\"&gt;   &lt;tr&gt;&lt;td&gt;용도&lt;/td&gt;&lt;td&gt;중량&lt;/td&gt;  &lt;td colspan=\"2\"&gt;개수가격&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td rowspan=\"2\"&gt;선물용&lt;/td&gt;&lt;td&gt;3kg&lt;/td&gt;&lt;td&gt;11-16과&lt;/td&gt;&lt;td&gt;35000원&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;                         &lt;td&gt;5kg&lt;/td&gt;&lt;td&gt;18-26과&lt;/td&gt;&lt;td&gt;52000원&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;&lt;td rowspan=\"2\"&gt;가정용&lt;/td&gt;&lt;td&gt;3kg&lt;/td&gt;&lt;td&gt;11-16과&lt;/td&gt;&lt;td&gt;30000원&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;                         &lt;td&gt;5kg&lt;/td&gt;&lt;td&gt;18-26과&lt;/td&gt;&lt;td&gt;47000원&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;      colspan으로 가로로 나란히 위치한 칸들을 합치고 rowspan으로 세로로 나란히 위치한 칸들을 합칠 수 있다.   🔸 폼(양식) 태그     기능과 데이터들을 묶어주는 것   submit 버튼을 클릭하면 폼태그에 있는 내용(데이터, 이름 =&gt; 값)을 서버(백엔드)로 전송하는 기능을 폼태그를 사용해 만들 수 있다.   전송 방식에는 Get 방식과 Post 방식이 있다.   &lt;fieldset&gt; &lt;!-- 테두리를 그려서 그룹으로 묶어주는 태그 --&gt; \t&lt;legend&gt;그룹이름1&lt;/legend&gt; \t&lt;label&gt;아이디 :&lt;/label&gt; \t&lt;input type=\"text\" name=\"id\" value=\"아이디\" size=\"30\" maxlength=\"5\" readonly=\"readonly\"&gt;&lt;br&gt; \t&lt;!-- size=\"30\" 30자를 적을 수 있는 크기 maxlength=\"5\" 입력학 글자개수 readonly=\"readonly\" 읽기전용 --&gt; \t&lt;label&gt;비밀번호 : &lt;/label&gt; \t&lt;input type=\"password\" name=\"pass\" required autofocus&gt;&lt;br&gt; \t&lt;!-- 비밀번호 필수요소로 입력제어 \tautofocus : 입력상자에 커서 깜박이게 하기  --&gt; \t&lt;label&gt;자기소개 : &lt;/label&gt; \t&lt;textarea rows=\"5\" cols=\"10\"&gt;&lt;/textarea&gt;&lt;br&gt; \t&lt;label&gt;이메일 :&lt;/label&gt; \t&lt;input type=\"email\" name=\"email\" placeholder=\"이메일 형식\"&gt;&lt;br&gt; \t&lt;!-- placeholer : 배경이미지 형태로 설명글 --&gt; \t&lt;label&gt;날짜 : &lt;/label&gt; \t&lt;input type=\"date, name=\"date\" min=\"2022-01-01\" max=\"22022-01-14\"&gt; \t&lt;label&gt;날짜(월) : &lt;/label&gt; \t&lt;input type=\"week\" name=\"week\"&gt; \t&lt;label&gt;시간 : &lt;/label&gt; \t&lt;input type=\"time\" name=\"time\"&gt;&lt;br&gt; \t&lt;label&gt;날짜 시간 : &lt;/label&gt; \t&lt;input type=\"datetime-local\" name=\"datetime\"&gt;&lt;br&gt; &lt;/fieldset&gt;```  * `type`의 `text`는 입력하는 글자를 보여주는 것이고 `password`는 입력하는 글자를 보여주지 않는 것이다.  ```html &lt;textarea rows=\"5\" cols=\"30\" placeholder=\"본사 지원 동기를 간략히 적어주세요.\"&gt;&lt;/textarea&gt;&lt;br&gt;      &lt;textarea&gt;를 사용하면 긴 텍스트를 입력할 수 있는 텍스트박스를 만들 수 있다.   placeholder=\"\" 속성은 회색 글씨로 안내 사항을 입력해 놓는 것. 입력을 시작하면 사라진다.   &lt;fieldset&gt; \t&lt;legend&gt;그룹이름2&lt;/legend&gt; \t&lt;label&gt;검색 : &lt;/label&gt; \t&lt;input type=\"search\" name=\"search\"&gt;&lt;br&gt; \t&lt;label&gt;웹주소 : &lt;/label&gt; \t&lt;input type=\"url\" name=\"url\"&gt;&lt;br&gt; \t&lt;label&gt;연락처(모바일) : &lt;/label&gt; \t&lt;input type=\"tel\" name=\"tel\"&gt;&lt;br&gt; &lt;!-- 모바일 환경에서는 숫자 키패드 나옴 --&gt; \t&lt;label&gt;숫자 : &lt;/label&gt; \t&lt;input type=\"number\" name=\"number\"&gt;&lt;br&gt; \t&lt;label&gt;슬라이드 밸류값 설정 : &lt;/label&gt; \t&lt;input type=\"range\" name=\"range\"&gt;&lt;br&gt;  &lt;/fieldset&gt;   🔸 라디오 버튼(radio)과 체크박스(checkbox)   성별 : &lt;input type=\"radio\" name=\"gender\" value=\"남\"&gt;남성        &lt;input type=\"radio\" name=\"gender\" value=\"여\"&gt;여성&lt;br&gt; 취미 : &lt;input type=\"checkbox\" name=\"hobby\" value=\"여행\"&gt;여행 \t  &lt;input type=\"checkbox\" name=\"hobby\" value=\"게임\"&gt;게임       &lt;input type=\"checkbox\" name=\"hobby\" value=\"독서\"&gt;독서&lt;br&gt; 목록상자 : &lt;select name=\"sel\" size=\"5\" multiple=\"multiple\"&gt; \t\t&lt;option value=\"목1\"&gt;목록1&lt;/option&gt; \t\t&lt;option value=\"목2\"&gt;목록2&lt;/option&gt; \t\t&lt;option value=\"목3\"&gt;목록3&lt;/option&gt;         &lt;/select&gt;      radio는 하나만 선택 가능할 때 사용하고 checkbox는 여러개를 선택할 수 있을 때 사용한다.   이 때 name을 동일하게 해야 같은 그룹으로 취합되고 그 안에서 선택하는 것이 가능하다.   &lt;form action=\"test1.html\" method=\"get\"&gt;  파일업로드 : &lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; 히든값 : &lt;input type=\"hidden\" name=\"hi\" value=\"값\"&gt; &lt;!-- 사용자에게는 보이지 않는 숨겨진 입력 필드 정의 --&gt; &lt;input type=\"button\" value=\"버튼\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"전송\"&gt;&lt;br&gt; &lt;!-- action=\"test1.html\"으로 작성 내용들을 전달함. 폼태그 밖에서 쓰면 작동 안됨  --&gt;  &lt;input type=\"image\" scr=\"5.jpeg\" width=\"100\" height=\"100\"&gt; &lt;input type=\"reset\" value=\"초기화\"&gt;&lt;br&gt; &lt;/form&gt;   🔸 영역 지정 태그  &lt;div&gt;   큰 영역을 지정할 때 사용(웹 블록 지정) &lt;/div&gt;  &lt;span&gt; 인라인(작은 영역) 블록 지정 &lt;/span&gt;   🔸 특수 문자 입력 태그  &amp;nbsp;  공백 표시 &amp;lt;    꺽쇄(&lt; &gt;) 표시 &amp;copy;  ©  &amp;amp;   &amp;  &amp;quot;  \"  &amp;clubs; ♣  ","categories": ["HTML"],
        "tags": ["HTML","Front-end"],
        "url": "/html/HTML-language01/",
        "teaser": null
      },{
        "title": "프론트엔드와 백엔드",
        "excerpt":"👀 프론트엔드란?     웹 화면에 보여지는 모든 것들을 프론트엔드라 칭한다.     👀 백엔드란?     웹 화면에 보여지지 않지만 화면에 표시하기 위해 서버로부터 보내는 데이터, 데이터베이스에 있는 고객의 정보 등 화면에 보여지지 않지만 웹 화면 구성을 위해서 필요한 것들     👀 HTML이란?     Hyper Text Markup Language의 약자로 웹 문서를 작성하는 마크업 언어(Markup Language)이다.   Hyper Text : 문서를 서로 연결해주는 링크   Markup : 표시한다(텍스트, 이미지, 영상, …) 웹 문서를 만드는 기본 언어   HTML은 태그로 구성되어 있으며, 태그를 이용해 인터넷에 문자와 그림을 표현하거나 하이퍼링크로 서로 다른 문서들을 연결한다.   학습에 참고하면 좋은 사이트 : http://www.w3schools.com  ","categories": ["HTML"],
        "tags": ["HTML","Front-end","Back-end"],
        "url": "/html/HTML/",
        "teaser": null
      },{
        "title": "JSP 액션 태그",
        "excerpt":"👀 액션 태그란?   &lt;jsp:~ 형태로 시작하는 태그&gt;      JSP 페이지에서 HTML 태그 형태로 JSP 코드의 역할을 수행하는 것   스크립틀릿 등의 스크립트 요소(자바 코드)를 사용하지 않기 때문에 JSP 페이지의 내부적인 프로그램 로직을 사용자로부터 감출 수 있다.   즉, 사용자에게 보여지는 프레젠테이션 부분과 사용자의 요청을 처리하는 비즈니스 로직 부분(프로그램 부분)을 분리하는 것이 가능하다.   프로그램 재사용성을 높여주고 코드의 간결성을 향상시킨다.   🔸 &lt; jsp:forward &gt;   &lt;jsp:forward page=\"이동할 페이지(ex. forward.jsp)\" /&gt; &lt;jsp:forward page=\"이동할 페이지\"&gt;&lt;/jsp:forward&gt;      액션 태그는 XML 문법을 이용하여 구현된 기능이므로 태그의 종료 끝에 반드시 종료 태그가 있어야 한다.   forward 액션은 현재 페이지의 요청과 응답에 관한 처리권을 page 속성에 지정된 이동할 페이지로 영구적으로 넘기는 기능을 한다.   🔸 &lt; jsp:include &gt;   &lt;jsp:include page=\"이동할 페이지(ex. forward.jsp)\" flush=\"false\" /&gt; &lt;jsp:include page=\"이동할 페이지(ex. forward.jsp)\" flush=\"false\"&gt;&lt;/jsp:include&gt;      특정 페이지를 include 한다.   각각의 페이지를 컴파일 후 해당 파일을 include 한다.   top, bottom과 같은 동일 사용 페이지를 추가할 때 사용한다.   🔸 &lt; jsp:param &gt;   &lt;jsp:param name=\"파라미터 이름1\" value=\"파라미터 값1\" /&gt; &lt;jsp:param name=\"파라미터 이름2\" value=\"파라미터 값2\" /&gt;      forward와 include 태그를 사용하여 이동할 페이지에 추가적으로 넘겨줄 파라미터가 있으면 &lt;jsp:param/&gt; 태그를 사용할 수 있다.  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-action-tag/",
        "teaser": null
      },{
        "title": "JSP 지시어(Directive)",
        "excerpt":"👀 JSP 지시어란?(Directive)   &lt;%@ ... %&gt;      JSP 파일 내에서 JSP를 실행할 컨테이너에서 해당 페이지를 어떻게 처리할 것인가에 대한 설정 정보들을 지정해주는 데 사용   page 지시어, include 지시어, taglib 지시어 3가지로 나누어진다.   1. page 지시어   &lt;%@ page 속성1=\"값1\" 속성2=\"값2\" 속성3=\"값3\"... %&gt;      JSP 페이지에 대한 속성을 지정하는 지시어   속성에는 스크립트 언어, import할 패키지/클래스, 세션 사용 여부, 에러 페이지 등 12개의 설정 정보를 지정해 사용할 수 있다.                  속성       사용법       기본값       설명                               language       language=”java”       java       스크립트 요소에서 사용할 언어 설정                         extends       extends=”클래스명”       없음       상속받을 클래스를 설정                         import       import=”패키지.클래스명”       없음       import할 패키지.클래스 설정                         session       session=”true”       true       HttpSession 사용 여부를 설정                         buffer       buffer=”16kb”       8kb       JSP 페이지의 출력 버퍼 크기를 설정                         autoFlush       autoFlush=”true”       true       출력 버퍼가 다 찼을 경우 처리 방법을 설정                         isThreadSafe       isThreadSafe=”true”       true       다중 스레드의 동시 실행 여부를 설정                         info       info=”페이지 설명”       없음       페이지 설명                         errorPage       errorPage=”에러 페이지.jsp”       없음       에러 페이지로 사용할 페이지를 지정                         contentType       contentType=”text/html”       text/html;charset=ISO-8859-1       JSP 페이지가 생성할 문서의 타입을 지정                         isErrorPage       isErrorPage=”false”       false       현재 페이지를 에러 페이지로 지정                         pageEncoding       pageEncoding=”euc-kr”       ISO-8859-1       현재 페이지의 문자 인코딩 타입 설정                      각각의 속성을 하나의 page 지시어에 한 번에 지정할 수도 있으며 여러 개의 page 지시어에 나누어 지정할 수도 있다.   하지만 import 속성을 제외한 나머지 속성은 하나의 페이지에서 오직 한 번씩만 지정할 수 있다.     2. include 지시어   &lt;%@ include file=\"header.jsp\" %&gt;      특정한 JSP 파일 또는 HTML 파일을 해당 JSP 페이지에 삽입할 수 있도록 하는 기능을 제공한다.   include되는 JSP 코드 자체가 해당 JSP 페이지에 복사되어 더해지므로 서블릿 컴파일 과정은 include 되는 페이지의 수가 아무리 많아도 단 한 번만 이루어지게 된다.   사용되는 공통 변수값들을 추가할 때 주로 사용한다.   include 지시어는 중첩 사용이 가능하기 때문에 include되는 파일 안에서 또 다른 파일을 include하여도 문제없이 동작한다.     3. taglib 지시어   &lt;%@ taglib url=\"http://taglib.com/sampleURI\" prefix=\"samplePrefix\" %&gt;      JSTL(JSP Standard Tag Library)이나 커스텀 태그 등 태그 라이브러리를 JSP`에서 사용할 때 접두사를 지정하기 위해 사용된다.   uri 속성과 prefix 속성으로 이루어진다.   🔸 uri 속성     태그 라이브러리에서 정의한 태그와 속성 저보를 저장한 TLD(Tag Library Descriptor) 파일이 존재하는 위치 지정   🔸 prefix 속성     사용할 커스텀 태그의 네임 스페이스(Name Space)를 지정  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-directive/",
        "teaser": null
      },{
        "title": "JSP 내장 객체",
        "excerpt":"👀 내장 객체란?     JSP 페이지가 웹 컨테이너에 의해서 서블릿으로 변환할 때 웹 컨테이너가 자동으로 생성해 주는 객체(클래스, import 구분없이 사용 가능)     javax.servlet 패키지 - 8개                   내장 객체 변수명       설명                               request       클라이언트의 HTTP 요청 정보를 저장한 객체(HTTP헤더 정보, 파라미터 등)                         response       클라이언트 요청에 대한(HTTP) 응답 정보를 저장한 객체                         session       클라이언트의 세션 정보를 저장한 객체                         pageContext       페이지 실행에 필요한 컨텍스트 정보를 저장한 객체                         out       응답 페이지 정보를 전송하기 위한 출력 스트림 객체                         application       동일한 애플리케이션의 컨텍스트 정보를 저장한 객체                         config       해당 페이지의 서블릿 설정 정보(초기화 정보)를 저장한 객체                         page       해당 페이지 서블릿 객체(인스턴스)                    java.lang 패키지 - 1개      exception : 예외 처리를 위한 객체   1. request 객체          사용자의 요청에 관한 정보를 얻기 위한 객체         서버 도메인명 : request.getServerName();   서버 포트번호 : request.getServerPort();   URL : request.getRequestURL();   URI : request.getRequestURI();   클라이언트 호스트명 : request.getRemoteHost();   클라이언트 IP주소 : request.getRemoteAddr();   프로토콜 : request.getProtocol();   페이지 요청(전송)방식 : request.getMethod();   프로젝트 경로 : request.getContextPath();   물리적 경로 : request.getRealPath(\"/\");   http헤더 (user-agent): request.getHeader(\"user-agent\");   http헤더 (accept-language) : request.getHeader(\"accept-language\");   http헤더 (host) : request.getHeader(\"host\");        http헤더 (connection) : request.getHeader(\"connection\");       전송을 통해 다른 페이지에서 전달받은 (이름 등의)정보를 얻을 때   String name = request.getParameter(\"name\");         정보들을 배열로 얻을 때   String hobbies[] = request.getParameterValues(\"hobby\");   🔸 URI     URI는 특정 리소스를 식별하는 통합 자원 식별자(Uniform Resource Identifier)를 의미한다.   웹 기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스다.   🔸 URL     URL은 흔히 웹 주소라고도 하며, 컴퓨터 네트워크 상에서 리소스가 어디 있는지 알려주기 위한 규약이다. URI의 서브셋이다.   한마디로 URI가 자원 자체에 대한 고유 식별자라면 URL은 자원이 실제로 존재하는 위치를 가리킨다.         2. response 객체          클라이언트의 요청에 대한 HTTP 응답(HTTP Response)을 나타내는 객체              response.setHeader(“헤더이름”, 값);       response.addHeader(\"Refresh\", \"3\"); // 3초에 한번씩 새로고침 response.addHeader(\"Refresh\", \"3;url=http://www.naver.co.kr\"); // 3초 후에 다음 페이지로 이동      response.sendRedirect(“주소”); // “주소”로 요청 재전송   response.sendRedirect(\"http://www.naver.co.kr\"); // 해당 페이지로 바로 이동      response.setContentType(\"속성값\"); 컨텐츠 타입 지정   response.addCookie(\"쿠키값\"); 쿠키 추가   3. session 객체          클라이언트의 정보가 유지되어야 할 필요가 있는 경우를 위해 가상 연결을 구현해주는 세션         세션ID값 : session.getId();   세션생성시간 정보(ms) : session.getCreationTime();   최종 접속 시간(ms) : session.getLastAccessedTime();   세션 유지시간(기본)(1800s,30m) : session.getMaxInactiveInterval();    4. application 객체          해당 웹 애플리케이션의 실행 환경을 제공하는 서버의 정보와 서버측 자원에 대한 정보를 얻어내거나 해당 애플리케이션의 이벤트 로그를 다루는 메소드들을 제공         서버정보 : application.getServerInfo();   서버의 물리적 경로 : application.getRealPath(\"/\");   5. out 객체     서블릿/JSP 컨테이너가 응답 페이지를 만들기 위해 사용하는 출력 스트림 객체        하지만 표현식을 사용해서 자바 코드의 변수 값들과 메소드의 리턴 값들을 출력할 수 있기 때문에 잘 사용되지 않는다.         출력 : out.print(\"Hello\");   버퍼 사이즈 : &lt;%=out.getBufferSize() %&gt;byte&lt;br&gt;   버퍼 사용후 : &lt;%=out.getRemaining() %&gt;byte&lt;br&gt;  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-implicit-object/",
        "teaser": null
      },{
        "title": "JSP 영역 객체와 속성",
        "excerpt":"👀 영역 객체(Scope)와 속성(Attribute)     jsp 내장객체 중에서 특정 공간(Scope)에 정보를 저장하고, 저장된 정보(Attribute)를 공유할 수 있는 객체   JSP에서는 page, request, session, application 4가지 영역으로 정의한다.       ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-scope-attribute/",
        "teaser": null
      },{
        "title": "JSP 스크립트 요소",
        "excerpt":"👀 JSP 스크립트 요소  1. 선언문   &lt;%!     // 멤버변수와 메서드 선언 %&gt;      멤버변수와 메서드를 선언하기 위한 영역   클래스에서 멤버변수와 메서드를 선언한 것과 동일한 결과로 같은 JSP 페이지 어느 위치에서든 참조가 가능하다.   2. 스크립틀릿(Scriptlet)   &lt;% 문장1; %&gt; &lt;%     문장2; 문장3; 문장4; ... %&gt;      JSP 코드를 작성하는 영역   서블릿 코드의 작성법이 다소 어려워서 이것을 보완하기 위해 만들어진 방식   스크립틀릿 영역에서 선언되는 변수들은 지역변수로 인식된다.   JSP 파일이 실행되면 웹 컨테이너에 의해 JSP 파일이 파싱되어 서블릿 클래스로 변환된 자바 소스 파일과 클래스 자바 파일이 서버에 저장된다.   3. 표현식(Expression)   &lt;%=변수 %&gt; &lt;%=리턴값이 있는 메소드 %&gt; &lt;%=수식(변수 또는 리턴값이 있는 메소드를 포함할 수 있음) %&gt;      선언문, 스크립틀릿에 생성한 변수, 메소드의 리턴값을 스크립틀릿 태그 외부에서 출력하기 위해 사용   하나의 표현식 태그 내의 구문 전체가 print() 메소드의 괄호 안에 통채로 들어가기 때문에 표현식 태그 내부에서는 세미콜론(;)을 사용해서는 안된다.  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/JSP-script-elements/",
        "teaser": null
      },{
        "title": "세션(Session)과 쿠키(Cookie)",
        "excerpt":"👀 세션(Session)이란?  ☑️ 서버랑 클라이언트와의 관계(상태)를 유지하기 위해서 사용하는 값     HTTP 프로토콜은 상태가 유지되지 않기 때문에 요청에 대한 응답이 한 번씩 이뤄지고 나면 그 관계가 소멸된다.   하지만 이런 방식으로는 사용자가 회원 사이트에 로그인 했을 때 지속적으로 업무를 볼 수 없게 된다.   그래서 사용자가 지속적으로 업무를 볼 수 있도록 서버와 클라이언트간의 관계를 일정 시간동안 유지해주기 위해 쓰는 것이 세션이다.   세션객체(영역)는 브라우저당 1개씩 생성된다.   🔸 세션 메소드     세션값 생성 : session.setAttribute(\"이름\", 값);   세션값 사용 : session.getAttribute(\"이름\");   세션값 제거 : session.removeAttribute(\"이름\");   세션값 초기화 : session.invalidate();            ❗️ 세션값 제거 메소드를 통한 부분제거보다는 세션값 초기화를 시켜야 한다.       일부만 제거하면 사용자가 로그아웃 했는데 로그인 했을 때와 같은 행동이 일부 가능할 수 있다.               👀 쿠키(Cookie)란?     클라이언트 측에서 관리되는 정보   사용 가능한 기간동안 하드디스크에 저장되기 때문에 웹 브라우저가 사라져도 사용이 가능하다.   하지만 그만큼 보안적으로 취약하다. (그래서 보안이 필요한 정보는 세션 사용)   🔸 쿠키 생성 절차  1. 쿠키 생성  2. 쿠키가 필요로 하는 설정값 저장(유효기간, 설명, 도메인, …)  3. 웹 브라우저에 생성된 쿠키 정보 전달  4. 웹 브라우저 요청에서 쿠키를 얻어온다.  5. 쿠키 정보는 이름, 값의 데이터 쌍으로 형성된다.  6. 쿠키 이름을 사용해서 해당 값을 사용한다.   🔸 쿠키 사용 방법  1) HTTP 헤더 정보 사용 - 안씀 XX  2) 서블릿 API 사용 - 현재 쓰는 방식      쿠키 생성하는 예제 코드   &lt;%     // 쿠키값 생성 - 서블릿 API 사용     Cookie cookie = new Cookie(\"name\", \"CookieValue\"); // HDD 저장X, 메모리에만 있는 상태 \t\t     // 쿠키값 설정 - 유효기간 설정     cookie.setMaxAge(600); // 초 단위 - 10분 \t\t     // 쿠키값을 저장(응답정보(response)에 저장)     response.addCookie(cookie);     System.out.println(\"쿠키정보가 전달 완료시 사용자의 HDD에 저장\"); %&gt;           먼저 쿠키를 생성한 다음 클라이언트에게 전송한다.            쿠키값 가져오는 예제 코드       &lt;%     // 쿠키값 가져오기(request - 요청정보로부터 꺼내오기)     Cookie[] cookies = request.getCookies(); \t\t\t     if (null != cookies) // !!배열을 반복문 돌리기 전에 예외처리 꼭 하기!!     {         for (int i = 0; cookies.length &gt; i; i++)         {             //System.out.println(cookies[i]);             if (cookies[i].getName().equals(\"name\"))             {                 // Cookie cookie = new Cookie(\"name\", \"CookieValue\"); // HDD 저장X, 메모리O                 // ⬆️ 얘를 가져올 것임                 // 이름이 같다면 내가 직접 생성한 쿠키임                 System.out.println(cookies[i].getValue()); \t\t\t\t\t\t                 out.print(\"쿠키명: \" + cookies[i].getName() + \"\\n\");                 out.print(\"쿠키값 : \" + cookies[i].getValue());             }         }     } %&gt;      그 다음 클라이언트 측에서 쿠키를 가져온다.   쿠키값을 가져올 때엔 꼭 예외처리를 해서 null값이 아닐 때에만 가져오는 동작을 수행하도록 해야한다.  ","categories": ["JSP"],
        "tags": ["JSP","WEB","Session","Cookie"],
        "url": "/jsp/JSP-session-cookie/",
        "teaser": null
      },{
        "title": "JavaScript 기본 문법",
        "excerpt":"자바스크립트란?     웹 페이지에 방문했을 때 사용자의 동작(이벤트)에 따른 처리를 하는 언어   인터프리터 언어로 작성된 코드를 위에서 아래로 순차적으로 실행한다.   컴파일 언어와 다른 점은 일단 실행을 하고 에러가 발생하기 전 까지의 코드만 실행한다.   객체 기반 언어이다.   오픈소스 언어   다양한 라이브러리(API) 사용 가능            Jquery 주로 사용 - Ajax, Json           HTML5(웹표준) API 기반의 언어      변수 선언     var 키워드를 이용해 선언한다.   var num = 1;      일반적인 프로그래밍 언어와 다르게 자료형별로 구분해서 선언하지 않는다. 변수 선언과 동시에 초기화하는 내용물에 따라서 자바스트립트가 알아서 자료형을 지정한다.   편한 듯 하면서도 원래 하던 언어가 있어서 그런지 무의식적으로 int num … 과 같이 타이핑하게 될 때가 많다.   🔸 var     var 키워드는 같은 이름으로 중복해서 선언하고 값을 넣는 것이 가능하다.   var name = \"james\"; console.log(name); // james  var name = \"lily\"; console.log(name); // lily      컴파일 언어를 하다 온 입장에서는 다소 이해가 되지 않지만 자바스크립트에서의 var 키워드는 이런 흐름이 가능하다.   변수가 많아지면 중간에 꼬일 가능성이 아주 많아 보이는 속성이다. 그래서 이것을 보완하기 위해 나온 것이 let 키워드이다.   🔸 let     let 키워드도 var처럼 변수를 선언하는 키워드지만 약간 속성이 다르다.   let name = \"james\"; console.log(name); // james  let name = \"lily\"; console.log(name);  // Uncaught SyntaxError: Identifier 'name' has already been declared      let 키워드를 사용하니까 컴파일 언어와 같은 흐름을 보인다.   🔸 const     컴파일 언어에서와 마찬가지로 상수 선언 키워드이다.   const 다음에 자료형은 쓸 필요 없이 바로 변수 이름을 선언하고 초기화하면 된다.   const name = \"james\";       연산자     연산자의 사용은 동일하지만 자바스크립트에는 ===과 !==이라는 연산자가 있다.   데이터값과 자료형이 모두 동일한지 확인하는 연산자이다.   ==, != 연산자들은 단순히 값만 확인하고 자료형이 같은지는 확인하지 않는다.            그래서 문자 100과 숫자 100을 ==을 이용해서 값이 같은지 비교하면 true를 리턴한다.       === 연산자 사용시 false 리턴           🔸 연산자 우선순위      ()    단항연산자(++, –, !)    산술연산자(+, -, *, /, %)    비교연산자(&gt;, &lt;, &gt;=, &lt;=, ==, !=, ===, !==)                                    논리연산자(&amp;&amp;,                       )                            복합대입연산자(=, +=, -=, *=, /=, %=)     함수     함수 또한 자료형을 구분하지 않고 function 키워드 하나만 쓴다.   function 함수명() {     실행문; } 호출법 : 함수명();          익명함수도 사용 가능하다.     변수 = function () {   실행문; } 호출법 : 참조 변수명();                   객체     내 눈앞에 보이는 모든 대상   🔸 객체 생성은 new 키워드를 이용해서 생성한다.  var 참조변수(레퍼런스) = new Object();       1) 내장객체     자바스크립트 안에 포함된 객체            문자(String), 날짜(Date), 수학(Math), 숫자(Number), 배열(Array), …           🔸 날짜(Date)객체   var day = new Date(2022,0,1); // 2022년 1월 1일      자바스크립트에서의 날짜객체에서 좀 희안한 점이라면 월(Month)이 실제 숫자보다 1 적은 형태로 표현된다는 것이다. new Date(2022,1,1); 이라 쓰면 2022년 2월 1일이다.   🔸 배열(Array)객체   var arr1 = new Array(); var arr2 = new Array('a', 'b', 'c'); // 다 가능 let arr3 = [1, 2, 3];       자바스크립트에서 배열은 배열객체를 통해 생성 할 수도 있고 컴파일 언어와 비슷하게 []를 사용해서 초기화 하는 형태로 선언할 수도 있다.   또 특이한 점이라면 하나의 배열에 서로 다른 자료형을 가진 값을 담을 수 있다는 것이다.   2) 브라우저 객체 모델(BOM)     웹 브라우저에 포함되어 브라우저를 표현하는 객체   계층형 구조로 되어 있다.            / document, screen, ... window -   location, history          \\ navigator      알림창을 출력할 때     window.alert(\"메시지 출력 메서드\");           를 많이 쓴다.   &lt;script type=\"text/javascript\"&gt; function myOpen() {     window.open(\"test1.html\", \"test1\", \"width=300, height=200, top=150, left=500\"); } &lt;/script&gt;  &lt;input type=\"button\" value=\"팝업창 열기\" onclick=\"myOpen();\"&gt;      위 처럼 HTML 태그와 함께 쓸 수 있다.   🔸 location 객체   location.href = 'test1.html'; // test1.html로 이동 location.reload(); // 페이지 새로고침 location.replace('test2.html'); // 현재 페이지를 test2.html로 변경      주소창과 관련된 기능을 가지고 있다.   특정 페이지로 이동하거나 현재 페이지를 다시 로드하는 등의 동작을 수행할 수 있다.   🔸 history 객체   history.back(); // 뒤로 가기 history.forward(); // 앞으로 가기 history.go(-숫자); // 숫자만큼 뒤로 가기 history.go(숫자); // 숫자만큼 앞으로 가기      페이지의 방문기록에 따른 동작을 수행할 수 있다.   🔸 navigator 객체     방문자(클라이언트)의 브라우저 정보 및 운영체제정보 확인 가능   &lt;script type=\"text/javascript\"&gt;     alert(navigator.userAgent); &lt;/script&gt;      위와 같이 쓰면 팝업창에서 사용자의 브라우저 정보와 운영체제정보를 볼 수 있다.   3) 문서 객체 모델(DOM)     HTML문서 구조(객체)   document.images[0].src; // 현재 페이지에 있는 이미지들 중 첫번째 소스에 접근   document.폼태그명.속성      HTML의 폼태그와 결합해 사용할 수 있다.   🔸 폼태그 form     사용자의 정보를 입력받아서 특정 페이지(action)로 정보를 전달하는(submit) 태그   전달 방식에서는 Get방식과 Post방식이 있다.   &lt;fieldset&gt;     &lt;legend&gt;회원정보 가입하기&lt;/legend&gt;     &lt;form action=\"itwill.jsp\" name=\"fr2\" method=\"get\" onsubmit=\"return fun8();\"&gt;         &lt;label&gt;아이디 : &lt;/label&gt;&lt;input type=\"text\" name=\"id\" value=\"\"&gt; &lt;br&gt;         비밀번호 : &lt;input type=\"password\" name=\"pw\"&gt; &lt;br&gt;          주민번호 : &lt;input type=\"text\" name=\"ju1\" onkeyup=\"check1();\" maxlength=\"6\"&gt; - &lt;input type=\"text\" name=\"ju2\" maxlength=\"7\" onkeyup=\"check2();\"&gt;         &lt;br&gt; 메세지 :         &lt;textarea rows=\"5\" cols=\"10\" name=\"msg\"&gt;&lt;/textarea&gt;         &lt;br&gt; &lt;input type=\"submit\" value=\"회원 가입하기\" onsubmit=\"return fun8();\"&gt;          &lt;hr&gt;         &lt;input type=\"button\" value=\"속성 확인 버튼\" onclick=\"fun5()\"&gt;          &lt;input type=\"button\" value=\"속성 변경 버튼\" onclick=\"fun6()\"&gt;          &lt;input type=\"button\" value=\"데이터 확인 버튼\" onclick=\"fun7()\"&gt;     &lt;/form&gt; &lt;/fieldset&gt;      위와 같이 사용 가능하다.  ","categories": ["JavaScript"],
        "tags": ["JSP","JavaScript"],
        "url": "/javascript/JavaScript/",
        "teaser": null
      },{
        "title": "JSP란?",
        "excerpt":"👀 JSP(Java Server Page)란?     Java를 이용하여 동적인 웹 페이지를 만들기 위해 Sun Microsystems사가 개발한 기술     JSP의 특징  1. 강력한 이식성     자바기반의 언어로 어떤 JSP 컨테이너에서도 사용이 가능하므로 한 번 작성한 코드를 별다른 수정 없이 다른 플랫폼으로 이식이 가능하다.   모듈화와 모듈의 재사용성이 좋다.   2. 서버 자원의 효율적인 사용     스레드(Thread) 기반의 아키텍처 사용으로 불필요한 자원 낭비를 감소시켰다.   3. 간편한 MVC 패턴(디자인 패턴)     MVC 패턴을 JSP(View)와 자바빈즈(Model), 서블릿(Controller)을 이용해 쉽게 구현할 수 있다.   🔸 MVC 패턴     사용자에게 보여지는 화면인 View 부분과 실제 비즈니스 로직이 들어가는 Model 부분 그리고 View와 Model을 연결시켜주는 Controller 부분으로 구성   최근에 중대형 프로젝트에서 효과적이라 평가되어 많이 사용되고 있다.   🔸 디자인 패턴     프로젝트를 개발함에 있어서 특정한 문제가 주어졌을 때 그 문제를 해결하기 위한 방법을 설명해 놓은 일종의 지침   ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/What-is-JSP/",
        "teaser": null
      },{
        "title": "JSP 사용",
        "excerpt":"👀 JSP 사용     HTML 태그와 Java 코드를 함께 사용한다.   &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;%       // 스크립틀릿   %&gt; &lt;/body&gt; &lt;/html&gt;      HTML body 태그 안에서 스크립틀릿을 쓴 다음에 스크립틀릿의 범위 내에 코드를 작성한다.   &lt;h2&gt;자바코드로 테이블 생성&lt;/h2&gt;   &lt;table border=\"1\"&gt;     &lt;tr&gt;         &lt;td&gt;번호&lt;/td&gt;&lt;td&gt;이름&lt;/td&gt;     &lt;/tr&gt;     &lt;%         for (int i = 1; 6 &gt; i; i++)         {             %&gt;             &lt;tr&gt;                 &lt;td&gt;&lt;%=i %&gt;&lt;/td&gt;&lt;td&gt;학생&lt;%=i %&gt;&lt;/td&gt;             &lt;/tr&gt;             &lt;%         }     %&gt;   &lt;/table&gt;      위와 같이 자바 코드 사이에 스크립틀릿이 끝나는 표시(%&gt;)를 하고 HTML 태그를 쓴 다음에 &lt;%= %&gt;를 이용해 자바 코드의 지역 변수를 출력하는 것이 가능하다.(신기…)   🔸 JSP 주석   &lt;%-- --%&gt; (웹페이지 개발자 도구창에서 나타나지 않기 때문에 보안상 이것을 쓰는 것이 더 좋다) // 자바 스타일도 사용 가능  ","categories": ["JSP"],
        "tags": ["JSP","WEB"],
        "url": "/jsp/use-JSP/",
        "teaser": null
      },{
        "title": "운영체제",
        "excerpt":"👀 운영체제란?     Operating System, OS        컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층            좁은 의미의 운영체제(커널)            운영체제의 핵심 부분으로 메모리에 상주하는 부분       전공자 입장에서는 운영체제 하면 커널만을 이야기한다.           넓은 의미의 운영체제            커널 뿐 아니라 메모리에 상주하지 않는 각종 주변 시스템 유틸리티를 포함한 개념             🔸 운영체제의 목적      컴퓨터 시스템을 편라하게 사용할 수 있는 환경 제공   컴퓨터 시스템의 자원을 효율적으로 관리            하드웨어 자원인 프로세서, 기억장치, 입출력 장치들의 관리와       소프트웨어 자원인 프로세스, 파일, 메시지 등 모든 것을 관리한다.       사용자간의 형평성 있는 자원 분배가 가능해야 하고 주어진 자원으로 최대한의 성능을 낼 수 있어야 한다.       실행 중인 프로그램들은 CPU를 번갈아가며 차지하며 동작을 하게 되는데 이 때 운영체제는 한 프로그램이 CPU를 너무 오랫동안 쓰지 않고 짧은 시간동안 번갈아 쓰도록 할당해 주어야 한다.       또한 실행 중인 프로그램들에게 메모리 공간을 적절히 분배해 주어야 한다.             🔸 운영체제의 분류     동시 작업 가능 여부   사용자의 수   처리 방식     위 세 가지에 따라 분류할 수 있는데 현대 운영체제는 동시 작업이 가능하고 다중 사용자를 지원하며 시분할이 가능하다고 정리할 수 있다.   ☑️ 동시 작업 가능 여부  단일 작업(single tasking)     한 번에 하나의 작업만을 처리한다.   예) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음   과거에 MS-DOS에서 주로 사용되던 방식으로 현대 컴퓨터에선 쓰이지 않지만 엘리베이터처럼 기능이 단순하거나 특수 목적을 수행하는 기계에는 지금도 사용되고 있다.   다중 작업(multi tasking)     동시에 두 개 이상의 작업 처리   예) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음   스마트폰을 포함한 현대의 대부분의 하드웨어에서 사용되는 운영체제이다.     ☑️ 사용자의 수  단일 사용자(single user)     예) MS-DOS, MS Windows   다중 사용자(multi user)     예) UNIX, NT server   사용자가 많아지면 파일에 대한 접근 권한이나 사용자간 자원 분배를 형평성 있게 해 줄 수 있어야 한다.     ☑️ 처리 방식  일괄 처리(batch processing)     Interactive 하지 않은 방식   작업 요청을 일정량 모아서 한꺼번에 처리   작업이 완전 종료될 때까지 기다려야 함(하루 이상 걸림)   에) 초기 Punch Card 처리 시스템   시분할(time sharing)     Interactive한 방식   현대에 주로 사용하는 운영체제로 일반적인 범용 컴퓨터에서 사용   여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할해서 사용   일괄 처리 시스템에 비해 짧은 응답 시간을 가짐(UNIX)   하지만 응답 시간이 항상 고정된 것은 아니며 사용자가 많아지면 느려질 수 있다.   사람이 빠르다고 느끼면서 주어진 자원과 시간을 최대한 활용하는 것이 목적이다.   실시간(Realtime OS)     정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간시스템을 위한 OS   원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어 등 특수 목적을 가진 시스템에서 사용된다.   ▪️ 실시간 시스템의 개념 확장     Hard realtime system(경성 실시간 시스템)            데드라인을 지키지 않으면 큰일나는 시스템       예) 반도체, 미사일 등           Soft realtime system(연성 실시간 시스템)            데드라인을 좀 못 지켜도 괜찮은 시스템       예) OTT             🔸 비슷한 의미로 사용되지만 약간 다른 용어들     Multitasking : 하나의 프로그램이 끝나기 전에 다른 프로그램 작업이 가능한 것   Multiprogramming : 여러 프로그램이 메모리에 올라가 있는 것을 강조   Time sharing : CPU의 시간을 분할하여 나누어 쓴다는 것을 강조   Multiprocess : 여러 프로그램이 동시에 실행된다.   =&gt; 모두 컴퓨터에서 여러 작업을 동시에 수행한다는 것을 뜻하지만 어디에 더 초점을 맞추느냐에 따라 다르게 사용된다.   ☑️ Multiprocessor     하나의 컴퓨터에 CPU(processor)가 여러 개 붙어 있음을 의미   CPU가 하나임을 전제로 하는 위의 네 가지 용어들과는 하드웨어적으로 다르다.     🔸 운영체제의 예  ☑️ 유닉스(UNIX)     멀티태스킹 가능   다중 사용자용   대형 서버용   코드의 대부분을 C언어로 작성 - 기계어 사용에 어려움이 많아서 유닉스 개발용으로 C언어를 만들었다.   높은 이식성 - 다른 기계어 집합을 사용하는 컴퓨터에 이식이 쉽다.   최소한의 커널 구조   복잡한 시스템에 맞게 확장 용이   소스 코드 공개 - 학술적으로 사용하기 좋다.   프로그램 개발에 용이   다양한 버전            System V, FeeBSD, SunOS, Solaris - 유로. 소스 코드 비공개       Linux - 무료. 소스 코드 공개. 유닉스보다는 규모가 작은 환경이나 개인용 컴퓨터에 사용된다.           ☑️ DOS(Disk Operating System)     MS사에서 1981년 IBM-PC를 위해 개발   단일 사용자용 운영체제   싱글태스크   메모리 관리 능력의 한계(주 기억 장치 최대 용량 : 640KB)   ☑️ MS Windows     MS사의 다중 작업용 GUI 기반 운영체제   Plug and Play, 네트워크 환경 강화   DOS용 응용 프로그램과 호환성 제공   불안정성(초창기 윈도우즈)   풍부한 지원 소프트웨어   ☑️ Handheld device를 위한 OS     PalmOS, Pocket PC(WinCE), Tiny OS     🔸 운영체제의 구조     크게 CPU - memory - Disk - I/O device 구조   ☑️ CPU     CPU 스케줄링을 통해 실행중인 프로그램들에게 CPU를 효율적으로 할당해야 함   CPU에게는 선착순 처리가 효율적이지 않기 때문에 프로그램마다 걸리는 작업 시간에 따라 처리하도록 스케줄링한다.   ☑️ memory     프로그램을 실행하려면 memory에 올려야 하는데 memory는 한정되어 있기 때문에 적당히 잘 쪼개어 써야 한다.   최근에 많이 사용된 데이터는 오래 보관하고 그렇지 않으면 쫓아내는 방식으로 관리   ☑️ Disk     Disk에는 헤드가 있고 그 헤드를 움직이면서 일정 위치에 파일을 기록하기 때문에 I/O 요청이 들어왔을 때 헤드를 최대한 적게 움직이면서 최대한 빠르게 많이 처리할 수 있도록 처리 순서를 스케줄링 해야 한다.   ☑️ I/O device     지금까지 나온 장치들 중에선 가장 느리다.   때문에 인터럽트 기반으로 관리되며 CPU는 평소에는 자기 할 일을 하고 있다가 I/O 장치에서 인터럽트 요청이 들어오면 입출력을 수행하는 방식으로 진행된다.   ☑️ 프로세스 관리     프로세스의 생성과 삭제   자원 할당 및 반환   프로세스 간 협력   ☑️ 그 외     보호 시스템   네트워킹   명령어 해석기(command line interpreter)  ","categories": ["Operating System"],
        "tags": ["CS","OS"],
        "url": "/operating%20system/OS-01/",
        "teaser": null
      },{
        "title": "시스템 구조와 프로그램 실행",
        "excerpt":"👀 컴퓨터 시스템 구조            CPU는 매 시간마다 Memory에서 기계어 Instruction을 읽어서 실행하게 된다.   따라서 Memory는 CPU의 작업공간이라 할 수 있다.        Disk가 I/O 장치인 이유는 데이터를 Memory에서 읽어들이기도 하고 처리된 데이터를 가져와서 저장하기도 하기 때문이다.         device controller는 각 I/O device를 전담하는 작은 CPU 역할을 한다.   I/O device가 CPU에 비해 많이 느려서 CPU가 I/O 작업 처리가 끝나는 것을 마냥 기다릴 수는 없기 때문에 중간에 controller를 둬서 I/O 작업이 끝나면 CPU에게 알려준다.   local buffer는 각 I/O device controller의 작업공간이다.   입력받은 내용이나 출력할 내용을 여기에 저장해뒀다가 device controller가 사용자 프로그램으로 전달하거나 화면에 출력하는 등의 작업을 한다.     Mode bit     사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요해서 사용한다.   현재 수행중인 Instruction이 운영체제인지 사용자 프로그램인지 구분하기 위한 것   0과 1이라는 두 가지 operation을 사용해 모니터 모드와 사용자 모드를 구분한다.            1 사용자 모드 : 사용자 프로그램 수행       0 모니터 모드(= 커널 모드, 시스템 모드) : OS 코드 수행           보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 특권명령으로 규정한다.   Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꾼다.   사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅     Timer     CPU를 특정 프로그램이 독점하는 것으로부터 보호하기 위해서 사용한다.            정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 Interrupt를 발생시킨다.       Timer는 매 클럭 틱 때마다 1씩 감소한다.       Timer 값이 0이 되면 Timer Interrupt 발생             time sharing을 구현하기 위해 널리 이용된다.   현재 시간을 계산하기 위해서도 사용된다.     Device Controller     해당 I/O 장치유형을 관리하는 일종의 작은 CPU   제어 정보를 위해 control register, status register를 가진다.            CPU는 device controller를 통해 일을 시키는데 이 때 control register와 status register를 사용한다.                local buffer를 가진다.(일종의 data register)         I/O는 실제 device와 local buffer 사이에서 일어난다.   device controller는 I/O가 끝났을 경우 Interrupt로 CPU에 그 사실을 알린다.     ☑️ device driver(장치구동기)     OS 코드 중 각 장치별 처리루틴 ➡️ software            ex) 새 프린터를 사면 설치하는 프린터용 드라이버           ☑️ device controller(장치제어기)     각 장치를 통제하는 일종의 작은 CPU ➡️ hardware     입출력(I/O)의 수행     모든 입출력 명령은 특권명령이다.   ☑️ 사용자 프로그램의 I/O 방법     시스템콜(system call)            사용자 프로그램은 운영체제에게 I/O 요청           trap을 사용하여 인터럽트 벡터의 특정 위치로 이동   제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동   올바른 I/O 요청인지 확인 후 I/O 수행   I/O 완료 시 제어권을 system call 다음 명령으로 옮김     인터럽트(Interrupt)     인터럽트 당한 시점의 레지스터와 program counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.   ☑️ 넓은 의미의 인터럽트     Interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트로 일반적인 의미의 인터럽트   Trap (소프트웨어 인터럽트)            Exception : 프로그램이 오류를 범한 경우(프로그램 강제종료 등으로 대응)       System call : 프로그램이 커널 함수를 호출하는 경우           일반적으로 인터럽트 하면 하드웨어적인 인터럽트를 의미하고 소프트웨어적인 인터럽트는 Trap이라고 따로 지칭한다.   ☑️ 인터럽트 관련 용어     인터럽트 벡터            해당 인터럽트의 처리 루틴 주소(처리 위치)를 가지고 있다.           인터럽트 처리 루틴(= Interrupt Service Routine, 인터럽트 핸들러)            해당 인터럽트를 처리하는 커널 함수           🔸 현대의 운영체제는 인터럽트에 의해 구동된다.     만약 인터럽트가 없으면 CPU는 항상 사용자 프로그램이 쓰고 있게 될 것이다.     시스템콜(System Call)     사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것   사용자 프로그램이 I/O 등의 작업을 수행해야 할 때 시스템콜을 통해 운영체제에게 CPU를 넘겨줌으로서 필요한 서비스를 받을 수 있게 된다.     동기식 입출력과 비동기식 입출력  ☑️ 동기식 입출력 (Synchronous I/O)          I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에게 넘어간다.         구현 방법 1 (잘 안 씀)            하나의 I/O가 끝날 때까지 그거 하나만 한다.       I/O가 끝날 때까지 CPU를 낭비시킴       매시점 하나의 I/O만 일어날 수 있음             구현 방법 2 (보통 이렇게 구현함)            I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음       I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움       다른 프로그램에게 CPU를 줌       이 프로그램의 I/O 작업이 끝나면 다시 CPU를 준다.           ☑️ 비동기식 입출력 (Asynchronous I/O)     I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 즉시 넘어간다.   🔸 두 경우 모두 I/O의 완료는 인터럽트로 알려준다.   DMA(Direct Memory Access)     입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다.   CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송   byte 단위가 아니라 block 단위로 인터럽트를 발생시킴     서로 다른 입출력 명령어            일반적인 I/O 방식은 메모리를 관리하는 주소와 디바이스를 관리하는 주소를 따로 관리한다.   Memory Mapped 방식은 디바이스를 관리하는 주소도 메모리 영역에서 함께 관리한다.     저장장치 계층 구조            위로 갈수록 Speed ⬆️  Cost ⬆️(단위공간당 용량이 적어진다)  Volatility ⭕️ (휘발성 - 전원을 끄면 데이터가 사라진다)            CPU에서 직접 접근 가능(byte 단위 접근 가능)           아래로 갈수록 Speed ⬇️  Cost ⬇️(단위공간당 용량이 커진다)  Volatility ❌ (비휘발성 - 전원을 꺼도 데이터가 사라지지 않는다)            CPU 직접 접근 불가(byte 단위 접근이 불가능하며 섹터 단위 접근 가능)           ☑️ Caching     메인 메모리에 있는 내용 중 당장 필요한 것만 캐시 메모리에 올려 쓰는 것으로 재사용을 빠르게 하기 위한 목적     프로그램의 실행(메모리 load)         커널 주소 공간의 내용         사용자 프로그램이 사용하는 함수          모든 프로그램은 함수 구조로 짜여 있다. (기계어 레벨에서도 함수의 시작과 끝이 표시됨)         사용자 정의 함수            자신의 프로그램에서 정의한 함수             라이브러리 함수            자신의 프로그램에서 정의하지 않고 만들어져 있는 것을 가져다 쓴 함수       자신의 프로그램의 실행 파일에 포함되어 있다.           ☑️ 이 두 가지는 자신의 프로그램의 코드 영역에 포함되어 있어서 가상 메모리 안에서 자유롭게 점프가 가능하다.        커널 함수            운영체제 프로그램의 함수       커널 함수의 호출 = 시스템 콜           ☑️ 커널 함수는 커널의 코드 영역에 포함되어 있기 때문에 사용자 프로그램에서 자유로운 점프를 할 수 없다. ➡️ System call을 통해 운영체제에게 CPU 제어권을 넘기게 된다.     프로그램의 실행      ","categories": ["Operating System"],
        "tags": ["CS","OS","System Structure","Program Execurion"],
        "url": "/operating%20system/OS-02-System-structure-Program-excution/",
        "teaser": null
      },{
        "title": "MySQL 시작하기",
        "excerpt":"👀 MySql 시작하기     맥 기준으로 MySql을 설치하는 방법에는 2가지가 있는데   homebrew를 통해 설치하는 방법과        MySql 홈페이지에서 dmg 파일을 다운받아 설치하는 방법이 있다.          나는 여기서 homebrew를 통해 설치하는 방법을 택했다.   homebrew는 맥에서 쓸 수 있는 터미널 버전 앱스토어 같은 느낌으로 개발에 필요한 각종 소프트웨어들을 명령어 한 줄로 간편하게 설치할 수 있다.   MySql 설치     homebrew가 설치되어 있다는 전제하에 homebrew 터미널을 열어 명령어 입력을 통한 설치를 진행할 것인데, 먼저 홈 브루를 최신 버전으로 업데이트 시켜주고 시작하자.     brew update           업데이트가 완료되면 아래 명령어를 입력하면 MySql이 설치된다.     brew install mysql           설치가 완료된 후     brew list           를 입력하면 홈 브루를 통해 설치된 프로그램들이 나열되는데 그 중에 mysql이 있으면 설치가 잘 된 것임   MySql 실행     아까 설치할 때 썼던 터미널창에서 명령어 입력을 통해 MySql을 실행할 수 있는데 역시 2가지 방법이 있다.     brew services start mysql 혹은 mysql.server start           둘 중 하나를 입력해서 MySql서버를 시작할 수 있다.   네트워크 연결 허용하겠냐는 창이 뜨면 허용하겠다고 하면 된다.   MySql 초기 설정     서버가 시작되었다고 바로 쓸 수 있는 것은 아니고 간단한 설정을 해 주어야 한다.     mysql_secure_installation                위 명령어를 입력하면 MySql 초기 세팅을 시작할 수 있다.                                         “Would you like to setup VALIDATE PASSWORD component? (Press y           Y for Yes, any other key for No)”                           비밀번호를 복잡하게 설정하겠느냐는 것인데 아직 초보 단계니까 No를 입력해서 ‘1234’와 같은 쉬운 비밀번호를 설정한다. (Yes를 입력하면 복잡한 비밀번호 설정)        새 비밀번호를 입력하라는 메시지가 나오면 입력하고 엔터 누르면 된다.                                         “Remove anonymous users? (Press y           Y for Yes. any other key for No)”                           사용자 설정을 묻는 것인데 Yes를 선택했다.   Yes - 접속하는 경우 “mysql -uroot”처럼 -u 옵션 필요        No - 접속하는 경우 “mysql”처럼 -u 옵션 불필요                                         “Disallow root login remotely? (Press y           Y for Yes, any other key for No)”                           다른 IP에서 root 아이디로 원격 접속이 가능한지 묻는 것인데 Yes는 불가능, No는 가능        나는 Yes로 선택했다.                                         “Remove test database and access to it? (Press y           Y for Yes, any other key for No)”                                테스트 데이터베이스를 삭제할건지 말건지 묻는 것인데 나는 Yes로 선택했다.                                         “Reload privilege tables now? (Press y           Y for Yes, any other key for No)”                                변경된 권한을 테이블에 적용하는 설정에 대한 질문인데 이 질문은 무조건 Yes로 선택하는 것이 좋다고 한다.         여기까지 하면 모든 초기 설정이 완료된다.   MySql 접속  mysql -u root -p     위 명령어를 입력하면 root 아이디로 로그인할 수 있다.   비밀번호 입력창이 나오면 비밀번호를 입력 후(보이지 않지만 그냥 치면 됨) 엔터를 누르면 로그인이 완료된다.   정상적으로 로그인 되면 쉘이 mysql&gt;로 바뀐다.   mysql&gt; status;     위 명령어를 입력하면 현재 설정을 확인할 수 있다.   MySql 종료  mysql&gt; exit     위 명령어를 입력하면 Bye라는 메시지와 함께 mysql에서 빠져나올 수 있다.   brew services stop mysql 혹은 mysql.server stop     둘 중 하나를 입력하면 MySql 서버가 종료된다.  ","categories": ["MySQL"],
        "tags": ["MySQL","Database","JSP"],
        "url": "/mysql/mysql-beginning/",
        "teaser": null
      },{
        "title": "Java) BOJ 2908. 상수",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2908     문제          상근이의 동생 상수는 수학을 정말 못한다. 상수는 숫자를 읽는데 문제가 있다. 이렇게 수학을 못하는 상수를 위해서 상근이는 수의 크기를 비교하는 문제를 내주었다. 상근이는 세 자리 수 두 개를 칠판에 써주었다. 그 다음에 크기가 큰 수를 말해보라고 했다.            상수는 수를 다른 사람과 다르게 거꾸로 읽는다. 예를 들어, 734와 893을 칠판에 적었다면, 상수는 이 수를 437과 398로 읽는다. 따라서, 상수는 두 수중 큰 수인 437을 큰 수라고 말할 것이다.            두 수가 주어졌을 때, 상수의 대답을 출력하는 프로그램을 작성하시오.         입력     첫째 줄에 상근이가 칠판에 적은 두 수 A와 B가 주어진다. 두 수는 같지 않은 세 자리 수이며, 0이 포함되어 있지 않다.     출력     첫째 줄에 상수의 대답을 출력한다.      👀 풀이     입력으로 주어지는 숫자들을 % 연산을 이용해 뒤집은 다음 뒤집은 수들을 비교한 뒤 큰 값을 출력한다.   버퍼입출력을 이용해 출력할 때 주의점은 정수형은 string으로 타입캐스팅을 해 주어야 제대로 출력된다.(처음에 이걸 모르고 정수형 그대로 넣어서 이상한 값이 출력되어서 헤멨다…)       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2908","String","Java"],
        "url": "/boj/boj2908/",
        "teaser": null
      },{
        "title": "Java) BOJ 5622. 다이얼",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/5622     문제          상근이의 할머니는 아래 그림과 같이 오래된 다이얼 전화기를 사용한다.             전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.            숫자 1을 걸려면 총 2초가 필요하다. 1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.            상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.            할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 최소 시간을 구하는 프로그램을 작성하시오.         입력     첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 단어의 길이는 2보다 크거나 같고, 15보다 작거나 같다.     출력     첫째 줄에 다이얼을 걸기 위해서 필요한 최소 시간을 출력한다.      👀 풀이     다소 하드코딩으로 풀었는데… 1~9까지 돌리는데 걸리는 최소 시간을 배열에 저장한 다음에 각 문자의 범위별로 인덱스값을 정해주어 시간을 저장한 배열에서 시간을 가져와서 더해주었다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No5622","String","Java"],
        "url": "/boj/boj5622/",
        "teaser": null
      },{
        "title": "MySQL Workbench 시작하기",
        "excerpt":"👀 MySQL Workbench란?     터미널을 통한 데이터베이스 관리를 좀 더 편하게 할 수 있게 해주는 도구   IDE를 이용해서 프로그래밍 하는 것처럼 자동완성도 되고 테이블도 시각적으로 좀 더 편하게 볼 수 있고 터미널보다 훨씬 편하다.   최신버전에는 버그가 있어서 8.0.19 버전으로 수업을 진행할 예정   윈도우라면 MySQL 인스톨러에서 Remove 버튼을 눌러 개별 프로그램만 간편히 제거한 후 Add 버튼을 눌러 원하는 버전으로 선택해서 설치할 수 있다.   하지만 난 맥을 써서 homebrew로 MySQL만 따로 깔았기 때문에 Workbench는 홈페이지에서 dmg 파일을 따로 받아서 설치했다.       MySQL 주석문  # 주석문 -- 주석문 /* 주석문 */      셋 다 사용가능하다.       DB 조회  select * from jspdb.tbl_member;      Workbench에서 테이블을 조회하려면 테이블 앞에 DB명을 꼭 붙여줘야 한다.   그런데 매번 이렇게 쓰려면 좀 귀찮다…   use jspdb;  select * from tbl_member;      C++에서 using을 쓰듯 use를 써서 DB명을 선언해주면 그 다음부터는 DB명 없이 테이블을 부를 수 있다.   쿼리문 실행  Windows) ctrl + enter Mac) command + enter      일정 쿼리 구문들만 실행하고 싶으면 해당 쿼리문들을 블록으로 선택한 후 위 명령어를 입력하면 해당 쿼리문들만 실행된다.   Windows) ctrl + shift + enter Mac) command + shift + enter      전체 쿼리 실행은 위 명령어를 입력한다.  ","categories": ["MySQL"],
        "tags": ["MySQL","Workbench","Database","JSP"],
        "url": "/mysql/mysql-workbench-beginning/",
        "teaser": null
      },{
        "title": "Java) BOJ 1259. 팰린드롬수",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/1259     문제            어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. ‘radar’, ‘sees’는 팰린드롬이다.         수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다.   123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다.   또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만,   특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.      입력       입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다.   입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.       출력       각 줄마다 주어진 수가 팰린드롬수면 ‘yes’, 아니면 ‘no’를 출력한다.       👀 풀이       예제의 팰린드롬수를 보면 수의 개수가 짝수개일 땐 절반으로 나눈 앞뒤가 같아야 하고        홀수개일 땐 가운데 숫자를 제외한 나머지 앞뒤가 같아야 한다.         그래서 반복문으로 반복자는 문자열 길이의 절반까지만 반복하며   첫 글자와 맨 뒤 글자를 비교하면서 첫 글자를 가리키는 반복자는 증가시키고 끝 글자를 가리키는 반복자는 감소시켜가면서   두 반복자간의 거리를 좁히면서 검사하면 해당 수가 팰린드롬인지 아닌지 쉽게 확인할 수 있다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1259","String","Java"],
        "url": "/boj/boj1259/",
        "teaser": null
      },{
        "title": "Java) BOJ 1316. 그룹 단어 체커",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/1316     문제     그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다.   예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만,   aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.   단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.     입력     첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다.   단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.      출력     첫째 줄에 그룹 단어의 개수를 출력한다.      👀 풀이          문제 이해가 잘 되지 않아서 질문게시판의 문제 해설을 참고했다.                     현재 문자가 이미 나온 적이 있고                       바로 이전 문자가 아니면                -&gt; 그 단어는 그룹 단어가 아니다.         이 흐름에 따라 알파벳이 등장했는지 확인할 boolean 배열을 만들어 알파벳이 이전에 나왔는지 확인한 후   나온 적이 없고 바로 앞 문자와 같으면 그룹단어로 카운트하였고   나온 적이 있는데 바로 앞 문자와 같지 않으면 더 이상 확인을 중단하고 다음 문자를 확인하는 방식으로 코드를 짰다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1316","String","Java"],
        "url": "/boj/boj1316/",
        "teaser": null
      },{
        "title": "Java) BOJ 2941. 크로아티아 알파벳",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2941     문제     예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.   예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다.   단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.   dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.     입력     첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 ‘-‘, ‘=’로만 이루어져 있다.   단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.      출력     입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.      👀 풀이     특정 크로아티아 문자들 (“c=”, “c-“, “dz=”, “d-“, “lj”, “nj”, “s=”, “z=”)의 첫글자가 나오면 다음에 연속되는 문자를 검사해서 지정된 크로아티아 문자이면 그 길이만큼 반복문의 반복자를 증가시키고 아니면 반복자를 1씩 증가시키면서 글자수를 셌다.   이러한 조건문을 작성할 때 처음에는 반복자의 범위에 대한 예외처리를 해주지 않아서 제출하니까 string index out of bounds가 떴다.   배열을 다룰 때엔 항상 인덱스 범위를 잘 지키는 것에 유의하자.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2941","String","Java"],
        "url": "/boj/boj2941/",
        "teaser": null
      },{
        "title": "Java) BOJ 4949. 균형잡힌 세상",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/4949     문제            세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.              정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.              문자열에 포함되는 괄호는 소괄호(“()”) 와 대괄호(“[]”)로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.         모든 왼쪽 소괄호(“(“)는 오른쪽 소괄호(“)”)와만 짝을 이뤄야 한다.   모든 왼쪽 대괄호(“[“)는 오른쪽 대괄호(“]”)와만 짝을 이뤄야 한다.   모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.   모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.        짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.         정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.      입력       하나 또는 여러줄에 걸쳐서 문자열이 주어진다.        각 문자열은 영문 알파벳, 공백, 소괄호(“( )”) 대괄호(“[ ]”)등으로 이루어져 있으며, 길이는 100글자보다 작거나 같다.         입력의 종료조건으로 맨 마지막에 점 하나(“.”)가 들어온다.       출력       각 줄마다 해당 문자열이 균형을 이루고 있으면 “yes”를, 아니면 “no”를 출력한다.       👀 풀이            ’(‘, ‘[’ 괄호가 나오면 스택에 넣고 ‘)’, ‘]’ 괄호가 나오면 스택에서 마지막 값을 pop해서 매치되는 괄호면 넘어가고 매치되지 않으면 오답처리하고 탐색을 중단하고 “no”를 출력하는 방식으로 짰는데…         문제를 제대로 안 읽어서 소문자 “yes”, “no”로 출력해야 할 것을 대문자 “YES”, “NO”로 출력해서 20%에서 계속 틀렸다 ㅠ.ㅠ   문제를 제대로 읽자………….. 한시간 버렸다…….       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No4949","String","Java"],
        "url": "/boj/boj4949/",
        "teaser": null
      },{
        "title": "Java) BOJ 5430. AC",
        "excerpt":"문제 링크       https://www.acmicpc.net/problem/5430     문제       선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다.        이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.              함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.         함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, “AB”는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다.        예를 들어, “RDD”는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.         배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.      입력            첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.              각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.              다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)              다음 줄에는 [x1,…,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)              전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.         출력       각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.       👀 풀이       처음엔 스택과 큐를 이용해서        큐에 원래 순서대로 숫자를 집어넣고 뒤집어야 하면 스택에 push했다가 다시 큐로 pop 하는 방식을 썼는데 수의 최대 개수가 10만개라 예상대로 시간초과가 발생했다.              그래서 질문게시판을 찾아보다 덱을 사용하는 것을 보고 컨테이너를 덱으로 바꿨다.         그리고 R 연산이 짝수번이면 뒤집었다 다시 뒤집는 것이기 때문에 결국 뒤집지 않은 것이랑 같다.   그래서 연속된 R의 개수를 세어서 홀수번이면 덱의 맨 뒤에서 D 연산을 수행하고        연속된 R이 짝수번이면 맨 앞에서 D 연산을 수행하도록 하였다.              그 후 뒤집힌 상태라면 덱의 맨 뒤에서부터 pop연산을 수행하고 뒤집히지 않았다면 덱의 맨 앞에서부터 pop연산을 수행했다.              하지만 덱에 들어있는 숫자들을 정답 형태로 만들 때 단순 string에 더하는 형태로 만들었더니 가비지 컬렉션이 많이 발생해서… 거기서 최적화가 되지 않아서 또 시간초과를 받았다.         그래서 StringBuilder로 바꾼 뒤 정답 형태의 문자열로 만드는 부분을 좀 더 최적화 해 주었더니 932ms에 통과할 수 있었다…       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No5430","String","Java"],
        "url": "/boj/boj5430/",
        "teaser": null
      },{
        "title": "Java) BOJ 9012. 괄호",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/9012     문제     괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다.   그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다.   한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다.   그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다.   예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.   여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.      입력     입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다.   각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.      출력     출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.       👀 풀이          처음엔 왼쪽 오른쪽 괄호 개수를 세서 같으면 정답처리하는 방식으로 짰는데 2번 테케에서 틀렸다.              그래서 왼쪽 오른쪽 괄호가 나왔는지 확인하는 boolean 배열을 만들어서 확인하는 방식으로 수정했는데 사실상 1번이랑 다를 바 없었기 때문에 또 틀렸다.         그 다음엔 괄호의 개수를 세는데 왼쪽 괄호가 나오면 1을 더해주고 오른쪽 괄호가 나오면 1을 빼주는 방식으로 코드를 짰다.   그러면 양쪽 괄호가 맞게 나오면 최종 결과값은 0일 것이고,   왼쪽 괄호가 더 많다면 결과값이 양수일 것이다.   오른쪽 괄호가 더 많다면 음수가 나오게 되는데 처음으로 음수가 나오는 시점부터 이 테스트케이스는 매치되지 않는다고 판단하고 탐색을 중단하고 오답처리하면 된다.        왜냐면 )( 같은 경우에는 끝까지 카운트하면 0이 나오게 되는데 숫자상으로 보면 정답이지만 사실 매치되지 않는 괄호쌍이기 때문에 )이 처음 나와서 음수가 되는 순간부터 이 문장에 있는 괄호들은 매치되지 않는다.         따라서 한 문장에 대한 탐색이 끝나고 난 후 결과값이 0일 때에만 \"YES\"를 출력하고 나머지 경우엔 \"NO\"를 출력하면 된다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No9012","String","Java"],
        "url": "/boj/boj9012/",
        "teaser": null
      },{
        "title": "Java) BOJ 1712. 손익분기점",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/1712     문제     월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며,        한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.              예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.         노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.        최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.         A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.      입력     첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.       출력     첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.       👀 풀이          반복문으로 수익이 날 때까지 개수를 늘려가면서 계산했더니 시간초과가 나서 질문게시판을 검색했다..         반복문이 아닌 수학적으로 접근해야 하는 문제였으며 이 문제를 풀기 위해서는 순이익이 얼마인지 알아야 한다.   순이익은 (순이익 = 판매금액 C - 생산비용 B)로 구할 수 있다.        그런데 순이익이 0이거나 음수면 평생 팔아도 절대 수익이 나지 않는다. 그래서 이 경우엔 -1을 출력한다.         순이익이 양수라면 언젠가는 수익이 난다는 뜻이므로 정답을 구할 수 있다.   순이익은 판매비용에서 생산비용을 뺀 값이므로 순이익을 계산하는 과정에서 판매비용에 대한 계산은 끝나게 된다.   그럼 남은 것은 건설비용 A인데 물건을 판매할 때마다 순이익으로 건설비용 A를 갚다보면 언젠가는 남은 건설비용이 -가 될 것이다.   그러므로 건설비용을 순이익으로 나눈 몫이 손해가 나지 않을 최소 금액이라는 것을 알 수 있다.   그런데 문제에서 요구하는 손익분기점은 마이너스에서 최초로 이익이 발생하는 지점이므로 (건설비용 / 순이익)에다 1을 더해줘야 최초로 수익이 나는 지점이 된다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1712","Math","Java"],
        "url": "/boj/boj1712/",
        "teaser": null
      },{
        "title": "Java) BOJ 2292. 벌집",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2292     문제         위의 그림과 같이 육각형으로 이루어진 벌집이 있다.   그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다.   숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오.   예를 들면, 13까지는 3개, 58까지는 5개를 지난다.      입력     첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.       출력     입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.       👀 풀이     중심에서부터 벌집 테두리가 하나씩 늘어날 때 마다 6, 12, 18, … 6의 배수로 늘어난다.   즉 중심에서부터 벌집까지의 거리가 2인 테두리(첫번째 테두리)의 벌집 개수는 6개이고 거리가 3인 테두리는 12개, … 식으로 늘어난다.   그리고 벌집의 방 번호는 1부터 시작하기 때문에 N번째 방 번호는 1 + (61) + (62) + (63) + … (6N)이라는 것을 알 수 있다.        여기서 N을 구하는 것을 기본 아이디어로 잡고 시작했다.         문제의 조건은 1번에서 N번까지의 거리를 구하는 것이기 때문에   첫번째 테두리의 가장 큰 수인 7번방까지의 거리를 구한다면 (6*1) + 1 = 7이다. 이 때 N은 1이다.   그런데 처음 위치도 카운트해야 하기 때문에 1을 더해줘서 최종 정답은 2가 된다.        첫번째 테두리에 있는 가장 큰 수 까지의 거리가 2니까 같은 테두리에 있는 더 작은 숫자들까지의 거리도 2가 된다.          두번째 테두리의 가장 큰 수인 19까지의 거리를 구하면 (61) + (62) + 1 = 19이고 이 때의 N은 2이고 1을 더해주면 총 거리는 3이 된다.        마찬가지로 두번째 테두리의 가장 큰 수 까지의 거리가 3이니까 같은 테두리에 있는 더 작은 숫자들까지의 거리도 3이다.               이 아이디어를 N번째 숫자가 될 때까지 확장시켜가면 정답을 구할 수 있다.          위에서 더했던 과정을 반대로 생각하면 i=1부터 1씩 증가할 때 N에서 6*i을 빼고 남은 나머지가 1보다 작거나 같다면 N은 i번째 테두리에 있다고 할 수 있다.   그러면 N=i가 되는 것이고 이렇게 구한 N에다 첫 시작지점인 1을 더해주면 정답을 구할 수 있다.       ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2292","Math","Java"],
        "url": "/boj/boj2292/",
        "teaser": null
      },{
        "title": "2/8 CSS 수업 내용",
        "excerpt":"👀 오늘 수업 내용            HTML 페이지를 CSS로 이렇게 꾸미는 것을 했다.      소스코드 - CSS        &lt;style type=\"text/css\"&gt;         * { /*             기본적인 여백 없앰 - 0px */             margin: 0px; padding: 0px;         }                  body {             background-color: #ccc;             padding: 20px;         }                  form { /*            배경색 흰색, 테두리 1실선, #222, 테두리 둥글게 5px,              안여백 20px, 너비 400px 밖여백 위아래 30px 왼쪽오른쪽 가운데정렬 */             background-color: white;             border: 1px solid #222;             border-radius: 5px;             padding: 20px;             width: 400px;             margin: 30px auto;         }                  fieldset { /*            테두리 1px 실선 #ccc, 밖 아래여백 30px */             border: 1px solid #ccc;             margin-bottom: 30px;         }                  legend { /*            폰트크기 16px, 폰트굵게 bold, 안 왼쪽여백 5px, 안 아래여백 10px */             font-size: 16px;             font-weight: bold;             padding-left: 5px;             padding-bottom: 10px;         }                  li { /*            줄간격 30px, 리스트 스타일 none, 안여백 5px 10px, 밖아래여백 2px */             line-height: 30px;             list-style: none;             padding: 5px 10px;             margin-bottom: 2px;         }                  label { /*            왼쪽으로 배치, 폰트크기 13px, 너비 110px */             float: left;             font-size: 13px;             width: 110px;         }                  .btn { /*            테두리 1px 실선 #222, 테두리 둥글게 20px, 글자크기 16px,              글자간격 1px, 밖여백 자동 가운데정렬, 안여백 7px 25px */             display: block;             border: 1px solid #222;             border-radius: 20px;             font-size: 16px;             letter-spacing: 1px;             margin: 0px auto;             padding: 7px 25px;         }          /*        input type=\"submit\" 제외하는 법 */         input:not([type=submit]) { /*            테두리선 1px 실선 #ccc, 테두리선 둥글게 3px, 글자크기 13px, 안여백 5px,              너비 200px */             border: 1px solid #ccc;             border-radius: 3px;             font-size: 13px;             padding: 5px;             width: 200px;         }          /*        여러 필드셋 중 마지막 필드셋만 스타일 지정 */         fieldset:last-of-type {             border: none;             margin-bottom: 0px;         }          /*        태그 중 조건을 걸어줄 땐 대괄호 [] */         input[required] {             border: 1px solid red;         }                  input[readonly] {             border: none;         }     &lt;/style&gt;       소스코드 - HTML    &lt;body&gt; &lt;form action=\"a.jsp\" method=\"get\"&gt; \t&lt;fieldset&gt; \t\t&lt;legend&gt;로그인 정보&lt;/legend&gt; \t\t&lt;ul&gt; \t\t\t&lt;li&gt;&lt;label&gt;아이디&lt;/label&gt; \t\t\t    &lt;input type=\"text\" name=\"id\" autofocus required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;비밀번호&lt;/label&gt; \t\t\t    &lt;input type=\"password\" name=\"pwd1\"  required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;비밀번호 확인&lt;/label&gt; \t\t\t    &lt;input type=\"password\" name=\"pwd2\"  required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;회원 등급&lt;/label&gt; \t\t\t    &lt;input type=\"text\" name=\"level\" value=\"준회원\" readonly&gt;&lt;/li&gt; \t\t&lt;/ul&gt; \t&lt;/fieldset&gt; \t&lt;fieldset&gt; \t\t&lt;legend&gt;개인정보&lt;/legend&gt; \t\t&lt;ul&gt; \t\t\t&lt;li&gt;&lt;label&gt;이름&lt;/label&gt; \t\t\t    &lt;input type=\"text\" name=\"name\" placeholder=\"5자미만 공백없이\" required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;메일 주소&lt;/label&gt; \t\t\t    &lt;input type=\"email\" name=\"email\" placeholder=\"abcd@domain.com\" required&gt;&lt;/li&gt; \t\t\t&lt;li&gt;&lt;label&gt;연락처&lt;/label&gt; \t\t\t    &lt;input type=\"tel\" name=\"tel\"&gt;&lt;/li&gt; \t\t&lt;/ul&gt; \t&lt;/fieldset&gt; \t&lt;fieldset class=\"btnFieldset\"&gt; \t\t&lt;input type=\"submit\" value=\"제출\" class=\"btn\"&gt; \t&lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;  ","categories": ["HTML"],
        "tags": ["HTML","Front-end","CSS"],
        "url": "/html/CSS/",
        "teaser": null
      },{
        "title": "Java) BOJ 1193. 분수찾기",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/1193     문제          무한히 큰 배열에 다음과 같이 분수들이 적혀있다.         1/1\t1/2\t1/3\t1/4\t1/5\t…   2/1\t2/2\t2/3\t2/4\t…\t…   3/1\t3/2\t3/3\t…\t…\t…   4/1\t4/2\t…\t…\t…\t…   5/1\t…\t…\t…\t…\t…        …\t…\t…\t…\t…\t…         이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.    X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.     제한     시간 제한 : 0.5초   메모리 제한 : 256MB     입력     첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.      출력     첫째 줄에 분수를 출력한다.       👀 풀이          ❗️ 1시간 고민했지만 풀이를 찾지 못해서 질문 게시판 참고함         x/y 라고 해볼께요. 일단 x=1일때를 봅시다. 왼쪽아래, 또는 오른쪽 으로 이동하죠? 이 때 x+y를 봅시다.   x+y가 짝수일때 오른쪽으로 이동하고, 홀수일 때 왼쪽아래로 이동하죠. 이와 마찬가지로 y=1일 때를 봅시다.   x+y가 짝수일 때 오른쪽 위로 이동하고, 홀수일 때 아래로 이동합니다.   다음과 같이 생각하시면 쉽게 풀 수 있을겁니다.   if x==1 or y==1 : (x+y)가 홀수일 때와 짝수일 때로 나눠서 시행하기        else : 바로 이전에 한 이동과 같은 방향으로 이동         위의 글에서 아이디어를 얻어서 다음과 같은 문제 해결법을 생각해 봄             필요한 것 : 현재 번호, 현재 분자와 분모를 저장할 변수, 이동 방향을 저장할 변수              x==1 or y==1 이라면 (x+y)가 홀수일 때 이동 방향을 왼쪽으로 설정한다.     \t- 왼쪽으로 이동한다는 것은 x가 증가한다.   2-1. (x+y)가 짝수면 이동 방향을 오른쪽으로 설정한다.    \t- 오른쪽으로 이동한다는 것은 y가 증가한다.              1번 경우에 들어가지 않는 경우에는 1번 경우에서 정해진 이동방향에 따라 이동한다.   3-1. 왼쪽 이동이면 x++, y--   3-2. 오른쪽 이동이면 x--, y++              위의 두 경우 모두 현재 번호가 증가하니까 현재 번호를 저장한 변수도 증가시킨다.              그런데 x==1 or y==1일 때에도 증가시키지 않는 쪽을 감소시켜야 하는데 최소값은 1이어야 하는데 그냥 감소시키면 0이 되어버리니까 1보다 클 때에만 감소시키도록 한다.              위의 과정을 코드로 구현하면 정답!!         ☑️ 결과 : 메모리) 16184kb, 시간) 176ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No1193","Math","Java"],
        "url": "/boj/boj1193/",
        "teaser": null
      },{
        "title": "GROUP BY절과 HAVING절",
        "excerpt":"☑️ 문법     그룹함수와 함께 사용하며 조건에 맞는 그룹으로 묶어서 보여준다.   SELECT    column, group_function FROM      table [WHERE    contition] [GROUP BY group_by_expression] [HAVING   group_condition] [ORDER BY column];   그룹함수     AVG : 평균을 구해주는 함수   COUNT : 개수를 세어주는 함수   MAX : 최대값을 구해주는 함수   MIN : 최소값을 구해주는 함수            날짜와 문자의 최대값과 최소값도 구할 수 있는데       날짜에서의 최대값은 가장 최근 날짜, 최소값은 가장 과거 날짜       문자에서는 알파벳/가나다 오름차순으로 보여준다.           STDDEV : 표준편차를 구해주는 함수(쓸 일이 많지는 않다)   SUM : 합계를 구해주는 함수   VARIANCE : 분산을 구해주는 함수(쓸 일이 많지는 않다)   SELECT AVG(salary), MAX(salary),        MIN(salary), SUM(salary) FROM   employees WHERE  job_id LIKE '%REP%';  SELECT COUNT(commission_pct) FROM   employess WHERE  department_id = 80;       GROUP BY절  SELECT   department_id, AVG(salary) FROM     employees GROUP BY department_id;  SELECT   department_id, job_id, SUM(salary) FROM     employees WHERE    department_id &gt; 40 GROUP BY department_id, job_id ORDER BY department_id;     select절에 있는 컬럼 리스트 중에서 그룹함수에 포함되어 있지 않은 컬럼은 반드시 group by절에 포함되어 있어야 문법 오류가 안 난다.     HAVING절  SELECT   job_id, SUM(salary) PAYROLL FROM     employees WHERE    job_id NOT LIKE '%REP%' GROUP BY job_id HAVING   SUM(salary) &gt; 13000 ORDER BY SUM(salary);     GROUP BY절과 HAVING절 사이에 순서는 없으나 ORDER BY절은 맨 마지막에 쓰는 것이 좋다.   왜냐면 최종 결과를 가지고 정렬하는 것이 가장 정확하니까.      JOIN     여러 테이블을 묶어서 데이터를 볼 때 사용한다.      ON절을 사용한 JOIN  SELECT e.employee_id, e.last_name, e.department_id,        d.department_id, d.location_id FROM   employees e JOIN departments d ON     (e.department_id = d.department_id); -- 여기에 연결시킬 컬럼명을 입력한다.  SELECT e.employee_id, e.last_name, e.department_id,        d.department_id, d.location_id FROM   employees e JOIN departments d ON     (e.department_id = d.department_id) WHERE  e.manager_id = 149;     컬럼명을 입력할 때 해당 컬럼이 속해있는 테이블명을 입력하면 해당 범위에서만 검색을 시행하기 때문에 실행속도가 훨씬 빨라진다. (테이블명을 적지 않아도 실행되지만 그만큼 모든 테이블을 대상으로 검색해서 결과를 가져오기 때문에 실행속도가 훨씬 느리다.)   그래서 실행속도가 빠른 쿼리문을 작성하는 것이 중요하다.   그런데 테이블 풀네임을 일일이 적어주면 너무 길어서 가독성이 떨어지니까 약자로 적을 수 있는데 대신 약자로 적었다면 FROM절에서 어떤 테이블명의 약자인지 꼭 명시해줘야 SQL이 헷갈리지 않고 잘 찾아올 수 있다.  ","categories": ["Database"],
        "tags": ["DB","SQL"],
        "url": "/database/SQL-groupby-having/",
        "teaser": null
      },{
        "title": "Java) BOJ 10250. ACM 호텔",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/10250     문제     ACM 호텔 매니저 지우는 손님이 도착하는 대로 빈 방을 배정하고 있다.   고객 설문조사에 따르면 손님들은 호텔 정문으로부터 걸어서 가장 짧은 거리에 있는 방을 선호한다고 한다.   여러분은 지우를 도와 줄 프로그램을 작성하고자 한다.   즉 설문조사 결과 대로 호텔 정문으로부터 걷는 거리가 가장 짧도록 방을 배정하는 프로그램을 작성하고자 한다.   문제를 단순화하기 위해서 호텔은 직사각형 모양이라고 가정하자.   각 층에 W 개의 방이 있는 H 층 건물이라고 가정하자 (1 ≤ H, W ≤ 99).   그리고 엘리베이터는 가장 왼쪽에 있다고 가정하자(그림 1 참고). 이런 형태의 호텔을 H × W 형태 호텔이라고 부른다.   호텔 정문은 일층 엘리베이터 바로 앞에 있는데, 정문에서 엘리베이터까지의 거리는 무시한다.   또 모든 인접한 두 방 사이의 거리는 같은 거리(거리 1)라고 가정하고 호텔의 정면 쪽에만 방이 있다고 가정한다.   방 번호는 YXX 나 YYXX 형태인데 여기서 Y 나 YY 는 층 수를 나타내고 XX 는 엘리베이터에서부터 세었을 때의 번호를 나타낸다.   즉, 그림 1 에서 빗금으로 표시한 방은 305 호가 된다.   손님은 엘리베이터를 타고 이동하는 거리는 신경 쓰지 않는다. 다만 걷는 거리가 같을 때에는 아래층의 방을 더 선호한다.   예를 들면 102 호 방보다는 301 호 방을 더 선호하는데, 102 호는 거리 2 만큼 걸어야 하지만 301 호는 거리 1 만큼만 걸으면 되기 때문이다.   같은 이유로 102 호보다 2101 호를 더 선호한다.   여러분이 작성할 프로그램은 초기에 모든 방이 비어있다고 가정하에 이 정책에 따라 N 번째로 도착한 손님에게 배정될 방 번호를 계산하는 프로그램이다.   첫 번째 손님은 101 호, 두 번째 손님은 201 호 등과 같이 배정한다. 그림 1 의 경우를 예로 들면, H = 6이므로 10 번째 손님은 402 호에 배정해야 한다.     제한     시간 제한 : 1 초   메모리 제한 : 256 MB     입력     프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T 개의 테스트 데이터로 이루어져 있는데 T 는 입력의 맨 첫 줄에 주어진다.   각 테스트 데이터는 한 행으로서 H, W, N, 세 정수를 포함하고 있으며 각각 호텔의 층 수, 각 층의 방 수, 몇 번째 손님인지를 나타낸다(1 ≤ H, W ≤ 99, 1 ≤ N ≤ H × W).     출력     프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행을 출력하는데, 내용은 N 번째 손님에게 배정되어야 하는 방 번호를 출력한다.       👀 풀이          N을 H로 나눈 몫 + 1이 방 번호의 맨 뒷자리가 되고 N을 H로 나눈 나머지만큼 앞자리 층수를 올려주면 되기 때문에 정답을 구하기 위한 계산식은 (N % H) * 100 + (N / H + 1) * 100 이 된다.         그런데 처음엔 N == H 인 경우를 생각하지 않아서 틀렸다.   N == H 일 경우 N을 H로 나눈 몫이 1이 되고 나머지는 0이기 때문에 처음에 생각했던 경우의 계산식만 적용하면 (N % H) * 100 = 0 이 된다.        거기다 1을 더하면 2가 나온다. 항상 오답됨         그래서 N == H 경우에는 층수는 H로 항상 고정되기 때문에 H * 100 + (N / H) 로 계산했다.      ☑️ 결과     메모리 : 14372 kb   시간 : 136 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No10250","Math","Java"],
        "url": "/boj/boj10250-java/",
        "teaser": null
      },{
        "title": "C++) BOJ 2869. 달팽이는 올라가고 싶다",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2869     문제     땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.   달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.   달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.     제한     시간 제한 : 0.15초   메모리 제한 : 128 MB     입력     첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B &lt; A ≤ V ≤ 1,000,000,000)     출력     첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.      👀 풀이     Java로 풀었는데 C++ 실행속도가 궁금해서 한 번 더 풀어보았다.        확실히 엄청 빠름         아주 오랜만에 스스로 풀이과정을 생각해 낸 수학문제… 그만큼 쉬운 문제였다.        입력의 최대 크기가 10억이기 때문에 반복문을 돌리면 안 되고 사칙연산을 이용해서 풀었다.         달팽이가 하루에 갈 수 있는 거리는 (총 이동거리 A - 자는동안 미끄러지는 거리 B) 이다.   그런데 정상에 도착하면 미끄러지지 않는다고 했으므로 A 거리만큼 이동해서 정상에 도착할 수 있는 날이면 B를 뺄 필요 없이 A만큼만 이동하면 된다.   그러면 (총 이동거리 A - 자는동안 미끄러지는 거리 B)만큼 이동하는 날수는 정상에서 A 거리만큼을 뺀 길이까지이다.   그래서 (정상 V - A) / (총 이동거리 A - 자는동안 미끄러지는 거리 B) 연산을 통해 마지막 날이 되기 전까지 며칠이 걸리는지 구할 수 있는데   나누기 연산을 하고 나서 나머지(짜투리 길이)가 생길 수 있다.   짜투리 길이만큼을 이동하는데에도 하루를 소모해야 하기 때문에 나누기 연산 후 나머지가 생기면 하루를 더해줘야 한다.   그 다음 마지막날을 더해주면 된다.     ☑️ 결과 : 메모리) 2020 kb, 시간) 0 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2869","Math","C++"],
        "url": "/boj/boj2869-cpp/",
        "teaser": null
      },{
        "title": "Java) BOJ 2869. 달팽이는 올라가고 싶다",
        "excerpt":"문제 링크     https://www.acmicpc.net/problem/2869     문제     땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.   달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.   달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.     제한     시간 제한 : 0.15초   메모리 제한 : 128 MB     입력     첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B &lt; A ≤ V ≤ 1,000,000,000)     출력     첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.      👀 풀이     아주 오랜만에 스스로 풀이과정을 생각해 낸 수학문제… 그만큼 쉬운 문제였다.        입력의 최대 크기가 10억이기 때문에 반복문을 돌리면 안 되고 사칙연산을 이용해서 풀었다.         달팽이가 하루에 갈 수 있는 거리는 (총 이동거리 A - 자는동안 미끄러지는 거리 B) 이다.   그런데 정상에 도착하면 미끄러지지 않는다고 했으므로 A 거리만큼 이동해서 정상에 도착할 수 있는 날이면 B를 뺄 필요 없이 A만큼만 이동하면 된다.   그러면 (총 이동거리 A - 자는동안 미끄러지는 거리 B)만큼 이동하는 날수는 정상에서 A 거리만큼을 뺀 길이까지이다.   그래서 (정상 V - A) / (총 이동거리 A - 자는동안 미끄러지는 거리 B) 연산을 통해 마지막 날이 되기 전까지 며칠이 걸리는지 구할 수 있는데   나누기 연산을 하고 나서 나머지(짜투리 길이)가 생길 수 있다.   짜투리 길이만큼을 이동하는데에도 하루를 소모해야 하기 때문에 나누기 연산 후 나머지가 생기면 하루를 더해줘야 한다.   그 다음 마지막날을 더해주면 된다.     ☑️ 결과 : 메모리) 2020 kb, 시간) 0 ms     코드     ","categories": ["BOJ"],
        "tags": ["Algorithm","BOJ","No2869","Math","Java"],
        "url": "/boj/boj2869-java/",
        "teaser": null
      },{
        "title": "회원관리 서비스 요구사항",
        "excerpt":"👀 회원관리 서비스 요구사항     모든 웹페이지의 기본 서비스라고 할 수 있는 회원관리 서비스! 아래와 같은 사항들이 가능해야 한다.     1) 회원가입 페이지 - 아이디는 이메일을 사용하거나 전화번호를 입력받는 등 회원가입에 필요한 정보 입력  2) 로그인  3) 메인페이지  4) 회원정보 조회  5) 회원정보 수정  6) 회원정보 삭제  7) 관리자 - 회원 전체 목록 조회        이렇게 작성하는 것을 요구사항 확인 혹은 요구사항 명세라고 한다.   이 과정을 진행하기 전에 DB 테이블 생성을 먼저 진행한다.  ","categories": ["JSP"],
        "tags": ["Database","JSP","JDBC"],
        "url": "/jsp/customer-management/",
        "teaser": null
      },{
        "title": "JDBC",
        "excerpt":"👀 JDBC(Java Database Connectivity)란?     Java랑 DBMS를 연결시켜주는 API   즉 자바랑 DB를 연결시켜서 사용할 수 있게 해주는 기능들이 모여있는 라이브러리라 할 수 있다.   데이터베이스에 데이터를 삽입, 수정, 삭제할 때 SQL 프롬프트에서 SQL문을 사용하지 않아도 자바 프로그램에서 SQL문을 사용하여 데이터베이스에 데이터를 추가하고 삭제하는 작업을 할 수 있게 하는 API이다.   JDBC는 DBMS 종류에 상관없이 독립적으로 사용 가능하다.            여러 언어에서 작동하는 방법이 전반적으로 같다고 할 수 있다.              JDBC 드라이버 설치     mysql 홈페이지에서 Connect J를 다운받는다.(현재 최신버전인 8.0.28)   윈도우라면 .zip 파일을 받으면 되고 맥이라면 .tar 파일을 받는다.   압축을 풀면 mysql-connector-java-8.0.28.jar란 파일이 있다.   저걸 JDBC를 사용하고자 하는 (이클립스)프로젝트의 WEB-INF/lib 폴더에 넣는다.(경로 다르면 안 됨!! 무조건 저기에 넣어야 함)   그러면 설치 끝!      JDBC 연동  1. 드라이버 로드(하드디스크에 있는 프로그램을 메모리로 불러오기)     아까 설치한 JDBC 드라이버를 불러올 것이다.     Class.forName(\"com.mysql.cj.jdbc.Driver\"); // static method라서 객체 생성 없이 바로 호출할 수 있음           이렇게 입력하면 드라이버를 로드할 수 있다.   MySQL 홈페이지 가서 Documentation 페이지 - Connector/J 8.0 Developer Guide - 6. ConnectJ reference - 6.1 Driver/Datasource Class Name 가면 드라이버를 로드할 때 무슨 클래스명을 입력해야 하는지 찾을 수 있다.            그 외에도 레퍼런스가 필요하면 참고하자.           만약 설치를 안 했다면 실행시 참고할 드라이버가 없어서 HTTP500 에러가 뜬다.     2. DB 연결     DriverManager.getConnection(\"디비주소\", \"디비아이디\", \"디비비밀번호\");   DriverManager 객체를 이용해 DB와 드라이버를 연결한다.   Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jspdb\", \"root\", \"1234\");      이런 식으로 DB의 주소와 아이디, 비밀번호를 입력한 뒤 연결 객체 정보를 Connection에 저장한다.   이러면 mysql과 연결된 것이다. 이제 jsp 파일에서 SQL문을 작성해 데이터베이스를 관리할 수 있다.   JDBC 사용 예제 1) 사용자가 홈페이지에 회원가입 하는 상황   1. insertForm.jsp라는 이름으로 간단한 회원가입 페이지를 만든다.  &lt;form action=\"insertPro.jsp\" method=\"post\"&gt;     아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;     비밀번호 : &lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;     이름 : &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt;     &lt;input type=\"submit\" value=\"전송하기\"&gt;   &lt;/form&gt;      여기서 사용자가 정보를 입력하고 submit버튼을 클릭하면 insertPro.jsp 페이지로 전달된다.     2. insertPro.jsp라는 이름으로 회원가입 정보를 받아서 DB에 사용자 정보를 추가하는 페이지를 만든다.    &lt;% // 스크립틀릿 사용     // 0단계 : 드라이버 설치 - 완료됐으니 로드 단계로 넘어간다.     // 1단계 : 드라이버 로드     Class.forName(\"com.mysql.cj.jdbc.Driver\");        System.out.println(\"드라이버 로드 성공!\");          // 2단계 : 디비 연결 (디비 바꾸려면 jdbc:mysql://localhost:3306/뒤에 디비 이름만 바꿔주면 됨)     Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/jspdb\", \"root\", \"1234\");          System.out.println(\"디비 연결 성공!\");     System.out.println(\"연결정보 : \" + con);          // 3단계 : SQL 구문 생성 &amp; stmt(statement) 객체 생성     // String sql = \"insert into itwill_member (id, pass, name) values('id', 'pw', 'name')\";          // secure 코딩 예시) values에 담을 데이터의 개수만큼 ?를 넣는다.     String sql = \"insert into itwill_member (id, pass, name) values(?, ?, ?)\";          // stmt 객체 만들기 : sql 구문을 실행하는 객체 \t        // Statement stmt = con.createStatement(); // 하지만 이렇게 쓰려면 valuse 괄호 안에 따옴표를 넘 많이 써야해서 안 쓸 예정                             // 그리고 따옴표 안에 정보를 노출해서 써야해서 보안적으로 좋지 않다.     // Statement랑 PreparedStatement 객체 둘 중 하나만 쓸 수 있음          // pstmt 객체 : sql 구문을 실행하는 객체     PreparedStatement pstmt = con.prepareStatement(sql); // 객체를 만들 때 쿼리 정보를 가져가서 사전준비함          // ??? 값 sql 구문에 채워넣기     // pstmt.setXXXXXX(물음표의 위치, 실제 들어갈 값);     // =&gt; XXXXX : 컬럼의 데이터타입(int, double, string, ...)에 따라 변경     // * ? 개수와 동일한 구문을 수행해야 함 - ?가 3개면 채우는 구문 3개 있어야 함     // null 넣고 싶으면 쿼리문(String sql) 안에 직접 넣으면 됨     pstmt.setString(1, id); // 뜻 : 1번 물음표에 id에 해당하는 값을 넣는다.     pstmt.setString(2, pass);     pstmt.setString(3, name);          // 4단계 : SQL 구문 실행     // stmt.executeUpdate(sql); // 얘는 미리 준비 안해서 파라미터로 넣어줌     pstmt.executeUpdate(); // 그리고 바로 실행          System.out.println(\"insert 동작 완료!\");   %&gt;      위 과정을 완료하면 터미널이나 워크벤치에서 직접 SQL문을 작성하지 않았는데도 DB에 데이터가 삽입된다!     ❗️ 페이지를 실행할 땐 ~Form.jsp 페이지에서 한다.     사용자가 보는 페이지는 Form 페이지이지 처리를 하는 Pro 페이지를 사용자가 볼 수 없고 그럴 필요도 없기 때문이다.   Pro 페이지는 개발과정에서 개발자만 보는 페이지이다.   JDBC 사용 예제 2) 회원 정보를 수정하는 상황  1. updateForm.jsp라는 이름으로 수정할 정보를 입력받을 간단한 페이지를 하나 만든다.    &lt;form action=\"updatePro.jsp\" method=\"post\"&gt;     아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;     비밀번호 : &lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;     수정할 이름 : &lt;input type=\"text\" name=\"update_name\"&gt;&lt;br&gt;     &lt;input type=\"submit\" value=\"전송하기\"&gt;   &lt;/form&gt;   2. updatePro.jsp라는 이름으로 전송받은 정보를 DB에 삽입할 페이지를 만든다.    &lt;%     // 그냥 받으면 한글이 깨지기 때문에 꼭 한글처리 후 데이터 받기를 시작한다.     request.setCharacterEncoding(\"UTF-8\");          // 전달된 파라미터 저장     String id = request.getParameter(\"id\");     String pass = request.getParameter(\"pass\");     String uName = request.getParameter(\"update_name\");   %&gt;      아이디 : &lt;%=id %&gt;&lt;br&gt;   비밀번호 : &lt;%=pass %&gt;&lt;br&gt;   수정할 이름 : &lt;%=uName %&gt;&lt;br&gt;   &lt;hr&gt;      &lt;%     final String DRIVER = \"com.mysql.cj.jdbc.Driver\";     final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";     final String DBID = \"root\";     final String DBPASS = \"1234\";   %&gt;      &lt;h2&gt; 1. 드라이버 로드 &lt;/h2&gt;   &lt;%     Class.forName(DRIVER); // Class는 java.lang 패키지에 들어서 임포트 없이 쓸 수 있음.          System.out.println(\"드라이버 로드 성공!\");   %&gt;      &lt;h2&gt; 2. 디비 연결 &lt;/h2&gt;   &lt;%     Connection con = DriverManager.getConnection(DBURL, DBID, DBPASS);          System.out.println(\"디비연결 성공!\");   %&gt;      &lt;h2&gt; 3. sql 작성 &amp; pstmt 생성 &lt;/h2&gt;   &lt;%     String sql = \"update itwill_member set name=? where id=? and pass=?\"; // ?는 mysql 문법이 아니고 jsp 코드에서만 쓸 수 있는 문법          PreparedStatement pstmt = con.prepareStatement(sql); // 인터페이스를 통해 객체를 생성하지 않고 만들어진 정보를 전달          // ? 채우기     pstmt.setString(1, uName);     pstmt.setString(2, id);     pstmt.setString(3, pass);   %&gt;      &lt;h2&gt; 4. sql 실행 &lt;/h2&gt;   &lt;%     pstmt.executeUpdate();     System.out.println(\"회원정보 수정 완료!\");   %&gt;   JDBC 사용 예제 3) 사용자 정보를 삭제하는 상황  1. deleteForm.jsp라는 이름으로 삭제할 사용자의 정보를 입력받는 페이지를 만든다.    &lt;form action=\"deletePro.jsp\" method=\"post\"&gt;     아이디 : &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt;     비밀번호 : &lt;input type=\"password\" name=\"pass\"&gt;&lt;br&gt;     &lt;input type=\"submit\" value=\"전송하기\"&gt;   &lt;/form&gt;   2. deletePro.jsp라는 이름으로 DB에서 전달받은 정보를 삭제하는 작업을 하는 페이지를 만든다.    &lt;%     request.setCharacterEncoding(\"UTF-8\");        String id = request.getParameter(\"id\");     String pass = request.getParameter(\"pass\");   %&gt;      &lt;%     final String DRIVER = \"com.mysql.cj.jdbc.Driver\";     final String DBURL = \"jdbc:mysql://localhost:3306/jspdb\";     final String DBID = \"root\";     final String DBPASS = \"1234\";   %&gt;      &lt;h2&gt; 1. 드라이버 로드 &lt;/h2&gt;   &lt;%     Class.forName(DRIVER);   %&gt;      &lt;h2&gt; 2. 디비 연결 &lt;/h2&gt;   &lt;%     Connection con = DriverManager.getConnection(DBURL, DBID, DBPASS);   %&gt;      &lt;h2&gt; 3. sql 작성 &amp; pstmt 생성 &lt;/h2&gt;   &lt;%     String sql = \"delete from itwill_member where id=? and pass=?\";          PreparedStatement pstmt = con.prepareStatement(sql);     pstmt.setString(1, id);     pstmt.setString(2, pass);   %&gt;      &lt;h2&gt; 4. sql 실행 &lt;/h2&gt;   &lt;%     pstmt.executeUpdate();        System.out.println(\"회원정보 삭제 완료!\");   %&gt;  ","categories": ["JSP"],
        "tags": ["Database","JSP","JDBC"],
        "url": "/jsp/jdbc/",
        "teaser": null
      }]
