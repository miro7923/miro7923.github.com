<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-31T15:18:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">깃허브 프로필(Github Profile) 꾸미기</title><link href="http://localhost:4000/story/decorate-github-profile/" rel="alternate" type="text/html" title="깃허브 프로필(Github Profile) 꾸미기" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/story/decorate-github-profile</id><content type="html" xml:base="http://localhost:4000/story/decorate-github-profile/"><![CDATA[<h1 id="-시작">🎬 시작<br /></h1>
<p>드디어 깃헙 블로그를 만들고… 다른 깃헙들을 구경하다 보니까 깃헙 메인 화면 자체를 예쁘게 꾸며놓으신 분들이 많더라고요!<br /><br />
<img src="../../assets/images/githubProfileComplete.png" alt="githubProfileComplete" /><br /><br />
이렇게요!<br /><br />
되게 좋아 보이잖아요?ㅎㅎㅎ 그래서 저도 꾸며보기로 했습니다.<br /><br /></p>

<h1 id="1-new-repository-만들기">1. New Repository 만들기<br /></h1>
<p><img src="../../assets/images/createNewRepo.png" alt="createNewRepo" /><br /><br />
먼저 내 아이디와 같은 이름으로 새로운 레포지토리를 만들어 줍니다.<br />
처음 깃헙 블로그를 만들 때 봤을 때엔 깃헙 프로필 페이지 자체를 꾸밀 수 있다는 것을 몰라서 뭔 소린가 했는데 이런 뜻이었네요…<br /><br /></p>

<p><img src="../../assets/images/addReadme.png" alt="addReadme" /><br /><br />
만들 때엔 add a readme에 꼭 체크해 주세요! readme로 프로필 페이지를 꾸며야 하거든요.<br /><br /></p>

<h1 id="2-readmemd-편집하기">2. README.md 편집하기<br /></h1>
<p><img src="../../assets/images/editReadme01.png" alt="editReadme01" /><br /><br />
새로 만든 레포로 들어오면 아무것도 없어서 휑한 모습을 볼 수 있습니다. 전 까먹고 스샷을 좀 늦게 찍었더니 어느정도 꾸미기를 진행한 상태였네요 😅 <br />
여기서 리드미 파일 상단의 연필 그림을 누르거나 오른쪽에 보이는 초록색 edit readme 버튼을 눌러서 웹상에서 바로 편집을 진행하셔도 되고 로컬로 다운받아서 편집한 다음에 푸시하셔도 됩니다.<br /><br /></p>

<h2 id="-markdown-미리보기">🔸 markdown 미리보기<br /></h2>
<p>혹은 <a href="https://dillinger.io/">https://dillinger.io/</a><br />
<img src="../../assets/images/markdownPreviewService.png" alt="markdownPreviewService" /><br /><br />
라는 사이트가 있는데 여기에서는 마크다운으로 작성하는 파일을 실시간으로 미리볼 수 있는 서비스를 제공하고 있습니다.<br />
보통 마크다운 파일을 편집할 땐 미리보기가 가능하지 않으니까 여러번 커밋과 푸시를 하게 되어서 좀 귀찮은데 이 사이트에서는 실시간으로 확인하면서 작성한 다음에 복붙해서 한 번에 커밋할 수 있어서 꽤 편합니다.<br /><br />
하지만 전 쓸 게 그렇게 많지는 않아서 여기 쓰려다가 안 쓰고 그냥 레포에서 바로 수정했습니다…😅<br /><br /></p>

<h2 id="-배지-만들기">🔸 배지 만들기<br /></h2>
<p><img src="../../assets/images/techStack.png" alt="techStack" /><br /><br />
다른 분들 보니까 이런식으로 c++같은 프로그래밍 언어들을 그냥 텍스트로 쓰지 않고 배지 그림으로 달아 놓으셨더라고요. 저도 좋아보이는 건 다 해보고 싶어서 배지 이미지를 만들어 주는 사이트에서 만들었습니다.<br /><br /></p>

<h3 id="️-배지--httpsshieldsio">▪️ 배지 : <a href="https://shields.io/">https://shields.io/</a></h3>
<h3 id="️-언어-로고--httpssimpleiconsorg">▪️ 언어 로고 : <a href="https://simpleicons.org/">https://simpleicons.org/</a><br /></h3>
<p>위 사이트들에 가면 저런 폼나는 아이콘들을 얻을 수 있습니다.<br /><br /></p>

<p>배지를 만드시려면<br /><br />
<img src="../../assets/images/makeBadge01.png" alt="makeBadge01" /><br /><br />
이런식으로 넣고 싶은 문구를 입력하고 세번째 칸의 화살표를 눌러서 색상을 선택하거나 직접 입력하시고 나서 오른쪽의 Make Badge 버튼을 누르시면 <br /><br />
<img src="../../assets/images/makeBadge02.png" alt="makeBadge02" /><br /><br />
이렇게 배지를 만들어 줍니다. 여기서 주소를 복사하세요.<br /><br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/-TechBlog-brightgreen"&gt;
</code></pre></div></div>
<p>위 태그를 리드미에 입력하시면 우리가 만든 배지를 불러옵니다. 하지만 이렇게만 작성하면 단순히 그림만 불러오고 이 그림을 눌렀을 때 어디로 이동할지는 정해주지 않았기 때문에 그냥 새 창에서 그림이 호출될 것이어요… <br /><br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="https://miro7923.github.io/"&gt;
&lt;img src="https://img.shields.io/badge/-TechBlog-brightgreen"&gt;
</code></pre></div></div>
<p>그렇기 때문에 이런식으로 a 태그를 이용해 하이퍼링크를 걸어주시면 우리가 만든 배지 그림을 눌렀을 때 나의 블로그로 이동하게 됩니다.<br /><br /></p>

<p>일반화한다면 <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/라벨-메세지-색상"&gt;
</code></pre></div></div>
<p>이렇게 작성하시면 됩니다.<br /><br /></p>

<p>만약 이메일 주소도 추가하고 싶으시면 <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="mailto:miro7923@gmail.com"&gt;
</code></pre></div></div>
<p>mailto를 이용해 메일주소를 적어주세요!<br /><br /></p>

<h2 id="-프로그래밍-언어-로고-만들기">🔸 프로그래밍 언어 로고 만들기<br /></h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/C++-00599C?style=flat-square&amp;logo=C%2B%2B&amp;logoColor=white"/&gt;&lt;/a&gt;&amp;nbsp 
</code></pre></div></div>
<p>프로그래밍 언어 로고는 위와 같이 태그를 입력하면 되는데 이것을 일반화하면<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src="https://img.shields.io/badge/언어-색상?style=flat-square&amp;logo=simpleicons에서 로고 이름&amp;logoColor=white"/&gt;&lt;/a&gt;&amp;nbsp 
</code></pre></div></div>
<p>위와 같은 형태로 만들 수 있습니다.<br /><br />
<img src="../../assets/images/simpleIcons.png" alt="simpleIcons" /><br /><br />
simpleicons 사이트에서 원하는 언어를 검색해서 그 언어의 이름과 색상을 넣어준 다음 simpleicons 사이트에서 표시되어 있는 언어의 이름을 넣어주시면 됩니다. <br /><br /></p>

<p>단, c++을 쓸 때에만 좀 주의하면 되는데 simpleicons 사이트에는 단순히 C++이라 나와있지만 이걸 그대로 쓰면 적용이 안 되고 C%2B%2B라고 적어주어야 적용이 된다고 합니다. %2B가 +에 대응된다고 합니다.<br /><br />
c#은 C Sharp 이라는 이름으로 등록되어 있었습니다.<br /><br /></p>

<p><img src="../../assets/images/editReadme02.png" alt="editReadme02" /><br /><br />
대략 이렇게 태그들을 쓴 다음에 <br /><br /></p>

<p><img src="../../assets/images/editReadme03.png" alt="editReadme03" /><br /><br />
커밋 버튼 눌러서 마무리!<br /><br /></p>

<h1 id="3-최종-완성">3. 최종 완성<br /></h1>
<p><img src="../../assets/images/completeReadme.png" alt="completeReadme" /><br /><br />
짠 👏 커밋 버튼을 눌러서 나오면 이렇게 완성된 리드미를 볼 수 있습니다.<br /><br /></p>

<p><img src="../../assets/images/githubProfileComplete.png" alt="githubProfileComplete" /><br /><br />
그리고 제 깃헙 프로필 메인 페이지를 확인해보면 이렇게 있어보이게 바꼈습니다! 😄 뿌듯~~!!<br /><br />
이렇게 보니까 할 줄 아는거 되게 많네요! ㅎㅎ 더 뿌듯하다…<br /><br /></p>

<p>앞으로 공부 더 열심히 해야겠습니다. 그럼 다음 글에서 만나요! 👋<br /></p>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Story" /><category term="story" /><summary type="html"><![CDATA[🎬 시작 드디어 깃헙 블로그를 만들고… 다른 깃헙들을 구경하다 보니까 깃헙 메인 화면 자체를 예쁘게 꾸며놓으신 분들이 많더라고요! 이렇게요! 되게 좋아 보이잖아요?ㅎㅎㅎ 그래서 저도 꾸며보기로 했습니다.]]></summary></entry><entry><title type="html">DB 구동 및 접속</title><link href="http://localhost:4000/database/DB-start-conn/" rel="alternate" type="text/html" title="DB 구동 및 접속" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/database/DB-start-conn</id><content type="html" xml:base="http://localhost:4000/database/DB-start-conn/"><![CDATA[<h1 id="-db-구동-및-접속">🎬 DB 구동 및 접속<br /></h1>

<h2 id="1-linux-부팅-및-터미널-실행">1. Linux 부팅 및 터미널 실행</h2>
<ul>
  <li>Windows에서 가상 PC를 실행한 뒤 Linux 부팅 후 로그인한다.</li>
  <li>Linux 부팅이 완료되면 <strong>마우스 우클릭 - 터미널 열기</strong></li>
</ul>

<h2 id="2-listener-시작">2. Listener 시작</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ lsnrctl start
</code></pre></div></div>
<ul>
  <li>Listener를 시작한다.</li>
  <li>Listener는 네트워크를 이용하여 클라이언트에서 오라클 서버로 연결하기 위한 오라클 네트워크 관리자이다.</li>
  <li>리스너를 시작하지 않아도 DB 구동엔 문제가 없지만 네트워크를 통한 연결은 모두 리스너가 담당하기 때문에 리스너를 시작하지 않으면 DB에 접속하고자 하는 클라이언트들이 접속할 수 없다.</li>
  <li>따라서 터미널이 실행되면 가장 먼저 리스너를 시작한 후 다음 프로세스를 진행한다.<br /><br /></li>
</ul>

<h2 id="3-sqlplus-실행">3. SqlPlus 실행</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sqlplus /nolog
</code></pre></div></div>

<h2 id="4-database-접속">4. Database 접속</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ conn 아이디/비밀번호 as sysdba(권한)
</code></pre></div></div>
<h3 id="-db-user">🔸 DB User</h3>
<ul>
  <li>sysdba : dba + DB 생성 + DB 시작/종료 권한</li>
  <li>system : dba 권한</li>
  <li>hr : Object(테이블, 뷰, 시퀀스 등) 생성 및 운영 권한<br /><br /></li>
</ul>

<h2 id="5-database-시작">5. Database 시작</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; startup
</code></pre></div></div>

<h2 id="6-hr-사용자로-db-login">6. HR 사용자로 DB Login</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; conn 아이디/비밀번호
</code></pre></div></div>

<h2 id="7-사용자-확인">7. 사용자 확인</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; show user
</code></pre></div></div>
<ul>
  <li>HR 사용자로 최종 로그인 되었는지 확인한다.</li>
</ul>

<h3 id="-user-비밀번호-변경-방법">🔸 User 비밀번호 변경 방법</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; alter user 아이디
     identified by 새 비밀번호;
</code></pre></div></div>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[🎬 DB 구동 및 접속]]></summary></entry><entry><title type="html">DB 기초</title><link href="http://localhost:4000/database/DB-start/" rel="alternate" type="text/html" title="DB 기초" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/database/DB-start</id><content type="html" xml:base="http://localhost:4000/database/DB-start/"><![CDATA[<h1 id="-db란">🎬 DB란?<br /></h1>

<h2 id="-db를-쓰는-이유">🔸 DB를 쓰는 이유</h2>
<ul>
  <li>데이터를 오프라인으로 캐비넷에 저장하자니 물리적 저장 공간은 한정되어 있다.</li>
  <li>그렇다면 엑셀 파일을 만들어 암호를 걸어 쓰는 방법이 있는데 만약 암호가 유출된다면 그 엑셀 파일 안에 저장된 정보도 모두 유출된다. 따라서 이것도 안전한 방법은 아니다.</li>
  <li>그래서 서버에 데이터베이스를 구축하고 거기에 고객 정보를 저정하고 관리하는 것이다.
    <ul>
      <li>데이터베이스엔 애초에 허가받은 사용자만 접근할 수 있고 허가받은 권한 만큼만 데이터에 접근할 수 있다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="-dbms">🔸 DBMS</h2>
<ul>
  <li>데이터베이스 관리 시스템</li>
  <li>DB에서 필요한 데이터를 검색하거나 삽입, 수정, 삭제하기 위한 프로그램</li>
  <li>ORACLE, MySQL등이 있으며 이것들이 DB 자체를 의미하는 것은 아니다.
    <ul>
      <li>DB를 다루기 위한 수단으로서 MySQL을 사용하면 MySQL을 사용한 DB 프로그램인 것이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="-rdbms">🔸 RDBMS</h2>
<ul>
  <li>관계형 DBMS</li>
  <li>시중에 나와있는 대부분의 DBMS라고 보면 된다.<br /><br /></li>
</ul>

<h2 id="-sql">🔸 SQL</h2>
<ul>
  <li>데이터 액세스를 위해 ORACLE server와 통신하는 언어로 DB와 소통하기 위한 언어</li>
  <li>모든 DBMS에서 사용하는 공용언어<br /><br /></li>
</ul>

<h2 id="-table">🔸 TABLE</h2>
<ul>
  <li>DB에서 사용하는 대표 객체(오브젝트)</li>
  <li>테이블을 사용해서 데이터를 분류한다.<br /><br />
<img src="../../assets/images/table.png" alt="table" /><br /><br /></li>
  <li>세로는 <strong>열(column)</strong>, 가로는 <strong>행(row)</strong>!!</li>
  <li>column과 row가 만나는 곳은 <strong>Field(Record)값</strong>이라고 부른다.<br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[🎬 DB란?]]></summary></entry><entry><title type="html">SELECT 구문을 사용한 데이터 검색</title><link href="http://localhost:4000/database/SQL-SELECT/" rel="alternate" type="text/html" title="SELECT 구문을 사용한 데이터 검색" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/database/SQL-SELECT</id><content type="html" xml:base="http://localhost:4000/database/SQL-SELECT/"><![CDATA[<h1 id="-sql-문법은-기본적으로-대소문자를-구분하지-않는다-">🎬 SQL 문법은 기본적으로 대소문자를 구분하지 않는다. <br /></h1>

<h2 id="️-문법">☑️ 문법</h2>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="o">|</span> <span class="p">{[</span><span class="k">DISTINCT</span><span class="p">]</span> <span class="k">column</span> <span class="o">|</span> <span class="n">expression</span> <span class="p">[</span><span class="k">alias</span><span class="p">],</span> <span class="p">...}</span>
<span class="k">FROM</span>   <span class="k">table</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="1-테이블-구조-조회">1. 테이블 구조 조회</h2>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DESCRIBE</span> <span class="n">employees</span>
</code></pre></div></div>
<p><img src="../../assets/images/describe.png" alt="describe" /><br /><br /></p>

<h2 id="2-테이블로부터-데이터-검색">2. 테이블로부터 데이터 검색</h2>
<h3 id="1-select-구문">1) SELECT 구문</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span>   <span class="n">department</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>‘*‘은 모든 것을 보여달라고 할 때 사용한다.</li>
  <li>SQL 구문 또한 세미콜론(;)을 사용해서 문장이 끝났다는 것을 표시하기 때문에 명령어를 실행하려면 마지막에 세미콜론을 꼭 찍어줘야 한다.<br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">location_id</span>
<span class="n">FORM</span>   <span class="n">departments</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>SELECT 뒤에 컬럼명을 지정하면 해당 컬럼에 해당하는 내용들만 보여달라는 뜻이 된다.<br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="n">salary</span><span class="o">+</span><span class="mi">100</span>
<span class="k">FROM</span>   <span class="n">employees</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li><strong>12*salary+100</strong> 처럼 내가 원하는 계산을 한 결과를 출력하게 할 수도 있다.<br /><br /></li>
</ul>

<h4 id="-입력한-명령어-수정-마지막으로-쓴-명령어와-비슷한-명령어를-또-써야-할-때-유용하다">🔸 입력한 명령어 수정 (마지막으로 쓴 명령어와 비슷한 명령어를 또 써야 할 때 유용하다)</h4>
<ul>
  <li>SQL에서는 가장 마지막에 입력한 구문 하나만 버퍼에 저장되어서 이것을 수정할 수 있다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ed</span>
</code></pre></div>    </div>
  </li>
  <li>위 명령어를 입력하고 엔터를 치면 버퍼를 수정할 수 있는 모드에 들어갈 수 있다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span>
</code></pre></div>    </div>
  </li>
  <li>를 누르면 하단에 –INTSERT–가 표시되며 버퍼에 저장된 명령어를 수정할 수 있다.</li>
  <li>이 때 구문의 마지막에 세미콜론을 입력하면 <strong>안 된다!!!</strong></li>
  <li>모든 수정이 끝나면 ESC를 눌러 수정을 종료한 뒤
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">:</span><span class="n">wq</span>
</code></pre></div>    </div>
  </li>
  <li>위 명령어를 입력하면 버퍼 수정 모드를 빠져나온다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span> <span class="o">+</span> <span class="n">ENTER</span>
</code></pre></div>    </div>
  </li>
  <li>’/’를 입력하고 엔터를 누르면 버퍼에 저장된 명령어를 실행하는 동작이다. 모든 수정을 마치고 나와서 ‘/’ + 엔터를 실행해주면 아까 수정했던 명령어가 실행되는 것을 볼 수 있다.<br /><br /></li>
</ul>

<h3 id="2-null값이란">2) null값이란?</h3>
<ul>
  <li>사용할 수 없는 값, 알려지지 않은 값, 할당받지 못한 값, 모르는 값, 아직 정의되지 않은 값 등…</li>
  <li>null은 0(zero)이나 공백과는 다른 특수한 값으로 모든 데이터타입에 사용 가능하다.<br /><br /></li>
</ul>

<h3 id="3-column-alias">3) Column Alias</h3>
<ul>
  <li>컬럼명에 별명을 붙이는 것</li>
  <li>원래 정해져 있는 컬럼명을 사용자가 보기에 좀 더 알아보기 쉽게 표시하고 싶을 때 사용한다.
    <h4 id="1️⃣--컬럼명-as-alias">1️⃣  컬럼명 AS alias</h4>
    <h4 id="2️⃣--컬럼명-alias">2️⃣  컬럼명 alias</h4>
    <h4 id="3️⃣--컬럼명-as-alias--대소문자-구분-공백-포함-특수문자-포함을-원하는-경우">3️⃣  컬럼명 [AS] “Alias” =&gt; 대소문자 구분, 공백 포함, 특수문자 포함을 원하는 경우</h4>
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span> <span class="k">AS</span> <span class="n">name</span><span class="p">,</span> <span class="n">commission_pct</span> <span class="n">comm</span>
<span class="n">FORM</span>   <span class="n">employees</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><img src="../../assets/images/alias01.png" alt="alias01" /><br /><br /></p>
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span> <span class="nv">"Name"</span><span class="p">,</span> <span class="n">salary</span><span class="o">*</span><span class="mi">12</span> <span class="nv">"Annual Salary"</span>
<span class="k">FROM</span>   <span class="n">employees</span><span class="p">;</span>
</code></pre></div>    </div>
    <p><img src="../../assets/images/alias02.png" alt="alias02" /><br /><br /></p>
  </li>
</ul>

<h3 id="4-연결-연산자-">4) 연결 연산자 (||)</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span> <span class="o">||</span> <span class="n">job_id</span> <span class="k">AS</span> <span class="nv">"Employees"</span>
<span class="k">FROM</span>   <span class="n">employees</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td> </td>
          <td>로 연결된 컬럼들을 묶어서 한 컬럼에 표시해 준다. 이것 또한 Alias 지정이 가능하다.<br /><br /></td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="5-리터럴-문자">5) 리터럴 문자</h3>
<ul>
  <li>리터럴 문자란 쿼리 구문에 포함된 일반 문자, 숫자, 날짜 값</li>
  <li>문자나 날짜 리터럴은 작은 따옴표로 묶어서 작성해야 함
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span> <span class="o">||</span> <span class="s1">' is a '</span> <span class="o">||</span> <span class="n">job_id</span>
     <span class="k">AS</span> <span class="nv">"Employee Details"</span>
<span class="k">FROM</span>   <span class="n">employees</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>Alias를 지정하지 않았다면 ‘last_name is a job_id’ 라는 컬럼명으로 표시된다.<br /><br /></li>
</ul>

<h3 id="6-distinct-키워드">6) DISTINCT 키워드</h3>
<ul>
  <li>중복된 값을 자동으로 제거해 주는 키워드
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">department_id</span>
<span class="k">FROM</span>   <span class="n">employees</span><span class="p">;</span>
</code></pre></div>    </div>
    <hr />
  </li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[🎬 SQL 문법은 기본적으로 대소문자를 구분하지 않는다.]]></summary></entry><entry><title type="html">WHERE(조건문)절과 ORDER BY(정렬)절</title><link href="http://localhost:4000/database/SQL-WHERE-ORDER-BY/" rel="alternate" type="text/html" title="WHERE(조건문)절과 ORDER BY(정렬)절" /><published>2022-01-31T00:00:00+09:00</published><updated>2022-01-31T00:00:00+09:00</updated><id>http://localhost:4000/database/SQL-WHERE-ORDER-BY</id><content type="html" xml:base="http://localhost:4000/database/SQL-WHERE-ORDER-BY/"><![CDATA[<h1 id="️-문법">☑️ 문법</h1>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="o">|</span> <span class="p">{[</span><span class="k">DISTINCT</span><span class="p">]</span> <span class="k">column</span> <span class="o">|</span> <span class="n">expression</span> <span class="p">[</span><span class="k">alias</span><span class="p">],</span> <span class="p">...}</span>
<span class="k">FROM</span>   <span class="k">table</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">condition</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
<span class="p">[</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="p">{</span><span class="k">column</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="k">alias</span><span class="p">}</span> <span class="p">[</span><span class="k">ASC</span> <span class="o">|</span> <span class="k">DESC</span><span class="p">]];</span>
</code></pre></div></div>

<h1 id="1-1-where절">1) 1. WHERE절</h1>
<ul>
  <li>WHERE절을 사용해서 특정 칼럼에서 어떤 값을 가진 필드값만 찾아달라고 할 수 있다.
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">department_id</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">department_id</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>employee_id, last_name, job_id, department_id 컬럼을 출력하는데 department_id가 90인 필드만 출력해라<br /><br />
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">department_id</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Whalen'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>last_name, job_id, department_id 컬럼을 출력하는데 last_name이 ‘Whalen’인 필드만 출력해라<br /><br />
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">hire_date</span> <span class="o">=</span> <span class="s1">'17-FEB-96'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>last_name 컬럼을 출력하는데 hire_date가 96년 2월 17일인 필드를 출력해라</li>
  <li>날짜를 쓸 때엔 ‘DD-MM-YY’형식으로 쓴다.<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">salary</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">salary</span> <span class="o">&lt;=</span> <span class="mi">3000</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>last_name, salary 컬럼을 출력하는데 salary가 3000 이하인 필드를 출력해라<br /><br />
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">salary</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">salary</span> <span class="k">BETWEEN</span> <span class="mi">2500</span> <span class="k">AND</span> <span class="mi">3500</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>last_name, salary 컬럼을 출력하는데 salary가 2500 ~ 3500 사이인 필드를 출력해라<br /><br />
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">salary</span><span class="p">,</span> <span class="n">manager_id</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">manager_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">201</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>employee_id, last_name, salary, manager_id 컬럼을 출력하는데 manager_id가 100이거나 101이거나 201인 필드를 출력해라(or과 같은 역할)<br /><br />
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">last_name</span> <span class="k">LIKE</span> <span class="s1">'_O%'</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>last_name 컬럼을 출력하는데 last_name의 두번째 문자가 o인 필드를 출력해라
    <h2 id="-like-비교연산자">🔸 LIKE 비교연산자</h2>
  </li>
  <li>% : 0 char 또는 여러개 char</li>
  <li>_ : 반드시 1 char
    <ul>
      <li>a로 시작되는 문자열 : ‘a%’</li>
      <li>a가 포함된 문자열 : ‘%a%’</li>
      <li>a로 끝나는 문자열 : ‘%a’</li>
      <li>두번째 문자가 a인 문자열 : ‘_a%’</li>
      <li>끝에서 세번째 문자가 a인 문자열 : ‘%a__‘<br /><br /></li>
    </ul>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">manager_id</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">manager_id</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>last_name, manager_id 컬럼을 출력하는데 manager_id가 null인 필드를 출력해라<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">salary</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">salary</span> <span class="o">&gt;=</span> <span class="mi">10000</span>
<span class="k">AND</span>    <span class="n">job_id</span> <span class="k">LIKE</span> <span class="s1">'%MAN%'</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>employee_id, last_name, job_id, salary 컬럼을 출력하는데 salary가 10000 이상이고 job_id에 MAN이 포함되는 필드를 출력해라<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">salary</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">WHERE</span>  <span class="n">salary</span> <span class="o">&gt;=</span> <span class="mi">10000</span>
<span class="k">OR</span>     <span class="n">job_id</span> <span class="k">LIKE</span> <span class="s1">'%MAN%'</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>employee_id, last_name, job_id, salary 컬럼을 출력하는데 salary가 10000 이상이거나 job_id에 MAN이 포함되는 필드를 출력해라<br /><br /></li>
</ul>

<h2 id="-비교연산자에-not논리연산자이-조합으로-사용된-경우">🔸 비교연산자에 NOT(논리연산자)이 조합으로 사용된 경우</h2>
<p><img src="../../assets/images/notOperator.png" alt="notOperator" /><br /><br /></p>

<h1 id="2-order-by절">2. ORDER BY절</h1>
<ul>
  <li>ORDER BY절을 사용해서 특정 조건에 따라 필드값을 정렬해서 볼 수 있다.</li>
  <li>ASC : Ascending order, default 오름차순</li>
  <li>DESC : Descending order 내림차순
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">hire_date</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">hire_date</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>last_name, job_id, department_id, hire_date 컬럼을 출력하는데 hire_date의 내림차순으로 정렬해라<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">employee_id</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">salary</span><span class="o">*</span><span class="mi">12</span> <span class="n">annsal</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">annsal</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>employee_id, last_name, salary<em>12 annsal 컬럼을 출력하는데 salary</em>12은 annsal이라는 Alias로 출력하고 annsal의 오름차순으로 정렬해라<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">job_id</span><span class="p">,</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">hire_date</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>last_name, job_id, department_id, hire_date 컬럼을 출력하는데 3번째 컬럼(department_id)의 오름차순으로 정렬해라</li>
  <li>하지만 숫자로 표시하면 알아보기 힘들어서 추천하는 방법은 아니다.<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">salary</span>
<span class="k">FROM</span>   <span class="n">employees</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">salary</span> <span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>last_name, department_id, salary 컬럼을 출력하는데 department_id, salary 컬럼의 내림차순으로 정렬해라<br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[☑️ 문법 SELECT * | {[DISTINCT] column | expression [alias], ...} FROM table [WHERE condition(s)] [ORDER BY {column, expr, alias} [ASC | DESC]];]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 구성</title><link href="http://localhost:4000/computer%20science/CS07/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 구성" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS07</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS07/"><![CDATA[<h1 id="컴퓨터-하드웨어-구성">컴퓨터 하드웨어 구성<br /></h1>
<ul>
  <li>컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다.<br /></li>
  <li>하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다.<br /></li>
  <li>중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다.<br /></li>
  <li>소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.<br /><br /></li>
</ul>

<h2 id="컴퓨터-하드웨어의-구성">컴퓨터 하드웨어의 구성<br /></h2>
<h3 id="1-입력-장치">1) 입력 장치<br /></h3>
<ul>
  <li>자료를 컴퓨터에 읽어 들이는 기능을 가지고 있다.<br /></li>
  <li>디스크 장치, 테이프 장치, 단말기, 카드 판독기 등이 있다.<br /><br /></li>
</ul>

<h3 id="2-기억-장치">2) 기억 장치<br /></h3>
<ul>
  <li>주기억 장치와 보조 기억 장치로 나누며, 입력된 자료가 처리될 때까지 일시적으로 기억하거나 연산 결과와 출력할 내용 등을 기억한다.<br /><br /></li>
</ul>

<h3 id="3-연산-장치">3) 연산 장치<br /></h3>
<ul>
  <li>산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)라고도 한다.<br /></li>
  <li>제어 장치의 지시에 따라 전송된 자료를 처리하기 위하여 사칙 연산, 논리 연산, 자리 이동 등의 연산을 수행하는 장치이다.<br /><br /></li>
</ul>

<h3 id="4-제어-장치">4) 제어 장치<br /></h3>
<ul>
  <li>자료를 처리하는 순서를 저장한 프로그램의 명령어를 해독하여 입력 장치, 기억 장치, 연산 장치, 출력 장치 등을 제어한다.<br /><br /></li>
</ul>

<h3 id="5-출력-장치">5) 출력 장치<br /></h3>
<ul>
  <li>CPU로부터 출력 결과를 받아서 사람이 알 수 있는 형태로 변환하거나 다른 기억 장치(자기 테이프, 자기 디스크 장치 등)로 전송한다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>중앙 처리 장치(CPU)</th>
      <th>주변 장치</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제어 장치</td>
      <td>보조 기억 장치</td>
    </tr>
    <tr>
      <td>주기억 장치</td>
      <td>입력 장치</td>
    </tr>
    <tr>
      <td>연산 장치</td>
      <td>출력 장치</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터 하드웨어 구성 컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다. 하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다. 중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다. 소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 기억장치</title><link href="http://localhost:4000/computer%20science/CS08/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 기억장치" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS08</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS08/"><![CDATA[<h1 id="컴퓨터-하드웨어-기억장치">컴퓨터 하드웨어 기억장치<br /></h1>

<h2 id="기억-장치">기억 장치<br /></h2>
<ul>
  <li>입력 장치에서 읽어 들인 숫자, 문자, 각종 기호 등의 자료들을 저장하는 장치로 주기억 장치와 보조 기억 장치로 나누어진다.<br /><br /></li>
</ul>

<h3 id="1-주기억-장치main-memory-unit">1) 주기억 장치(main memory unit)<br /></h3>
<ul>
  <li>컴퓨터 중앙 처리 장치(CPU)에 위치하며 실행하고자 하는 프로그램이나 자료를 기억시키는 장치<br /><br /></li>
</ul>

<h3 id="2-보조-기억-장치auxiliary-storage-unit">2) 보조 기억 장치(auxiliary storage unit)<br /></h3>
<ul>
  <li>주변 장치로서(CPU에 속하지 않음!) 주기억 장치에 필요한 프로그램이나 자료를 보낼 수 있고, 처리된 자료 또는 개발된 프로그램 등을 저장할 수 있다.<br /><br /></li>
</ul>

<h3 id="3-기억-장치에서-사용되는-단위">3) 기억 장치에서 사용되는 단위<br /></h3>
<ul>
  <li>최소 단위는 비트(bit : binary digit)이다. <br /></li>
  <li>8개의 비트가 모이면 1바이트가 된다.<br /></li>
  <li>1바이트는 영문자 1개를 기억하며 한글 1문자를 저장하는 데엔 2바이트가 필요하다.<br /></li>
  <li>
    <p>1킬로 바이트(KB)는 1,024바이트로 구성되며, 1메가 바이트(MB)는 1,024킬로 바이트이고, 1기가 바이트(GB)는 1,024메가 바이트가 된다.<br /><br /></p>
  </li>
  <li>메모리 셀(memory cell)<br />
    <ul>
      <li><u>**한 소자나 전기회로가 하나의 비트를 저장**</u>하는 데 사용된다.<br /></li>
      <li>(0 또는 1) 플립플롭, 충전된 커패시터, 자기테이프 또는 디스크 등을 예로 들 수 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 워드(memory word)<br />
    <ul>
      <li>메모리에 있는 비트는 몇 가지 형태의 명령이나 데이터로 표현된다.<br /></li>
      <li>예를 들면, 8개의 플립플롭으로 구성된 레지스터는 8비트 워드로 저장되는 메모리로 생각할 수 있다.<br /></li>
      <li>워드의 용량은 보통 4~8바이트 사이이다.<br /><br /></li>
    </ul>
  </li>
  <li>바이트(byte)<br />
    <ul>
      <li>8비트 워드에 대해 사용되는 용어이다.<br /></li>
      <li>항상 8비트로 구성된다.<br /></li>
      <li>마이크로컴퓨터에서 가장 일반적인 워드 크기이다.<br /><br /></li>
    </ul>
  </li>
  <li>용량(capacity)<br />
    <ul>
      <li>비트들을 저장할 수 있는 공간<br /></li>
      <li>메모리에 있어 워드수는 대개 1024의 곱이다.<br /></li>
      <li>우리가 흔히 보는 하드 용량 몇 GB는 2^10(1,024), 2^20(1,048), … 와 같이 딱 나눠 떨어지는 10의 배수가 아닌 2의 거듭제곱들이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="주기억-장치">주기억 장치<br /></h2>
<h3 id="1-주기억-장치의-구성">1) 주기억 장치의 구성<br /></h3>
<ul>
  <li>주기억 장치는 수많은 바이트로 구성된다.</li>
  <li>입력 장치를 통하여 읽어 들은 자료는 1과 0의 상태가 모아져 바이트 단위로 구성되며 순서에 따라 특정한 장소에 저장된다.<br /></li>
  <li>
    <p>자료를 저장하거나 저장된 자료를 읽기 위하여 각 기억 장소는 고유한 주소를 갖는다.<br />
<img src="../../assets/images/main_memory_unit.jpeg" alt="main_memory_unit" /><br /></p>
  </li>
  <li>기억부<br />
    <ul>
      <li>주어진 프로그램이나 데이터를 기억해 두는 2진 기억 소자(memory cell)들이 2차원 행렬(matrix)로 구성되어 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 주소 레지스터(MAR : Memory Address Register)<br />
    <ul>
      <li>프로그램이나 데이터를 입출력하기 위한 번지를 가지고 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 버퍼 레지스터(MBR : Memory Buffer Register)<br />
    <ul>
      <li>입출력하고자 하는 프로그램이나 데이터를 임시 보관하는 레지스터<br /><br /></li>
    </ul>
  </li>
  <li>번지 선택 회로<br />
    <ul>
      <li>MAR(메모리 주소 레지스터)에 의하여 기억 장소를 선택하는 회로<br /><br /></li>
    </ul>
  </li>
  <li>제어 회로<br />
    <ul>
      <li>기억 장치에 저장하라는 Write 신호와 기억 장치로부터 읽어내리는 Read 신호를 발생시키는 회로<br /></li>
      <li>칩이나 모듈 개념으로 여러개로 나누어 구성될 경우 칩 선택 신호나 메모리 모듈 선택 신호가 필요하다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h3 id="2-기억-장치에-저장하는-외부-동작의-순서">2) 기억 장치에 저장하는 외부 동작의 순서<br /></h3>
<ol>
  <li>기억 장치의 위치(번지)를 MAR(메모리 주소 레지스터)에 넣는다.<br /></li>
  <li>프로그램이나 데이터의 비트를 MBR(메모리 버퍼 레지스터)에 넣는다.<br /></li>
  <li>입력 신호로 MBR(메모리 버퍼 레지스터)의 내용이 메모리에 저장된다.<br /><br /></li>
</ol>

<h3 id="3-기억-장치로부터-읽어낼-때-외부-동작-순서">3) 기억 장치로부터 읽어낼 때 외부 동작 순서<br /></h3>
<ol>
  <li>읽어내려는 프로그램이나 데이터 번지를 MAR에 넣은 후 출력신호를 준다.<br /></li>
  <li>메모리의 해당 내용이 MBR로 옮겨져 외부로 출력하게 된다.<br /><br /></li>
</ol>

<h3 id="4-어드레스address">4) 어드레스(Address)<br /></h3>
<ul>
  <li>메모리에서 한 워드의 위치를 식별하는 주소(숫자)<br /></li>
  <li>메모리소자 또는 시스템에 저장된 각 워드는 고유의 주소를 갖는다.<br /></li>
  <li>주소는 보통 2진수, 8진수, 16진수로 표현되고, 편의를 위해 10진수로 표현되기도 한다.<br /></li>
  <li>메모리에 있는 특정 워드의 위치를 언급할 때마다 그것을 식별하기 위해서 그 위치의 주소코드를 사용한다.<br /></li>
</ul>

<h1 id="모든-프로그램은-주기억-장치에서만-실행된다">!모든 프로그램은 주기억 장치에서만 실행된다!</h1>
<ul>
  <li>그래서 주기억 장치(RAM)의 용량이 클수록 더 많은 정보를 기억하고 실행할 수 있기 때문에 비싸다.<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터 하드웨어 기억장치]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 주기억 장치의 종류</title><link href="http://localhost:4000/computer%20science/CS09/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 주기억 장치의 종류" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS09</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS09/"><![CDATA[<h1 id="주기억-장치의-종류">주기억 장치의 종류<br /></h1>
<ul>
  <li>컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다.<br /><br /></li>
</ul>

<h2 id="1-과거의-주기억-장치">1. 과거의 주기억 장치</h2>
<ul>
  <li>초기</li>
  <li>
    <p>처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다.<br /><br /></p>
  </li>
  <li>1960년대 초반 ~ 1970년대 중반</li>
  <li>
    <p>자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.<br /><br /></p>
  </li>
  <li>기억 원리
    <ul>
      <li>코어의 링을 통과하는 도선에 전류를 흘려 ‘플레밍의 오른손 법칙’에 따라 <strong>자화</strong>의 방향을 바꾸어 준다.</li>
      <li>자기 코어는 한 번 1 또는 0의 상태가 되면 어떠한 변화를 주지 않는 한 계속 자화 상태를 유지하여 정보를 기억하게 되고, 여러 개의 코어를 코어판(core plane)의 형태로 묶어서 사용하게 된다.<br /><br /></li>
    </ul>
  </li>
  <li>자화(magnetization)
    <ul>
      <li>물질을 자기장 속에 놓았을 때 그 물질 전체가 갖는 거시적인 자기(磁氣)모멘트</li>
      <li>물질의 자기적 성질은 주로 전자의 자기모멘트에 연유하는데, 전자가 가진 극히 작은 미시적인 자기모멘트가 많이 모여, 그 총합으로 거시적으로 물질이 나타내는 자기모멘트를 <strong>자화</strong>라고 한다.<br /><br /></li>
    </ul>
  </li>
  <li>플레밍의 오른손 법칙<br /><br />
<img src="../../assets/images/rightHand.png" alt="rightHand" /><br />
    <ul>
      <li>N극에서 S극 방향으로 자기장이 형성되었을 때 그림처럼 자기장의 방향과 수직으로 도체(금속 막대 등)가 움직이고 있다면 전류는 가운데 손가락 방향으로 흐른다.</li>
      <li>엄지손가락 방향 : 도체를 움직이는 힘(속도)의 방향</li>
      <li>두번째 손가락 방향 : 자기장의 방향</li>
      <li>가운데 손가락 방향 : 전류가 흐르는 방향</li>
    </ul>
  </li>
</ul>

<h2 id="2-현재의-주기억-장치">2. 현재의 주기억 장치</h2>
<ul>
  <li>1960년대 후반부터 반도체 집적 회로(IC : Integrated Circuit) 기술의 개발과 함께 기억 소자로의 적용이 추진된 후, 1968년에는 주기억 장치의 버퍼 메모리로 사용되기 시작했다.</li>
  <li>집적 회로는 집적도, 소비 전력, 소형성, 경제성 등으로 코어 메모리를 대체하여 널리 이용되고 있다.<br /><br /></li>
</ul>

<h2 id="3-미래의-주기억-장치">3. 미래의 주기억 장치</h2>
<ul>
  <li>현재보다 크기가 작고, 대용량, 고속의 기억 소자가 사용될 것이라 예상된다.</li>
  <li>그 중 하나가 조셉슨 소자(Josephson device)인데, 현재의 기억 소자보다 10배 이상 빠르게 나타나고 있으며 대량 생산과 가격 등의 문제점을 해결하고 있다.<br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[주기억 장치의 종류 컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다. 1. 과거의 주기억 장치 초기 처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다. 1960년대 초반 ~ 1970년대 중반 자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 - 반도체 메모리</title><link href="http://localhost:4000/computer%20science/CS10/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 - 반도체 메모리" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS10</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS10/"><![CDATA[<h1 id="반도체-메모리">반도체 메모리</h1>
<ul>
  <li>현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.<br /><br /></li>
</ul>

<h2 id="메모리의-제조기술적인-분류에-따른-특성">메모리의 제조기술적인 분류에 따른 특성<br /></h2>
<p>1) 밀도(chip당 bit 용량)<br />
2) 속도<br />
3) 소비전력(bit당 mW)<br />
4) bit당 cost(반도체 제조가격 측면)<br />
5) Noise 면역성<br /><br /></p>

<h2 id="읽기동작read-operation과-쓰기동작">읽기동작(read operation)과 쓰기동작</h2>
<ul>
  <li>특별한 메모리위치(주소)에 저장되어 있는 2진 워드가 감지되어 다른 소자에 전달되는 동작</li>
  <li>만약 100번 주소에 있는 메모리에서 워드 4를 사용하려 한다면 주소 100번에서 읽기동작을 실행해야 한다.</li>
  <li>한 워드를 메모리부터 가져오기 때문에 패치(fetch)동작이라고도 한다.<br /><br /></li>
</ul>

<h2 id="접근-시간access-time">접근 시간(access time)</h2>
<ul>
  <li>기억 장치가 출력 신호를 받은 시간부터 데이터가 출력된 때까지의 시간</li>
  <li>자기 코어 기억 장치에서는 접근 시간과 복원 시간을 합해서 사이클(cycle) 시간이라 하며, IC 메모리에서는 사이클 시간이 접근 시간과 같다.</li>
  <li>메모리소자 동작속도의 측정치로 읽기동작하는 데 필요한 시간이라고도 할 수 있으며, 이는 주소입력 순간으로부터 메모리 내용의 출력순간까지의 시간이다.<br /><br /></li>
</ul>

<h2 id="랜덤-액세스메모리ram">랜덤 액세스메모리(RAM)</h2>
<ul>
  <li>한 메모리 워드의 실제 물리적 위치가 그 위치로부터 읽거나 쓰는 데 걸리는 시간이 얼마나 걸리는가에는 영향을 받지 않는 메모리이다. 즉 액세스시간이 메모리의 모든 주소에 대해서 같은 메모리이다.</li>
  <li>대부분의 반도체메모리와 코어메모리는 RAM이다.
    <ul>
      <li>사용 예 : CDP(컴팩트 디스크 플레이어)는 적당한 코드를 입력함으로써 어떤 한 노래를 선택하든간에 같은 시간을 갖는다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="순차-액세스-메모리sam">순차 액세스 메모리(SAM)</h1>
<ul>
  <li>액세스시간이 일정하지 않고 주소위치에 따라 변하는 메모리의 한 형태이다.</li>
  <li>원하는 주소에 도달할 때까지 모든 주소위치를 통하여 저장된 워드를 순차적으로 찾기 때문에 랜덤 액세스메모리보다 더 긴 액세스시간을 갖는다.
    <ul>
      <li>사용 예 : 자기테이프, 디스크, 자기버블메모리<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="읽기전용메모리rom">읽기전용메모리(ROM)</h2>
<ul>
  <li>읽기동작이 쓰기동작보다 매우 많은 응용분야를 위해 설계된 반도체메모리의 종류</li>
  <li>기술적으로 (주로 제작자에 의해)단 한 번만 프로그래밍되어 쓸 수 있으며, 이후로는 내용을 수정할 수 없으며 읽기만 가능하다.</li>
  <li>모든 ROM은 비휘발성이며 전원이 제거되어도 데이터는 그대로 저장된다.</li>
  <li>한 번 이상 쓰기동작을 할 수 있는 메모리 RMM(Read Mostly Memory)도 있는데 읽기동작보다 쓰기동작이 훨씬 복잡하기 때문에 자주 사용되지는 않는다.<br /><br />
<img src="../../assets/images/rom.png" alt="rom" /><br />
    <blockquote>
      <p>ROM의 구성도<br /></p>
    </blockquote>
  </li>
  <li>ROM은 읽어내기만 하기 때문에 기억부와 번지 해독기, 출력 버퍼만으로 구성된다.<br /><br /></li>
</ul>

<h3 id="프로그램이나-자료-저장-방법에-따른-rom-분류">프로그램이나 자료 저장 방법에 따른 ROM 분류</h3>
<ul>
  <li>마스크(Mask) ROM : 사용자의 요구에 따라 제작사가 자료를 넣기 때문에 내용을 바꿀 수는 없지만 대량 생산에 적합</li>
  <li>PROM(Programmable ROM) : 제작시에 아무런 내용을 넣지 않은 상태로 만들어져서 사용자가 원하는 내용을 저장할 수 있다. 하지만 한 번 기억되면 그 내용을 변경할 수 없다.</li>
  <li>EPROM(Erasable ROM) : ROM의 내용을 자외선 삭제 장치로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능</li>
  <li>EEPROM(Electrically Erasable PROM) : ROM의 내용을 전기신호로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능<br /><br /></li>
</ul>

<h2 id="정적-램static-ram-device-sram">정적 램(static RAM device, SRAM)</h2>
<ul>
  <li>전원이 인가되는 동안은 저장된 데이터가 영원히 저장되고, 주기적으로 데이터를 다시 쓸 필요가 없는 반도체 메모리장치</li>
  <li>플립플롭 조합으로 구성되어 있다.<br /><br /></li>
</ul>

<h2 id="동적-램dynamic-ram-device-dram">동적 램(dynamic RAM device, DRAM)</h2>
<ul>
  <li>전원이 인가되어도 저장된 데이터가 영원히 유지되지 못하며, 데이터가 메모리에 주기적으로 다시 쓰여져야 저장된 데이터가 계속 저장되는 반도체메모리</li>
  <li>이러한 주기적 동작을 리플레시(refresh)동작이라 한다.<br /><br /></li>
</ul>

<h2 id="휘발성-메모리volatile-memory">휘발성 메모리(volatile memory)</h2>
<ul>
  <li>전원이 제거되면 메모리에 있는 모든 정보가 소실된다.</li>
  <li>반도체메모리가 휘발성 메모리에 해당한다.<br /><br /></li>
</ul>

<h2 id="캐시-메모리cache-memory">캐시 메모리(cache memory)</h2>
<ul>
  <li>SRAM과 구성이 동일하다.</li>
  <li>기억 용량은 작으나 속도가 매우 빠른 버퍼(buffer) 메모리로 주기억 장치와 CPU와의 속도 차이를 줄여서 처리의 효율을 높이기 위해서 사용된다.</li>
  <li>캐시 기억 장치의 호출 시간은 주기억 장치의 호출 시간보다 5~10배 정도 빠르다.</li>
  <li>전체 기억 장치 시스템의 총 소요 시간을 최소화하면서 가능한 하 높은 평균 액세스 속도를 얻기 위해서 사용한다.<br /><br /><br /></li>
</ul>

<h1 id="메모리의-연결">메모리의 연결</h1>
<ul>
  <li>컴퓨터 내부메모리는 어드레스(Address) 버스, 데이터(Data) 버스, 제어(Control) 버스라는 세 종류의 버스로 CPU에 연결되는 신호선이 구성된다.<br /><br /></li>
</ul>

<h2 id="버스">버스<br /></h2>
<p>1) 어드레스 버스 : CPU에서 메모리 IC까지 2진 어드레스 출력을 전달하는 단방향 버스<br />
2) 데이터 버스 : CPU와 메모리 IC 사이에 데이터를 옮기는 양방향 버스<br />
3) 제어 버스 : CPU에서 메모리 IC까지 제어신호들 전달<br /><br /></p>

<h2 id="cpu의-쓰기동작-순서">CPU의 쓰기동작 순서<br /></h2>
<p>1) CPU가 데이터가 저장될 메모리 위치에 2진 어드레스 공급. 어드레스 버스선에서 이 어드레스를 인가한다.<br />
2) CPU가 데이터 버스선에 저장될 데이터 인가<br />
3) CPU가 메모리 쓰기 동작을 위해 제어신호선 동작시킴<br />
4) 메모리 IC들은 저장될 위치를 선택하기 위해 2진 어드레스 해독<br />
5) 데이터 버스에 있는 데이터가 선택된 메모리 위치로 전송됨<br /><br /></p>

<h2 id="cpu의-읽기동작-순서">CPU의 읽기동작 순서<br /></h2>
<p>1) 어드레스 버스선에 이 어드레스 인가. CPU가 데이터의 메모리 위치의 2진 어드레스 공급<br />
2) CPU가 메모리 읽기동작을 위해 제어신호선 활성화 시킴<br />
3) 메모리 IC중에서 읽기동작이 실행되는 위치를 선택하기 위해, 2진 어드레스를 해독한다.<br />
4) 메모리 IC들은 선택된 메모리 위치로부터 데이터 버스에 데이터 인가. 데이터가 전송되는 곳으로부터 CPU로 데이터 인가<br /><br /></p>

<h1 id="메모리-맵memory-map">메모리 맵(Memory Map)</h1>
<ul>
  <li>원하는 용량 및 워드사이즈에 알맞게 응용하기 위해 메모리칩을 조합하거나 큰 용량을 나누어 쓰는 것<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[반도체 메모리 현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 - 보조 기억 장치</title><link href="http://localhost:4000/computer%20science/CS11/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 - 보조 기억 장치" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS11</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS11/"><![CDATA[<h1 id="보조-기억-장치">보조 기억 장치</h1>
<ul>
  <li>주기억 장치는 적은 자료를 기억하여 고속으로 처리한다.</li>
  <li><u>**그에 반해 많은 양의 자료를 기억시켜 관리하기 위한 장치**</u>를 보조 기억 장치 또는 2차 기억 장치(secondary memory)라 한다.</li>
  <li>보조 기억 장치의 자료를 액세스하는 방법에 따라 <u>**순차 액세스**</u>와 <u>**임의 액세스**</u>로 분류할 수 있다.<br /><br /></li>
</ul>

<h2 id="순차-액세스sequential-access">순차 액세스(sequential access)</h2>
<ul>
  <li>물리적으로 저장된 순서에 따라 자료를 검색해 나가기 때문에 일괄 처리(batch processiong)에 적합하다.</li>
  <li>그렇기 때문에 빠른 액세스가 요구되는 실시간 처리에는 잘 사용되지 않는다.
    <ul>
      <li>사용 예 : 자기 테이프<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="임의-액세스random-access">임의 액세스(random access)</h2>
<ul>
  <li>원하는 레코드에 직접 액세스할 수 있는 방식</li>
  <li>레코드를 순차적으로 읽지 않기 때문에 원하는 데이터를 빠르게 검색할 수 있다.</li>
  <li>주로 실시간 처리 시스템에서 사용된다.
    <ul>
      <li>사용 예 : 자기 디스크<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="보조-기억-장치의-종류">보조 기억 장치의 종류</h1>
<h2 id="자기-테이프magnetic-tape">자기 테이프(magnetic tape)</h2>
<ul>
  <li>플라스틱 테이프의 표면에 자성 도료를 입혀 제작된 것<br /><br /></li>
</ul>

<p>1) 특성<br /></p>
<ul>
  <li>녹음 테이프와 비슷하게 생겼는데 폭이 1/2~3/4인지 정도로 넓고 기록 밀도가 높다.<br />
<img src="../../assets/images/magneticTape.jpeg" alt="magneticTape" /><br /><br /></li>
  <li>대량의 자료를 반영구적으로 보관할 수 있고 가격이 저렴하다는 장점을 가지고 있다.</li>
  <li>하지만 테이프가 릴에 순차적으로 감겨 있기 때문에 자료의 순차적 처리만 가능하다.<br /><br /></li>
</ul>

<p>2) 기록 밀도<br /></p>
<ul>
  <li>자기 테이프 1릴(reel)의 길이는 보통 800, 1,200, 1,600, 2,400 피트(feet) 등이며, 테이프의 기록 밀도는 테이프 1인치 당 저장될 수 있는 문자(character)의 수 혹은 바이트(byte)의 수로 계산 되고 있다.</li>
  <li>이 기록 밀도의 단위를 BPI(Byte Per Inch)라고 하며 800, 1,600, 3,200, 6,250, 20,000BPI 등의 기록 밀도가 있다.</li>
  <li>자기 테이프는 최초로부터 4~5m 지점에 BOT(Beginning of Tape) 마커가 있고 끝의 6~7m 앞지점에 EOT(End of Tape) 마커가 있는데, 이 부분에는 자료를 수록할 수 없다.</li>
  <li>자기 테이프는 7개 또는 9개의 트랙(track)으로 구성되어 데이터를 표현한다.</li>
  <li>자료의 저장은 ASCII 코드나 EBCDIC 코드로 표현된다.</li>
  <li>파일의 갱신과 보수를 쉽게 하기 위하여 레이블을 사용하는데 레이블에는 표준 레이블, 비표준 레이블, 레이블이 없는 것 세 가지 종류가 있다.<br /><br /></li>
</ul>

<p>3) 저장 방법<br /></p>
<ul>
  <li>레코드는 자기 테이프에 순차적으로 기록되고 읽혀진다.</li>
  <li>이 때 테이프가 레코드를 읽거나 기록하는 과정에서 테이프를 출발시키거나 멈추게 하는데는 물리적인 가속 및 감속 구간이 필요한데, 이를 IRG(Inter Record Gap)로 나타낸다.</li>
  <li>IRG의 길이는 약 0.3~0.75인치로 각 레코드마다 IRG를 두게 되면 그만큼 저장할 수 있는 공간이 줄어들기 때문에 비효율적이다.</li>
  <li>따라서 효율성을 위해 몇 개의 레코드를 묶어서 한 개의 물리적 레코드로 만들어 준다.</li>
  <li>이것을 블록화라고 하며 하나의 블록에 포함된 논리 레코드의 수를 블록화 인수, 각 블록 사이의 간격을 IBG(Inter Block Gap)라 한다.<br /><br /></li>
</ul>

<p>4) 자기 테이프의 레코드 형식<br /></p>
<ul>
  <li>고정 길이 비블록 레코드(fixed unblock record)
    <ul>
      <li>블록화되지 않은 고정 길이 레코드</li>
      <li>물리 레코드와 논리 레코드의 길이가 같다.</li>
    </ul>
  </li>
  <li>고정 길이 블록 레코드(fixed block record)
    <ul>
      <li>블록화된 고정 길이 레코드</li>
      <li>레코드의 길이가 일정하며 하나의 물리 레코드 내에 2개 이상의 논리 레코드가 존재한다.</li>
    </ul>
  </li>
  <li>가변 길이 비블록 레코드(variable unblock record)
    <ul>
      <li>블록화되지 않은 가변 길이 레코드</li>
      <li>각 논리 레코드의 길이가 일정하지 않다.</li>
    </ul>
  </li>
  <li>가변 길이 블록 레코드(variable block record)
    <ul>
      <li>블록화된 가변 길이 레코드</li>
      <li>길이가 일정하지 않은 논리 레코드가 블록화되어 있는 형식이다.</li>
    </ul>
  </li>
  <li>부정 형식 레코드(undefined record)
    <ul>
      <li>길이를 나타내는 필드가 없는 가변 길이 레코드</li>
      <li>비블록 레코드이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="자기-디스크-장치">자기 디스크 장치<br /></h2>
<p><img src="../../assets/images/magneticDisk.jpeg" alt="magneticDisk" /><br /></p>
<ul>
  <li>대용량을 저장할 수 있고 임의로 호출이 가능하기 때문에 은행 업무, 좌석 예약 업무 등 실시간 처리가 요구되는 자료 처리에 효율적이다.</li>
  <li>처리 속도는 1,200 ~ 3,600 회전/분이며, 기록 밀도는 한 트랙당 3,000 ~ 13,000바이트, 즉 60만 ~ 520만 바이트가 수록된다.</li>
  <li>자기 디스크 장치는 여러 디스크가 하나의 축에 연결되어 있는데 이것을 디스크 팩(pack)이라 한다.</li>
  <li>그리고 각 면의 트랙을 수직으로 연결한 트랙군을 실린더(cylinder)라 한다.</li>
  <li>트랙과 실린더에는 고유 번호인 트랙 번호와 실린더 번호가 있어서 기억 매체상의 주소(address)가 할당되어 있기 때문에 데이터에 직접 액세스 하는 것이 가능하다.<br /><br /></li>
</ul>

<h2 id="자기-드럼-장치magnetic-drum">자기 드럼 장치(magnetic drum)<br /></h2>
<p><img src="../../assets/images/magneticDrum.jpeg" alt="magneticDrum" /><br /></p>
<ul>
  <li>초기에 사용되던 주기억 장치</li>
  <li>새로운 기억 장치가 개발되면서 보조 기억 장치로 사용되기 시작했지만 현재는 그마저도 잘 안 쓴다.</li>
  <li>직경 20~30cm인 금속 원통의 표면에 자성 물질을 입힌 드럼으로 드럼을 회전시킬 때 표면에 헤드를 접근시켜 기억된 내용을 읽거나 새로운 내용을 기억시킨다.<br /><br /></li>
</ul>

<h2 id="플로피-디스크-장치floppy-disk">플로피 디스크 장치(floppy disk)<br /></h2>
<p><img src="../../assets/images/floppyDisk.jpeg" alt="floppyDisk" /><br /></p>
<ul>
  <li>자기 디스크와 같이 데이터를 직접 액세스하며 가볍고 취급이 간편한 반면, 먼지, 햇볕, 열 또는 자성 물질에 가까이 두지 않는 등 관리상 주의가 필요하다.</li>
  <li>기록 방법에 따라 단밀도, 배밀도, 고밀도 등이 있으며, 2D는 양면 배밀도를 뜻하고 2HD는 양면 고밀도를 뜻한다.<br /><br /></li>
</ul>

<h2 id="하드-디스크hard-disk">하드 디스크(hard disk)<br /></h2>
<p><img src="../../assets/images/hardDisk.jpeg" alt="hardDisk" /><br /></p>
<ul>
  <li>개인용 컴퓨터의 보조 기억 장치로 널리 사용되고 있다.</li>
  <li>동작 속도는 ms로 나타내며, 보통 평균 액세스 속도와 트랙간 이동 속도, 최대 이동 거리 속도 등을 표시한다.</li>
  <li>평균 속도가 빠를수록 전체적으로 동작이 빠르며 가격도 높아진다.</li>
  <li>하드 디스크는 본체에 내장되어 사용되는 것이 보통이나 기억 용량의 증가, 편의성 등으로 외장형 하드 디스크도 사용되고 있다.<br /><br /></li>
</ul>

<h2 id="광학-디스크optical-disk">광학 디스크(optical disk)<br /></h2>
<ul>
  <li>레이저를 이용해서 자료를 기록한다.</li>
  <li>레이저가 필요한 표면에 도착하면 표면을 태워서 비트 형태의 데이터를 저장한다.</li>
  <li>광학 디스크는 데이터가 잘 지워지지 않는 백업 파일, 역사적 기록 등의 분야에 이용된다.<br /><br /></li>
</ul>

<h3 id="광-디스크의-종류">광 디스크의 종류<br /></h3>
<h4 id="1-cd-romcompact-disk-read-only-memory">1) CD-ROM(Compact Disk-Read Only Memory)<br /></h4>
<p><img src="../../assets/images/cdrom.jpeg" alt="cdrom" /><br /></p>
<ul>
  <li>지름이 12cm인 소형 디스크 위에 정보를 기록, 저장 및 검색할 수 있는 형식의 시스템으로 광학 드라이브를 이용해서 읽을 수 있다.</li>
  <li>원본에 정보를 기록하기 위해서는 WORM 장치가 사용된다.</li>
  <li>오디오 디스크, 비디오 디스크, 각종 상품화된 소프트웨어의 저장에 이용된다.<br /><br /></li>
</ul>

<h4 id="2-wormwrite-once-read-memory">2) WORM(Write Once Read Memory)<br /></h4>
<ul>
  <li>디스크에 단 한 번만 정보를 기록할 수 있고 기록한 후에 지울 수 없고 판독만 할 수 있는데, 그 후에는 드라이브에 있는 데이터가 삭제되지 않도록 보호하는 데이터 저장기술이다.</li>
  <li>문서용 파일, 비디오용 파일 등에 이용된다.<br /><br /></li>
</ul>

<h4 id="3-mo-diskmagneto-optical-disk">3) MO DISK(Magneto Optical Disk)<br /></h4>
<p><img src="../../assets/images/magnetoOpticalDisk.jpeg" alt="magnetoOpticalDisk" /><br /></p>
<ul>
  <li>자기광학 디스크라고도 하며 자기박막의 광자기 효과를 이용하여 자료를 기록하고 읽어낼 수 있는 CD-ROM 형태의 외부 기억 매체</li>
  <li>자료를 기록할 때엔 레이저광을 사용하여 자화시키는데 이 자화가 유지되어 정보가 기록된다.</li>
  <li>판독시엔 피트(pit : 광자기 디스크 표면의 미세한 홈)에 반사되는 빛의 유무로 데이터를 판독한다.</li>
  <li>광자기 디스크는 3.5인치 디스켓보다는 빠르지만 하드 디스크보다는 느리다.</li>
  <li>광자기 디스크는 자료 백업용 기억매체로 사용하기 좋으며 이동이 간편하고 신뢰성이 높은 것이 장점이다.</li>
  <li>오디오용, 비디오용, 컴퓨터 데이터 파일 등에 이용된다.<br /><br /></li>
</ul>

<h4 id="4-dvd">4) DVD<br /></h4>
<ul>
  <li>CD에서 더 발전한 광학 디스크 기술을 이용하는 저장매체이다.</li>
  <li>외형은 CD와 같지만 다른 포맷으로 저장되며 높은 용량을 가지고 있다.</li>
  <li>DVD는 MPEG-2 파일과 압축 표준을 사용한다.</li>
  <li>MPEG-2 이미지들은 MPEG-1 이미지의 4배 해상도를 가지며, 2개의 필드가 하나의 이미지 프레임을 구성하는 상황에서 초당 60개의 인터레이스드 필드(Interlaced Field)를 전송할 수 있다. (MPEG-1은 초당 30개의 인터레이스되지 않은 프레임을 전송한다)<br /><br /></li>
</ul>

<p><img src="../../assets/images/memoryHierarchy.png" alt="memoryHierarchy" /><br /></p>
<blockquote>
  <p>메모리 계층 구조<br /></p>
</blockquote>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[보조 기억 장치 주기억 장치는 적은 자료를 기억하여 고속으로 처리한다. **그에 반해 많은 양의 자료를 기억시켜 관리하기 위한 장치**를 보조 기억 장치 또는 2차 기억 장치(secondary memory)라 한다. 보조 기억 장치의 자료를 액세스하는 방법에 따라 **순차 액세스**와 **임의 액세스**로 분류할 수 있다.]]></summary></entry></feed>