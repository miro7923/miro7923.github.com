<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-27T19:07:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 18870. 좌표 압축</title><link href="http://localhost:4000/boj/boj18870-java/" rel="alternate" type="text/html" title="Java) BOJ 18870. 좌표 압축" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj18870-java</id><content type="html" xml:base="http://localhost:4000/boj/boj18870-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/18870">https://www.acmicpc.net/problem/18870</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.</p>
  </li>
  <li>
    <p>Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.</p>
  </li>
  <li>
    <p>X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N이 주어진다.</li>
  <li>둘째 줄에는 공백 한 칸으로 구분된 X1, X2, …, XN이 주어진다.</li>
  <li>1 ≤ N ≤ 1,000,000</li>
  <li>-109 ≤ Xi ≤ 109<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 X’1, X’2, …, X’N을 공백 한 칸으로 구분해서 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력받은 수 배열에서 i번째 수보다 작은 수의 갯수를 세어서 i번째에 출력하면 되는데 i번째 수보다 작은 수가 몇 개인지 알려면 오름차순으로 정렬을 해 봐야 한다.</li>
  <li>오름차순으로 정렬을 해 보면 i번째 수의 앞에 있는 수들은 다 작은 수들이니까 배열을 순회하면서 그 수가 몇 개인지 세면 i번째 수를 압축한 수가 된다.</li>
  <li>
    <p>정답 출력 형식을 보면 입력된 숫자의 순서대로 압축한 수를 출력해야 하는데 입력 배열을 정렬해 버리면 순서가 흐트러져서 정답 형식으로 출력할 수 없다. 그래서 입력 배열과 같은 임시 배열을 만들어 정렬한다.<br /></p>
  </li>
  <li>그런데 최대 백만개가 입력으로 주어지는데 2중 for문을 통해 하나씩 비교하는 <code class="language-plaintext highlighter-rouge">O(n^2)</code> 알고리즘을 사용하면 시간초과를 받을 것이기 때문에 정렬 알고리즘은 <code class="language-plaintext highlighter-rouge">O(n log n)</code> 시간복잡도를 가지는 것을 쓰는 것이 좋다.</li>
  <li>그리고 입력으로 중복된 수가 들어오는데 예제의 답을 보면 중복된 수는 카운트하지 않는다.</li>
  <li>즉 1, 1, 2 일 때 2보다 작은 수인 1이 2개 있는데 이럴 경우 답은 0, 0, 1이 되어야 한다. 2보다 작은 수는 1개가 되어야 한다.</li>
  <li>
    <p>그래서 오름차순으로 정렬하고 난 후 중복되는 숫자들은 제거해 주어야 한다. 중복 숫자를 제거하지 않으면 i번째 수보다 작은 수를 셀 때 오차가 생길 것이다.<br /></p>
  </li>
  <li>중복된 숫자들을 제거하고 나면 &lt;i번째 숫자, i번째 숫자보다 작은 숫자의 갯수&gt; pair를 저장하는 map을 만들어서 각 원소를 삽입해준다.</li>
  <li>
    <p>그 다음 마지막으로 입력 원본 배열을 순회하면서 map에서 i번째 원소를 key로 가지는 value를 찾아 출력하면 된다.<br /></p>
  </li>
  <li>시간제한이 2초인데 2788ms로 통과된 거 보면 자바는 느려서 시간을 좀 더 주는 것 같다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 2788 ms</li>
  <li>메모리 : 254876 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/1cd7a372bd0ad6186aadcb222ca3afc6.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No18870" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/18870 제한 시간 제한 : 2 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 1181. 단어 정렬</title><link href="http://localhost:4000/boj/boj1181-java/" rel="alternate" type="text/html" title="Java) BOJ 1181. 단어 정렬" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1181-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1181-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1181">https://www.acmicpc.net/problem/1181</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</li>
</ul>

<ol>
  <li>길이가 짧은 것부터</li>
  <li>길이가 같으면 사전 순으로<br /><br /></li>
</ol>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>Collections.sort와 Comparator 람다식을 이용해 구현했다.</li>
  <li>마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 392 ms</li>
  <li>메모리 : 23208 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/55e1fca4233f64a9249c59ee80aeb16f.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1181" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1181 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11651. 좌표 정렬하기2</title><link href="http://localhost:4000/boj/boj11651-java/" rel="alternate" type="text/html" title="Java) BOJ 11651. 좌표 정렬하기2" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11651-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11651-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11651">https://www.acmicpc.net/problem/11651</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>11650번에서 썼던 Comparator 함수에서 기준값을 x에서 y로만 바꿔주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 860 ms</li>
  <li>메모리 : 49896 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/bafcfe58127991148c9f70bab678805d.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11651" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11651 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11650. 좌표 정렬하기</title><link href="http://localhost:4000/boj/boj11650-java/" rel="alternate" type="text/html" title="Java) BOJ 11650. 좌표 정렬하기" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11650-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11650-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11650">https://www.acmicpc.net/problem/11650</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 <code class="language-plaintext highlighter-rouge">Pair</code> 클래스에서 <code class="language-plaintext highlighter-rouge">Comparable</code>을 구현해서 썼는데 리턴값을 잘못 설정했는지 계속 7%에서 틀렸다 ㅠ.ㅠ</li>
  <li>그래서 구글링해서 Comparator 람다식으로 바꾸고 통과함<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 800 ms</li>
  <li>메모리 : 51232 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/49b9efbb416fe3905a7e48e17b4d3990.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11650" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11650 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 10814. 나이순 정렬</title><link href="http://localhost:4000/boj/boj10814-java/" rel="alternate" type="text/html" title="Java) BOJ 10814. 나이순 정렬" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10814-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10814-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10814">https://www.acmicpc.net/problem/10814</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</li>
</ul>

<ol>
  <li>길이가 짧은 것부터</li>
  <li>길이가 같으면 사전 순으로<br /><br /></li>
</ol>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>Collections.sort와 Comparator 람다식을 이용해 구현했다.</li>
  <li>마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 392 ms</li>
  <li>메모리 : 23208 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/978be8ad9674667c38e12894cd1c7144.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10814" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10814 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">JSP) 서블릿</title><link href="http://localhost:4000/jsp/JSP-servlet/" rel="alternate" type="text/html" title="JSP) 서블릿" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-servlet</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-servlet/"><![CDATA[<h1 id="-서블릿servlet이란">👀 서블릿(Servlet)이란?</h1>
<ul>
  <li>자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 <code class="language-plaintext highlighter-rouge">JSP</code> 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다.</li>
  <li>즉 <code class="language-plaintext highlighter-rouge">JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class)</code> 이런 과정을 거치게 된다.</li>
</ul>

<h2 id="서블릿-작성-규칙">서블릿 작성 규칙</h2>
<p>1) javax.servlet.Servlet 인터페이스 구현<br />
2) 1)의 구현이 어려운 경우 javax.servlet.http.HttpServlet 클래스 상속(일반적으로 사용)<br />
3) doGet()/ doPost() 생성(오버라이딩), HttpServletRequest/ HttpServletResponse 객체 구현<br />
4) IOException/ ServletException을 처리해야 함<br />
5) web.xml 파일을 통해서 주소 매핑 (어노테이션 처리)<br /></p>

<h2 id="서블릿-실행-구조">서블릿 실행 구조</h2>

<p><img src="../../assets/images/servletProcess.png" /><br /><br /><br /></p>

<h1 id="서블릿-클래스-만들기">서블릿 클래스 만들기</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.RequestDispatcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.itwillbs.test.Student</span><span class="o">;</span>

<span class="c1">// 서블릿 - jsp코드 + java코드를 함께 수행할 수 있는 파일</span>
<span class="c1">// 서블릿 클래스 상속받으면 서블릿이 됨</span>

<span class="c1">// http://localhost:8090/JSP6/ex1</span>
<span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/ex1"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> 
<span class="o">{</span>
    <span class="c1">// 폼태그에서 get method를 썼을 때 호출되는 함수</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"doGet() 호출"</span><span class="o">);</span>
		
        <span class="c1">// 응답정보의 내용의 형태는 html문서로 표현하겠다.</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html; charset=UTF-8"</span><span class="o">);</span>

        <span class="c1">// response를 통해서 출력가능한 통로를 생성하겠다.</span>
<span class="c1">//	    PrintWriter out = response.getWriter();</span>
<span class="c1">//</span>
<span class="c1">//	    // 서블릿을 이용한 JSP 페이지 표현 - 사용하진 않을 것임</span>
<span class="c1">//	    out.print("&lt;html&gt;");</span>
<span class="c1">//	    out.print("&lt;head&gt;");</span>
<span class="c1">//	    out.print("&lt;/head&gt;");</span>
<span class="c1">//	    out.print("&lt;body&gt;");</span>
<span class="c1">//	    out.print("&lt;h1&gt; 서블릿을 활용한 JSP페이지 만들기&lt;/h1&gt;");</span>
<span class="c1">//	    out.print("&lt;/body&gt;");</span>
<span class="c1">//	    out.print("&lt;/html&gt;");</span>
<span class="c1">//	    out.close();</span>

        <span class="c1">// 포워딩 전 request 영역에 정보를 저장</span>
        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"itwill"</span><span class="o">,</span> <span class="s">"busan"</span><span class="o">);</span>

        <span class="c1">// 객체정보를 전달</span>
        <span class="nc">Student</span> <span class="n">kim</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"김학생"</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setKor</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setEng</span><span class="o">(</span><span class="mi">90</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setMath</span><span class="o">(</span><span class="mi">76</span><span class="o">);</span>
        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"Student"</span><span class="o">,</span> <span class="n">kim</span><span class="o">);</span>

        <span class="nc">Student</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"사용자"</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setKor</span><span class="o">(</span><span class="mi">45</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setEng</span><span class="o">(</span><span class="mi">70</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setMath</span><span class="o">(</span><span class="mi">98</span><span class="o">);</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">memberList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;();</span>
        <span class="n">memberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">kim</span><span class="o">);</span>
        <span class="n">memberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"memberList"</span><span class="o">,</span> <span class="n">memberList</span><span class="o">);</span>

        <span class="c1">// 서블릿 코드를 사용한 화면 출력 X</span>
        <span class="c1">// =&gt; 포워딩을 사용한 화면 출력 O</span>

        <span class="c1">// 자바 코드를 이용한 포워딩 방식 - 외우기</span>
<span class="c1">//	    &lt;jsp:forward/&gt; 사용불가 - JSP 페이지가 아닌 자바파일이라서 못 씀</span>
        <span class="c1">// 이동할 경로 설정</span>
        <span class="nc">RequestDispatcher</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">"/jstl/coreSet2.jsp"</span><span class="o">);</span>

        <span class="n">dis</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
	<span class="o">}</span> <span class="c1">// doGet()</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이렇게 만들면 되는데 사용할 함수들을 다 오버라이딩 하기 때문에 일일이 작성하지 않아도 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">HttpServlet</code>을 상속받고 나면 이클립스가 구현해야 하는 함수들을 다 만들어 준다.</li>
  <li>우리는 형태가 만들어진 함수의 내부만 채우면 된다.<br /><br /><br /></li>
</ul>

<h1 id="jsp-페이지에서-서블릿을-활용한-정보-전달">JSP 페이지에서 서블릿을 활용한 정보 전달</h1>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 서블릿에서 저장된 정보(request.setAttribute("itwill", "busan");) 출력 --&gt;</span>
  itwill : <span class="nt">&lt;%=</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"itwill"</span><span class="o">)</span> <span class="nt">%&gt;&lt;br&gt;</span>
  itwill : ${itwill }<span class="nt">&lt;br&gt;</span>
  itwill : ${requestScope.itwill }<span class="nt">&lt;br&gt;</span>
  
<span class="c">&lt;!-- 앞으로는 보안을 위해 주소에 정보가 처리되는 jsp 페이지를 나타내지 않을 것임
  		자바 서블릿 코드를 이용해 jsp 페이지 작성(가상주소 생성) --&gt;</span>
</code></pre></div></div>

<ul>
  <li>자바 서블릿 코드를 이용해 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지를 작성할 것이기 때문에 서블릿 클래스를 실행하면 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지로 연결되어 액션을 수행하지만 주소창에는 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지가 나타나지 않고 어노테이션 <code class="language-plaintext highlighter-rouge">@WebServlet("/ex1")</code>에 쓴 <code class="language-plaintext highlighter-rouge">/ex1</code>가 맨 뒤에 붙어 주소창에는 <code class="language-plaintext highlighter-rouge">http://localhost:8090/JSP6/ex1</code> 와 같은 형태로 나타나게 된다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${Student}<span class="nt">&lt;br&gt;</span>
학생 이름 : ${Student.getName() }<span class="nt">&lt;br&gt;</span>
국어 : ${Student.getKor() }<span class="nt">&lt;br&gt;</span>
영어 : ${Student.getEng() }<span class="nt">&lt;br&gt;</span>
수학 : ${Student.getMath() }<span class="nt">&lt;br&gt;</span>
  
<span class="nt">&lt;%</span>
  <span class="nc">Student</span> <span class="n">kim</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"Student"</span><span class="o">);</span>
<span class="nt">%&gt;</span>
<span class="nt">&lt;%=</span><span class="n">kim</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="nt">%&gt;&lt;br&gt;</span>
${Student.name }<span class="nt">&lt;br&gt;</span><span class="c">&lt;!-- el 표현식에서는 내부적으로 get/set 메서드를 자동으로 구현해 사용함. 그래서 변수명으로도 접근가능 --&gt;</span>
  
<span class="c">&lt;!-- 좀 더 간단하게 쓰기 --&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"kim"</span><span class="na"> value=</span><span class="s">"</span><span class="si">${</span><span class="nc">Student</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  
${kim.name }
  
<span class="nt">&lt;hr&gt;</span>
  
${requestScope.memberList }<span class="nt">&lt;br&gt;</span>
${requestScope.memberList[0].name }
</code></pre></div></div>

<ul>
  <li>그리고 아까 서블릿에서 함께 저장했던 클래스 객체도 위와 같이 <code class="language-plaintext highlighter-rouge">el 표현식</code>을 사용해서 출력할 수 있다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="Servlet" /><summary type="html"><![CDATA[👀 서블릿(Servlet)이란? 자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 JSP 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다. 즉 JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class) 이런 과정을 거치게 된다.]]></summary></entry><entry><title type="html">JSP) JSTL</title><link href="http://localhost:4000/jsp/JSP-jstl/" rel="alternate" type="text/html" title="JSP) JSTL" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-jstl</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-jstl/"><![CDATA[<h1 id="-jstljsp-standard-tag-library이란">👀 JSTL(JSP Standard Tag Library)이란?</h1>
<ul>
  <li>자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태</li>
  <li>
    <p>태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.</p>
  </li>
  <li>CORE 라이브러리 : 기본적인 동작 제공
    <ul>
      <li>변수 선언, 조건문, 반복문 코드를 처리하는 태그</li>
      <li>페이지 이동처리 태그 (태그만 사용해서 반복문 처리를 할 수 있음)</li>
    </ul>
  </li>
  <li>Formatting 라이브러리
    <ul>
      <li>데이터 국제화 처리 (다국어) 태그</li>
      <li>형식화 (날짜, 숫자, 시간) 태그</li>
    </ul>
  </li>
  <li>DB 라이브러리 : sql구문처리 동작
    <ul>
      <li>CRUD 동작 수행 태그</li>
    </ul>
  </li>
  <li>XML 라이브러리
    <ul>
      <li>XML 문서 읽고 처리하는 태그</li>
    </ul>
  </li>
</ul>

<h2 id="다운로드-및-설치">다운로드 및 설치</h2>
<ul>
  <li>톰캣 홈페이지에서 taglibs 메뉴에 들어가서 하단에</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taglibs-standard-jstlel-1.2.5.jar
taglibs-standard-spec-1.2.5.jar
taglibs-standard-impl-1.2.5.jar
</code></pre></div></div>

<ul>
  <li>세 파일을 다운받는다.</li>
  <li>다운받은 파일들을 <code class="language-plaintext highlighter-rouge">WEB-INF/lib</code>에 복붙하면 설치 완료<br /><br /><br /></li>
</ul>

<h1 id="core-라이브러리">CORE 라이브러리</h1>
<h2 id="변수-선언-및-사용">변수 선언 및 사용</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"c"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/core"</span> <span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li>먼저 페이지 상단에 라이브러리 인클루드 해 주어야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">prefix</code>는 태그의 접두사를 지정해 주는 것으로 <code class="language-plaintext highlighter-rouge">prefix</code>에 지정한 문자를 쓰고 <code class="language-plaintext highlighter-rouge">:</code>을 쓰면 태그 예약어들을 사용할 수 있다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;%-- &lt;c:set var="변수명" value="값"/&gt; --%&gt;</span>
  <span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"num3"</span><span class="na"> value=</span><span class="s">"300"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"num4"</span><span class="na"> value=</span><span class="s">"400"</span><span class="nt">/&gt;</span>
  
  <span class="c">&lt;!-- 변수값 출력할 때엔 el 표현식 사용 --&gt;</span>
  <span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">num3</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">num4</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;hr&gt;</span>
  
  ${num3 } + ${num4 } = ${num3 + num4 }
</code></pre></div></div>

<ul>
  <li>태그 속에서 변수를 선언하고 값을 넣어줄 수 있다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> value=</span><span class="s">"S22"</span><span class="na"> scope=</span><span class="s">"request"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>스크립틀릿을 이용해서 자바 코드로 변수를 선언하면 지역변수로 인식되어서 선언한 페이지에서만 쓸 수 있는데 <code class="language-plaintext highlighter-rouge">JSTL</code> 태그를 사용하면 변수의 영역도 지정해 줄 수 있어서 자바 코드를 사용하는 것에 비해 훨씬 활용도를 높일 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">scope : page, request, session, application</code> 네 영역 모두 설정해 줄 수 있다. <code class="language-plaintext highlighter-rouge">scope</code>를 설정하지 않으면 기본값은 <code class="language-plaintext highlighter-rouge">page</code>라서 선언한 페이지에서만 쓸 수 있다.</li>
</ul>

<h2 id="출력">출력</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"안녕하세요 JSTL입니다."</span><span class="nt">&gt;&lt;/c:out&gt;</span>
</code></pre></div></div>

<ul>
  <li>만약 <code class="language-plaintext highlighter-rouge">null</code>값을 출력하는 경우 빈공백으로 처리된다. (JSP 표현식은 컴파일 에러남)</li>
  <li>컴파일 에러난 페이지를 보여주는 것 보다는 <code class="language-plaintext highlighter-rouge">null</code>값을 출력하는게 사용자 신뢰도에는 더 좋다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;</span> <span class="nt">abc&gt;</span>태그는 abc입니다.<span class="nt">&lt;hr&gt;</span>

<span class="ni">&amp;lt;</span>abc&gt;태그는 abc입니다.<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"&lt;abc&gt;태그는 abc입니다."</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>만약 태그 자체를 출력하고 싶다면 위 세 가지 방법으로 출력이 가능하다.</li>
</ul>

<h2 id="조건문">조건문</h2>
<h3 id="if">if</h3>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- jstl 변수 2개 생성(속성) --&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> value=</span><span class="s">"itwill"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"tel"</span><span class="na"> value=</span><span class="s">"010-1234-5678"</span><span class="nt">/&gt;</span>

<span class="c">&lt;!-- 사용자의 이름이 "itwill"인지 체크 --&gt;</span>
<span class="nt">&lt;c:if </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">name</span> <span class="o">==</span> <span class="l">'itwill'</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span><span class="c">&lt;!-- 표현식 안에서는 작은 따옴표를 써야 함(큰 따옴표 쓰면 밖에 따옴표랑 반응함) --&gt;</span>
  사용자 이름 : ${name }<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:if&gt;</span>

<span class="nt">&lt;c:if </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="mi">100</span> <span class="n">lt</span> <span class="mi">200</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span><span class="c">&lt;!-- lt : 비교연산자(&lt;)와 같은 역할을 하는 예약어 --&gt;</span>
  200이 더 크다.<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:if&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HTML</code> 태그처럼 태그 사이에 출력하고 싶은 문구를 작성할 수 있다.<br /><br /></li>
</ul>

<h3 id="switch-case">switch ~case</h3>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:choose&gt;</span>
  <span class="nt">&lt;c:when </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">param</span><span class="o">.</span><span class="na">num1</span> <span class="n">le</span> <span class="n">param</span><span class="o">.</span><span class="na">num2</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span>
    num1! <span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:when&gt;</span>
  <span class="nt">&lt;c:when </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">param</span><span class="o">.</span><span class="na">num1</span> <span class="n">lt</span> <span class="n">param</span><span class="o">.</span><span class="na">num2</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span>
    num2! <span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:when&gt;</span>
  <span class="nt">&lt;c:otherwise&gt;</span>
    그 외 나머지<span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:otherwise&gt;</span>
<span class="nt">&lt;/c:choose&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">choose</code> 태그를 사용해서 <code class="language-plaintext highlighter-rouge">switch ~case</code>문을 작성할 수 있다.<br /><br /></li>
</ul>

<h2 id="반복문">반복문</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:forEach </span><span class="na">var=</span><span class="s">"i"</span><span class="na"> begin=</span><span class="s">"1"</span><span class="na"> end=</span><span class="s">"10"</span><span class="na"> step=</span><span class="s">"1"</span><span class="nt">&gt;</span>
  ${i }
<span class="nt">&lt;/c:forEach&gt;</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 <code class="language-plaintext highlighter-rouge">for</code>문에서 변수를 선언하고 조건식, 증감식을 설정해 줄 수 있는데 저렇게는 잘 안 쓴다.(단순 순회할 때 <code class="language-plaintext highlighter-rouge">for</code>문에서 귀찮은 것들을 덜어내고 쓰는 것이 <code class="language-plaintext highlighter-rouge">foreach</code>니까…)<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="o">{</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
<span class="nt">%&gt;</span>
<span class="c">&lt;!-- 이 형태를 많이 쓴다.(items 자리엔 jsp 표현식보다는 el 표현식을 쓴다.) --&gt;</span>
<span class="nt">&lt;c:forEach </span><span class="na">var=</span><span class="s">"test"</span><span class="na"> items=</span><span class="s">"&lt;%=arr %&gt;"</span><span class="nt">&gt;</span>
  ${test } 
<span class="nt">&lt;/c:forEach&gt;</span>
</code></pre></div></div>

<ul>
  <li>위와 같은 형태로 배열을 순회할 때 많이 사용한다.<br /><br /></li>
</ul>

<h2 id="문자열-parsing">문자열 Parsing</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:forTokens </span><span class="na">var=</span><span class="s">"abc"</span><span class="na"> items=</span><span class="s">"a,b,c,d,e,f,g,h"</span><span class="na"> delims=</span><span class="s">","</span><span class="nt">&gt;</span>
  ${abc } 
<span class="nt">&lt;/c:forTokens&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"data"</span><span class="na"> value=</span><span class="s">"자바 디비 웹 JSP"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;c:forTokens </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> items=</span><span class="s">"</span><span class="si">${</span><span class="n">data</span> <span class="si">}</span><span class="s">"</span><span class="na"> delims=</span><span class="s">" "</span><span class="nt">&gt;</span>
  ${name }<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:forTokens&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">delims</code>에 넣은 인자값을 기준으로 문자열을 자를 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="formatting-라이브러리">Formatting 라이브러리</h1>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"c"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/core"</span><span class="nt">%&gt;</span>
<span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"fmt"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/fmt"</span><span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Formatting</code> 라이브러리는 일반적으로 <code class="language-plaintext highlighter-rouge">fmt</code> 접두사를 쓴다.</li>
</ul>

<h2 id="날짜-출력하기">날짜 출력하기</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"today"</span><span class="na"> value=</span><span class="s">"&lt;%=new Date() %&gt;"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- time: 시간정보 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- both: 날짜 &amp; 시간정보 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"both"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"long"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"medium"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"short"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"both"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="na"> timeStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"long"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"medium"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"short"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;h3&gt;</span>2022/2/25(금) (오전) 11:50:00 형식으로 표현하기<span class="nt">&lt;/h3&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> pattern=</span><span class="s">"yyyy/MM/dd(E)"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> pattern=</span><span class="s">"(a)hh:mm:ss"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dateStyle</code>에 넣은 값만큼 출력되는 날짜 정보의 갯수를 조절할 수 있다.</li>
</ul>

<h2 id="통화-출력하기">통화 출력하기</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"today"</span><span class="na"> value=</span><span class="s">"&lt;%=new Date() %&gt;"</span><span class="nt">/&gt;</span>
${today }
<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"ko_kr"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"en_us"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"zh_cn"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"ja_jp"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="숫자-출력">숫자 출력</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"100000000"</span><span class="na"> groupingUsed=</span><span class="s">"false"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"100000000"</span><span class="na"> groupingUsed=</span><span class="s">"true"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;h2&gt;</span>소수점 자리 표현<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="mf">2.12345676</span> <span class="si">}</span><span class="s">"</span><span class="na"> pattern=</span><span class="s">"#.####"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- 0은 .뒤에 0을 채워줌 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"20.0"</span><span class="na"> pattern=</span><span class="s">"##.00"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"0.5"</span><span class="na"> type=</span><span class="s">"percent"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- 통화 심볼도 바꿀 수 있다 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"10000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="na"> currencySymbol=</span><span class="s">"@"</span><span class="nt">/&gt;&lt;br&gt;</span>
</code></pre></div></div>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="JSTL" /><summary type="html"><![CDATA[👀 JSTL(JSP Standard Tag Library)이란? 자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태 태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.]]></summary></entry><entry><title type="html">JSP) 커넥션 풀</title><link href="http://localhost:4000/jsp/JSP-connection-pool/" rel="alternate" type="text/html" title="JSP) 커넥션 풀" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-connection-pool</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-connection-pool/"><![CDATA[<h1 id="-커넥션-풀-connection-pool이란">👀 커넥션 풀 (Connection Pool)이란?</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">JDBC</code>를 연동하기 위해서는 드라이버를 로드하고 <code class="language-plaintext highlighter-rouge">JDBC URL</code>로 접속하여 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 얻어오는 단계를 거쳐야 한다.</li>
  <li>커넥션 풀은 데이터베이스와 연결된 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다.</li>
  <li>사용자가 웹 사이트에 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다.</li>
  <li>하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.</li>
</ul>

<h2 id="커넥션풀의-연결전략">커넥션풀의 연결전략</h2>
<p>1) DB연결이 필요한 JSP 페이지 (service()) 실행시 DB연결 요청당 1개씩 할당<br />
2) 커넥션의 개수를 제한<br />
3) 커넥션의 사용을 다 한 경우 (객체관리자가 자원을 모두 다 쓰면) 자원 회수<br /></p>

<h2 id="실제-동작-구현">실제 동작 구현</h2>
<ol>
  <li>웹브라우저 요청<br /></li>
  <li>할당될 커넥션 객체가 있는지 없는지 체크<br /><br /></li>
</ol>

<p>2-1. 있을 때<br />
    3. 커넥션 객체 할당 (pool에 저장된 정보 전달)<br />
    4. 객체 사용<br />
    5. 객체 사용 반환 (자원해제 X, pool에 저장)<br /></p>

<p>2-2. 없을 때<br />
    1. 커넥션 객체를 기다림 (커넥션이 반환될 때 까지)<br />
    2. 임시 커넥션 객체 생성 -&gt; 사용 -&gt; 반환 (사라짐)<br /><br /><br /></p>

<h1 id="jndi-java-namming-and-directory-interface">JNDI (Java Namming and Directory Interface)</h1>
<ul>
  <li>명명 서비스 및 디렉토리 서비스에 접근하기 위한 API. 즉 특정 자원에 접근하기 위한 이름으로 사용된다.</li>
  <li><a href="https://commons.apache.org/">아파치 홈페이지</a>에 가서 <code class="language-plaintext highlighter-rouge">collections</code>, <code class="language-plaintext highlighter-rouge">DBCP</code>, <code class="language-plaintext highlighter-rouge">Pool</code> 다운받기
    <ul>
      <li>압축 풀어서 <code class="language-plaintext highlighter-rouge">commons-collections4-4.4.jar</code> 처럼 옆에 잡다한 이름 안 붙은걸로 복사해서 <code class="language-plaintext highlighter-rouge">WEB-INF/lib</code>에 붙여넣기</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">API</code>를 설치했으면 <code class="language-plaintext highlighter-rouge">xml</code> 파일을 만들어야 한다.</li>
</ul>

<h2 id="xml">XML</h2>
<ul>
  <li>태그 형태로 데이터를 저장하는 페이지로 <code class="language-plaintext highlighter-rouge">HTML</code> 태그 형태는 아니지만 지정된 태그를 통해서 데이터를 저장하고 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">src/main/webapp/META-INF</code>에 <code class="language-plaintext highlighter-rouge">content.xml</code> 파일을 생성하고 서버에 공유할 리소스를 정의한다.</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="nt">&lt;Context&gt;</span>
  <span class="nt">&lt;Resource</span> 
    <span class="na">name=</span><span class="s">"jdbc/mysql"</span> 
    <span class="na">auth=</span><span class="s">"Container"</span> 
    <span class="na">type=</span><span class="s">"javax.sql.DataSource"</span> 
    <span class="na">username=</span><span class="s">"root"</span> 
    <span class="na">password=</span><span class="s">"1234"</span> 
    <span class="na">driverClassName=</span><span class="s">"com.mysql.cj.jdbc.Driver"</span> 
    <span class="na">url=</span><span class="s">"jdbc:mysql://localhost:3306/jspdb"</span> 
    <span class="na">maxActive=</span><span class="s">"500"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Context&gt;</span>
</code></pre></div></div>

<ul>
  <li>이렇게 작성하면 되는데 각 코드 라인의 의미는 다음과 같다.</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Context&gt;</span>
  <span class="c">&lt;!-- Context : 프로젝트 --&gt;</span>
  <span class="nt">&lt;Resource</span> 
    <span class="na">name=</span><span class="s">"디비에 접근하기 위한 이름"</span> 
    <span class="na">auth=</span><span class="s">"컨테이너 자원 관리자 설정 - Application or Container"</span> 
    <span class="na">type=</span><span class="s">"리소스를 사용할 때 실제로 사용되는 클래스 타입"</span> 
    <span class="na">username=</span><span class="s">"디비 아이디"</span> 
    <span class="na">password=</span><span class="s">"디비 비밀번호"</span> 
    <span class="na">driverClassName=</span><span class="s">"드라이버 주소"</span> 
    <span class="na">url=</span><span class="s">"디비 연결 주소"</span> 
    <span class="na">maxActive=</span><span class="s">"커넥션 회수 대기시간"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Context&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xml</code> 파일에서도 주석문 사용이 가능하지만 사용하지 않는 것이 좋다.</li>
  <li>왜냐면 주석 처리한 코드가 실행되는 경우가 있는데 이 때 에러가 나도 컴파일 에러가 표시되지 않고 단순 서버 에러라고만 나오기 때문에 원인 찾기가 매우매우 힘들다.</li>
  <li><code class="language-plaintext highlighter-rouge">xml</code> 파일까지 만들었다면 <code class="language-plaintext highlighter-rouge">MemberDAO</code> 클래스를 커넥션 풀을 사용하도록 수정해야 한다.<br /><br /><br /></li>
</ul>

<h1 id="memberdao-클래스를-커넥션-풀을-쓰도록-수정하기">MemberDAO 클래스를 커넥션 풀을 쓰도록 수정하기</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getConnect()</code> 함수를 아래와 같이 수정한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Connection</span> <span class="nf">getConnect</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">try</span> 
    <span class="o">{</span>
        <span class="c1">// 커넥션풀을 사용한 디비연결</span>
        
        <span class="c1">// 업캐스팅이라 인터페이스인데 객체 생성 가능</span>
        <span class="c1">// 프로젝트(CTX)정보 초기화</span>
        <span class="nc">Context</span> <span class="n">initCTX</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InitialContext</span><span class="o">();</span>
        
<span class="c1">//	Context envCTX = (Context) initCTX.lookup("java:comp/env");</span>
<span class="c1">//				envCTX.lookup("jdbc/mysql"); // 이거랑 아래 한 문장이랑 같은 의미</span>
        <span class="c1">// java:comp/env/ 여기까지는 항상 고정 &amp; 뒤에 xml 파일의 name에 쓴 내용 넣기</span>
        <span class="c1">// type="javax.sql.DataSource" 에서 정해준 데이터타입으로 다운캐스팅 해줘야 함</span>
        <span class="nc">DataSource</span> <span class="n">ds</span> <span class="o">=</span> <span class="o">(</span><span class="nc">DataSource</span><span class="o">)</span> <span class="n">initCTX</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"java:comp/env/jdbc/mysql"</span><span class="o">);</span>
        
        <span class="c1">// ds에 연결정보가 다 들어있으니까 getConnection만 실행</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 커넥션풀을 사용한 디비연결 성공"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : "</span> <span class="o">+</span> <span class="n">con</span><span class="o">);</span>
    <span class="o">}</span> 
    <span class="k">catch</span> <span class="o">(</span><span class="nc">NamingException</span> <span class="n">e</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> 
    <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">con</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이후 사용하는 것은 기존과 같이 사용하면 된다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="ConnectionPool" /><summary type="html"><![CDATA[👀 커넥션 풀 (Connection Pool)이란? JDBC를 연동하기 위해서는 드라이버를 로드하고 JDBC URL로 접속하여 Connection 객체를 얻어오는 단계를 거쳐야 한다. 커넥션 풀은 데이터베이스와 연결된 Connection 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 Connection 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다. 사용자가 웹 사이트에 Connection 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다. 하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.]]></summary></entry><entry><title type="html">컴퓨터 네트워크) 데이터 통신</title><link href="http://localhost:4000/computer%20network/computer-network-02/" rel="alternate" type="text/html" title="컴퓨터 네트워크) 데이터 통신" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/computer%20network/computer-network-02</id><content type="html" xml:base="http://localhost:4000/computer%20network/computer-network-02/"><![CDATA[<h1 id="전송-모드">전송 모드</h1>
<h2 id="병렬-전송parallel-transfer">병렬 전송(Parallel Transfer)</h2>
<ul>
  <li>여러 전송라인을 통해 여러 비트들을 동시에 전송</li>
  <li>두 장치들간의 거리가 짧은 경우에 일반적으로 사용
    <ul>
      <li>예) PC에서 프린터로 전송하는 것</li>
      <li>예) 컴퓨터와 주변 장치들간의 연결</li>
    </ul>
  </li>
  <li>긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.</li>
</ul>

<h2 id="직렬-전송serial-transfer">직렬 전송(Serial Transfer)</h2>
<ul>
  <li>하나의 전송라인을 사용하여 하나씩 모든 비트를 보낸다.</li>
  <li>긴 거리를 전송할 때 병렬 전송에 비해 적은 비용이 들고 신뢰성 증가</li>
  <li>하지만 비트를 하나씩 보내는 만큼 병렬 전송에 비해 느리다.</li>
</ul>

<h2 id="비동기식-전송">비동기식 전송</h2>
<ul>
  <li>한 번에 한 문자씩 보내거나 받는 방식</li>
  <li>문자는 7~8 비트로 구성되며, 문자의 앞에 시작비트(Start bit)를, 끝에는 정지비트(Stop bit)를 첨가해서 보냄</li>
  <li>송신측과 수신측 사이에 동기를 맞추기 위한 클럭 신호를 사용하지 않음</li>
  <li>시작비트는 수신측에 문자에 해당하는 비트가 따라올 것이라는 것을 알려주는 역할</li>
  <li>문자 비트들을 모두 수신하면 정지비트가 뒤따른다.</li>
  <li>키보드와 프린터 같이 느린 장치들을 위해 사용되며 높은 오버헤드를 가진다.</li>
</ul>

<h2 id="동기식-전송">동기식 전송</h2>
<ul>
  <li>정해진 수 만큼의 문자들을 하나의 그룹(프레임)으로 만들어서 일시에 전송하는 방법</li>
  <li>일반적으로 비동기식 전송에 비해서 더 빠르다.</li>
  <li>송신측과 수신측이 하나의 기준 클럭으로 동기신호를 맞추어 동작</li>
  <li>동기화를 위한 클럭라인이 필요하다.</li>
  <li>일반적으로 많이 사용하는 방식</li>
</ul>

<h3 id="바이트기반-전송byte-oriented-transmission">바이트기반 전송(Byte-Oriented Transmission)</h3>
<ul>
  <li>각 프레임을 바이트(문자)의 연속으로 간주하는 방식</li>
  <li>STX(Start of Text), ETX(End of Text), DLE(Data-Link Escape)로 프레임의 시작과 끝을 구분</li>
  <li>예) BISYNC, PPP, DDCMP 등</li>
</ul>

<h3 id="비트기반-전송bit-oriented-transmission">비트기반 전송(Bit-Oriented Transmission)</h3>
<ul>
  <li>일반적으로 많이 사용하는 방식</li>
  <li>각 프레임을 비트의 연속으로 간주하는 방식</li>
  <li>프레임의 시작과 끝을 알리기 위해 플래그(Flag)라고 하는 특수한 비트 패턴, “01111110”을 사용</li>
  <li>예) 인터넷에서의 이더넷(Ethernet)과 HDLC(High-level Data Link Control) 등<br /><br /></li>
</ul>

<h2 id="비트-스터핑bit-stuffing">비트 스터핑(Bit Stuffing)</h2>
<ul>
  <li>비트기반 전송에서 프레임의 시작과 끝이 아닌 데이터 필드에 프레임의 시작과 끝을 알리는 플래그가 포함될 수 있다. 그러면 전송이 아직 끝나지 않았는데 수신측에서는 전송이 끝난 것으로 간주하고 데이터 받기를 중단할 것이다.</li>
  <li>그래서 이걸 해결하기 위해 사용하는 기법이 비트 스터핑 기법이다.</li>
</ul>

<h3 id="비트-스터핑-방법">비트 스터핑 방법</h3>
<ul>
  <li>송신측 : 보낼 프레임의 데이터 필드에서 연속된 5개의 1을 발견하면 다섯 번째 1 뒤에 0을 추가함. 이렇게 하면 시작과 끝 부분 외에는 1이 연속해서 6개 위치하는 경우가 없어진다.</li>
  <li>수신측 : 연속되는 5개의 1이 수신되고 나서 0이 수신되면 이 0은 비트 스터핑 된 것이라 간주하고 제거함<br /><br /><br /></li>
</ul>

<h2 id="단방향-반이중-전이중">단방향, 반이중, 전이중</h2>
<h3 id="단방향simplex">단방향(Simplex)</h3>
<ul>
  <li>한 방향으로만 신호 전송이 가능한 형태</li>
  <li>예) 공항 모니터, 프린터, TV 방송</li>
</ul>

<h3 id="반이중half-duplex">반이중(Half duplex)</h3>
<ul>
  <li>양쪽 방향에서 보내고 받을 수 있지만 교대로 전송만 가능</li>
  <li>예) 무전기</li>
</ul>

<h3 id="전이중full-duplex">전이중(Full duplex)</h3>
<ul>
  <li>양쪽 호스트가 동시에 데이터전송 가능</li>
  <li>예) 인터넷<br /><br /><br /></li>
</ul>

<h1 id="교환-기술">교환 기술</h1>
<ul>
  <li>N개의 통신 장비를 각각 직접 연결하면 필요한 연결선의 갯수가 너무 많아진다.</li>
  <li>이것에 대한 해결방안으로 각각의 장비들은 통신망에 연결한 뒤 통신망을 이용해 서로 데이터를 주고 받는데 이걸 좀 더 효과적으로 운영하기 위해 교환 기술(Switching Technology)을 사용한다.</li>
</ul>

<h2 id="회선-교환circuit-switching">회선 교환(Circuit Switching)</h2>
<ul>
  <li>공중 전화 망에서 사용</li>
  <li>데이터 전송 과정 : 회선 설정 - 데이터 전송 - 회선 해제</li>
  <li>단점 : 회선을 설정하고 해제할 때까지 채널의 대역폭을 독점하기 때문에 다른 회선을 동시에 사용할 수 없다.</li>
  <li>장점 : 단점의 이유로 신뢰성 있는 데이터 전송이 가능하며 일정한 데이터 전송률로 데이터를 전송한다.</li>
  <li>회선 설정(call setup) 시간이 필요하며 링크 및 스위칭 장비가 성능에 영향을 미친다.<br /><br /><br /></li>
</ul>

<h1 id="오류-검출과-교정기법">오류 검출과 교정기법</h1>
<h2 id="해밍코드오류-교정-코드">해밍코드(오류 교정 코드)</h2>
<ul>
  <li>N 비트의 데이터에 k개의 패리티 비트를 더하여 (n+k)비트의 코드워드(Codeword)를 생성</li>
  <li>일종의 비트마스킹 기법으로 오류를 검출할 수 있다.</li>
  <li>N개의 비트를 사용해서 오류가 생긴 비트를 검출할 것이기 때문에 N 비트 데이터와 k개의 패리티 비트를 사용한다고 할 때 <code class="language-plaintext highlighter-rouge">2^k &gt;= n + k + 1</code> 라는 수식이 성립해야 한다.(1을 더해주는 이유는 오류가 생기지 않는 경우도 표현하기 위해서)</li>
  <li>수신측은 <code class="language-plaintext highlighter-rouge">XOR</code> 연산을 통해 syndrome을 계산해서 syndrome을 10진수로 바꾼 값이 오류발생 위치(syndrome의 모든 비트가 0이면 오류가 없음)<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1357811&amp;ar=relateCourse">데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Network" /><category term="CS" /><category term="Network" /><summary type="html"><![CDATA[전송 모드 병렬 전송(Parallel Transfer) 여러 전송라인을 통해 여러 비트들을 동시에 전송 두 장치들간의 거리가 짧은 경우에 일반적으로 사용 예) PC에서 프린터로 전송하는 것 예) 컴퓨터와 주변 장치들간의 연결 긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.]]></summary></entry><entry><title type="html">컴퓨터구조) Instructions</title><link href="http://localhost:4000/computer%20science/computer-architecture-03/" rel="alternate" type="text/html" title="컴퓨터구조) Instructions" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/computer-architecture-03</id><content type="html" xml:base="http://localhost:4000/computer%20science/computer-architecture-03/"><![CDATA[<h1 id="instruction-set">Instruction Set</h1>
<ul>
  <li>프로세서에서 지원하는 명령어들의 집합</li>
  <li>다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다.</li>
  <li>현대 컴퓨터는 대부분 간단한 명령어셋(<code class="language-plaintext highlighter-rouge">MIPS</code> - <code class="language-plaintext highlighter-rouge">RISK</code> 방식)을 가지고 있다.</li>
</ul>

<h2 id="instruction-set-architecture-isa">Instruction Set Architecture (ISA)</h2>
<ul>
  <li>하드웨어와 낮은 레벨의 소프트웨어를 연결하는 인터페이스로 시스템 소프트웨어(운영체제)라 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">ISA</code>가 같으면 같은 소프트웨어를 여러 개의 <code class="language-plaintext highlighter-rouge">CPU</code>에서 실행할 수 있다.</li>
</ul>

<h2 id="abi">ABI</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ISA</code>와 운영체제 인터페이스를 합친 것</li>
  <li><code class="language-plaintext highlighter-rouge">ABI</code>만 같으면 같은 프로그램이 어디에서든 실행될 수 있다.</li>
  <li>윈도우 운영체제를 쓰는 컴퓨터들은 어떤 컴퓨터를 쓰든 같은 프로그램을 실행할 수 있는 것<br /><br /><br /></li>
</ul>

<h1 id="design-principle">Design Principle</h1>
<h2 id="1-정규화규칙화해서-간단하게-만들기">1. 정규화(규칙화)해서 간단하게 만들기</h2>
<ul>
  <li>간단할수록 저비용으로 고성능을 만들기가 쉽다.</li>
</ul>

<h2 id="2-메모리-용량이-작은-것이-빠르다">2. 메모리 용량이 작은 것이 빠르다</h2>
<ul>
  <li>메모리 용량을 작은 레지스터를 최대한 활용하는 것이 성능 향상에 도움이 된다.</li>
</ul>

<h2 id="3-공통-케이스는-빠르게-만들기">3. 공통 케이스는 빠르게 만들기</h2>
<ul>
  <li>자주 사용하고 비중이 높은 연산은 빠르게 처리하도록 만드는 것이 성능 향상에 좋다.</li>
</ul>

<h2 id="4-좋은-디자인을-위해-최대한-통일하기">4. 좋은 디자인을 위해 최대한 통일하기</h2>
<ul>
  <li>명령어의 포맷 가짓수는 최대한 줄이고 통일하는 것이 좋다.</li>
  <li>포맷이 다르면 디코딩 하는 데 복잡해지고 이것은 성능 하락으로 이어지기 때문이다. <br /><br /><br /></li>
</ul>

<h1 id="operations-of-the-computer-hardware">Operations of the Computer Hardware</h1>
<h2 id="arithmetic-operations-산술연산">Arithmetic Operations (산술연산)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">register</code> 간 연산으로 <code class="language-plaintext highlighter-rouge">RISK</code> 프로세서 방식</li>
  <li><code class="language-plaintext highlighter-rouge">add</code>와 <code class="language-plaintext highlighter-rouge">subtract</code>, 더하기와 빼기로 이루어져 있으며 피연산자 3개가 필요하다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add a, b, c
</code></pre></div></div>

<ul>
  <li>위와 같이 쓰면 <code class="language-plaintext highlighter-rouge">b</code>와 <code class="language-plaintext highlighter-rouge">c</code>를 더한 값을 <code class="language-plaintext highlighter-rouge">a</code>에 저장해라는 의미<br /><br /><br /></li>
</ul>

<h1 id="operands-of-the-computer-hardware">Operands of the Computer Hardware</h1>
<h2 id="register-operands">Register Operands</h2>
<ul>
  <li>자주 사용하는 데이터에 빠르게 접근하기 위해서 레지스터를 사용한다.</li>
  <li>32개의 <code class="language-plaintext highlighter-rouge">bit</code>로 이루어져 있으며 <code class="language-plaintext highlighter-rouge">word</code>라 부른다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>는 32개의 <code class="language-plaintext highlighter-rouge">32bit</code> 레지스터 파일을 가지고 있다.</li>
</ul>

<h2 id="byte-addresses">Byte Addresses</h2>
<ul>
  <li>대부분의 아키텍처는 <code class="language-plaintext highlighter-rouge">byte</code> 단위로 메모리를 관리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">word</code>는 <code class="language-plaintext highlighter-rouge">4bytes</code>로 이루어져 있으며 이것은 하나의 명령어 단위가 된다.</li>
  <li>레지스터에 있는 데이터를 메모리에 저장할 때 자리수가 큰 게 최하위 비트(LSB)에 오면 <code class="language-plaintext highlighter-rouge">Big Endian</code>, 자리수가 제일 작은 것이 최하위 비트에 오면 <code class="language-plaintext highlighter-rouge">Little Endian</code>이라 한다.</li>
</ul>

<h2 id="memory-operands">Memory Operands</h2>
<ul>
  <li>메인 메모리는 자료의 집합을 이용한다.</li>
  <li>산술 연산을 하기 위해서 메모리에 접근할 수 있는 명령어가 지정되어 있다.(<code class="language-plaintext highlighter-rouge">Load/Store</code>)</li>
  <li>메모리는 <code class="language-plaintext highlighter-rouge">8bit</code> 크기의 주소로 이루어져 있다.</li>
  <li>모든 명령어의 크기는 <code class="language-plaintext highlighter-rouge">4bytes</code>이기 때문에 메모리 주소 또한 <code class="language-plaintext highlighter-rouge">4bytes</code> 간격으로 나열되어 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>는 빅 엔디안 방식을 사용한다.</li>
</ul>

<h2 id="registers-vs-memory">Registers vs. Memory</h2>
<ul>
  <li>레지스터가 메모리에 접근하는 것 보다 훨씬 빠르다.</li>
  <li>그래서 메모리 접근을 최대한 줄이고 레지스터에서 연산하는 것이 성능 향상에 좋은데 그렇다고 너무 레지스터만 써도 성능이 떨어지니까 자주 쓰지 않는 데이터는 메모리로 내려주는 것이 좋다.</li>
  <li>한 주소는 <code class="language-plaintext highlighter-rouge">32bit</code>로 이루어져 있는데 레지스터 하나는 <code class="language-plaintext highlighter-rouge">5bit</code> 크기이기 때문에 메모리에 접근하는 것 보다는 레지스터를 최대한 사용하는 것이 한 번에 처리할 수 있는 코드가 많아진다.</li>
</ul>

<h2 id="immediate-operands">Immediate Operands</h2>
<ul>
  <li>피연산자 중에 하나가 상수일 때 사용하는 명령어</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $s3 , $s3, 4 // 동작은 add와 같음
addi $s2, $s1, -1 // 뺄셈은 -1 사용
</code></pre></div></div>

<ul>
  <li>상수를 레지스터에서 만들어 쓰지 않으면 메모리에 접근해서 가져와야 하는데 이러면 느리다.</li>
  <li>그래서 0 같이 자주 사용되는 상수는 메모리에 접근할 필요 없이 레지스터에서 바로 연산하면 훨씬 빠르다.</li>
</ul>

<h2 id="constant-zero">Constant Zero</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$zero</code>라고 표시하며 <code class="language-plaintext highlighter-rouge">read only</code>로만 사용할 수 있다.</li>
  <li>주로 레지스터간 <code class="language-plaintext highlighter-rouge">move</code>연산을 할 때 사용하는데</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add $t1, $s1, $zero
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">move</code>와 같은 명령어를 따로 만들어서 사용하는 것 보다 <code class="language-plaintext highlighter-rouge">add</code>연산을 하는데 나머지 연산자를 0으로 만들어서 사용하면 <code class="language-plaintext highlighter-rouge">move/copy</code>와 같은 효과를 낼 수 있어서 명령어를 따로 만들지 않고 이렇게 쓴다.</li>
  <li>왜냐면 명령어 셋은 최대한 간단한 것이 성능 향상에 좋기 때문이다.</li>
  <li>어떤 특정 연산 처리만을 위한 명령어를 많이 만들어 쓰다 보면 구현 자체도 쉽지 않지만 구현해도 그 명령어를 처리하는 시간이 다른 쉬운 명령어보다 늘어나는데, 그 늘어난 시간은 다른 간단한 명령어의 실행 시간에도 영향을 미쳐서 다 같이 느려진다.<br /><br /><br /></li>
</ul>

<h1 id="logical-operations">Logical Operations</h1>
<h2 id="시프트-연산자">시프트 연산자</h2>
<ul>
  <li>왼쪽 시프트
    <ul>
      <li>시프트하면서 생기는 빈 비트는 0으로 채운다.</li>
      <li>원래 값에 2^i 을 곱한 효과(음수, 양수 둘 다 적용)</li>
    </ul>
  </li>
  <li>오른쪽 시프트
    <ul>
      <li>시프트하면서 생기는 빈 비트는 0으로 채운다.</li>
      <li>원래 값을 2^i 만큼 나눈 효과(양수에만 적용됨)</li>
    </ul>
  </li>
</ul>

<h2 id="비트-연산자">비트 연산자</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">nor</code> 연산자를 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>에는 NOT 연산자가 없기 때문에 대신 <code class="language-plaintext highlighter-rouge">nor</code> 연산자(a도 아니고 b도 아니다)를 사용해서 NOT 연산자와 같은 효과를 낸다.<br /><br /><br /></li>
</ul>

<h1 id="instructinos-for-making-decisions">Instructinos for Making Decisions</h1>
<h2 id="conditional-operations">Conditional Operations</h2>
<ul>
  <li>어떤 조건이 <code class="language-plaintext highlighter-rouge">true</code>인 경우에 이름지어져 있는 명령어로 분기를 나누고 <code class="language-plaintext highlighter-rouge">false</code>라면 다음 명령어를 계속 실행하는 것 (if ~ else문)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beq rs, rt, L1 // rs와 rt가 같으면 L1에 있는 명령어 실행
bne rs, rt, L2 // rs와 rt가 같지 않으면 L1에 있는 명령어 실행
j L1 // 무조건 L1으로 Jump하는 것
</code></pre></div></div>
<ul>
  <li>어떤 수들의 대소관계 비교도 전용 명령어를 따로 만들지 않고 <code class="language-plaintext highlighter-rouge">beq</code>를 비롯한 여러 명령어들을 조합해서 쓰는 것이 성능 면에서 더 좋기 때문에 조합해서 쓴다.<br /><br /><br /></li>
</ul>

<h1 id="명령-실행-단계">명령 실행 단계</h1>
<p>1) <code class="language-plaintext highlighter-rouge">caller</code>가 <code class="language-plaintext highlighter-rouge">callee</code>에게 파라미터를 넘긴다.
2) <code class="language-plaintext highlighter-rouge">caller</code>가 <code class="language-plaintext highlighter-rouge">callee</code>에게 제어권을 넘긴다.(실행)
3) <code class="language-plaintext highlighter-rouge">callee</code>가 스택에 메모리를 할당한다.
4) <code class="language-plaintext highlighter-rouge">callee</code>가 태스크를 수행한다.
5) <code class="language-plaintext highlighter-rouge">callee</code>가 <code class="language-plaintext highlighter-rouge">caller</code>가 접근할 수 있는 곳에 결과를 둔다.
6) <code class="language-plaintext highlighter-rouge">callee</code>가 <code class="language-plaintext highlighter-rouge">caller</code>에게 제어권을 넘긴다.<br /><br /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Procedure</code> 실행에는 <code class="language-plaintext highlighter-rouge">Leaf</code>와 <code class="language-plaintext highlighter-rouge">Non-Leaf</code> 방식이 있는데 <code class="language-plaintext highlighter-rouge">Leaf</code>는 자기 자신을 포함한 어떤 함수도 호출하지 않는 것이고 <code class="language-plaintext highlighter-rouge">Non-Leaf</code>는 자기 자신을 포함한 함수를 호출하는 것이다.</li>
  <li>프로그래밍 할 때 흔히 작성하는 값 하나를 리턴하고 끝나는 함수는 <code class="language-plaintext highlighter-rouge">Leaf</code> 방식이고 재귀 함수와 같은 형태는 <code class="language-plaintext highlighter-rouge">Non-Leaf</code>로 이루어진다.</li>
</ul>

<h2 id="메모리-영역">메모리 영역</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Text</code> : 프로그램 코드(명령어)가 있는 영역</li>
  <li><code class="language-plaintext highlighter-rouge">Static data</code> : 전역 변수가 있는 영역</li>
  <li><code class="language-plaintext highlighter-rouge">Dynamic data</code> : <code class="language-plaintext highlighter-rouge">heap</code> 영역이라고도 하며 동적으로 할당된 메모리가 있는 영역. 메모리 주소를 가리키는 포인터는 아래에서 위로 이동한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code> : 함수가 호출되면 생기는 지역 변수가 있는 영역. 메모리 주소를 가리키는 포인터는 위에서 아래로 이동한다.<br /><br /><br /></li>
</ul>

<h1 id="코드가-실행되는-과정">코드가 실행되는 과정</h1>
<p>1) 프로그래밍 언어로 프로그램을 작성한다.
2) 컴파일러가 어셈블리어로 번역한다.
3) 어셈블러가 기계어로 번역한다.
4) 기계어로 번역하면서 내가 쓴 코드를 이용해서 만든 기계어 오브젝트와 라이브러리에서 가져오는 코드로 만든 오브젝트가 생기는데 링커가 두 오브젝트 코드들을 합쳐서 실행파일로 만든다.
5) 로더가 실행파일을 메모리에 올려서 실행상태로 만든다.<br /><br /><br /></p>

<h1 id="알고리즘과-수행속도">알고리즘과 수행속도</h1>
<ul>
  <li>명령어 수와 <code class="language-plaintext highlighter-rouge">CPI</code>가 낮은 것이 무조건 성능이 좋은 것은 아니다. 성능에 영향을 미치는 것은 여러가지 요인이 있다.</li>
  <li>컴파일러 최적화는 알고리즘에 영향을 많이 받는다.</li>
  <li>그렇기 때문에 뭐니뭐니해도 알고리즘이 효율적이어야 성능이 좋아진다.<br /><br /><br /></li>
</ul>

<h1 id="배열과-포인터">배열과 포인터</h1>
<ul>
  <li>둘 다 배열을 다룰 때 사용할 수 있지만 배열 인덱스에 접근하려면 내부적으로 인덱스의 주소값을 계산하는 과정이 필요하다. (시작 주소에서부터 몇 칸 떨어져 있는지…)</li>
  <li>하지만 포인터는 그런 연산이 필요없이 그냥 4씩 더해주면서 다음 메모리 주소로 이동하면 된다.</li>
  <li>그렇지만… 최신 컴파일러는 내가 직접 포인터 연산하는 코드를 쓰는 것과 배열 인덱스로 접근하는 코드가 같은 성능을 낼 수 있도록 최적화를 다 해 준다.</li>
  <li>그래서 같은 동작을 수행하는 코드라면 배열 인덱스를 사용하는 코드를 써도 무방하며 포인터를 사용한 코드보다 이해하기도 더 쉽다. 포인터에 비해 버그를 일으키는 코드를 작성할 확률도 줄어드니까 그냥 배열을 쓰자.<br /><br /><br /></li>
</ul>

<h1 id="x86-instructions">x86 Instructions</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>와는 명령어 셋이 다르며 설계 면에서도 차이가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>에 비해 다소 복잡하게 설계되어 있어 고성능으로 만들기 어려운 <code class="language-plaintext highlighter-rouge">CISK</code> 아키텍처다.</li>
  <li>그래서 고성능을 내기 위해 하드웨어가 내부적으로 복잡한 원래 명령어를 간단한 명령어들로 쪼갠 다음에 실행하는 방식을 쓴다.(결국 <code class="language-plaintext highlighter-rouge">RISC</code>와 같은 매커니즘으로 실행되게 된다고 볼 수 있다)</li>
  <li>이렇게 보면 인텔은 진작에 망했어야 할 거 같지만 시장 점유율을 성공적으로 높이면서 자리잡았기 때문에 인텔 프로세서에서 실행되는 프로그램들이 많다보니 여전히 높은 점유율을 차지하며 지금까지 오고 있는 것이다.<br /><br /><br /></li>
</ul>

<h1 id="결론">결론</h1>
<ul>
  <li>명령어 여러 개를 한꺼번에 처리하면 효율적이겠지만 그만큼 하드웨어 게이트(로직) 수가 많아지면서 실행 속도가 느려진다. 그리고 다른 명령어도 같이 느려진다.</li>
  <li>그래서 간단한 명령어를 여러개 조합해서 쓰는 것이 효율적이다. (<code class="language-plaintext highlighter-rouge">RISK Processor</code> 철학)</li>
  <li>어셈블리 코드를 쓰면 기계어와 가까워서 좋은 성능을 낼 수 있지만 최신 컴파일러는 <code class="language-plaintext highlighter-rouge">C</code> 언어와 같은 고급 언어로 쓴 코드도 어셈블리어와 비슷한 성능을 낼 수 있도록 최적화를 다 해 주기 때문에 그냥 고급 언어를 쓰는 것이 생산성이 더 높고 좋다. (어셈블리어는 생산성이 낮다)<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=16bd07027739ad22">컴퓨터구조 - 영남대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><category term="Instruction" /><summary type="html"><![CDATA[Instruction Set 프로세서에서 지원하는 명령어들의 집합 다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다. 현대 컴퓨터는 대부분 간단한 명령어셋(MIPS - RISK 방식)을 가지고 있다.]]></summary></entry></feed>