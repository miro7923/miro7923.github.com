<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-15T23:12:42+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 1002. 터렛</title><link href="http://localhost:4000/boj/boj1002-java/" rel="alternate" type="text/html" title="Java) BOJ 1002. 터렛" /><published>2022-02-15T00:00:00+09:00</published><updated>2022-02-15T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1002-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1002-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1002">https://www.acmicpc.net/problem/1002</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.</li>
  <li>이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다.</li>
  <li>조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.</li>
  <li>조규현의 좌표 (x1, y1)와 백승환의 좌표 (x2, y2)가 주어지고, 조규현이 계산한 류재명과의 거리 r1과 백승환이 계산한 류재명과의 거리 r2가 주어졌을 때,</li>
  <li>류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.</li>
  <li>한 줄에 x1, y1, r1, x2, y2, r2가 주어진다. x1, y1, x2, y2는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이고,</li>
  <li>r1, r2는 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 무슨 문제인가 싶어서 질문게시판을 보니까 두 원 사이의 접점을 구하는 문제였다.</li>
  <li>두 원의 관계는 내접하는 경우, 외접하는 경우, 만나지 않는 경우, 겹쳐지는 경우가 있는데</li>
  <li>내접과 외접하는 경우에는 접점이 1개이다. (원 그려보면 됨)</li>
  <li>만나지 않는 경우에는 접점이 0이다. 이 땐 서로 멀리 떨어져 있거나 큰 원 안에 작은 원이 있는데 두 원 사이의 접점이 없는 경우이다.</li>
  <li>겹쳐지는 경우에는 완전히 똑같이 겹쳐지느냐 조금 겹쳐지느냐에 따라 달라지는데</li>
  <li>원점의 위치가 똑같고 반지름도 똑같으면 완전히 겹쳐진다. 이럴 때엔 원의 테두리 어디에든 존재할 수 있으니 무한대이다.</li>
  <li>
    <p>조금 겹쳐지는 경우엔 접점이 항상 2개이다. (이것도 원 그려보면 됨)<br /><br /></p>
  </li>
  <li>원이 서로 내접하는지 아닌지 보려면 두 원점 사이의 거리를 구해야 하는데 이것은 피타고라스의 정리로 구했다.</li>
  <li>그런데 피타고라스의 정리를 사용하면 거리는 원래 거리의 제곱값이 나오기 때문에 이것의 제곱근을 구하기 위해 sqrt 함수를 사용했는데 여기서 오차가 생겨서 틀렸다.</li>
  <li>4의 제곱근을 구하는 경우라면 문제 없지만 5의 제곱근을 구하는 경우에는 정수로 나눠 떨어지지 않으니까… 여기서 오차가 생긴다.</li>
  <li>
    <p>그래서 두 원점 사이의 거리는 제곱한 상태로 사용해야 한다.<br /><br /></p>
  </li>
  <li>그래서 위의 케이스들을 잘 나눠서 분기처리를 해주면 되는데 처음에는 내접하는 경우와 큰 원 안에 작은 원이 있는데 접점이 없는 경우를 생각하지 못해서 틀렸다.</li>
  <li>처음에는 두 원점 사이의 거리와 두 반지름의 합만을 이용해서 연산을 했기 때문에 내접하거나 큰 원 안에 작은 원이 있는제 접점이 없는 경우를 처리할 수 없었다.</li>
  <li>(다 귀찮아서 원을 안 그려봐서 생긴 일…)</li>
  <li>그래서 또 질문게시판을 참고해서 원을 그려보니까 두 반지름의 차도 이용을 해야 완벽하게 답을 구할 수 있다는 것을 알게 되었다.</li>
  <li>두 원점 사이의 거리와 두 반지름의 차가 같으면 내접하고 (거리와 합이 같으면 외접)</li>
  <li>두 원점 사이의 거리가 두 반지름의 차보다 작으면 큰 원 안의 작은 원이 접점이 없는 경우였다. (합보다 작으면 서로 겹침)</li>
  <li>
    <p>=&gt; 이거 해결하고 통과했다.<br /><br /></p>
  </li>
  <li>그래서 최종적인 분기처리는
    <ol>
      <li>두 원의 원점이 같고 반지름도 같으면 -1</li>
      <li>원점이 같지만 반지름이 다르면 -1</li>
      <li>거리의 제곱이 반지름 합의 제곱과 같거나 반지름 차의 제곱과 같으면 1</li>
      <li>거리의 제곱이 반지름 합의 제곱보다 크거나 반지름 차의 제곱보다 작으면 0</li>
      <li>나머지 경우는 2<br /><br /></li>
    </ol>
  </li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 136 ms</li>
  <li>메모리 : 14292 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8d5e174a8b0e3b6d4b77580e1424b9c7.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1002" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1002 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Mac) Java OpenJDK 버전 여러개 설치해 놓고 돌려가며 쓰기</title><link href="http://localhost:4000/java/set-java-version/" rel="alternate" type="text/html" title="Mac) Java OpenJDK 버전 여러개 설치해 놓고 돌려가며 쓰기" /><published>2022-02-15T00:00:00+09:00</published><updated>2022-02-15T00:00:00+09:00</updated><id>http://localhost:4000/java/set-java-version</id><content type="html" xml:base="http://localhost:4000/java/set-java-version/"><![CDATA[<p>👀 터미널에서 단어 하나만 입력하면 <code class="language-plaintext highlighter-rouge">OpenJDK 8</code> 버전과 <code class="language-plaintext highlighter-rouge">OpenJDK 11</code> 버전을 그 때 그 때 기본으로 세팅할 수 있다.</p>

<h1 id="homebrew로-openjdk-설치">Homebrew로 OpenJDK 설치</h1>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ruby</span> <span class="o">-</span><span class="n">e</span> <span class="s">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Homebrew</code>가 설치되어 있지 않다면 위 명령어를 터미널에 입력해서 설치한다.</li>
  <li>처음엔 그림도 없고 <code class="language-plaintext highlighter-rouge">CLI</code> 환경이라 겁 먹었는데 적응되니까 세상에서 젤 편한 브루~ 😄
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">brew</span> <span class="n">install</span> <span class="o">--</span><span class="n">cask</span> <span class="n">adoptopenjdk</span>
</code></pre></div></div>
<ul>
  <li>브루용 터미널을 켠 다음에 위 명령어를 입력하면 현재 <code class="language-plaintext highlighter-rouge">OpenJDK</code>의 최신버전을 설치할 수 있다.</li>
  <li>현재 17, 18 버전까지 나와있는데 많이 사용하는 버전은 8과 11 버전인 거 같다.</li>
  <li>그래서 나도 8과 11 버전만 설치할 것이다.</li>
</ul>

<h2 id="버전별-명령어-리스트">버전별 명령어 리스트</h2>
<p><img src="../../assets/images/openjdkVersions.png" alt="openjdkVersions" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">brew</span> <span class="n">tap</span> <span class="nc">AdoptOpenJDK</span><span class="o">/</span><span class="n">openjdk</span>
<span class="n">brew</span> <span class="n">install</span> <span class="o">--</span><span class="n">cask</span> <span class="n">adoptopenjdk11</span>
</code></pre></div></div>
<ul>
  <li>현재 8버전은 깔려 있어서 11버전만 추가로 설치했다.</li>
  <li>위 목록에서 설치하고 싶은 버전을 <code class="language-plaintext highlighter-rouge">--cask</code> 뒤에 입력하면 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Homebrew</code>를 통해 설치하는 것은 정식 루트를 통하는 것은 아니고 커뮤니티에 배포되어 있는 것을 사용하는 것이라고 하는데 오라클 JDK가 유료화 된 이후로 다 이렇게 써서 문제 되는 것은 없다고 한다. 
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">🍺</span>  <span class="n">adoptopenjdk11</span> <span class="n">was</span> <span class="n">successfully</span> <span class="n">installed</span><span class="o">!</span>
</code></pre></div></div>
<ul>
  <li>정상적으로 설치가 되면 마지막에 성공적으로 설치되었다는 메세지를 볼 수 있다. 
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">java</span> <span class="o">-</span><span class="n">version</span>
<span class="n">openjdk</span> <span class="n">version</span> <span class="s">"1.8.0_302"</span>
<span class="nc">OpenJDK</span> <span class="nc">Runtime</span> <span class="nf">Environment</span> <span class="o">(</span><span class="nc">Temurin</span><span class="o">)(</span><span class="n">build</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_302</span><span class="o">-</span><span class="n">b08</span><span class="o">)</span>
<span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nf">VM</span> <span class="o">(</span><span class="nc">Temurin</span><span class="o">)(</span><span class="n">build</span> <span class="mf">25.302</span><span class="o">-</span><span class="n">b08</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>현재 사용중인 자바의 버전을 확인해보면 기존에 사용하던 것이 있어서 8버전이 나온다.
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="no">V</span>
<span class="nc">Matching</span> <span class="nc">Java</span> <span class="nc">Virtual</span> <span class="nf">Machines</span> <span class="o">(</span><span class="mi">3</span><span class="o">):</span>
    <span class="mf">11.0</span><span class="o">.</span><span class="mi">11</span> <span class="o">(</span><span class="n">x86_64</span><span class="o">)</span> <span class="s">"AdoptOpenJDK"</span> <span class="o">-</span> <span class="s">"AdoptOpenJDK 11"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">adoptopenjdk</span><span class="o">-</span><span class="mi">11</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_312</span> <span class="o">(</span><span class="n">arm64</span><span class="o">)</span> <span class="s">"Azul Systems, Inc."</span> <span class="o">-</span> <span class="s">"Zulu 8.58.0.13"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">zulu</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_302</span> <span class="o">(</span><span class="n">x86_64</span><span class="o">)</span> <span class="s">"Eclipse Temurin"</span> <span class="o">-</span> <span class="s">"Eclipse Temurin 8"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">temurin</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
</code></pre></div></div>
<ul>
  <li>설치된 모든 자바 버전을 보고 싶으면 <code class="language-plaintext highlighter-rouge">/usr/libexec/java_home -V</code> 명령어를 입력하면 된다.</li>
  <li>사용중이던 8버전 외에 11버전도 추가로 잘 설치된 것을 볼 수 있다. <br /><br /></li>
</ul>

<h1 id="기본으로-사용할-openjdk-버전-바꾸기">기본으로 사용할 OpenJDK 버전 바꾸기</h1>
<ul>
  <li>컴퓨터에 설치된 자바가 하나뿐이라면 그게 자동으로 기본값으로 설정이 되지만 나는 사정상 11로 완전 갈아타면 안 되고 8버전도 써야 하기 때문에 두 개를 바꿔가며 써야 하는데 매번 환경설정을 해주려면 참 귀찮을거 같아서 좀 미뤄왔었다.</li>
  <li>그런데 구글링 해 보니까 완전 편한 방법이 있었다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">export</span> <span class="no">JAVA_HOME</span><span class="o">=</span><span class="err">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.8</span><span class="o">)</span>
<span class="n">export</span> <span class="no">PATH</span><span class="o">=</span><span class="s">"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/sbin:$JAVA_HOME"</span>
<span class="n">alias</span> <span class="n">setJava8</span><span class="o">=</span><span class="err">'</span><span class="n">export</span> <span class="no">JAVA_HOME</span><span class="o">=</span><span class="err">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.8</span><span class="o">)</span><span class="err">'</span>
<span class="n">alias</span> <span class="n">setJava11</span><span class="o">=</span><span class="err">'</span><span class="n">export</span> <span class="no">JAVA_HOME</span><span class="o">=</span><span class="err">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mi">11</span><span class="o">)</span><span class="err">'</span>
</code></pre></div></div>
<ul>
  <li>위 명령어를 한 줄씩 복붙해서 실행하면 자바 버전별로 <code class="language-plaintext highlighter-rouge">앨리어스</code>를 지정해 사용할 수 있다.</li>
  <li>이제 터미널에서 <code class="language-plaintext highlighter-rouge">setJava11</code>만 입력하면 11버전으로 바꿀 수 있다! 8로 돌아가는 것도 마찬가지</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">setJava11</span>
<span class="o">%</span> <span class="n">java</span> <span class="o">-</span><span class="n">version</span>
<span class="n">openjdk</span> <span class="n">version</span> <span class="s">"11.0.11"</span> <span class="mi">2021</span><span class="o">-</span><span class="mo">04</span><span class="o">-</span><span class="mi">20</span>
<span class="nc">OpenJDK</span> <span class="nc">Runtime</span> <span class="nc">Environment</span> <span class="nc">AdoptOpenJDK</span><span class="o">-</span><span class="mf">11.0</span><span class="o">.</span><span class="mi">11</span><span class="o">+</span><span class="mi">9</span> <span class="o">(</span><span class="n">build</span> <span class="mf">11.0</span><span class="o">.</span><span class="mi">11</span><span class="o">+</span><span class="mi">9</span><span class="o">)</span>
<span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="no">VM</span> <span class="nc">AdoptOpenJDK</span><span class="o">-</span><span class="mf">11.0</span><span class="o">.</span><span class="mi">11</span><span class="o">+</span><span class="mi">9</span> <span class="o">(</span><span class="n">build</span> <span class="mf">11.0</span><span class="o">.</span><span class="mi">11</span><span class="o">+</span><span class="mi">9</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>

<span class="o">%</span> <span class="n">setJava8</span>
<span class="o">%</span> <span class="n">java</span> <span class="o">-</span><span class="n">version</span>
<span class="n">openjdk</span> <span class="n">version</span> <span class="s">"1.8.0_312"</span>
<span class="nc">OpenJDK</span> <span class="nc">Runtime</span> <span class="nf">Environment</span> <span class="o">(</span><span class="nc">Zulu</span> <span class="mf">8.58</span><span class="o">.</span><span class="mf">0.13</span><span class="o">-</span><span class="no">CA</span><span class="o">-</span><span class="n">macos</span><span class="o">-</span><span class="n">aarch64</span><span class="o">)</span> <span class="o">(</span><span class="n">build</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_312</span><span class="o">-</span><span class="n">b07</span><span class="o">)</span>
<span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nf">VM</span> <span class="o">(</span><span class="nc">Zulu</span> <span class="mf">8.58</span><span class="o">.</span><span class="mf">0.13</span><span class="o">-</span><span class="no">CA</span><span class="o">-</span><span class="n">macos</span><span class="o">-</span><span class="n">aarch64</span><span class="o">)</span> <span class="o">(</span><span class="n">build</span> <span class="mf">25.312</span><span class="o">-</span><span class="n">b07</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>
</code></pre></div></div>
<p><br /><br /></p>

<h2 id="출처">출처</h2>
<ul>
  <li><a href="https://yonguri.tistory.com/119">[Mac] OpenJDK 버전별로 여러개 설치하기 ( using Homebrew )</a></li>
  <li><a href="https://velog.io/@jsoh/%EC%98%A4%EB%9D%BC%ED%81%B4-JDK%EB%A5%BC-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B3%A0-OpenJDK-11-%EC%84%A4%EC%B9%98">MacOS에서 오라클 JDK를 삭제하고 OpenJDK 11 설치</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Java" /><category term="Java" /><category term="OpenJDK" /><category term="Homebrew" /><summary type="html"><![CDATA[👀 터미널에서 단어 하나만 입력하면 OpenJDK 8 버전과 OpenJDK 11 버전을 그 때 그 때 기본으로 세팅할 수 있다.]]></summary></entry><entry><title type="html">Java) BOJ 3009. 네 번째 점</title><link href="http://localhost:4000/boj/boj3009-java/" rel="alternate" type="text/html" title="Java) BOJ 3009. 네 번째 점" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj3009-java</id><content type="html" xml:base="http://localhost:4000/boj/boj3009-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/3009">https://www.acmicpc.net/problem/3009</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>직사각형의 네 번째 점의 좌표를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>x와 y의 값이 서로 다른 점끼리 더한 값이 같아야 하기 때문에</li>
  <li>입력 받으면서 이전 x와 현재 x의 값이 같지 않으면 두 수를 더해주고 아니라면 수를 보관해 뒀다가 이전 x와 현재 x가 같지 않은 두 수의 합에서 빼 주었다.</li>
  <li>(x, y 각각 적용)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 148 ms</li>
  <li>메모리 : 16056 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/afe7a25ef643fea5a5cb6861ef93fcb8.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No3009" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/3009 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 3053. 택시 기하학</title><link href="http://localhost:4000/boj/boj3053-java/" rel="alternate" type="text/html" title="Java) BOJ 3053. 택시 기하학" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj3053-java</id><content type="html" xml:base="http://localhost:4000/boj/boj3053-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/3053">https://www.acmicpc.net/problem/3053</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>19세기 독일 수학자 헤르만 민코프스키는 비유클리드 기하학 중 택시 기하학을 고안했다.</li>
  <li>택시 기하학에서 두 점 T1(x1,y1), T2(x2,y2) 사이의 거리는 다음과 같이 구할 수 있다.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>D(T1,T2) =</td>
          <td>x1-x2</td>
          <td>+</td>
          <td>y1-y2</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>두 점 사이의 거리를 제외한 나머지 정의는 유클리드 기하학에서의 정의와 같다.</li>
  <li>따라서 택시 기하학에서 원의 정의는 유클리드 기하학에서 원의 정의와 같다.</li>
  <li>원: 평면 상의 어떤 점에서 거리가 일정한 점들의 집합</li>
  <li>반지름 R이 주어졌을 때, 유클리드 기하학에서 원의 넓이와, 택시 기하학에서 원의 넓이를 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 반지름 R이 주어진다. R은 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. 정답과의 오차는 0.0001까지 허용한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>유클리드 기하학이랑 택시 기하학이 처음 보는 단어여서 이해하는데 시간이 좀 걸렸는데</li>
  <li>유클리드 기하학은 학교 다닐 때 배웠던 것처럼 <code class="language-plaintext highlighter-rouge">반지름 r의 제곱 * 파이(3.14....)</code>였고</li>
  <li>택시 기하학은 <code class="language-plaintext highlighter-rouge">반지름 r의 제곱 * 2</code> 였다.</li>
  <li>저렇게 구현해서 통과했는데 파이는 무한대로 이어지는 값이라서 <code class="language-plaintext highlighter-rouge">Math</code>에 있는 <code class="language-plaintext highlighter-rouge">PI</code>를 썼다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 132 ms</li>
  <li>메모리 : 14556 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/13217f334d41da7de8cc2eef964c6af6.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No3053" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/3053 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 4153. 직각삼각형</title><link href="http://localhost:4000/boj/boj4153-java/" rel="alternate" type="text/html" title="Java) BOJ 4153. 직각삼각형" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj4153-java</id><content type="html" xml:base="http://localhost:4000/boj/boj4153-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/4153">https://www.acmicpc.net/problem/4153</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>과거 이집트인들은 각 변들의 길이가 3, 4, 5인 삼각형이 직각 삼각형인것을 알아냈다. 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>입력은 여러개의 테스트케이스로 주어지며 마지막줄에는 0 0 0이 입력된다. 각 테스트케이스는 모두 30,000보다 작은 양의 정수로 주어지며, 각 입력은 변의 길이를 의미한다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 입력에 대해 직각 삼각형이 맞다면 “right”, 아니라면 “wrong”을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>피타고라스의 정리로 풀었는데 예제에는 입력이 오름차순으로만 주어져 있어서 처음엔 (a의 제곱 + b의 제곱 = c의 제곱) 수식을 썼는데</li>
  <li>중간에 입력이 오름차순으로 들어오지 않는 경우가 있는지 틀렸다.</li>
  <li>문제에 오름차순으로 입력이 들어온다는 말이 없어서 예상했긴 하지만… 처음부터 그냥 예외처리 해서 쓸 걸 그랬다.</li>
  <li>세 수 중 최대값과 나머지 두 수를 찾아서 피타고라스의 정리 수식을 적용해 주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 124 ms</li>
  <li>메모리 : 14012 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/196d69b177d3d418eaaa0638d14ae211.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No4153" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/4153 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 1085. 직사각형에서 탈출</title><link href="http://localhost:4000/boj/boj9020-java/" rel="alternate" type="text/html" title="Java) BOJ 1085. 직사각형에서 탈출" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj9020-java</id><content type="html" xml:base="http://localhost:4000/boj/boj9020-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1085">https://www.acmicpc.net/problem/1085</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다.</li>
  <li>직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 x, y, w, h가 주어진다.</li>
  <li>1 ≤ w, h ≤ 1,000</li>
  <li>1 ≤ x ≤ w-1</li>
  <li>1 ≤ y ≤ h-1</li>
  <li>x, y, w, h는 정수<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 문제의 정답을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>예제를 보니까 (x, y)에서 가로와 세로 직선 방향으로 직사각형의 변으로 가면 되는 것이라</li>
  <li>x는 x와 w - x 값 중 더 작은 값을, y는 y와 h - y 중 더 작은 값을 찾은 다음에 저 둘 중 더 작은 값을 최종 출력하면 정답인 거 같아서 그대로 썼는데 통과되었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 140 ms</li>
  <li>메모리 : 14216 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/842a7990b2c0aeee814beb998cd21d67.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1085" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1085 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 11653. 소인수분해</title><link href="http://localhost:4000/boj/boj11653-java/" rel="alternate" type="text/html" title="Java) BOJ 11653. 소인수분해" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11653-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11653-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11653">https://www.acmicpc.net/problem/11653</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>소인수분해 하는 방법 그대로 코드로 구현했다.</li>
  <li>2부터 시작해서 N이 2로 나눠 떨어지면 N을 2로 나누고 2를 출력하고 나눠 떨어지지 않으면 1 증가시켜서 다음 수로 같은 과정을 반복하도록 했다.</li>
  <li>최대입력인 10,000,000을 가장 작은 수인 2로 나눠도 최대 5,000,000번의 연산을 하기 때문에 시간복잡도는 충분할 것이라 생각하고 제출해 봤는데 통과되었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 172 ms</li>
  <li>메모리 : 14280 KB</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8e358173fb3a2fe43ebbfc4fe642f2e2.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11653" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11653 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 1011. Fly me to the Alpha Centauri</title><link href="http://localhost:4000/boj/boj1011-java/" rel="alternate" type="text/html" title="Java) BOJ 1011. Fly me to the Alpha Centauri" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1011-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1011-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1011">https://www.acmicpc.net/problem/1011</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다.</li>
  <li>그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.</li>
  <li>그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에,</li>
  <li>그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다.</li>
  <li>하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서,</li>
  <li>이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다.</li>
  <li>예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나</li>
  <li>사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며,</li>
  <li>
    <p>그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. ) <br /><br />
<img src="https://www.acmicpc.net/upload/201003/rlaehdgur.JPG" alt="img" /></p>
  </li>
  <li>김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다.</li>
  <li>하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.</li>
  <li>김우현을 위해 x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다.</li>
  <li>각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x &lt; y &lt; 231)<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/board/view/75491">https://www.acmicpc.net/board/view/75491</a></li>
  <li>
    <p>참고 해설<br /><br /></p>
  </li>
  <li>30분 고민해 봤으나 <code class="language-plaintext highlighter-rouge">k1 = 1, kn = 1</code>이어야 한다까지만 알겠고 나머지 풀이는 영 감이 안 와서 질문게시판을 검색했다.</li>
  <li>내가 처음에 했던 생각에서 아주 구체화 된 풀이를 찾을 수 있었는데</li>
  <li><code class="language-plaintext highlighter-rouge">121</code> <code class="language-plaintext highlighter-rouge">12321</code> <code class="language-plaintext highlighter-rouge">123421</code> <code class="language-plaintext highlighter-rouge">123454321</code> … 이런식으로 이동해야 한다. (각 자리수마다 장치를 작동하는 것임)</li>
  <li>저 수들에서 찾을 수 있는 규칙은 각 자리수의 합은 <code class="language-plaintext highlighter-rouge">2의 제곱</code>, <code class="language-plaintext highlighter-rouge">3의 제곱</code>, <code class="language-plaintext highlighter-rouge">4의 제곱</code>, … 과 같다.</li>
  <li>
    <p>그리고 수의 길이는 <code class="language-plaintext highlighter-rouge">2의 제곱-1</code>, <code class="language-plaintext highlighter-rouge">3의 제곱-1</code>, <code class="language-plaintext highlighter-rouge">4의 제곱-1</code>, … 과 같다. =&gt; 이건 장치의 작동 회수가 된다.<br /><br /></p>
  </li>
  <li>이제 도착지 <code class="language-plaintext highlighter-rouge">y</code>와 출발지 <code class="language-plaintext highlighter-rouge">x</code> 사이의 거리를 구한다.</li>
  <li>그리고 거리보다 작거나 같으면서 가장 가까운 <code class="language-plaintext highlighter-rouge">제곱수</code>의 <code class="language-plaintext highlighter-rouge">제곱근</code>을 구한다. (제곱근 구해주는 함수는 <code class="language-plaintext highlighter-rouge">Math.sqrt()</code> 쓰면 됨)</li>
  <li>그 다음 <code class="language-plaintext highlighter-rouge">거리</code>에서 <code class="language-plaintext highlighter-rouge">제곱수</code>를 뺀다.</li>
  <li>
    <p>이 때 뺀 수가 <code class="language-plaintext highlighter-rouge">0</code>이면 아까 구했던 수의 길이를 그대로 출력하면 되고<br /><br /></p>
  </li>
  <li>예) 이동해야 하는 거리가 25일 때</li>
  <li>25</li>
  <li>
    <p>123454321 &lt;- 5*2-1 = 9 번만에 이동할 수 있다.<br /><br /></p>
  </li>
  <li>0보다 크면서 제곱근보다 작거나 같으면 위에서 구했던 수의 길이에다 1을 더해주면 된다.</li>
  <li>26</li>
  <li>
    <p>1234543211 &lt;- 9번 이동한 다음 1번 더 이동해야 각 자리수를 더한 합이 26이 된다.<br /><br /></p>
  </li>
  <li>27</li>
  <li>
    <p>1234543221 &lt;- 마찬가지로 9번 이동하고 1번 더 이동해야 한다.<br /><br /></p>
  </li>
  <li>28</li>
  <li>
    <p>1234543321<br /><br /></p>
  </li>
  <li>29</li>
  <li>
    <p>1234544321<br /><br /></p>
  </li>
  <li>30</li>
  <li>
    <p>1234554321<br /><br /></p>
  </li>
  <li>
    <p>왜냐면 위의 예시와 같이 중간에 이동할 수 있기 때문이다. <br /><br /></p>
  </li>
  <li>하지만 뺀 수가 0보다 크면서 제곱근보다 크면 수의 길이에다 2를 더해줘야 한다.</li>
  <li>31 (여기서 한자리 숫자가 더 늘어나죠?)</li>
  <li>12345543211 &lt;- 31보다 작으면서 가장 가까운 제곱수는 5<em>5=25이기 때문에 (6</em>6=36은 초과해서 안됨) 31-25를 해야 한다.</li>
  <li>…</li>
  <li>35</li>
  <li>
    <p>12345554321 &lt;- 여기까지는 (5*2-1) + 2 = 11 <br /><br /></p>
  </li>
  <li>36(여기는 6의 제곱)</li>
  <li>
    <p>12345654321 &lt;- 6*2-1 = 11<br /><br /></p>
  </li>
  <li>이 과정을 코드로 구현하면 통과할 수 있다.</li>
  <li>수학 문제는 규칙을 찾는 것이 중요하다는 것을 알 수 있었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 128 ms</li>
  <li>메모리 : 14084 KB</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/37d48b05cb8e98f33ac7988203013727.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1011" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1011 제한 시간 제한 : 2 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 4948. 베르트랑 공준</title><link href="http://localhost:4000/boj/boj4948-java/" rel="alternate" type="text/html" title="Java) BOJ 4948. 베르트랑 공준" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj4948-java</id><content type="html" xml:base="http://localhost:4000/boj/boj4948-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/4948">https://www.acmicpc.net/problem/4948</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.</li>
  <li>이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.</li>
  <li>예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)</li>
  <li>자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.</li>
  <li>입력의 마지막에는 0이 주어진다. 1 ≤ n ≤ 123,456<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>n초과 2n이하의 수들을 소수를 판별하는 연산을 해서 소수면 카운트해서 2n까지 판별이 끝나면 총 개수를 출력했다.</li>
  <li>하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.</li>
  <li>i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.</li>
  <li>예를 들어 i=16라면</li>
  <li>1*16</li>
  <li>2*8</li>
  <li>4*4</li>
  <li>8*2</li>
  <li>16*1</li>
  <li>위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.</li>
  <li>
    <p>그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.<br /><br /></p>
  </li>
  <li><a href="https://notepad96.tistory.com/entry/C-%EC%86%8C%EC%88%98-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0">소수 구하기</a></li>
  <li>예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 696 ms</li>
  <li>메모리 : 14660 KB</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/aefd8a5c816d3e500f28493fdae88fbe.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No4948" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/4948 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 2581. 소수</title><link href="http://localhost:4000/boj/boj2581-java/" rel="alternate" type="text/html" title="Java) BOJ 2581. 소수" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2581-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2581-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2581">https://www.acmicpc.net/problem/2581</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.</li>
  <li>예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로,</li>
  <li>이들 소수의 합은 620이고, 최솟값은 61이 된다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.</li>
  <li>M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.</li>
  <li>단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>소수 구하기는 프로그래밍을 처음 배울 때 풀어봤던 문제이기도 하고 예전에 몇 번 풀어봐서 풀이를 떠올리는 것은 어렵지 않았다.</li>
  <li>하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.</li>
  <li>i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.</li>
  <li>예를 들어 i=16라면</li>
  <li>1*16</li>
  <li>2*8</li>
  <li>4*4</li>
  <li>8*2</li>
  <li>16*1</li>
  <li>위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.</li>
  <li>
    <p>그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.<br /><br /></p>
  </li>
  <li><a href="https://notepad96.tistory.com/entry/C-%EC%86%8C%EC%88%98-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0">C++ 소수 판별하기</a></li>
  <li>
    <p>예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.<br /><br /></p>
  </li>
  <li>이 문제에서는 M 이상 ~ N 이하 범위의 수들을 반복문을 돌리면서 i번째 수가 소수라면 합계에 더해주고 그 중 가장 작은 값도 함께 저장했다.</li>
  <li>입력의 최대값이 10,000이기 때문에 소수를 판별하는 알고리즘은 최대한 빠른 것을 사용했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 128 ms</li>
  <li>메모리 : 14208 KB</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/62010af0c3c1d5f4ee8a0b165d29a66b.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2581" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2581 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry></feed>