<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-13T22:09:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부 기록하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) 프로그래머스 - 숫자 게임</title><link href="http://localhost:4000/programmers/programmers-number-game/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 숫자 게임" /><published>2022-07-13T00:00:00+09:00</published><updated>2022-07-13T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-number-game</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-number-game/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62947">https://school.programmers.co.kr/learn/courses/10302/lessons/62947</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다.</p>
  </li>
  <li>먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다.</li>
  <li>각 사원은 딱 한 번씩 경기를 합니다.</li>
  <li>각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다.</li>
  <li>만약 숫자가 같다면 누구도 승점을 얻지 않습니다.</li>
  <li>전체 사원들은 우선 무작위로 자연수를 하나씩 부여받았습니다. 그다음 A팀은 빠르게 출전순서를 정했고 자신들의 출전 순서를 B팀에게 공개해버렸습니다. B팀은 그것을 보고 자신들의 최종 승점을 가장 높이는 방법으로 팀원들의 출전 순서를 정했습니다. 이때의 B팀이 얻는 승점을 구해주세요.</li>
  <li>A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 A와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 B가 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>A와 B의 길이는 같습니다.</li>
  <li>A와 B의 길이는 1 이상 100,000 이하입니다.</li>
  <li>A와 B의 각 원소는 1 이상 1,000,000,000 이하의 자연수입니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<h2 id="1차-시도">1차 시도</h2>
<ul>
  <li>문제를 보니 경기하는 순서가 중요한 거 같지 않아서 두 배열 모두 오름차순으로 정렬한 다음 <strong>앞</strong>에서부터 비교를 하며 승점을 계산했다. 하지만 정확성 테스트도 모두 통과하지 못해서 다른 방법을 생각해 봤다.</li>
</ul>

<h2 id="2차-시도">2차 시도</h2>
<ul>
  <li>배열 <code class="language-plaintext highlighter-rouge">B</code>만 오름차순으로 정렬한 다음 2중 반복문을 이용해 <code class="language-plaintext highlighter-rouge">A</code>의 원소 하나에 대해 <code class="language-plaintext highlighter-rouge">B</code>의 원소들을 하나씩 대입해 보며 승점을 계산했다.</li>
  <li>정확성 테스트는 통과했지만 효율성 테스트를 시간초과로 통과하지 못했다… 2중 반복문이 원인인 것 같았지만 수정하기 전에 마지막으로 <code class="language-plaintext highlighter-rouge">B</code>를 <code class="language-plaintext highlighter-rouge">ArrayList</code>로 바꾼 다음 사용된 숫자를 배열에서 제거하며 <code class="language-plaintext highlighter-rouge">B</code>의 순회 범위를 줄이는 방식으로도 해 보았다. 하지만 역시 시간초과가 났다.</li>
</ul>

<h2 id="3차-시도">3차 시도</h2>
<ul>
  <li>풀이 강의를 보았다.</li>
  <li>내가 생각한 풀이와 정말 한 끗 차이로 효율성 테스트를 통과하는 풀이였다.</li>
  <li>1차 시도에서처럼 두 배열 모두 오름차순 정렬한 다음 <strong>뒤</strong>에서부터 비교를 시작하되, 배열 인덱스 포인터를 따로 사용하는 것이었다.</li>
  <li>이렇게 하면 반복문을 하나만 사용해서 문제를 해결할 수 있었다.</li>
  <li>자세한 내용은 코드에 주석문으로…<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/b31d9de91d26ef1943e7d862b541a340.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><category term="Simulation" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62947]]></summary></entry><entry><title type="html">정보처리기사) 실기 개념 정리</title><link href="http://localhost:4000/certificate/cs-certificate/" rel="alternate" type="text/html" title="정보처리기사) 실기 개념 정리" /><published>2022-07-13T00:00:00+09:00</published><updated>2022-07-13T00:00:00+09:00</updated><id>http://localhost:4000/certificate/cs-certificate</id><content type="html" xml:base="http://localhost:4000/certificate/cs-certificate/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="소프트웨어-아키텍처-패턴">소프트웨어 아키텍처 패턴</h1>
<ul>
  <li>소프트웨어 설계 시 참조 가능한 솔루션</li>
  <li>일반적으로 발생하는 문제점들에 대해 일반화되고 재사용 가능한 솔루션<br /><br /></li>
</ul>

<h1 id="요구공학">요구공학</h1>
<ul>
  <li>요구사항을 도출, 분석, 명세, 확인하는 구조화된 활동<br /><br /></li>
</ul>

<h2 id="요구사항-분석-기법">요구사항 분석 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">자료 흐름 지향 분석</code> : 데이터 흐름도(DFD)와 자료 사전(DD)을 통해 분석</li>
  <li><code class="language-plaintext highlighter-rouge">객체지향 분석</code> : 시스템 기능과 데이터를 함께 분석해 UML로 표준화</li>
</ul>

<h2 id="요구공학-프로세스">요구공학 프로세스</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">개발 단계(CMM Level 3)</code> : 요구사항 분석</li>
  <li><code class="language-plaintext highlighter-rouge">관리 단계 (CMM Levle 2)</code> : 설계 - 개발 - 테스트를 거치는 동안 요구사항 잘 만족하는지 확인</li>
</ol>

<h2 id="요구공학-개발-단계-구성-cmm-level-3">요구공학 개발 단계 구성 (CMM Level 3)</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">도출</code> : 이해관계자 식별, 고객 분석</li>
  <li><code class="language-plaintext highlighter-rouge">분석</code> : 분류 -&gt; 개념 모델링 생성 -&gt; 할당 -&gt; 협상 -&gt; 분석</li>
  <li><code class="language-plaintext highlighter-rouge">명세</code> : 정형화된 형태로 명세 작성</li>
  <li><code class="language-plaintext highlighter-rouge">확인</code> : 요구사항 이해를 확인하고 문서가 완전한지 검증</li>
</ol>

<h2 id="요구사항-도출-기법">요구사항 도출 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">인터뷰</code> : 직접 대화</li>
  <li><code class="language-plaintext highlighter-rouge">브레인스토밍</code> : 말하기 쉬운 분위기 속에서 비판없이 의견을 수용</li>
  <li><code class="language-plaintext highlighter-rouge">델파이 기법</code> : 전문가 경험 활용</li>
  <li><code class="language-plaintext highlighter-rouge">롤 플레잉</code> : 각자 맡은 역을 연기</li>
  <li><code class="language-plaintext highlighter-rouge">워크숍</code> : 단기간 집중하여 정보 획득 후 공유(사전 준비 필요)</li>
  <li><code class="language-plaintext highlighter-rouge">설문 조사</code></li>
</ul>

<h2 id="요구사항-분석-단계">요구사항 분석 단계</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">요구사항 분류</code> : 기능적 요구사항 (시스템이 제공해야 할 기능) vs 비기능적 요구사항(시스템이 준수해야 할 제약사항)</li>
  <li><code class="language-plaintext highlighter-rouge">개념 모델링 생성</code> : 주로 UML 사용. 요구사항을 쉽게 이해할 수 있도록 개념적 표현</li>
  <li><code class="language-plaintext highlighter-rouge">요구사항 할당</code> : 요구사항 만족을 위한 아키텍처 구성요소 식별</li>
  <li><code class="language-plaintext highlighter-rouge">요구사항 협상</code> : 충돌되는 경우 합의, 우선순위 부여</li>
  <li><code class="language-plaintext highlighter-rouge">정형 분석</code> : 정형화된 언어를 통해 수학적 기호로 표현</li>
</ol>

<h2 id="요구사항-명세-기법">요구사항 명세 기법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">비정형 명세 기법</code> : 자연어 기반 서술</li>
  <li><code class="language-plaintext highlighter-rouge">정형 명세 기법</code> : 수학적 표기법으로 서술</li>
</ol>

<h2 id="요구사항-명세-원리-및-검증-항목">요구사항 명세 원리 및 검증 항목</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">명확성</code> : 각 명세 내용은 하나의 의미만 부여</li>
  <li><code class="language-plaintext highlighter-rouge">완전성</code> : 모든 요구사항이 포함되어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">검증 가능성</code> : 달성 정도를 확인할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">일관성</code> : 모순이 없어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">수정 용이성</code> : 쉽게 수정할 수 있어야 함</li>
  <li><code class="language-plaintext highlighter-rouge">개발 후 이용성</code> : 운영 및 유지보수에 이용이 가능해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">추적 가능성</code> : 추적이 가능해야 함</li>
</ol>

<h2 id="요구사항-확인-기법">요구사항 확인 기법</h2>
<ol>
  <li>정형 기술 검토(TCR)</li>
  <li>프로토타이핑 활용</li>
  <li>테스트 케이스를 통한 확인</li>
  <li>CASE 도구 활용</li>
  <li>베이스라인 검증</li>
  <li>요구사항 추적표 (RTM : Requirement Tracebility Matrix) 통해 검증
    <ul>
      <li>요구사항 정의서 기준으로 개발단계별 최종 산출물이 어떻게 변경되었는지 확인 가능한 문서</li>
    </ul>
  </li>
</ol>

<h2 id="정형-기술-검토-tcr-기법">정형 기술 검토 (TCR) 기법</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">동료 검토 (Peer Review)</code> : 작성자가 설명하고, 이해 관계자들이 설명을 들으며 결함 발견</li>
  <li><code class="language-plaintext highlighter-rouge">워크 스루 (Walk Through)</code> : 검토 자료 사전 배포 후, 짧은 시간 동안 회의 진행</li>
  <li><code class="language-plaintext highlighter-rouge">인스펙션 (Inspection)</code> : 저작자가 아닌 다른 전문가가 검토</li>
  <li>참가자 구성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">주재자(Moderator)</code> : 참가자를 선정하고 계획 및 주재</li>
      <li><code class="language-plaintext highlighter-rouge">작성자</code></li>
      <li><code class="language-plaintext highlighter-rouge">낭독자</code></li>
      <li><code class="language-plaintext highlighter-rouge">기록자</code></li>
      <li><code class="language-plaintext highlighter-rouge">검토자</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">관리 리뷰 (Management Review)</code> : 프로젝트 진행 상황을 전반적으로 검토</li>
  <li><code class="language-plaintext highlighter-rouge">기술 리뷰 (Technical Review)</code> : 명세를 준수하고 있는지 검토</li>
  <li><code class="language-plaintext highlighter-rouge">감사 (Audit)</code> : 제품이 표준이나 가이드라인을 준수하는지 검토. 제품 제공자, 소비자, 제 3기관이 수행</li>
</ul>

<h2 id="요구공학-관리-단계-구성cmm-level-2">요구공학 관리 단계 구성(CMM Level 2)</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">협상</code> : 구현 가능한 기능 협상</li>
  <li><code class="language-plaintext highlighter-rouge">기준선 설정</code> : 기준선(베이스라인) 설정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">베이스라인</code> : 개발 과정의 산출물의 변화를 통제하는 시점</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">변경관리</code> : 형상통제 위원회를 운영하여 변경 관리
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CCB</code> : 형상 관리의 방침을 정하고 산출물을 검토하는 조직</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">확인 및 검증</code> : 요구사항에 부합하는지 확인<br /><br /></li>
</ol>

<h1 id="미들웨어">미들웨어</h1>
<ul>
  <li>컴퓨터와 컴퓨터 간 연결 및 연결 관리를 돕는 소프트웨어<br /><br /></li>
</ul>

<h1 id="dbms">DBMS</h1>
<ul>
  <li>데이터베이스를 관리할 수 있는 응용 프로그램</li>
</ul>

<h2 id="dbms-분석-시-고려-사항">DBMS 분석 시 고려 사항</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">성능 측면</code> : 가용성, 성능, 상호 호환성</li>
  <li><code class="language-plaintext highlighter-rouge">지원 측면</code> : 기술 지원, 구축 비용<br /><br /></li>
</ol>

<h1 id="네트워크">네트워크</h1>
<ul>
  <li>원하는 정보를 수신자에게 정확하게 전달하기 위한 인프라</li>
</ul>

<h1 id="osi-7계층">OSI 7계층</h1>
<ul>
  <li>네트워크 통신에서 충돌 문제를 최소화하고자, 국제표준화기구(ISO)에서 제시한 네트워크 통신 규약</li>
  <li>물데네트세표응!</li>
</ul>

<h2 id="물리-계층">물리 계층</h2>
<ul>
  <li>데이터를 전기적인 신호로 변환시켜 통신
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 비트</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : RS-232C</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : 허브, 리피터</li>
    </ol>
  </li>
</ul>

<h3 id="물리-계층-장비">물리 계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">허브</code> : 여러 대의 컴퓨터를 연결해 네트워크로 보내거나, 하나의 네트워크로 수신된 정보를 여러 대의 컴퓨터로 보내는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">리피터</code> : 디지털 신호를 증폭시키는 장비<br /><br /></li>
</ul>

<h2 id="데이터링크-계층">데이터링크 계층</h2>
<ul>
  <li>노드 간 오류 제어, 흐름 제어, 회선 제어
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 프레임</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : L2 스위치, 브릿지, NIC, 스위칭 허브</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : HDLC, PPP, Frame Relay, ATM</li>
    </ol>
  </li>
</ul>

<h3 id="데이터링크-계층-장비">데이터링크 계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L2 스위치</code> : 목적지 MAC 주소를 기반으로 빠르게 데이터를 전송하는 장비
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Store and Forwarding</code> : 데이터를 전부 받은 후 처리</li>
      <li><code class="language-plaintext highlighter-rouge">Cut Through</code> : 목적지 주소만 확인 후 바로 전송</li>
      <li><code class="language-plaintext highlighter-rouge">Fragment Frame</code> : 앞 64비트만 읽어 에러 처리 후 전송</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">브릿지</code> : LAN과 LAN을 연결하는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">NIC</code> : 네트워크 인터페이스 카드. 외부 네트워크와 빠른 통신을 위해 컴퓨터 내에 설치되는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">스위칭 허브</code> : 스위치 기능을 가진 허브</li>
</ul>

<h3 id="데이터링크-계층-프로토콜">데이터링크 계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HDLC</code> : 점대점, 다중점 통신에 사용하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">PPP</code> : 통신 노드 간 연결을 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">Frame Relay</code> : 프레임 간 중계기능, 다중화 기능을 통해 빠른 데이터 전송이 가능한 고속 전송 기술</li>
  <li><code class="language-plaintext highlighter-rouge">ATM</code> : 고정 크기 단위로 전송하는 비동기식 전송 기술<br /><br /></li>
</ul>

<h2 id="네트워크-계층">네트워크 계층</h2>
<ul>
  <li>데이터 전송을 위한 최적의 경로 설정
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 패킷</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : L3 스위치, 라우터, 게이트웨이, 인터넷 공유기, 망(백본) 스위칭 허브</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : IP, 라우팅 프로토콜, ARP, RARP, ICMP, IGMP</li>
    </ol>
  </li>
</ul>

<h3 id="네트워크-계층-장비">네트워크 계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L3 스위치</code> : 3계층에서 동작하는 스위치 (L2 스위치 기능 + L3 라우터 기능을 모두 갖춘 장비)</li>
  <li><code class="language-plaintext highlighter-rouge">라우터</code> : 최적의 경로를 지정하고 경로에 따라 전송시키는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">게이트웨이</code> : 다른 통신망에 접속할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">인터넷 공유기</code> : 하나의 인터넷 라인을 여러 컴퓨터가 공유할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">망(백본) 스위칭 허브</code> : 광역 네트워크를 커버하는 스위칭 허브</li>
</ul>

<h3 id="네트위크-계층-프로토콜">네트위크 계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IP</code> : 패킷 단위의 네트워크 통신 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">라우팅 프로토콜</code> : 최적의 데이터 전송 경로를 설정하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ARP</code> : IP주소(3계층)를 MAC 주소(2계층)으로 변환하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">RARP</code> : MAC 주소는 알지만 IP 주소를 모를 때 사용하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ICMP</code> : IP 패킷 처리 시의 문제를 알려주는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">IGMP</code> : 멀티캐스트 실시간 전송을 위해 사용하는 프로토콜(화상회의 등)<br /><br /></li>
</ul>

<h2 id="전송계층transport">전송계층(Transport)</h2>
<ul>
  <li>종단 간 신뢰성있고 효율적으로 데이터 전송
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 세그먼트</li>
      <li><code class="language-plaintext highlighter-rouge">장비</code> : L4 스위치</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : TCP, UDP</li>
    </ol>
  </li>
</ul>

<h3 id="전송계층-장비">전송계층 장비</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L4 스위치</code> : OSI 4계층에서 네트워크 단위를 연결하는 장비. TCP/UDP 등 스위칭 수행</li>
</ul>

<h3 id="전송계층-프로토콜">전송계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TCP</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">신뢰성 보장</code> : 패킷 손실, 중복이 없도록 보장 (IP 계층 보완)</li>
      <li><code class="language-plaintext highlighter-rouge">연결지향적</code> : 연결 회선을 통해 통신이 이뤄짐</li>
      <li><code class="language-plaintext highlighter-rouge">흐름제어</code> : 송신-수신 속도 일치시킴</li>
      <li><code class="language-plaintext highlighter-rouge">혼잡제어</code> : 네트워크 혼잡도에 따라 송신율 제어</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">TCP 헤더 구조</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Source Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">Destination Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">Sequence Number</code> : 신뢰성과 흐름 담당</li>
      <li><code class="language-plaintext highlighter-rouge">Acknowledgement Number</code> : 승인 번호(수신을 기대하는 다음 번호)</li>
      <li><code class="language-plaintext highlighter-rouge">HLEN</code> : 헤더 길이</li>
      <li><code class="language-plaintext highlighter-rouge">Flag Bit</code> : 값 유효 여부 등을 표시하는 플래그</li>
      <li><code class="language-plaintext highlighter-rouge">Window Size</code></li>
      <li><code class="language-plaintext highlighter-rouge">Checksum</code> : 에러 확인</li>
      <li><code class="language-plaintext highlighter-rouge">Urgent Pointer</code> : 시퀀스 번호로부터의 옵셋</li>
      <li><code class="language-plaintext highlighter-rouge">Options and Padding</code></li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UDP</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">비신뢰성</code> : 메시지의 도착을 보장하지 않음</li>
      <li><code class="language-plaintext highlighter-rouge">비순서화</code> : 수신된 메시지 순서 맞추지 않음</li>
      <li>실시간 응용 및 멀티캐스팅 가능</li>
      <li>단순 헤더 (고정 크기 헤더)</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UDP 헤더 구조</code>
    <ol>
      <li><code class="language-plaintext highlighter-rouge">Source Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">Destination Port Number</code></li>
      <li><code class="language-plaintext highlighter-rouge">UDP Length</code></li>
      <li><code class="language-plaintext highlighter-rouge">UDP Checksum</code></li>
      <li><code class="language-plaintext highlighter-rouge">Data</code><br /><br /></li>
    </ol>
  </li>
</ul>

<h2 id="세션계층-session">세션계층 (Session)</h2>
<ul>
  <li>송수신간 연결을 제어
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 데이터</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : RPC, NetBIOS, SSH, SSL/TLS</li>
    </ol>
  </li>
</ul>

<h3 id="세션계층-프로토콜">세션계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">RPC</code> : 원격 프로시저 호출. 다른 주소 공간에 있는 프로세스 실행 가능</li>
  <li><code class="language-plaintext highlighter-rouge">NetBIOS</code> : 응용계층의 애플리케이션에 API 제공</li>
  <li><code class="language-plaintext highlighter-rouge">SSH</code> : 보안 쉘. 원격 호스트에 접근하기 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">SSL/TLS</code> : 안전한 데이터 전송을 위한 보안 프로토콜 (4계층(응용) - 7계층(전송) 사이에서 안전한 데이터 전송을 보장)<br /><br /></li>
</ul>

<h2 id="표현계층-presentaion">표현계층 (Presentaion)</h2>
<ul>
  <li>응용프로그램의 데이터를 통신에 알맞은 형태로 만들거나, 하위 계층의 데이터를 사용자가 이해할 수 있는 형태로 만드는 계층
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 데이터</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : JPEG, MPEG</li>
    </ol>
  </li>
</ul>

<h3 id="표현계층-프로토콜">표현계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">JPEG</code> : 이미지를 위한 표준 규격</li>
  <li><code class="language-plaintext highlighter-rouge">MPEG</code> : 멀티미디어를 위한 표준 규격<br /><br /></li>
</ul>

<h2 id="응용계층-application">응용계층 (Application)</h2>
<ul>
  <li>사용자가 OSI 환경에 접근할 수 있도록 서비스(인터페이스)를 제공하는 계층
    <ol>
      <li><code class="language-plaintext highlighter-rouge">단위</code> : 데이터</li>
      <li><code class="language-plaintext highlighter-rouge">프로토콜</code> : HTTP, FTP, SMTP, POP3, IMAP, Telnet</li>
    </ol>
  </li>
</ul>

<h3 id="응용계층-프로토콜">응용계층 프로토콜</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP</code> : 인터넷에서 데이터를 주고받기 위한 텍스트 기반의 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">FTP</code> : 서버-클라이언트 간 파일 전송을 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">SMTP</code> : 이메일을 보내기 위한 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">POP3</code> : 이메일을 가져오기 위한 프로토콜 (로컬 PC에 저장 후 불러옴)</li>
  <li><code class="language-plaintext highlighter-rouge">IMAP</code> : 이메일을 가져오기 위한 프로토콜 (메일 서버에서 불러옴)</li>
  <li><code class="language-plaintext highlighter-rouge">Telnet</code> : 네트워크 연결에 사용하는 응용계층의 프로토콜<br /><br /></li>
</ul>

<h1 id="os">OS</h1>
<ul>
  <li>컴퓨터의 하드웨어를 사용자가 쉽게 사용할 수 있도록 인터페이스를 담당하는 소프트웨어</li>
</ul>

<h2 id="os-현행-시스템-분석">OS 현행 시스템 분석</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">품질 측면</code> : 신뢰도, 성능</li>
  <li><code class="language-plaintext highlighter-rouge">지원 측면</code> : 기술 지원, 주변 기기, 구축 비용<br /><br /></li>
</ol>

<h1 id="디자인-패턴">디자인 패턴</h1>
<ul>
  <li>소프트웨어 설계 시 자주 쓰이는 방법을 정리한 패턴으로, 참고 시 개발 효율성이 높아진다.</li>
</ul>

<h2 id="디자인-패턴-구성요소">디자인 패턴 구성요소</h2>
<ol>
  <li>패턴 이름</li>
  <li>문제 및 배경</li>
  <li>솔루션</li>
  <li>사례</li>
  <li>결과</li>
  <li>샘플코드
    <ul>
      <li><code class="language-plaintext highlighter-rouge">라이브러리 구성</code> : 도움말, 설치파일, 샘플코드</li>
    </ul>
  </li>
</ol>

<h2 id="디자인-패턴-유형">디자인 패턴 유형</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">생성(5)</code> : 객체의 생성방식을 결정하는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">구조(7)</code> : 객체를 조직화하는데 유용한 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">행위(11)</code> : 객체의 행위를 조직, 관리, 연합하는데 사용하는 패턴</li>
</ol>

<h3 id="디자인-패턴---생성-패턴">디자인 패턴 - 생성 패턴</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">팩토리 메소드(Factory Method)</code> : 상위 클래스에서 인터페이스 정의, 서브 클래스가 실제 생성</li>
  <li><code class="language-plaintext highlighter-rouge">프로토타입(Prototype)</code> : 원형 객체를 복사하여 생성 (객체 생성 시 갖춰야 할 기본 형태가 있을 때 사용)</li>
  <li><code class="language-plaintext highlighter-rouge">빌더(Builder)</code> : 객체를 조립하여 생성. 생성 방법과 구현 방법을 구분하여, 동일한 객체 생성이여도 다른 결과가 나올 수 있음)</li>
  <li><code class="language-plaintext highlighter-rouge">싱글톤(Singletone)</code> : 클래스 내 객체가 하나 뿐임을 보장. 하나의 객체를 생성해 어디든 참조할 수 있으나 동시 참조 불가</li>
  <li><code class="language-plaintext highlighter-rouge">추상 팩토리(Abstract Factory)</code> : 구체적인 클래스에 의존하지 않고, 연관된 객체들의 그룹으로 생성 (객체 간 결합이 느슨해짐)</li>
</ol>

<h3 id="디자인-패턴---구조-패턴">디자인 패턴 - 구조 패턴</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">퍼싸드(Facade)</code> : 복잡한 시스템에 단순한 인터페이스를 제공해 접근성을 높인 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">플라이웨이트(Flyweight)</code> : 객체가 필요할 때 생성하는 대신 공유하여 메모리 절약</li>
  <li><code class="language-plaintext highlighter-rouge">컴포지트(Composite)</code> : 객체 관계를 파일 트리 구조로 구성하여, 복합 객체와 단일 객체를 동일하게 취급</li>
  <li><code class="language-plaintext highlighter-rouge">프록시(Proxy)</code> : 실제 기능을 수행하는 객체(Real object) 대신 가상의 객체(Proxy object)를 사용해 로직의 흐름을 제어하는 디자인 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">브리지(Bridge)</code> : 구현부에서 추상층을 분리하여 결합도를 낮춘 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">어댑터(Adapter)</code> : 호환성 없는 클래스의 인터페이스를 이용할 수 있게 변환</li>
  <li><code class="language-plaintext highlighter-rouge">데코레이터(Decorator)</code> : 객체 결합을 통해 기능을 확장</li>
</ol>

<h3 id="디자인-패턴---행위-패턴">디자인 패턴 - 행위 패턴</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">중재자(Mediator)</code> : 객체 사이에 중재자를 두어 의존성을 줄이는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">인터프리터(Interpreter)</code> : 여러 언어 구문을 해석할 수 있게 해주는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">템플릿 메소드(Template Method)</code> : 상위 클래스에서 기능을 정의하고, 하위 클래스에서 세부 처리 방법을 구체화하는 패턴</li>
  <li><code class="language-plaintext highlighter-rouge">옵저버(Observer)</code> : 객체를 지켜보고 있다가, 객체의 상태가 변하면 그 객체에 의존하는 다른 객체들에게 변화된 상태를 전달</li>
  <li><code class="language-plaintext highlighter-rouge">커맨드(Command)</code> : 요청을 객체로 캡슐화하여, 각 요청(명령)이 들어오면 그에 맞는 서브 클래스 실행</li>
  <li><code class="language-plaintext highlighter-rouge">비지터(Visitor)</code> : 처리 기능을 별도로 분리한 패턴 (분리된 처리 기능은 클래스를 방문하여 수행)</li>
  <li><code class="language-plaintext highlighter-rouge">반복자(Iterator)</code> : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 (내부 노출 없이 순차적 접근 가능)</li>
  <li><code class="language-plaintext highlighter-rouge">상태(State)</code> : 객체의 상태를 캡슐화하고, 이를 참조해 동작을 다르게 처리</li>
  <li><code class="language-plaintext highlighter-rouge">전략(Strategy)</code> : 동일한 계열의 알고리즘을 캡슐화하고, 전략을 선택해 사용</li>
  <li><code class="language-plaintext highlighter-rouge">책임 연쇄(Chain of Responsibility)</code> : 한 객체가 요청을 처리하지 못하면, 연결된 객체로 넘어가 처리</li>
  <li><code class="language-plaintext highlighter-rouge">메멘토(Memento)</code> : 특정 시점의 객체 내부 상태를 객체화하여, 해당 시점으로 되돌리는 기능을 제공<br /><br /></li>
</ol>

<h1 id="소프트웨어-아키텍처">소프트웨어 아키텍처</h1>
<ul>
  <li>소프트웨어 구성요소와, 구성요소의 특성, 구성요소 간 관계를 표현하는 구조</li>
</ul>

<h2 id="현행-시스템-파악">현행 시스템 파악</h2>
<ol>
  <li>구성 현황 / 기능 현황 / 인터페이스 파악</li>
  <li>아키텍처, 소프트웨어 구성 파악</li>
  <li>하드웨어, 네트워크 구성 파악</li>
</ol>

<h2 id="소프트웨어-41-뷰">소프트웨어 4+1 뷰</h2>
<ul>
  <li>요구사항을 4개의 관점에서 바라보는 방법. 4개 구조가 충돌되지 않는지, 요구사항을 충족하는지 증명하기 위해 유스케이스 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">프로세스 뷰</code> : 비기능적인 속성으로 자원 사용 등을 표현한 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">유스케이스 뷰</code> : 유스케이스를 도출하고 다른 뷰를 검증하는 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">배치 뷰</code> : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 보여주는 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">논리 뷰</code> : 기능적인 요구사항이 어떻게 제공되는지 표현한 뷰</li>
      <li><code class="language-plaintext highlighter-rouge">구조 뷰</code> : 소프트웨어 모듈의 구성을 보여주는 뷰</li>
    </ul>
  </li>
</ul>

<h2 id="소프트웨어-아키텍처-패턴-종류">소프트웨어 아키텍처 패턴 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">계층화 패턴</code> : 시스템을 계층으로 구분 (ex. <code class="language-plaintext highlighter-rouge">OSI 7계층</code> : 서로 마주보든 계층에서만 상호작용 발생)</li>
  <li><code class="language-plaintext highlighter-rouge">클라이언트-서버 패턴</code> : 하나의 서버 + 다수의 클라이언트 -&gt; 사용자는 클라이언트와만 상호작용</li>
  <li><code class="language-plaintext highlighter-rouge">파이프-필터 패턴</code> : 데이터 스트림을 처리하는 시스템에서 사용 (ex. <code class="language-plaintext highlighter-rouge">Unix의 Shell</code> : 하나의 서브시스템이 데이터를 받아 처리하고, 결과를 다음 서브 시스템에게 넘겨줌)</li>
  <li><code class="language-plaintext highlighter-rouge">브로커 패턴</code> : 사용자가 요청하면, 브로커가 적합한 컴포넌트를 연결하는 방식. 원격 서비스 호출에 응답하는 컴포넌트가 여럿일 때 적합</li>
  <li><code class="language-plaintext highlighter-rouge">모델-뷰-컨트롤러 패턴</code> : 3개의 서브시스템으로 구조화한 패턴
    <ul>
      <li><code class="language-plaintext highlighter-rouge">모델</code> : 핵심 기능과 데이터 보관</li>
      <li><code class="language-plaintext highlighter-rouge">뷰</code> : 사용자에게 정보 표시</li>
      <li><code class="language-plaintext highlighter-rouge">컨트롤러</code> : 사용자의 입력 처리 - 하나의 모델에 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합</li>
    </ul>
  </li>
</ol>

<h2 id="소프트웨어-아키텍처-비용-평가-모델">소프트웨어 아키텍처 비용 평가 모델</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">SAAM</code> : 변경 용이성과 기능성에 집중. 경험없어도 쉽게 사용 가능</li>
  <li><code class="language-plaintext highlighter-rouge">ATAM</code> : <code class="language-plaintext highlighter-rouge">SAAM</code>을 계승. 아키텍처 품질 속성을 만족하는지도 평가</li>
  <li><code class="language-plaintext highlighter-rouge">CBAM</code> : <code class="language-plaintext highlighter-rouge">ATAM</code>에 경제성 평가 보장</li>
  <li><code class="language-plaintext highlighter-rouge">ADR</code> : 아키텍처 구성요소 간 응집도 평가</li>
  <li><code class="language-plaintext highlighter-rouge">ARID</code> : <code class="language-plaintext highlighter-rouge">ATAM + ADR</code>. 전체가 아닌 특정 부분에 대한 비용 평가<br /><br /></li>
</ol>

<h1 id="sdlc-소프트웨어-생명주기">SDLC (소프트웨어 생명주기)</h1>
<ul>
  <li>시스템의 요구분석 ~ 유지보수까지 전 과정을 모델링한 것</li>
</ul>

<h2 id="sdlc-모델-종류">SDLC 모델 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">폭포수 모델(Waterfall model)</code> : 선형 순차적 모델. 고전적 생명주기 모델. 각 개발 단계를 마무리 지은 후 넘어가는 모델로 가장 오래됐고, 성공사례가 많으며, 단계별 산출물이 명확하고 요구사항 변경이 어려움</li>
  <li><code class="language-plaintext highlighter-rouge">프로토타이핑 모델(Prototyping model)</code> : 주요 기능을 프로토타입으로 구현하고, 피드백을 반영해 만들어나가는 모델</li>
  <li><code class="language-plaintext highlighter-rouge">나선형 모델(Spiral model)</code> : 위험을 최소화하기 위해 점진적으로 개발해나가는 모델
    <ul>
      <li><code class="language-plaintext highlighter-rouge">절차</code> : 계획 및 정의 - 위험 분석 - 개발 - 고객 평가</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">반복적 모델(Iteration model)</code> : 병렬적으로 개발 후 통합하거나, 반복적으로 개발해 점차 완성시켜나가는 모델</li>
</ol>

<h2 id="sdlc-모델-프로세스">SDLC 모델 프로세스</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">요구사항 분석</code> : 요구사항을 분석하고, 제약조건, 목표 등을 정의</li>
  <li><code class="language-plaintext highlighter-rouge">설계</code> : 수행 방법을 논리적으로 결정 (ex. 시스템 구조 설계, 사용자 인터페이스 설계)</li>
  <li><code class="language-plaintext highlighter-rouge">구현</code> : 프로그래밍 언어를 사용해 실제로 코드를 작성 (ex. 인터페이스 개발, 자료 구조 개발, 오류 처리)</li>
  <li><code class="language-plaintext highlighter-rouge">테스트</code> (ex. 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트)</li>
  <li><code class="language-plaintext highlighter-rouge">유지보수</code><br /><br /></li>
</ol>

<h1 id="소프트웨어-개발-방법론">소프트웨어 개발 방법론</h1>
<ul>
  <li>소프트웨어의 개발 시작부터 전 개발 과정을 형상화한 방법론</li>
</ul>

<h2 id="소프트웨어-개발-방법론-종류">소프트웨어 개발 방법론 종류</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">구조적 방법론</code> : 전체 시스템을 나눠 개발하고 통합하는 분할-정복 방식의 방법론. 나씨-슈나이더만 차트 사용</li>
  <li><code class="language-plaintext highlighter-rouge">정보공학 방법론</code> : 정보 시스템 개발에 필요한 절차를 체계화한 방법론 (대형 프로젝트)</li>
  <li><code class="language-plaintext highlighter-rouge">객체지향 방법론</code> : 객체라는 단위로 시스템을 설계하는 방법론</li>
  <li><code class="language-plaintext highlighter-rouge">컴포넌트 기반 방법론</code> : 컴포넌트를 조립해 작성하는 방법론</li>
  <li><code class="language-plaintext highlighter-rouge">애자일 방법론</code> : 절차보다 사람이 우선되는, 변화에 유연한 경량 개발 방법론</li>
  <li><code class="language-plaintext highlighter-rouge">제품 개발 방법론</code> : 제품에 적용할 공통 기능을 정의하여 개발하는 방법론 (임베디드 소프트웨어 작성에 유용)<br /><br /></li>
</ol>

<h1 id="xp">XP</h1>
<ul>
  <li>1-3주의 반복 주기를 갖는 애자일 방법론</li>
</ul>

<h2 id="xp의-5가지-가치">XP의 5가지 가치</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">용기</code> : 용기를 갖고 빠르게 개발</li>
  <li><code class="language-plaintext highlighter-rouge">단순성</code> : 필요한 것만 하자</li>
  <li><code class="language-plaintext highlighter-rouge">의사소통</code> : 개발자-관리자-고객 간 원활하게 소통</li>
  <li><code class="language-plaintext highlighter-rouge">피드백</code> : 의사소통에 대한 빠른 피드백</li>
  <li><code class="language-plaintext highlighter-rouge">존중</code> : 팀원간 상호 존중</li>
</ol>

<h2 id="xp의-12가지-기본-원리">XP의 12가지 기본 원리</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">짝 프로그래밍 (Pair Programming)</code> : 다른 사람과 페어로 개발하여 공동 책임을 지님</li>
  <li><code class="language-plaintext highlighter-rouge">공동 코드 소유 (Collective Ownership)</code> : 시스템에 있는 코드는 누구나 언제든 수정 가능</li>
  <li><code class="language-plaintext highlighter-rouge">지속적인 통합 (CI ; Continuos Integration)</code> : 여러 번 소프트웨어를 통합하고 빌드해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">계획 세우기 (Planning Process)</code> : 고객이 원하는 가치를 정의하고, 개발에 필요한 것은 무엇이며, 어떤 곳에서 지연이 될 수 있는지 알려줘야 함</li>
  <li><code class="language-plaintext highlighter-rouge">작은 릴리즈 (Small Release)</code> : 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트</li>
  <li><code class="language-plaintext highlighter-rouge">메타포어 (Metaphor)</code> : 공통 이름 체계를 통해 의사소통을 원활히</li>
  <li><code class="language-plaintext highlighter-rouge">간단한 디자인 (Simple Release)</code> : 요구사항에 적합한 단순한 시스템을 설계</li>
  <li><code class="language-plaintext highlighter-rouge">테스트 기반 개발 (TDD ; Test Drive Develop)</code> : 테스트를 먼저 수행하고, 통과할 수 있는 코드를 작성</li>
  <li><code class="language-plaintext highlighter-rouge">리팩토링 (Refactoring)</code> : 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 코드를 재구성</li>
  <li><code class="language-plaintext highlighter-rouge">40시간 작업 (40-Hour Work)</code> : 피곤으로 인한 실수가 없도록 주 40시간만 일하자</li>
  <li><code class="language-plaintext highlighter-rouge">고객 상주 (On Site Customer)</code> : 개발자들의 질문에 즉각 대답해줄 수 있는 고객이 풀타임 상주해야 함</li>
  <li><code class="language-plaintext highlighter-rouge">코드 표준 (Coding Standard)</code> : 코딩 표준을 두고 효과적으로 개발<br /><br /></li>
</ol>

<h1 id="린">린</h1>
<ul>
  <li>낭비 요소를 제거해 품질을 향상시키는 애자일 방법론</li>
</ul>

<h2 id="린의-7가지-원칙">린의 7가지 원칙</h2>
<ol>
  <li>낭비제거</li>
  <li>품질 내재화</li>
  <li>지식 창출</li>
  <li>늦은 확정</li>
  <li>빠른 인도</li>
  <li>사람 존중</li>
  <li>전체 최적화<br /><br /></li>
</ol>

<h1 id="스크럼">스크럼</h1>
<ul>
  <li>매일 정해진 시간 / 장소에서 짧은 시간의 개발을 위한 애자일 방법론</li>
</ul>

<h2 id="스크럼-용어">스크럼 용어</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">백로그</code> : 제품에 대한 요구사항</li>
  <li><code class="language-plaintext highlighter-rouge">스프린트</code> : 짧은 기간 내 반복적으로 개발</li>
  <li><code class="language-plaintext highlighter-rouge">데일리(스크럼) 미팅</code> : 매일 To-Do List 계획 수립. 번다운 차트 작성</li>
  <li><code class="language-plaintext highlighter-rouge">스크럼 마스터</code> : 프로젝트 리더</li>
  <li><code class="language-plaintext highlighter-rouge">스프린트 회고</code> : 각자 반성하고 개선점 확인</li>
  <li><code class="language-plaintext highlighter-rouge">번 다운 차트</code> : 남아있는 백로그 대비 시간을 시각적으로 표현 (백로그를 수직, 시간을 수평)<br /><br /></li>
</ul>

<h1 id="비용산정-모델">비용산정 모델</h1>
<ul>
  <li>소프트웨어 개발 계획을 수립하기 위해 투입될 자원이나 시간을 산정하는 방식
    <ul>
      <li><code class="language-plaintext highlighter-rouge">하향식</code> : 전문가가 산정 (ex. 델파이 기법)</li>
      <li><code class="language-plaintext highlighter-rouge">상향식</code> : 요구사항과 기능에 따라 산정 (ex. LoC, Man Month, COCOMO, 푸트남, FP)</li>
    </ul>
  </li>
</ul>

<h2 id="비용산정-모델-종류">비용산정 모델 종류</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">LoC(Lines of Codes) 모형</code> : 코드 라인 수의 예측치를 구하여 비용 산정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">산정방법</code> : (낙관치 + 중관치 x 4 + 비관치) / 6</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">COCOMO 모형</code> : 프로그램 규모에 따라 비용을 산정
    <ol>
      <li><code class="language-plaintext highlighter-rouge">조직형 / 단순형 (Organic)</code> : 소규모 5만 라인 (5KSDI) 이하</li>
      <li><code class="language-plaintext highlighter-rouge">반 분리형 (Semi-Detached)</code> : 중간형 30만 라인 (30KSDI) 이하</li>
      <li><code class="language-plaintext highlighter-rouge">임베디드형 (Embedded)</code> : 초대형</li>
    </ol>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Man Month 모형</code> : 한 사람이 1개월 간 할 수 있는 일의 양을 기준으로 비용 산정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Man Month = LoC / 개발자의 월간 생산성</code></li>
      <li><code class="language-plaintext highlighter-rouge">프로젝트 기간 = Man Month / 프로젝트 인력</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">푸트남(Putnam) 모형</code> : 생명주기 단계별 인력분포를 예측하는 방식 (시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선 분포도 기초)</li>
  <li><code class="language-plaintext highlighter-rouge">FP(기능점수) 모형</code> : 요구 기능별로 가중치를 부여해 총 점수를 계산해 비용 산정<br /><br /></li>
</ul>

<h1 id="일정-관리-모델">일정 관리 모델</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">CPM(주 공정법)</code> : 여러 작업의 수행 순서가 얽힌 프로젝트에서 일정을 계산하는 기법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">임계 경로(Critical Path) 계산법</code> : 가장 긴 경로 계산</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">CCPM(중요 연쇄 공정법)</code> : 주 공정법의 연쇄법으로, 자원 제약사항을 고려해 계산</li>
  <li><code class="language-plaintext highlighter-rouge">PERT</code> : 낙관치, 중관치, 비관치의 3점 추정방식으로 일정 관리</li>
</ol>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 소프트웨어 아키텍처 패턴 소프트웨어 설계 시 참조 가능한 솔루션 일반적으로 발생하는 문제점들에 대해 일반화되고 재사용 가능한 솔루션]]></summary></entry><entry><title type="html">jQuery) 이벤트 목록</title><link href="http://localhost:4000/javascript/jquery-events/" rel="alternate" type="text/html" title="jQuery) 이벤트 목록" /><published>2022-07-13T00:00:00+09:00</published><updated>2022-07-13T00:00:00+09:00</updated><id>http://localhost:4000/javascript/jquery-events</id><content type="html" xml:base="http://localhost:4000/javascript/jquery-events/"><![CDATA[<h1 id="jquery-마우스-이벤트">jQuery 마우스 이벤트</h1>
<p>|   이벤트  |                     설명                       |<br />
|———|———————————————–|
| click |노드(elements)를 마우스 포인터로 눌렀다가 떼었을 때에 발생|
|dblclick |노드를 더블 클릭 했을 때에 발생 |
|hover |mouseenter와 mouseleave 이벤트를 한번에 bind한다. |
|mousedown |노드 영역에서 마우스를 눌렀다가 떼었을 때에 발생 |
|mouseenter |노드에 마우스가 진입했을 때에 발생(자식노드에서는 이벤트를 감지 못함) |
|mouseleave |마우스가 노드에서 벗어났을 때에 발생 |
|mousemove |노드 영역에서 마우스를 움직였을 때에 발생 |
|mouseout |노드에서 마우스 포인터가 떠났을 때에 발생 |
|mouseover |노드 영역에서 마우스를 올려놓았을 때 발생 (내부노드까지 이벤트를 감지) |
|mouseup |마우스 포인터를 노드에 올려놓고 마우스 버튼을 눌렀다 떼었을 때에 발생 |
|toggle |click 이벤트에 핸들러를 바인딩하고 클릭할 때마다 실행될 함수들을 차례대로 실행|</p>

<h1 id="jquery-문서로딩-이벤트">jQuery 문서로딩 이벤트</h1>
<p>| 이벤트 | 설명 |
|———|—————————————–|
|ready |해당 페이지가 로딩되었을 때에(처음 읽힐 때에) 발생 |
|unload |해당 페이지를 빠져나갈 때에 발생|</p>

<h1 id="jquery-폼-이벤트">jQuery 폼 이벤트</h1>
<p>| 이벤트 | 설명 |
|———|—————————————–|
|blur |노드에서 포커스가 떠날 때에 발생 |
|change |노드의 값이 변경될 때에 발생 |
|focus |노드가 포커스를 획득했을 때에 발생 |
|select |유저가 텍스트를 선택했을 때에 발생 |
|submit |폼의 내용을 전송할 때에 발생|</p>

<h1 id="jquery-키보드-이벤트">jQuery 키보드 이벤트</h1>
<p>| 이벤트 | 설명 |
|———|—————————————-|
|keydown |해당 영역에서 키보드를 눌렀을 때에 발생 |
|keypress |해당 영역에서 키보드를 계속 누르고 있을 때에 발생 |
|keyup |해당 영역에서 키보드를 눌렀다가 떼었을 때 발생|</p>

<h1 id="jquery-웹-브라우저-이벤트">jQuery 웹 브라우저 이벤트</h1>
<p>| 이벤트 | 설명 |
|———|——————————————–|
|resize |웹브라우저 윈도우 사이즈의 변화가 있을 때 |
|scroll |스크롤이 움직일 때에 발생|</p>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JavaScript" /><category term="jQuery" /><category term="event" /><summary type="html"><![CDATA[jQuery 마우스 이벤트 | 이벤트 | 설명 | |———|———————————————–| | click |노드(elements)를 마우스 포인터로 눌렀다가 떼었을 때에 발생| |dblclick |노드를 더블 클릭 했을 때에 발생 | |hover |mouseenter와 mouseleave 이벤트를 한번에 bind한다. | |mousedown |노드 영역에서 마우스를 눌렀다가 떼었을 때에 발생 | |mouseenter |노드에 마우스가 진입했을 때에 발생(자식노드에서는 이벤트를 감지 못함) | |mouseleave |마우스가 노드에서 벗어났을 때에 발생 | |mousemove |노드 영역에서 마우스를 움직였을 때에 발생 | |mouseout |노드에서 마우스 포인터가 떠났을 때에 발생 | |mouseover |노드 영역에서 마우스를 올려놓았을 때 발생 (내부노드까지 이벤트를 감지) | |mouseup |마우스 포인터를 노드에 올려놓고 마우스 버튼을 눌렀다 떼었을 때에 발생 | |toggle |click 이벤트에 핸들러를 바인딩하고 클릭할 때마다 실행될 함수들을 차례대로 실행|]]></summary></entry><entry><title type="html">Java) 프로그래머스 - 예산</title><link href="http://localhost:4000/programmers/programmers-binary-search/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 예산" /><published>2022-07-11T00:00:00+09:00</published><updated>2022-07-11T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-binary-search</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-binary-search/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62949">https://school.programmers.co.kr/learn/courses/10302/lessons/62949</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다.<br /><br /></li>
</ul>

<ol>
  <li>모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다.<br /></li>
  <li>모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다.</li>
</ol>

<ul>
  <li>예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150일 때, 상한액을 127로 잡으면 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 됩니다.</li>
  <li>각 지방에서 요청하는 예산이 담긴 배열 budgets과 총 예산 M이 매개변수로 주어질 때, 위의 조건을 모두 만족하는 상한액을 return 하도록 solution 함수를 작성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>지방의 수는 3 이상 100,000 이하인 자연수입니다.</li>
  <li>각 지방에서 요청하는 예산은 1 이상 100,000 이하인 자연수입니다.</li>
  <li>총 예산은 지방의 수 이상 1,000,000,000 이하인 자연수입니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>
    <p>뭔가 막연하게 이분탐색 문제같았는데 범위를 좁혀나가는 기준을 어떻게 설정해야 할 지 모르겠어서 풀이 영상을 봤다. 이분탐색 문제는 풀 때마다 어렵게 느껴진다 😭</p>
  </li>
  <li>문제를 풀기 위해서는 금액이 최대가 되는 상한액의 범위를 좁혀가면서 탐색해야 한다. 그래서 최소값(0)과 최대값(입력 중 가장 큰 값) 범위에서 중간값을 구한 다음 이 중간값이 적절한 상한액이면 정답이 되는 것이고 많이 모자란 값이라면 최소값을 증가시키고, 초과하는 값이라면 최대값을 감소시킨다.</li>
  <li>이 과정을 최소값과 최대값이 같아지는(서로 만나는) 지점까지 반복하면 된다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/d168474b2fe3ceb2d077e3962f62e964.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><category term="BinarySearch" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62949]]></summary></entry><entry><title type="html">정보처리기사) 네트워크 레이어 프로토콜</title><link href="http://localhost:4000/certificate/network-layer/" rel="alternate" type="text/html" title="정보처리기사) 네트워크 레이어 프로토콜" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/certificate/network-layer</id><content type="html" xml:base="http://localhost:4000/certificate/network-layer/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="네트워크-계층">네트워크 계층</h1>
<ul>
  <li>데이터 전송을 위한 최적의 경로 설정</li>
  <li>단위 : 패킷</li>
</ul>

<h2 id="장비">장비</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L3 스위치</code> : 3계층에서 동작하는 스위치 (L2 스위치 기능 + L3 라우터 기능을 모두 갖춘 장비)</li>
  <li><code class="language-plaintext highlighter-rouge">라우터</code> : 최적의 경로를 지정하고 경로에 따라 전송시키는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">게이트웨이</code> : 다른 통신망에 접속할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">인터넷 공유기</code> : 하나의 인터넷 라인을 여러 컴퓨터가 공유할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">망(백본) 스위치 허브</code> : 광역 네트워크를 커버하는 스위칭 허브</li>
</ul>

<h2 id="프로토콜">프로토콜</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IP</code> : 패킷 단위의 네트워크 통신 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">라우팅 프로토콜</code> : 최적의 데이터 전송 경로를 설정하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ARP</code> : IP주소(3계층)을 MAC주소(2계층)으로 변환하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">RARP</code> : MAC 주소는 알지만 IP 주소는 모를 때 사용하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ICMP</code> : IP 패킷 처리 시의 문제를 알려주는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">IGMP</code> : 멀티캐스트 실시간 전송을 위해 사용하는 프로토콜 (화상회의 등)</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="OSI7" /><category term="NetworkLayer" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 네트워크 계층 데이터 전송을 위한 최적의 경로 설정 단위 : 패킷]]></summary></entry><entry><title type="html">Java) 프로그래머스 - 가장 큰 수</title><link href="http://localhost:4000/programmers/programmers-bigNumber-java/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 가장 큰 수" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-bigNumber-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-bigNumber-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62948">https://school.programmers.co.kr/learn/courses/10302/lessons/62948</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.</li>
  <li>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.</li>
  <li>0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>numbers의 길이는 1 이상 100,000 이하입니다.</li>
  <li>numbers의 원소는 0 이상 1,000 이하입니다.</li>
  <li>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>주어지는 배열의 숫자들을 조합해서 숫자를 만들다 보면 정수 자료형의 범위를 초과할 수 있다.</li>
  <li>그래서 조합을 시도할 땐 정수를 문자열로 바꾸어야 한다. 여기까지는 맞는 접근…</li>
</ul>

<h2 id="1차-시도">1차 시도</h2>
<ul>
  <li>배열의 모든 원소를 조합해서 숫자를 만들어봐야 하기 때문에 순열문제라고 생각했다. 그래서 순열 만드는 함수를 만들어 모든 순열을 구한 다음에 그걸 정렬해서 가장 큰 수를 리턴하는 방식으로 했다.</li>
  <li>테스트 케이스는 통과했지만 막상 제출하니까 시간초과가 뜨면서 실패했다…ㅎ</li>
  <li>나중에 풀이를 보니까 접근 방법 자체가 달라서 통과할 수 없는 알고리즘이었다. 순열을 구하는 메서드에서 시간초과가 발생했거나 무한루프가 돈 것으로 예상되었다.</li>
</ul>

<h2 id="2차-시도">2차 시도</h2>
<ul>
  <li>풀이 영상을 보고 처음에 생각했던 접근방법이 틀렸다는 걸 알게 되었다.</li>
  <li>이 문제를 시간 안에 통과하기 위한 접근법은 숫자를 -&gt; 문자로 바꾸고 -&gt; 내림차순으로 정렬해서 -&gt; 문자열로 조합 이었다.</li>
  <li>하지만 무작정 내림차순으로 정렬하면 테스트 케이스 1처럼 <code class="language-plaintext highlighter-rouge">6, 10</code>인 경우에는 <code class="language-plaintext highlighter-rouge">610</code>이 큰 수지만 단순 내림차순으로 정렬해 버린 후 조합하면 <code class="language-plaintext highlighter-rouge">10, 6</code>이 되어 <code class="language-plaintext highlighter-rouge">106</code>이라는 결과를 얻게 된다. 그렇기 때문에 두 수를 조합한 결과가 큰 순서대로 내림차순 정렬될 수 있도록 해야한다.</li>
  <li>이를 위해 <code class="language-plaintext highlighter-rouge">compareTo()</code> 메서드를 사용해 정렬 대상이 되는 앞뒤 원소 두 개를 조합한 결과에 따라 내림차순 정렬이 될 수 있도록 했다.</li>
  <li>주 언어가 자바지만 정작 코테 준비는 <code class="language-plaintext highlighter-rouge">C++</code>이나 <code class="language-plaintext highlighter-rouge">파이썬</code>으로 많이 했었기 때문에 자바의 컬렉션에 좀 약했는데 풀이 강의는 자바 사용에 대한 팁도 많이 줘서 좋았다. 이것 하나로 수강료가 아깝지 않았다.</li>
  <li>프로그래머스 <a href="https://school.programmers.co.kr/learn/courses/10302">[Java/문제풀이] 코딩테스트 광탈 방지 Kit: Java편</a> 왕추천!! <br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/a4ecd2b3fa0442c38c6fc07058a86114.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><category term="Sorting" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62948]]></summary></entry><entry><title type="html">Java) 프로그래머스. 로또의 최고 순위와 최저 순위</title><link href="http://localhost:4000/programmers/programmers-lotto-java/" rel="alternate" type="text/html" title="Java) 프로그래머스. 로또의 최고 순위와 최저 순위" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-lotto-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-lotto-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/77484">https://school.programmers.co.kr/learn/courses/30/lessons/77484</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.</li>
  <li>민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.</li>
  <li>(문제 전문은 링크에…)<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>lottos는 길이 6인 정수 배열입니다.</li>
  <li>lottos의 모든 원소는 0 이상 45 이하인 정수입니다.
    <ul>
      <li>0은 알아볼 수 없는 숫자를 의미합니다.</li>
      <li>0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.</li>
      <li>lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.</li>
    </ul>
  </li>
  <li>win_nums은 길이 6인 정수 배열입니다.</li>
  <li>win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.
    <ul>
      <li>win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.</li>
      <li>win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>문제를 단순하게 보면 가장 높은 등수를 받을 수 있는 경우는 알아볼 수 없는 숫자 모두가 당첨번호와 일치하는 경우이고, 가장 낮은 등수는 알아볼 수 없는 숫자 모두가 당첨번호와 일치하지 않는 경우이다.</li>
  <li>그렇기 때문에 민우가 선택한 번호에서 당첨번호와 일치하는 숫자의 개수를 센 다음 0의 개수도 세어서 더해주면 가장 높은 등수이고 더하지 않는다면 가장 낮은 등수이다.</li>
  <li>2중 반복문을 사용했는데 이 과정에서 내부 반복문의 조건식에 외부 반복문의 변수를 잘못 적어서 인덱스 범위 초과 에러가 났었다… 중첩 반복문을 쓸 때 변수 헷갈리지 않도록 조심하자!</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/1a87d96c893a7a2cc45c3468acc77376.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/77484]]></summary></entry><entry><title type="html">정보처리기사) 암호화 알고리즘</title><link href="http://localhost:4000/certificate/encryption/" rel="alternate" type="text/html" title="정보처리기사) 암호화 알고리즘" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/certificate/encryption</id><content type="html" xml:base="http://localhost:4000/certificate/encryption/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="des">DES</h1>
<ul>
  <li>미국 NBS (National Bureau of Standards, 현재 NIST)에서 국가 표준으로 정한 암호 알고리즘으로, 64비트 평문을 64비트 암호문으로 암화하는 대칭키 암호 알고리즘이다. 키는 7비트마다 오류검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트이다. 현재는 취약하여 사용되지 않는다.<br /><br /></li>
</ul>

<h1 id="aria">ARIA</h1>
<ul>
  <li>대칭키(블록)</li>
  <li>학계(Academy) + 연구기관(Research Institute) + 정부(Agency)</li>
  <li>국정원과 산학연구협회가 개발함<br /><br /></li>
</ul>

<h1 id="rsa">RSA</h1>
<ul>
  <li>비대칭키</li>
  <li>수학교수 3명의 앞글자를 땄음 (리베스트, 샤미르, 아들만). 소인수 분해 문제의 어려움을 근거로 함<br /><br /></li>
</ul>

<h1 id="md5">MD5</h1>
<ul>
  <li>해시 암호화</li>
  <li><code class="language-plaintext highlighter-rouge">MD4</code>를 개선한 알고리즘</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="Algorithm" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 DES 미국 NBS (National Bureau of Standards, 현재 NIST)에서 국가 표준으로 정한 암호 알고리즘으로, 64비트 평문을 64비트 암호문으로 암화하는 대칭키 암호 알고리즘이다. 키는 7비트마다 오류검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트이다. 현재는 취약하여 사용되지 않는다.]]></summary></entry><entry><title type="html">Java) 프로그래머스 - 기지국 설치</title><link href="http://localhost:4000/programmers/programmers-coverage-java/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 기지국 설치" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-coverage-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-coverage-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62946">https://school.programmers.co.kr/learn/courses/10302/lessons/62946</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다.</li>
  <li>예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.)</li>
  <li>이때, 우리는 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다.</li>
  <li>아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요.</li>
  <li>(문제 전문은 링크에…)<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>N: 200,000,000 이하의 자연수</li>
  <li>stations의 크기: 10,000 이하의 자연수</li>
  <li>stations는 오름차순으로 정렬되어 있고, 배열에 담긴 수는 N보다 같거나 작은 자연수입니다.</li>
  <li>W: 10,000 이하의 자연수<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>
    <p>코테공부를 오래 쉰 거 치고는 생각외로 빠르게 푼 문제… 아직 완전히 감을 잃지는 않았나보다 ㅠㅠ 그리디 기본문제라 쉽긴 했다.<br /><br /></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">n</code>의 최대값이 2억으로 꽤 크기 때문에 완전탐색으로 답을 구하면 효율성 테스트를 통과하지 못 할 것이다.</li>
  <li>
    <p>그래서 기지국을 설치해야 하는 구간의 길이를 구한 다음 기지국 하나의 커버리지 길이로 나눠주면 완전탐색에 비해서는 빠르게 구할 수 있을 것이라 생각하고 코드를 짰다.<br /><br /></p>
  </li>
  <li>설치해야 할 기지국의 개수의 최솟값을 구하려면 먼저 하나의 기지국 당 커버할 수 있는 길이를 구해야 한다.
    <ul>
      <li>문제의 그림을 참고하면 하나의 기지국이 커버할 수 있는 길이는 <code class="language-plaintext highlighter-rouge">w * 2 + 1</code>이다. 기지국이 설치된 위치 기준으로 양 옆 <code class="language-plaintext highlighter-rouge">w</code>만큼 커버할 수 있기 때문에 <code class="language-plaintext highlighter-rouge">w</code>의 2배에 기지국이 설치된 위치 1만큼을 더해주어야 한다.<br /><br /></li>
    </ul>
  </li>
  <li>다음으로 기지국이 커버할 수 없어 비어있는 구간의 길이를 구해야 한다.
    <ul>
      <li>이는 (현재 기지국을 설치해야 하는 빈 구간의 끝점 - 시작점)으로 구할 수 있다.
        <ul>
          <li>빈 구간의 끝점은 빈 구간 다음에 첫 번째로 나오는 기지국의 위치에서 <code class="language-plaintext highlighter-rouge">w + 1</code>만큼을 빼면 구할 수 있다.</li>
          <li>시작점은 설치된 기지국의 위치 + <code class="language-plaintext highlighter-rouge">w + 1</code>로 구할 수 있다.</li>
        </ul>
      </li>
      <li>(끝점 - 시작점)으로 빈 구간의 길이를 구한 다음 위에서 구했던 기지국의 커버리지로 나눠본다.
        <ul>
          <li>나눈 나머지가 0이면 몫만큼 기지국을 설치하면 되지만, 나머지가 0보다 크다면 1개를 추가로 설치해야 모든 구역을 커버할 수 있다.</li>
        </ul>
      </li>
      <li>위의 과정을 기지국의 위치 배열인 <code class="language-plaintext highlighter-rouge">stations</code>의 원소 갯수만큼 반복한다.<br /><br /></li>
    </ul>
  </li>
  <li>두 번째 항목의 반복문이 끝나고 나면 마지막 기지국 뒤에 남아있는 빈 구간이 생길 수 있기 때문에 마지막으로 구했던 끝점이 아파트의 전체 길이보다 작다면 남은 구간에 대해 두 번째 항목을 한 번 더 수행한다.<br /><br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<ul>
  <li>효율성 테스트 결과 평균 <code class="language-plaintext highlighter-rouge">0.7ms</code> 정도에 통과할 수 있었다. 굿굿~~</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/4330cbc0e820660fdb28eca5b24e74a5.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Greedy" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62946]]></summary></entry><entry><title type="html">Java) 프로그래머스. 나머지가 1이 되는 수 찾기</title><link href="http://localhost:4000/programmers/programmers-rest1-java/" rel="alternate" type="text/html" title="Java) 프로그래머스. 나머지가 1이 되는 수 찾기" /><published>2022-07-08T00:00:00+09:00</published><updated>2022-07-08T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-rest1-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-rest1-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/87389">https://school.programmers.co.kr/learn/courses/30/lessons/87389</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>3 ≤ n ≤ 1,000,000<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>한동안 코테준비를 놓았다가 다시 시작해 보면서 프로그래머스의 레벨1부터 시작하기로 했다. 원하는 직무는 자바 개발이니까 자바로 코테를 연습하려 하는데 너~~~무 오랜만이라 그런지 풀이를 떠올리는데 의외로 오래 걸렸다…ㅠ 반성하자…</li>
  <li>시간에 대한 제한이 없고 입력값의 최대치도 그리 큰 수가 아니라 완전탐색으로 풀었다.</li>
  <li>입력으로 주어지는 값의 최소값이 3이니까 반복문으로 3의 나머지를 1로 만들 수 있는 2부터 시작해서 <code class="language-plaintext highlighter-rouge">n</code>보다 1 작을 때까지 증가시키며 모듈러 연산(%)을 사용해서 나머지를 구했다. 이 과정에서 나머지가 1이면 정답으로 저장하고 반복문을 탈출한다.</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/3e9869bda33ee95da0b89724c7f40456.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/87389]]></summary></entry></feed>