<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-24T10:54:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 7568. 덩치</title><link href="http://localhost:4000/boj/boj7568-java/" rel="alternate" type="text/html" title="Java) BOJ 7568. 덩치" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj7568-java</id><content type="html" xml:base="http://localhost:4000/boj/boj7568-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/7568">https://www.acmicpc.net/problem/7568</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다.</li>
  <li>두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 “더 크다”고 말한다.</li>
  <li>예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다.</li>
  <li>
    <p>예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, “덩치”로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.</p>
  </li>
  <li>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.</li>
  <li>이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.</li>
</ul>

<p>이름	(몸무게, 키)	덩치 등수<br />
A	(55, 185)	2<br />
B	(58, 183)	2<br />
C	(88, 186)	1<br />
D	(60, 175)	2<br />
E	(46, 155)	5<br /></p>
<ul>
  <li>위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다.</li>
  <li>그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.</li>
  <li>2 ≤ N ≤ 50</li>
  <li>10 ≤ x, y ≤ 200<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음에 너무 어렵게 생각해서 덩치 순서대로 배열을 정렬한 다음 정렬한 배열을 다시 순회하면서 정렬된 순서대로 등수를 매기는 방법을 썼는데 틀렸다.</li>
  <li>
    <p>그 후 질문게시판 반례를 찾아보니까 어렵게 생각할 문제가 아니라 내 앞에 있는 사람이 몇 명인지 세는 문제여서 그렇게 수정하니까 통과되었다.<br /><br /></p>
  </li>
  <li>통과 후 배열 순회 횟수 추가 유무에 따라 실행속도가 궁금해져서</li>
  <li>등수를 배열에 저장한 다음 마지막에 배열을 순회하면서 출력하는 방식 - 14268KB	124ms</li>
  <li>등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 BufferedWriter로 출력하는 방식 - 14416KB 	132ms</li>
  <li>등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 StringBuilder에 저장한 후 출력하는 방식으로 풀어 봤는데 - 15904KB	 144ms</li>
  <li>첫번째가 메모리를 가장 적게 쓰고 속도도 가장 빨랐다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 124 ms</li>
  <li>메모리 : 14268 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/709f749418093dd0e36f58f3c87f37e3.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No7568" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/7568 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">DB) 데이터베이스 기본개념</title><link href="http://localhost:4000/database/db-01/" rel="alternate" type="text/html" title="DB) 데이터베이스 기본개념" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/db-01</id><content type="html" xml:base="http://localhost:4000/database/db-01/"><![CDATA[<h1 id="데이터베이스의-필요성">데이터베이스의 필요성</h1>
<ul>
  <li>데이터(data) : 의미가 부여되지는 않았지만 현실 세계에서 단순히 관찰하거나 측정해 수집한 사실이나 값</li>
  <li>정보(information) : 의사 결정에 유용하게 활용할 수 있도록 데이터를 처리한 결과물</li>
</ul>

<h2 id="데이터-분류">데이터 분류</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Wisdom</code> : 지식을 활용할 수 있는 지혜로운 아이디어</li>
  <li><code class="language-plaintext highlighter-rouge">Knowledge</code> : 정보를 의미있게 처리, 활용한 것</li>
  <li><code class="language-plaintext highlighter-rouge">Information</code> : 가공된 의미있는 2차 데이터</li>
  <li><code class="language-plaintext highlighter-rouge">Data</code> : 가공 전의 순수한 데이터</li>
</ul>

<h2 id="빅데이터-시대">빅데이터 시대</h2>
<ul>
  <li>현대는 빅데이터 시대라 할 수 있는데 데이터를 이용해 정보화시킬 수 있는 범위와 능력이 증대되었기 때문이다.</li>
  <li>그만큼 데이터를 가공하는 역량이 중요한 시대가 되었다.<br /><br /></li>
</ul>

<h2 id="정보처리">정보처리</h2>
<ul>
  <li>데이터에서 정보를 추출하는 과정 또는 방법<br /><br /></li>
</ul>

<h2 id="정보-시스템과-데이터베이스">정보 시스템과 데이터베이스</h2>
<h3 id="정보-시스템information-system">정보 시스템(information system)</h3>
<ul>
  <li>조직 운영에 필요한 데이터를 수집하여 저장해두었다가 필요할 때 유용한 정보를 만들어 주는 수단</li>
</ul>

<h3 id="데이터베이스">데이터베이스</h3>
<ul>
  <li>정보 시스템 안에서 저장하고 있다가 필요할 때 제공하는 역할을 담당</li>
  <li>여러 가지 업무에 <code class="language-plaintext highlighter-rouge">공동</code>으로 필요한 데이터를 유기적으로 결합하여 저장한 집합체. 데이터를 <code class="language-plaintext highlighter-rouge">효율</code>적으로 처리하기 위하여 개발된 것으로, 같은 데이터가 <code class="language-plaintext highlighter-rouge">중복</code>되는 문제를 없앨 수 있으며 업무가 확대되어도 새로 파일을 준비할 필요가 없다는 장점이 있다.<br /><br /><br /></li>
</ul>

<h2 id="데이터베이스db-database">데이터베이스(DB, Database)</h2>
<ul>
  <li>특정 조직의 여러 사용자가 <code class="language-plaintext highlighter-rouge">공유</code>하여 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">통합</code>해서 <code class="language-plaintext highlighter-rouge">저장</code>한 <code class="language-plaintext highlighter-rouge">운영</code> 데이터의 집합</li>
</ul>

<h3 id="데이터베이스의-정의">데이터베이스의 정의</h3>
<ul>
  <li>통합 데이터(integrated data) : 최소의 중복과 통제가능한 중복만 허용하는 데이터</li>
  <li>저장 데이터(stored data) : 컴퓨터가 접근할 수 있는 매체에 저장된 데이터</li>
  <li>공유 데이터(shared data) : 특정 조직의 여러 사용자가 함께 소유하고 이용할 수 있는 공용 데이터</li>
  <li>운영 데이터(operational data) : 조직의 주요 기능을 수행하기 위해 지속적으로(조직이 문 닫을 때까지) 유지해야 하는 데이터</li>
</ul>

<h3 id="데이터베이스의-특성">데이터베이스의 특성</h3>
<ul>
  <li>실시간 접근(real-time accessibility) : 사용자의 데이터 요구에 실시간으로 응답</li>
  <li>계속 변화(continuous evolution) : 데이터의 계속적인 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지
    <ul>
      <li>예) 사원의 입사, 퇴사에 따른 변화를 반영</li>
    </ul>
  </li>
  <li>내용 기반 참조(contents reference) : 데이터가 저장된 주소나 위치가 아닌 내용으로 참조
    <ul>
      <li>예) 연봉이 5000만원 이상이며 과장급 이상인 사원을 검색하시오.</li>
    </ul>
  </li>
  <li>동시 공유(concurrent sharing) : 서로 다른 데이터의 동시 사용뿐만 아니라 같은 데이터의 동시 사용도 지원</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[데이터베이스의 필요성 데이터(data) : 의미가 부여되지는 않았지만 현실 세계에서 단순히 관찰하거나 측정해 수집한 사실이나 값 정보(information) : 의사 결정에 유용하게 활용할 수 있도록 데이터를 처리한 결과물]]></summary></entry><entry><title type="html">SQL) 데이터조작어(DML)</title><link href="http://localhost:4000/database/SQL-DML/" rel="alternate" type="text/html" title="SQL) 데이터조작어(DML)" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/SQL-DML</id><content type="html" xml:base="http://localhost:4000/database/SQL-DML/"><![CDATA[<ul>
  <li>테이블에 저장되어 있는 데이터를 다루는 명령어<br /><br /><br /></li>
</ul>

<h1 id="1-insert-구문">1. INSERT 구문</h1>
<ul>
  <li>테이블에 새로운 행 추가</li>
</ul>

<h2 id="️-문법">☑️ 문법</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table</span> <span class="p">[(</span><span class="k">column</span> <span class="p">[,</span> <span class="k">column</span><span class="p">...])]</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="n">value</span> <span class="p">[,</span> <span class="n">value</span><span class="p">...]);</span>
</code></pre></div></div>

<h2 id="예제">예제</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">departments</span><span class="p">(</span><span class="n">department_name</span><span class="p">,</span> <span class="n">namager_id</span><span class="p">,</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">location_id</span><span class="p">)</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="s1">'Java'</span><span class="p">,</span> <span class="mi">201</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">1700</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">departments</span><span class="p">(</span><span class="n">department_id</span><span class="p">,</span> <span class="n">department_name</span><span class="p">)</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="s1">'Jsp'</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>테이블명 다음에 설정한 컬럼수만큼 <code class="language-plaintext highlighter-rouge">values</code>에 값을 채워준다. 나머지는 자동으로 <code class="language-plaintext highlighter-rouge">null</code>값이 들어간다.<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">departments</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="mi">310</span><span class="p">,</span> <span class="s1">'Web'</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>아니면 <code class="language-plaintext highlighter-rouge">null</code>을 넣고 싶은 필드를 직접 지정해 줄 수도 있다.<br /><br /><br /></li>
</ul>

<h1 id="2-update-구문">2. UPDATE 구문</h1>
<ul>
  <li>테이블이 기존 행 수정</li>
</ul>

<h2 id="️-문법-1">☑️ 문법</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="k">table</span>
<span class="k">SET</span>    <span class="k">column</span> <span class="o">=</span> <span class="n">value</span> <span class="p">[,</span> <span class="k">column</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="p">...]</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">condition</span><span class="p">];</span>
</code></pre></div></div>

<h2 id="예제-1">예제</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">employees</span>
<span class="k">SET</span>    <span class="n">department_id</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">113</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>이렇게 쓰면 특정 <code class="language-plaintext highlighter-rouge">row</code>만 데이터 변경<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">employees</span>
<span class="k">SET</span>    <span class="n">department_id</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>이렇게 쓰면 해당 테이블 내의 모든 <code class="language-plaintext highlighter-rouge">row</code>의 데이터가 바뀐다. 이렇게 쓸 일은 거의 없으니까 <code class="language-plaintext highlighter-rouge">UPDATE</code> 사용시에는 <code class="language-plaintext highlighter-rouge">WHERE</code> 조건을 잘 확인하자.<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">copy_emp</span>
<span class="k">SET</span>    <span class="n">job_id</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">job_id</span>
                 <span class="k">FROM</span>   <span class="n">copy_emp</span>
                 <span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">205</span><span class="p">),</span>
       <span class="n">salary</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">salary</span>
                 <span class="k">FROM</span>   <span class="n">copy_emp</span>
                 <span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">205</span><span class="p">)</span>
<span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">113</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>수정할 데이터 구문에서 서브쿼리도 사용 가능<br /><br /><br /></li>
</ul>

<h2 id="3-delete-구문">3. DELETE 구문</h2>
<ul>
  <li>테이블의 기존 행 삭제</li>
</ul>

<h2 id="️-문법-2">☑️ 문법</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="p">[</span><span class="k">FROM</span><span class="p">]</span> <span class="k">table</span>
<span class="p">[</span><span class="k">WHERE</span>        <span class="n">condition</span><span class="p">];</span>
</code></pre></div></div>

<h2 id="예제-2">예제</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">departments</span>
<span class="k">WHERE</span>       <span class="n">department_id</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">copy_emp</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>이렇게 쓰면 전체 삭제<br /><br /><br /></li>
</ul>

<h2 id="4-트랜잭션transaction">4. 트랜잭션(Transaction)</h2>
<ul>
  <li>논리적인 작업 단위</li>
  <li>여러 <code class="language-plaintext highlighter-rouge">DML</code>이 모여서 하나의 트랜잭션이 구성된다.</li>
  <li><code class="language-plaintext highlighter-rouge">DML</code> 작업을 통해 변경한 내용들은 모두 <code class="language-plaintext highlighter-rouge">임시저장</code> 되어 있는 상태이다.</li>
  <li>그래서 <code class="language-plaintext highlighter-rouge">DML</code> 작업 후 <code class="language-plaintext highlighter-rouge">commit</code>(<code class="language-plaintext highlighter-rouge">DB</code>에 작업내용 최종 저장), <code class="language-plaintext highlighter-rouge">rollback</code>(<code class="language-plaintext highlighter-rouge">DB</code> 최종 저장 전에 작업내용 되돌리기)으로 트랜잭션을 종료해야 한다.<br /><br /></li>
</ul>

<h3 id="4-1-트랜잭션-구성">4-1) 트랜잭션 구성</h3>
<ul>
  <li>여러 <code class="language-plaintext highlighter-rouge">DML</code> 구문이 하나의 트랜잭션 (<code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">insert</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">delete</code>)</li>
  <li>하나의 <code class="language-plaintext highlighter-rouge">DDL</code> 구문이 하나의 트랜잭션 (<code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">alter</code>, <code class="language-plaintext highlighter-rouge">drop</code>, <code class="language-plaintext highlighter-rouge">truncate</code>)</li>
  <li>하나의 <code class="language-plaintext highlighter-rouge">DCL</code> 구문이 하나의 트랜잭션 (<code class="language-plaintext highlighter-rouge">grant</code>, <code class="language-plaintext highlighter-rouge">revoke</code>)<br /><br /></li>
</ul>

<h3 id="4-2-트랜잭션-시작-및-종료">4-2) 트랜잭션 시작 및 종료</h3>
<h4 id="-시작">🔸 시작</h4>
<ul>
  <li>첫 번째 <code class="language-plaintext highlighter-rouge">DML</code> 구문 실행 시</li>
</ul>

<h4 id="-종료">🔸 종료</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">COMMIT</code> 또는 <code class="language-plaintext highlighter-rouge">ROLLBACK</code> 실행 시
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DML</code> 쓰다가 <code class="language-plaintext highlighter-rouge">DDL/DCL</code> 작성하면 <code class="language-plaintext highlighter-rouge">autocommit</code> 되면서 위에 썼던 <code class="language-plaintext highlighter-rouge">DML</code>도 같이 커밋된다.(트랜잭션 끝)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DDL</code> 또는 <code class="language-plaintext highlighter-rouge">DCL</code> 구문 실행 시(<code class="language-plaintext highlighter-rouge">autocommit</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DDL</code>과 <code class="language-plaintext highlighter-rouge">DCL</code>은 <code class="language-plaintext highlighter-rouge">autocommit</code>을 내포하고 있기 때문에 실행하는 순간 <code class="language-plaintext highlighter-rouge">commit</code>되고 트랜잭션이 끝난다.</li>
      <li>그래서 <code class="language-plaintext highlighter-rouge">rollback</code>이 불가하기 때문에 신중하게 작업하는 것이 좋다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SQL *PLUS</code> 정상 종료 시(<code class="language-plaintext highlighter-rouge">autocommit</code>)
    <ul>
      <li>그래픽창의 <code class="language-plaintext highlighter-rouge">X</code>를 눌러 끄는 것은 비정상 종료다.</li>
      <li>터미널에서 <code class="language-plaintext highlighter-rouge">exit</code> 명령어 입력이나 그래픽 툴의 <code class="language-plaintext highlighter-rouge">exit</code> 버튼을 눌러서 끄는 것이 정상 종료이다.</li>
      <li>비정상 종료 시 <code class="language-plaintext highlighter-rouge">autorollback</code> 처리된다.</li>
    </ul>
  </li>
</ul>

<h4 id="-savepoint와-rollback-to">🔸 SAVEPOINT와 ROLLBACK TO</h4>
<ul>
  <li>최종 <code class="language-plaintext highlighter-rouge">commit</code> 전에 작업하던 중간 중간으로 되돌아 갈 수 있도록 <code class="language-plaintext highlighter-rouge">SAVEPOINT</code>를 만들 수 있다.</li>
  <li>하지만 만든 세이브포인트를 확인할 수 있는 명령어는 없기 때문에 만든 사람이 기억하고 있어야 한다.</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span><span class="p">...</span>
<span class="n">SAVEPOINT</span> <span class="n">update_done</span> <span class="c1">-- 세이브 포인트 생성</span>

<span class="p">...</span>

<span class="k">INSERT</span><span class="p">...</span>
<span class="k">ROLLBACK</span> <span class="k">TO</span> <span class="n">update_done</span><span class="p">;</span> <span class="c1">-- 세이브 포인트로 되돌리기</span>
</code></pre></div></div>

<ul>
  <li>세이브 포인트를 만들었다고 그 전까지 했던 작업들이 <code class="language-plaintext highlighter-rouge">COMMIT</code> 되는 것은 아니다.</li>
  <li>그렇기 때문에 모든 <code class="language-plaintext highlighter-rouge">DML</code> 작업이 끝났다면 최종 확인 후 꼭 <code class="language-plaintext highlighter-rouge">COMMIT</code>을 해 주어야 한다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><category term="SQL" /><category term="DML" /><summary type="html"><![CDATA[테이블에 저장되어 있는 데이터를 다루는 명령어]]></summary></entry><entry><title type="html">DB) 데이터베이스 관리 시스템</title><link href="http://localhost:4000/database/db-02-management-system/" rel="alternate" type="text/html" title="DB) 데이터베이스 관리 시스템" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/db-02-management-system</id><content type="html" xml:base="http://localhost:4000/database/db-02-management-system/"><![CDATA[<h1 id="데이터베이스-관리-시스템의-등장-배경">데이터베이스 관리 시스템의 등장 배경</h1>
<h2 id="파일-시스템file-system">파일 시스템(file system)</h2>
<ul>
  <li>과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어</li>
  <li>응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함</li>
</ul>

<h3 id="파일-시스템의-문제점">파일 시스템의 문제점</h3>
<ul>
  <li>같은 내용의 데이터가 여러 파일에 중복 저장된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">데이터 중복성</code></li>
      <li>저장 공간의 낭비는 물론 <code class="language-plaintext highlighter-rouge">데이터 일관성</code>과 <code class="language-plaintext highlighter-rouge">데이터 무결성</code> 유지가 어렵다.<br /><br /></li>
    </ul>
  </li>
  <li>응용 프로그램이 데이터 파일에 종속적이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">데이터 종속성</code></li>
      <li>사용하는 파일의 구조를 변경하면 응용 프로그램도 함께 변경해야 한다.<br /><br /></li>
    </ul>
  </li>
  <li>데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.</li>
  <li>응용 프로그램 개발이 쉽지 않다.<br /><br /><br /></li>
</ul>

<h1 id="데이터베이스-관리-시스템의-정의-및-특성">데이터베이스 관리 시스템의 정의 및 특성</h1>
<h2 id="데이터베이스-관리-시스템dbms-database-management-system">데이터베이스 관리 시스템(DBMS, DataBase Management System)</h2>
<ul>
  <li>파일 시스템의 문제를 해결하기 위해 제시된 소프트웨어</li>
  <li>조직에 필요한 데이터를 데이터베이스에 통합하여 저장하고 관리한다.</li>
</ul>

<h2 id="데이터베이스-관리-시스템의-주요-기능">데이터베이스 관리 시스템의 주요 기능</h2>
<ul>
  <li>정의 기능 : 데이터베이스 구조를 정의하거나 수정할 수 있다.</li>
  <li>조작 기능 : 데이터를 삽입, 삭제, 수정, 검색하는 연산을 할 수 있다.</li>
  <li>제어 기능 : 데이터를 항상 정확하고 안전하게 유지할 수 있다.</li>
</ul>

<h3 id="장점">장점</h3>
<ul>
  <li>데이터 중복을 통제할 수 있다.</li>
  <li>데이터 독립성이 확보된다.</li>
  <li>데이터를 동시 공유할 수 있다.</li>
  <li>데이터 보안이 향상된다.</li>
  <li>데이터 무결성을 유지할 수 있다.</li>
  <li>표준화할 수 있다.</li>
  <li>장애 발생 시 회복이 가능하다.</li>
  <li>응용 프로그램 개발 비용이 줄어든다.</li>
</ul>

<h3 id="단점">단점</h3>
<ul>
  <li>(경제적, 컴퓨터 자원 포함)비용이 많이 든다.</li>
  <li>백업과 회복 방법이 복잡하다.</li>
  <li>중앙 집중 관리로 인한 취약점이 존재한다.<br /><br /><br /></li>
</ul>

<h1 id="데이터베이스-관리-시스템의-발전-과정">데이터베이스 관리 시스템의 발전 과정</h1>
<h2 id="1세대--네트워크-dbms-계층-dbms-1960--1970">1세대 : 네트워크 DBMS, 계층 DBMS (1960 ~ 1970)</h2>
<ul>
  <li>네트워크 DBMS : 데이터베이스를 계층 형태로 구성
    <ul>
      <li>변경이 어렵다.</li>
      <li>예) IDS(Integrated Data Store)<br /><br /></li>
    </ul>
  </li>
  <li>계층 DBMS : 데이터베이스를 트리 형태로 구성
    <ul>
      <li>구조변경 및 복잡한 현실세계 반영이 어렵다.</li>
      <li>예) IMS(Information Management System)<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="2세대--관계-dbms-1980-">2세대 : 관계 DBMS (1980 ~)</h2>
<ul>
  <li>관계 DBMS : 데이터베이스를 테이블 형태로 구성
    <ul>
      <li>이해하기 쉽다.</li>
      <li>예) 오라클(Oracle), MS SQL 서버, 액세스(Access), 인포믹스(Informix), MySQL<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="3세대--객체지향-dbms-1980-후반--객체관계-dbms-1990-후반-">3세대 : 객체지향 DBMS (1980 후반 ~), 객체관계 DBMS (1990 후반 ~)</h2>
<ul>
  <li>객체지향 DBMS : 객체를 이용해 데이터베이스 구성
    <ul>
      <li>예) 오투(O2), 온투스(ONTOS), 젬스톤(GemStone)<br /><br /></li>
    </ul>
  </li>
  <li>
    <p>객체관계 DBMS : 객체 DBMS + 관계 DBMS<br /><br /></p>
  </li>
  <li>현대에는 이해하기 쉬운 2세대 RDBMS를 주로 사용하지만 객체지향 DBMS의 점유율도 점차 높아지고 있다.<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1163794">데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><category term="DBMS" /><category term="RDBMS" /><summary type="html"><![CDATA[데이터베이스 관리 시스템의 등장 배경 파일 시스템(file system) 과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어 응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함]]></summary></entry><entry><title type="html">컴퓨터 네트워크) 네트워크 기초</title><link href="http://localhost:4000/computer%20network/computer-network-01/" rel="alternate" type="text/html" title="컴퓨터 네트워크) 네트워크 기초" /><published>2022-02-20T00:00:00+09:00</published><updated>2022-02-20T00:00:00+09:00</updated><id>http://localhost:4000/computer%20network/computer-network-01</id><content type="html" xml:base="http://localhost:4000/computer%20network/computer-network-01/"><![CDATA[<h1 id="컴퓨터-네트워크">컴퓨터 네트워크</h1>
<ul>
  <li>전송 매체를 통해 서로 연결되어 데이터를 공유, 교환하는 컴퓨터의 모음</li>
  <li>예) 인터넷</li>
  <li>네트워크는 크게 나누면 유선, 무선 두 종류로 나눌 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="프로토콜protocol">프로토콜(Protocol)</h1>
<ul>
  <li>정보교환을 위해 필요한 통신 규약</li>
  <li>사람들끼리 말을 할 때 맥락없이 얘기하지 않고 서로 합의된 맥락 안에서 얘기하듯 컴퓨터 간 통신을 할 때에도 맥락이 필요하다.</li>
  <li>예) <code class="language-plaintext highlighter-rouge">HTTP</code>, <code class="language-plaintext highlighter-rouge">TCP</code>, <code class="language-plaintext highlighter-rouge">IP</code><br /><br /><br /></li>
</ul>

<h1 id="컴퓨터-네트워킹이-필요한-이유">컴퓨터 네트워킹이 필요한 이유</h1>
<h2 id="연결과-통신">연결과 통신</h2>
<ul>
  <li>멀리 떨어져 있는 사용자와도 효율적으로 정보를 교환하기 위해서</li>
</ul>

<h2 id="데이터-공유">데이터 공유</h2>
<ul>
  <li>컴퓨터 네트워크를 통해 쉽고 빠르게 데이터 공유</li>
  <li>컴퓨터 네트워크를 사용하는 ❗️ 가장 중요한 이유 중의 하나라고 할 수 있다.</li>
</ul>

<h2 id="하드웨어-공유">하드웨어 공유</h2>
<ul>
  <li>사무실에 프린터는 한 대만 두고 사무실내의 컴퓨터들이 네트워크를 통해 프린터를 공유하는 것처럼 하드웨어 공유를 통해 경비를 절감할 수 있다.</li>
</ul>

<h2 id="데이터-보안과-관리">데이터 보안과 관리</h2>
<ul>
  <li>네트워크에 연결된 서버에 저장, 데이터 읽기/수정 관리</li>
</ul>

<h2 id="성능-개선">성능 개선</h2>
<ul>
  <li>업무를 여러 컴퓨터에 분산시켜 동시에 처리<br /><br /><br /></li>
</ul>

<h1 id="기초-용어">기초 용어</h1>
<ul>
  <li>노드(Node) : 컴퓨터 네트워크에 연결된 컴퓨터 또는 네트워크 장비를 일반화한 용어</li>
  <li>호스트(Host) : 사용자의 요청을 처리하는 컴퓨터를 일반화한 용어</li>
  <li>클라이언트(Client) : 서비스를 요청하는 호스트</li>
  <li>서버(Server) : 서비스 요청을 받아 서비스를 제공하는 호스트</li>
  <li>네트워크 인터페이스(Interface) : 호스트와 컴퓨터 네트워크의 연결 지점으로 네트워크 인터페이스 카드(NIC)라고 한다.</li>
  <li>전송 매체(Transmission Medium)
    <ul>
      <li>송신측 호스트와 수신측 호스트 사이를 상호 연결하는 물리적인 선로</li>
      <li>유선(Wired) 전송 매체와 무선(Wireless) 전송 매체로 구분</li>
      <li>링크(Link)라고도 한다.</li>
    </ul>
  </li>
  <li>채널(Channel)
    <ul>
      <li>송신측에서 수신측으로 데이터를 전송하기 위해서 사용</li>
      <li>유선과 같은 전송매체 또는 무선(Radio) 채널과 같이 다중화(Multiplexing 여러 호스트가 하나의 채널을 공유하는 것) 된 매체에서 하나의 논리적 연결(Logical Connection)을 말함</li>
      <li>채널의 전송 용량은 <code class="language-plaintext highlighter-rouge">bps</code>(bit per second 초당 보내는 bit의 양) 단위의 전송률 또는 <code class="language-plaintext highlighter-rouge">Hz</code> 단위의 대역폭(Bandwidth)으로 표시<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="컴퓨터-통신구조">컴퓨터 통신구조</h1>
<ul>
  <li>서로 다른 시스템간의 통신을 하나의 모듈로 처리하기는 너무 복잡하기 때문에 기능별로 모듈을 세분화해서 구현할 필요가 있다.</li>
  <li>세분화된 모듈을 계층화 한 구조가 컴퓨터 통신 구조</li>
</ul>

<h2 id="계층화-하는-이유">계층화 하는 이유</h2>
<ul>
  <li>복잡한 시스템의 각 부분을 식별하고 연계하는데 좋다.</li>
  <li>모듈화는 시스템의 유지 및 개선을 용이하게 한다.</li>
  <li>특정 모듈을 변경하더라도 다른 모듈에 영향을 주지 않는다.<br /><br /></li>
</ul>

<p align="center"><img src="../../assets/images/networkHierarchy.png" width="500px" height="550px" /></p>
<p><br /></p>

<ul>
  <li>대표적으로 ISO OSI 7계층 통신구조와 인터넷 프로토콜 구조(5계층)이 있다.</li>
</ul>

<h2 id="인터넷-통신구조">인터넷 통신구조</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">응용(application)</code> : 응용 서비스 지원
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code>, <code class="language-plaintext highlighter-rouge">FTP</code>, <code class="language-plaintext highlighter-rouge">SMTP</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">트랜스포트(transport)</code> : 호스트간의 데이터 전송
    <ul>
      <li><code class="language-plaintext highlighter-rouge">TCP</code>, <code class="language-plaintext highlighter-rouge">UDP</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">네트워크(network)</code> : 라우팅
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IP</code>, <code class="language-plaintext highlighter-rouge">RIP</code>등</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">데이터링크(datalink)</code> : 네트워크 노드간의 데이터 전송
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Ethernet</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">물리(physical)</code> : 물리적인 케이블<br /></li>
  <li>각 계층은 하위계층을 반드시 이용해야 한다.</li>
  <li>응용계층쪽으로 갈수록 사용자와 가깝고 물리계층으로 갈수록 하드웨어와 가깝다.<br /><br /><br /></li>
</ul>

<h1 id="표준화">표준화</h1>
<ul>
  <li>정보통신 시스템 간의 프로토콜을 정립하는 활동</li>
  <li>정보통신 표준 : 정보통신 시스템간의 미리 합의된 규약의 집합</li>
  <li>정보통신 분야에 있어서 공통성, 통일성, 호환성, 등을 확보하기 위한 일반적 요구 사항</li>
</ul>

<h2 id="표준화-기구">표준화 기구</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ISO</code>(International Organization for Standards)</li>
  <li><code class="language-plaintext highlighter-rouge">ITU-T</code>(International Telecommunication Union-Telecommunication)</li>
  <li><code class="language-plaintext highlighter-rouge">ANSI</code>(American National Standards Institute)</li>
  <li><code class="language-plaintext highlighter-rouge">EIA</code>(Electronic Industries Association)</li>
  <li><code class="language-plaintext highlighter-rouge">TIA</code>(Telecommunications Industries Association)</li>
  <li><code class="language-plaintext highlighter-rouge">IEEE</code>(Institute of Electrical and Electronics Engineers)</li>
  <li><code class="language-plaintext highlighter-rouge">ETSI</code>(European Telecommunications Standards Institute)</li>
  <li><code class="language-plaintext highlighter-rouge">IETF</code>(Internet Engineering Task Force) : 인터넷 표준규격 제정(<code class="language-plaintext highlighter-rouge">HTTP</code>, <code class="language-plaintext highlighter-rouge">FTP</code>), <code class="language-plaintext highlighter-rouge">IETF</code>에서 만든 표준은 <code class="language-plaintext highlighter-rouge">RFC</code>(Request For Comments)로 시작<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1357811&amp;ar=relateCourse">KOCW 동서대학교 임효택 교수님 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Network" /><category term="CS" /><category term="Network" /><summary type="html"><![CDATA[컴퓨터 네트워크 전송 매체를 통해 서로 연결되어 데이터를 공유, 교환하는 컴퓨터의 모음 예) 인터넷 네트워크는 크게 나누면 유선, 무선 두 종류로 나눌 수 있다.]]></summary></entry><entry><title type="html">Java) BOJ 2798. 블랙잭</title><link href="http://localhost:4000/boj/boj2798-java/" rel="alternate" type="text/html" title="Java) BOJ 2798. 블랙잭" /><published>2022-02-20T00:00:00+09:00</published><updated>2022-02-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2798-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2798-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2798">https://www.acmicpc.net/problem/2798</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.</li>
  <li>한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.</li>
  <li>김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.</li>
  <li>이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.</li>
  <li>N장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다. 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.</li>
  <li>합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>참고 블로그 : <a href="https://minhamina.tistory.com/38">https://minhamina.tistory.com/38</a></li>
  <li>조합을 구하는 문제같아서 조합 알고리즘을 공부한 뒤 풀었다.</li>
  <li>
    <p>조합인 이유는 수를 뽑는 모든 경우의 수를 탐색해 봐야 하는데 뽑는 순서가 결과에 미치는 영향이 없기 때문이다.<br /></p>
  </li>
  <li>주어지는 N개의 숫자 중 3개를 뽑아서 M보다 작거나 같은 수 중 가장 큰 수를 만들면 되는데 이걸 알기 위해서는 조합이 가능한 모든 경우의 수를 탐색해 봐야 한다.</li>
  <li>그래서 재귀로 n개 중에 3개를 뽑는 경우, n-1개 중에 2개를 뽑는 경우, n-2개 중에 1개를 뽑는 경우,… 로 탐색하다가 n-r개 중에 0개를 뽑는 경우가 되면 그동안 뽑은 수들의 합 중 M보다 작거나 같으면서 가장 큰 수를 찾으면 된다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 132 ms</li>
  <li>메모리 : 14140 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/2c5b96d4e986e37ac3c5c0cd823ac3d1.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2798" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2798 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 2231. 분해합</title><link href="http://localhost:4000/boj/boj2231-java/" rel="alternate" type="text/html" title="Java) BOJ 2231. 분해합" /><published>2022-02-20T00:00:00+09:00</published><updated>2022-02-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2231-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2231-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2231">https://www.acmicpc.net/problem/2231</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 192 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.</li>
  <li>예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다.</li>
  <li>반대로, 생성자가 여러 개인 자연수도 있을 수 있다.</li>
  <li>자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>
    <p>참고 블로그 : <a href="https://st-lab.tistory.com/98">https://st-lab.tistory.com/98</a><br /></p>
  </li>
  <li>N의 생성자 중 가장 작은 수를 구하면 되니까 꼭 모든 수를 탐색할 필요는 없고 1부터 수를 만들어 보면서 N과 같은 수가 나오면 반복을 중단하고 해당 수를 출력하면 된다.</li>
  <li>만약 N을 넘어가는데도 생성자가 없다면 0을 출력한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 152 ms</li>
  <li>메모리 : 14828 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8f317b052aa2f68ecba29663847f959a.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2231" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2231 제한 시간 제한 : 2 초 메모리 제한 : 192 MB]]></summary></entry><entry><title type="html">컴퓨터구조) Performance</title><link href="http://localhost:4000/computer%20science/computer-architecture-02/" rel="alternate" type="text/html" title="컴퓨터구조) Performance" /><published>2022-02-20T00:00:00+09:00</published><updated>2022-02-20T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/computer-architecture-02</id><content type="html" xml:base="http://localhost:4000/computer%20science/computer-architecture-02/"><![CDATA[<h1 id="cpu-time">CPU Time</h1>
<ul>
  <li>한 컴퓨터 프로그램이 <code class="language-plaintext highlighter-rouge">CPU</code>를 차지하여 일을 한 시간의 양</li>
  <li>컴퓨터의 성능을 측정하기 위해 사용된다.</li>
  <li><code class="language-plaintext highlighter-rouge">CPU Time = Instruction Count x CPI x Clock Cycle Time</code></li>
  <li><code class="language-plaintext highlighter-rouge">CPU Time</code>이 적을수록 성능이 좋다고 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">clock cycle</code>을 줄이거나 <code class="language-plaintext highlighter-rouge">clock rate</code>가 올라가면 성능이 향상된다.<br /><br /><br /></li>
</ul>

<h1 id="instruction-count--cpi">Instruction Count &amp; CPI</h1>
<h2 id="instruction-count">Instruction Count</h2>
<ul>
  <li>명령어의 수</li>
</ul>

<h2 id="cpi">CPI</h2>
<ul>
  <li>Cycles per Instructions</li>
  <li><code class="language-plaintext highlighter-rouge">Instruction</code>의 실행주기</li>
  <li>짧은 <code class="language-plaintext highlighter-rouge">CPI</code>를 가진 <code class="language-plaintext highlighter-rouge">IC</code>가 많을수록 성능이 좋다고 할 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="성능에-영향을-미치는-요소">성능에 영향을 미치는 요소</h1>
<ul>
  <li>알고리즘 : <code class="language-plaintext highlighter-rouge">IC</code>, <code class="language-plaintext highlighter-rouge">CPI</code></li>
  <li>프로그래밍 언어 : <code class="language-plaintext highlighter-rouge">IC</code>, <code class="language-plaintext highlighter-rouge">CPI</code></li>
  <li>컴파일러 : <code class="language-plaintext highlighter-rouge">IC</code>, <code class="language-plaintext highlighter-rouge">CPI</code></li>
  <li>ISA(명령어셋) : <code class="language-plaintext highlighter-rouge">IC</code>, <code class="language-plaintext highlighter-rouge">CPI</code>, <code class="language-plaintext highlighter-rouge">T</code><br /><br /><br /></li>
</ul>

<h1 id="clock-period">Clock period</h1>
<ul>
  <li>Duration of a clock cycle</li>
  <li>하나의 <code class="language-plaintext highlighter-rouge">clock cycle</code>이 걸리는 시간</li>
  <li><code class="language-plaintext highlighter-rouge">1/clock rate</code>로 나타낼 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="power-wall">Power wall</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">clock rate</code>는 매년 꾸준히 늘다가 2004년을 기점으로 늘지 않고 있다.</li>
  <li>왜냐면 전력소모가 많이 줄었기 때문</li>
  <li>전력소모량은 <code class="language-plaintext highlighter-rouge">Capacitive load</code>x<code class="language-plaintext highlighter-rouge">Voltage^2</code>x<code class="language-plaintext highlighter-rouge">Frequency</code>로 구할 수 있는데 <code class="language-plaintext highlighter-rouge">Voltage</code>가 많이 줄었기 때문에 <code class="language-plaintext highlighter-rouge">Frequency</code>가 많이 늘어났음에도 전력소모량은 크게 늘지 않았다.</li>
  <li>그런데 <code class="language-plaintext highlighter-rouge">Voltage</code>가 높을수록 전력소모와 열 발생이 많은데 <code class="language-plaintext highlighter-rouge">Voltage</code>를 더이상 줄일 수가 없게 되었기 때문에 기존에 <code class="language-plaintext highlighter-rouge">clock rate</code>을 증가시키는 방법으로는 성능 향상을 꾀하기가 어려워졌다.</li>
  <li>2004년 이후로 <code class="language-plaintext highlighter-rouge">clock rate</code>을 증가시키지 못한 이유가 <code class="language-plaintext highlighter-rouge">CPU</code>에서 발생하는 열을 해결하지 못해서였다.</li>
  <li>그래서 <code class="language-plaintext highlighter-rouge">clock rate</code>을 올리지 않고 성능을 향상시키기 위한 방법으로 <code class="language-plaintext highlighter-rouge">Multi-core</code>가 등장하게 된다.<br /><br /><br /></li>
</ul>

<h1 id="multiprocessors">Multiprocessors</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Multicore microprocessors</code> : 하나의 칩 안에 프로세서가 여러 개 있는 것</li>
  <li><code class="language-plaintext highlighter-rouge">Parallel programming</code>이 필요하다.
    <ul>
      <li>하드웨어가 여러 명령을 동시에 실행할 수 있지만 그만큼 프로그래밍이 어렵다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="cpu-성능-측정">CPU 성능 측정</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SPEC CPU Benchmark</code>로 측정하거나 <code class="language-plaintext highlighter-rouge">MIPS</code>(Millions of Instructions per Second : 시간당 몇백만개의 명령을 실행하는가)를 이용해 측정할 수 있는데 <code class="language-plaintext highlighter-rouge">SPEC CPU Benchmark</code>가 더 정확하다고 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">SPEC CPU Benchmark</code>는 여러 파트에서 측정한 시간값을 바탕으로 총점을 매기는데 <code class="language-plaintext highlighter-rouge">MIPS</code>는 <code class="language-plaintext highlighter-rouge">IC</code>와 <code class="language-plaintext highlighter-rouge">Exectution time</code>을 이용해 계산하기 때문에 컴퓨터마다 <code class="language-plaintext highlighter-rouge">ISA</code>(명령어셋)가 다르고 또 명령어마다 필요한 <code class="language-plaintext highlighter-rouge">CPI</code>값이 다를 수 있기 때문에 객관적이라 하기 어렵다.<br /><br /><br /></li>
</ul>

<h1 id="amdahls-law">Amdahl’s Law</h1>
<ul>
  <li>컴퓨터의 어느 한 부분의 성능을 향상시키면 전체 성능의 향상은 그 부분이 컴퓨터에서 차지하는 비율만큼 향상된다는 법칙</li>
  <li><code class="language-plaintext highlighter-rouge">Corollary : make the common case fast</code></li>
  <li>따라서 전체 시스템에서 차지하는 비율이 높은 부분의 성능을 향상시키는 것이 전체 성능 향상에 도움이 된다.<br /><br /><br /></li>
</ul>

<h1 id="대기-중-전력소모">대기 중 전력소모</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>를 거의 사용하지 않는 상황에서도 생각보다 전력소모가 크다.
    <ul>
      <li>예를 들어 <code class="language-plaintext highlighter-rouge">CPU</code>가 10%만 사용중인데 전력은 전체의 47%를 사용한다는 등</li>
    </ul>
  </li>
  <li>그래서 프로세서를 만들 때 전력소모의 비율이 <code class="language-plaintext highlighter-rouge">CPU</code> 사용량에 비례되게 설계할 필요가 있는데 쉽지 않다.<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1388791&amp;ar=relateCourse">KOCW 영남대학교 최규상 교수님 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[CPU Time 한 컴퓨터 프로그램이 CPU를 차지하여 일을 한 시간의 양 컴퓨터의 성능을 측정하기 위해 사용된다. CPU Time = Instruction Count x CPI x Clock Cycle Time CPU Time이 적을수록 성능이 좋다고 할 수 있다. clock cycle을 줄이거나 clock rate가 올라가면 성능이 향상된다.]]></summary></entry><entry><title type="html">JSP) DAO</title><link href="http://localhost:4000/jsp/jdbc-dao/" rel="alternate" type="text/html" title="JSP) DAO" /><published>2022-02-19T00:00:00+09:00</published><updated>2022-02-19T00:00:00+09:00</updated><id>http://localhost:4000/jsp/jdbc-dao</id><content type="html" xml:base="http://localhost:4000/jsp/jdbc-dao/"><![CDATA[<h1 id="-daodata-access-object란">👀 DAO(Data Access Object)란?</h1>
<ul>
  <li>데이터 처리 객체</li>
  <li><code class="language-plaintext highlighter-rouge">DB</code>에 관련된 모든 동작을 수행하는 클래스</li>
  <li>지금까지 <code class="language-plaintext highlighter-rouge">JDBC</code>로 <code class="language-plaintext highlighter-rouge">DB</code>와 연결할 때 사용하려는 페이지마다 일일이 연결 코드를 적어줘야 했는데 이제는 <code class="language-plaintext highlighter-rouge">DAO</code>를 만들어서 연결 동작을 여기서 수행하도록 하고 <code class="language-plaintext highlighter-rouge">DB</code>연결이 필요한 페이지에서는 <code class="language-plaintext highlighter-rouge">DAO</code>만 호출하면 된다!</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.sql.Connection</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.DriverManager</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.PreparedStatement</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.ResultSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.sql.SQLException</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDAO</span> <span class="o">{</span> 
	
	<span class="c1">// DAO (Data Access Object) : 데이터 처리 객체</span>
	<span class="c1">// =&gt; DB에 관련된 모든 동작을 수행하는 클래스</span>
	
	<span class="c1">// 연결에 필요한 정보 저장</span>
	<span class="kd">private</span> <span class="nc">Connection</span> <span class="n">con</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">PreparedStatement</span> <span class="n">pstmt</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
	
	<span class="c1">// 디비연결 동작</span>
	<span class="kd">private</span> <span class="nc">Connection</span> <span class="nf">getConnect</span><span class="o">()</span>
	<span class="o">{</span>
	    <span class="kd">final</span> <span class="nc">String</span> <span class="no">DRIVER</span> <span class="o">=</span> <span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">;</span>
	    <span class="kd">final</span> <span class="nc">String</span> <span class="no">URL</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3306/jspdb"</span><span class="o">;</span>
	    <span class="kd">final</span> <span class="nc">String</span> <span class="no">ID</span> <span class="o">=</span> <span class="s">"root"</span><span class="o">;</span>
	    <span class="kd">final</span> <span class="nc">String</span> <span class="no">PASS</span> <span class="o">=</span> <span class="s">"1234"</span><span class="o">;</span>
	    
	    <span class="k">try</span> <span class="c1">// 예외가 발생할지도 모르는 코드 작성 </span>
	    <span class="o">{</span> 
			<span class="c1">// 1. 드라이버 로드</span>
			<span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="no">DRIVER</span><span class="o">);</span>

			<span class="c1">// 2. 디비연결</span>
			<span class="n">con</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="no">URL</span><span class="o">,</span> <span class="no">ID</span><span class="o">,</span> <span class="no">PASS</span><span class="o">);</span>
			
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 디비연결 성공!"</span> <span class="o">+</span> <span class="n">con</span><span class="o">);</span>
		<span class="o">}</span> 
	    <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> 
	    <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span> 
	    <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> 
	    <span class="o">{</span>
			<span class="c1">// TODO Auto-generated catch block</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span> <span class="c1">// 연결 정보가 계속 유지되어야 하기 때문에 finally 구문은 안쓴다.</span>
	    
		
		<span class="k">return</span> <span class="n">con</span><span class="o">;</span>
	<span class="o">}</span> <span class="c1">// 디비연결</span>
	
	<span class="c1">// 자원해제</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">CloseDB</span><span class="o">()</span>
	<span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			
			<span class="c1">// 리소스 해제는 생성의 역순으로 한다.</span>
			<span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">rs</span><span class="o">)</span> <span class="n">rs</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 연결해제</span>
			<span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">pstmt</span><span class="o">)</span> <span class="n">pstmt</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
			<span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">con</span><span class="o">)</span> <span class="n">con</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> 
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 자원해제 완료"</span><span class="o">);</span>
			
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// TODO Auto-generated catch block</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span> 
	<span class="o">}</span> <span class="c1">// 자원해제</span>
	
	<span class="c1">// 회원가입 - insertMember()</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertMember</span><span class="o">(</span><span class="nc">MemberBean</span> <span class="n">mb</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : insertMember() 호출"</span><span class="o">);</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="c1">// 1. 드라이버 로드</span>
			<span class="c1">// 2. 디비연결</span>
			<span class="n">con</span> <span class="o">=</span> <span class="n">getConnect</span><span class="o">();</span>
			
			<span class="c1">// 3. sql 작성 &amp; pstmt 객체 생성</span>
			<span class="n">sql</span> <span class="o">=</span> <span class="s">"insert into itwill_member(id, pass, name, age, gender, email, regdate) "</span>
					<span class="o">+</span> <span class="s">"values(?, ?, ?, ?, ?, ?, ?)"</span><span class="o">;</span>
			<span class="n">pstmt</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
			
			<span class="c1">// ???</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getPass</span><span class="o">());</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getGender</span><span class="o">());</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setTimestamp</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getRegdate</span><span class="o">());</span>
			
			<span class="c1">// 4. sql 실행</span>
			<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pstmt</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 회원가입 성공!"</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
			
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// TODO Auto-generated catch block</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="k">finally</span> <span class="o">{</span>
			
			<span class="nc">CloseDB</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span> <span class="c1">// 회원가입 - insertMember()</span>
	
	<span class="c1">// 로그인 - loginCheck(mb)</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">loginCheck</span><span class="o">(</span><span class="nc">MemberBean</span> <span class="n">mb</span><span class="o">)</span>
	<span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 로그인 - loginCheck(mb)"</span><span class="o">);</span>
		
		<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="c1">// 1, 2. 디비연결</span>
			<span class="n">con</span> <span class="o">=</span> <span class="n">getConnect</span><span class="o">();</span>
			
			<span class="c1">// 3. sql 작성(select) &amp; pstmt 객체 생성</span>
			<span class="n">sql</span> <span class="o">=</span> <span class="s">"select pass from itwill_member where id=?"</span><span class="o">;</span>
			<span class="n">pstmt</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
			
			<span class="c1">// ??</span>
			<span class="n">pstmt</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
			
			<span class="c1">// 4. sql 실행</span>
			<span class="n">rs</span> <span class="o">=</span> <span class="n">pstmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
			
			<span class="c1">// 5. 데이터처리</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span>
			<span class="o">{</span>
				<span class="c1">// 회원</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">mb</span><span class="o">.</span><span class="na">getPass</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"pass"</span><span class="o">)))</span>
				<span class="o">{</span>
					<span class="c1">// 본인</span>
					<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
				<span class="o">}</span>
				<span class="k">else</span> 
				<span class="o">{</span>
					<span class="c1">// 비밀번호 오류</span>
					<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="k">else</span> 
			<span class="o">{</span>
				<span class="c1">// 비회원</span>
				<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
			<span class="o">}</span>
			
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 로그인체크 완료 ("</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
			
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>

			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
			
			<span class="nc">CloseDB</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 로그인 - loginCheck(mb)"</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span> <span class="c1">// 로그인 - loginCheck(mb)</span>

<span class="o">}</span> <span class="c1">// MemberDAO</span>
</code></pre></div></div>

<ul>
  <li>이렇게 <code class="language-plaintext highlighter-rouge">DAO</code> 클래스를 만든 다음에<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
  <span class="nt">&lt;%</span>
    <span class="c1">// 한글처리</span>
    <span class="n">request</span><span class="o">.</span><span class="na">setCharacterEncoding</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
    
    <span class="c1">// 전달되는 정보 저장 - 액션태그</span>
  <span class="nt">%&gt;</span>
    <span class="nt">&lt;jsp:useBean </span><span class="na">id=</span><span class="s">"mb"</span><span class="na"> class=</span><span class="s">"com.itwillbs.member.MemberBean"</span><span class="nt">&gt;&lt;/jsp:useBean&gt;</span>
    <span class="nt">&lt;jsp:setProperty </span><span class="na">property=</span><span class="s">"*"</span><span class="na"> name=</span><span class="s">"mb"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;%</span>
    <span class="c1">// DB정보를 사용해서 로그인 체크</span>
    <span class="c1">// DAO 객체 생성</span>
    <span class="nc">MemberDAO</span> <span class="n">dao</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberDAO</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">dao</span><span class="o">.</span><span class="na">loginCheck</span><span class="o">(</span><span class="n">mb</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pro : 로그인체크 완료 ("</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">result</span><span class="o">)</span>
    <span class="o">{</span>
    	<span class="n">session</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="n">mb</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
    	<span class="nt">%&gt;</span>
    	  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
    	    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">로그인 성공!</span><span class="dl">"</span><span class="p">)</span>
    	    <span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="o">=</span><span class="dl">'</span><span class="s1">main.jsp</span><span class="dl">'</span><span class="p">;</span>
    	  <span class="nt">&lt;/script&gt;</span>
    	<span class="nt">&lt;%</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">result</span><span class="o">)</span>
    <span class="o">{</span>
    	<span class="nt">%&gt;</span>
    	  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
    	    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">비밀번호 오류!</span><span class="dl">"</span><span class="p">);</span>
    	    <span class="nx">history</span><span class="p">.</span><span class="nx">back</span><span class="p">();</span>
    	  <span class="nt">&lt;/script&gt;</span>
    	<span class="nt">&lt;%</span>
    <span class="o">}</span>
    <span class="k">else</span>
    <span class="o">{</span>
    	<span class="nt">%&gt;</span>
    	  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;</span>
    	    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">비회원 입니다!</span><span class="dl">"</span><span class="p">);</span>
    	    <span class="nx">history</span><span class="p">.</span><span class="nx">back</span><span class="p">();</span>
    	  <span class="nt">&lt;/script&gt;</span>
    	<span class="nt">&lt;%</span>
    <span class="o">}</span>
    
    <span class="c1">// 체크 결과에 따른 페이지 이동</span>
  <span class="nt">%&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JSP</code> 페이지에서는 아까 만든 객체를 호출하기만 하면 된다!</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="Database" /><category term="JSP" /><category term="DAO" /><summary type="html"><![CDATA[👀 DAO(Data Access Object)란? 데이터 처리 객체 DB에 관련된 모든 동작을 수행하는 클래스 지금까지 JDBC로 DB와 연결할 때 사용하려는 페이지마다 일일이 연결 코드를 적어줘야 했는데 이제는 DAO를 만들어서 연결 동작을 여기서 수행하도록 하고 DB연결이 필요한 페이지에서는 DAO만 호출하면 된다!]]></summary></entry><entry><title type="html">SQL) JOIN</title><link href="http://localhost:4000/database/SQL-join/" rel="alternate" type="text/html" title="SQL) JOIN" /><published>2022-02-19T00:00:00+09:00</published><updated>2022-02-19T00:00:00+09:00</updated><id>http://localhost:4000/database/SQL-join</id><content type="html" xml:base="http://localhost:4000/database/SQL-join/"><![CDATA[<h1 id="️-문법">☑️ 문법</h1>
<ul>
  <li>같은 컬럼을 가지고 있는 여러 테이블을 묶어서 데이터를 볼 때 사용한다.</li>
</ul>

<h2 id="1-on절을-사용한-join">1. ON절을 사용한 JOIN</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">e</span><span class="p">.</span><span class="n">employee_id</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">last_name</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">department_id</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">department_id</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">location_id</span>
<span class="k">FROM</span>   <span class="n">employees</span> <span class="n">s</span> <span class="k">JOIN</span> <span class="n">departments</span> <span class="n">d</span>
<span class="k">ON</span>     <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">department_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">department_id</span><span class="p">)</span> <span class="c1">-- 여기에 입력할 컬럼은 조인시킬 테이블 모두에 있어야 함</span>
<span class="k">WHERE</span>  <span class="n">e</span><span class="p">.</span><span class="n">manager_id</span> <span class="o">=</span> <span class="mi">149</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>테이블 두 개만 가능한 것은 아니고 세 개, 네 개, … 작성하는 만큼 가능하다.</li>
</ul>

<h2 id="2-on절을-사용한-self-join">2. ON절을 사용한 Self-Join</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>  <span class="n">worker</span><span class="p">.</span><span class="n">last_name</span> <span class="n">emp</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">last_name</span> <span class="n">mgr</span>
<span class="k">FROM</span>    <span class="n">employees</span> <span class="n">worker</span> <span class="k">JOIN</span> <span class="n">employees</span> <span class="n">manager</span>
<span class="k">ON</span>      <span class="p">(</span><span class="n">worker</span><span class="p">.</span><span class="n">manager_id</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">employee_id</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>같은 테이블 안에서 <code class="language-plaintext highlighter-rouge">JOIN</code> 하는 것도 가능하다.<br /></li>
</ul>

<h3 id="️-쿼리문-작성-팁">❗️ 쿼리문 작성 팁</h3>
<ul>
  <li>컬럼명을 입력할 때 해당 컬럼이 속해있는 테이블명을 입력하면 해당 범위에서만 검색을 시행하기 때문에 실행속도가 훨씬 빨라진다. (테이블명을 적지 않아도 실행되지만 그만큼 모든 테이블을 대상으로 검색해서 결과를 가져오기 때문에 실행속도가 훨씬 느리다.)</li>
  <li>그래서 실행속도가 빠른 쿼리문을 작성하는 것이 중요하다.</li>
  <li>그런데 테이블 풀네임을 일일이 적어주면 너무 길어서 가독성이 떨어지니까 약자로 적을 수 있는데 대신 약자로 적었다면 <code class="language-plaintext highlighter-rouge">FROM</code>절에서 어떤 테이블명의 약자인지 꼭 명시해줘야 <code class="language-plaintext highlighter-rouge">SQL</code>이 헷갈리지 않고 잘 찾아올 수 있다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><category term="SQL" /><summary type="html"><![CDATA[☑️ 문법 같은 컬럼을 가지고 있는 여러 테이블을 묶어서 데이터를 볼 때 사용한다.]]></summary></entry></feed>