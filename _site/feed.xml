<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-12T20:07:27+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부 기록하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) 프로그래머스 - 예산</title><link href="http://localhost:4000/programmers/programmers-binary-search/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 예산" /><published>2022-07-11T00:00:00+09:00</published><updated>2022-07-11T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-binary-search</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-binary-search/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62949">https://school.programmers.co.kr/learn/courses/10302/lessons/62949</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다.<br /><br /></li>
</ul>

<ol>
  <li>모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다.<br /></li>
  <li>모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다.</li>
</ol>

<ul>
  <li>예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150일 때, 상한액을 127로 잡으면 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 됩니다.</li>
  <li>각 지방에서 요청하는 예산이 담긴 배열 budgets과 총 예산 M이 매개변수로 주어질 때, 위의 조건을 모두 만족하는 상한액을 return 하도록 solution 함수를 작성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>지방의 수는 3 이상 100,000 이하인 자연수입니다.</li>
  <li>각 지방에서 요청하는 예산은 1 이상 100,000 이하인 자연수입니다.</li>
  <li>총 예산은 지방의 수 이상 1,000,000,000 이하인 자연수입니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>
    <p>뭔가 막연하게 이분탐색 문제같았는데 범위를 좁혀나가는 기준을 어떻게 설정해야 할 지 모르겠어서 풀이 영상을 봤다. 이분탐색 문제는 풀 때마다 어렵게 느껴진다 😭</p>
  </li>
  <li>문제를 풀기 위해서는 금액이 최대가 되는 상한액의 범위를 좁혀가면서 탐색해야 한다. 그래서 최소값(0)과 최대값(입력 중 가장 큰 값) 범위에서 중간값을 구한 다음 이 중간값이 적절한 상한액이면 정답이 되는 것이고 많이 모자란 값이라면 최소값을 증가시키고, 초과하는 값이라면 최대값을 감소시킨다.</li>
  <li>이 과정을 최소값과 최대값이 같아지는(서로 만나는) 지점까지 반복하면 된다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/d168474b2fe3ceb2d077e3962f62e964.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><category term="BinarySearch" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62949]]></summary></entry><entry><title type="html">정보처리기사) 네트워크 레이어 프로토콜</title><link href="http://localhost:4000/certificate/network-layer/" rel="alternate" type="text/html" title="정보처리기사) 네트워크 레이어 프로토콜" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/certificate/network-layer</id><content type="html" xml:base="http://localhost:4000/certificate/network-layer/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="네트워크-계층">네트워크 계층</h1>
<ul>
  <li>데이터 전송을 위한 최적의 경로 설정</li>
  <li>단위 : 패킷</li>
</ul>

<h2 id="장비">장비</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">L3 스위치</code> : 3계층에서 동작하는 스위치 (L2 스위치 기능 + L3 라우터 기능을 모두 갖춘 장비)</li>
  <li><code class="language-plaintext highlighter-rouge">라우터</code> : 최적의 경로를 지정하고 경로에 따라 전송시키는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">게이트웨이</code> : 다른 통신망에 접속할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">인터넷 공유기</code> : 하나의 인터넷 라인을 여러 컴퓨터가 공유할 수 있게 해주는 장비</li>
  <li><code class="language-plaintext highlighter-rouge">망(백본) 스위치 허브</code> : 광역 네트워크를 커버하는 스위칭 허브</li>
</ul>

<h2 id="프로토콜">프로토콜</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IP</code> : 패킷 단위의 네트워크 통신 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">라우팅 프로토콜</code> : 최적의 데이터 전송 경로를 설정하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ARP</code> : IP주소(3계층)을 MAC주소(2계층)으로 변환하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">RARP</code> : MAC 주소는 알지만 IP 주소는 모를 때 사용하는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">ICMP</code> : IP 패킷 처리 시의 문제를 알려주는 프로토콜</li>
  <li><code class="language-plaintext highlighter-rouge">IGMP</code> : 멀티캐스트 실시간 전송을 위해 사용하는 프로토콜 (화상회의 등)</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="OSI7" /><category term="NetworkLayer" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 네트워크 계층 데이터 전송을 위한 최적의 경로 설정 단위 : 패킷]]></summary></entry><entry><title type="html">Java) 프로그래머스 - 가장 큰 수</title><link href="http://localhost:4000/programmers/programmers-bigNumber-java/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 가장 큰 수" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-bigNumber-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-bigNumber-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62948">https://school.programmers.co.kr/learn/courses/10302/lessons/62948</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.</li>
  <li>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.</li>
  <li>0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>numbers의 길이는 1 이상 100,000 이하입니다.</li>
  <li>numbers의 원소는 0 이상 1,000 이하입니다.</li>
  <li>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>주어지는 배열의 숫자들을 조합해서 숫자를 만들다 보면 정수 자료형의 범위를 초과할 수 있다.</li>
  <li>그래서 조합을 시도할 땐 정수를 문자열로 바꾸어야 한다. 여기까지는 맞는 접근…</li>
</ul>

<h2 id="1차-시도">1차 시도</h2>
<ul>
  <li>배열의 모든 원소를 조합해서 숫자를 만들어봐야 하기 때문에 순열문제라고 생각했다. 그래서 순열 만드는 함수를 만들어 모든 순열을 구한 다음에 그걸 정렬해서 가장 큰 수를 리턴하는 방식으로 했다.</li>
  <li>테스트 케이스는 통과했지만 막상 제출하니까 시간초과가 뜨면서 실패했다…ㅎ</li>
  <li>나중에 풀이를 보니까 접근 방법 자체가 달라서 통과할 수 없는 알고리즘이었다. 순열을 구하는 메서드에서 시간초과가 발생했거나 무한루프가 돈 것으로 예상되었다.</li>
</ul>

<h2 id="2차-시도">2차 시도</h2>
<ul>
  <li>풀이 영상을 보고 처음에 생각했던 접근방법이 틀렸다는 걸 알게 되었다.</li>
  <li>이 문제를 시간 안에 통과하기 위한 접근법은 숫자를 -&gt; 문자로 바꾸고 -&gt; 내림차순으로 정렬해서 -&gt; 문자열로 조합 이었다.</li>
  <li>하지만 무작정 내림차순으로 정렬하면 테스트 케이스 1처럼 <code class="language-plaintext highlighter-rouge">6, 10</code>인 경우에는 <code class="language-plaintext highlighter-rouge">610</code>이 큰 수지만 단순 내림차순으로 정렬해 버린 후 조합하면 <code class="language-plaintext highlighter-rouge">10, 6</code>이 되어 <code class="language-plaintext highlighter-rouge">106</code>이라는 결과를 얻게 된다. 그렇기 때문에 두 수를 조합한 결과가 큰 순서대로 내림차순 정렬될 수 있도록 해야한다.</li>
  <li>이를 위해 <code class="language-plaintext highlighter-rouge">compareTo()</code> 메서드를 사용해 정렬 대상이 되는 앞뒤 원소 두 개를 조합한 결과에 따라 내림차순 정렬이 될 수 있도록 했다.</li>
  <li>주 언어가 자바지만 정작 코테 준비는 <code class="language-plaintext highlighter-rouge">C++</code>이나 <code class="language-plaintext highlighter-rouge">파이썬</code>으로 많이 했었기 때문에 자바의 컬렉션에 좀 약했는데 풀이 강의는 자바 사용에 대한 팁도 많이 줘서 좋았다. 이것 하나로 수강료가 아깝지 않았다.</li>
  <li>프로그래머스 <a href="https://school.programmers.co.kr/learn/courses/10302">[Java/문제풀이] 코딩테스트 광탈 방지 Kit: Java편</a> 왕추천!! <br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/a4ecd2b3fa0442c38c6fc07058a86114.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><category term="Sorting" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62948]]></summary></entry><entry><title type="html">Java) 프로그래머스. 로또의 최고 순위와 최저 순위</title><link href="http://localhost:4000/programmers/programmers-lotto-java/" rel="alternate" type="text/html" title="Java) 프로그래머스. 로또의 최고 순위와 최저 순위" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-lotto-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-lotto-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/77484">https://school.programmers.co.kr/learn/courses/30/lessons/77484</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.</li>
  <li>민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.</li>
  <li>(문제 전문은 링크에…)<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>lottos는 길이 6인 정수 배열입니다.</li>
  <li>lottos의 모든 원소는 0 이상 45 이하인 정수입니다.
    <ul>
      <li>0은 알아볼 수 없는 숫자를 의미합니다.</li>
      <li>0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.</li>
      <li>lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.</li>
    </ul>
  </li>
  <li>win_nums은 길이 6인 정수 배열입니다.</li>
  <li>win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.
    <ul>
      <li>win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.</li>
      <li>win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>문제를 단순하게 보면 가장 높은 등수를 받을 수 있는 경우는 알아볼 수 없는 숫자 모두가 당첨번호와 일치하는 경우이고, 가장 낮은 등수는 알아볼 수 없는 숫자 모두가 당첨번호와 일치하지 않는 경우이다.</li>
  <li>그렇기 때문에 민우가 선택한 번호에서 당첨번호와 일치하는 숫자의 개수를 센 다음 0의 개수도 세어서 더해주면 가장 높은 등수이고 더하지 않는다면 가장 낮은 등수이다.</li>
  <li>2중 반복문을 사용했는데 이 과정에서 내부 반복문의 조건식에 외부 반복문의 변수를 잘못 적어서 인덱스 범위 초과 에러가 났었다… 중첩 반복문을 쓸 때 변수 헷갈리지 않도록 조심하자!</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/1a87d96c893a7a2cc45c3468acc77376.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/77484]]></summary></entry><entry><title type="html">정보처리기사) 암호화 알고리즘</title><link href="http://localhost:4000/certificate/encryption/" rel="alternate" type="text/html" title="정보처리기사) 암호화 알고리즘" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/certificate/encryption</id><content type="html" xml:base="http://localhost:4000/certificate/encryption/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="des">DES</h1>
<ul>
  <li>미국 NBS (National Bureau of Standards, 현재 NIST)에서 국가 표준으로 정한 암호 알고리즘으로, 64비트 평문을 64비트 암호문으로 암화하는 대칭키 암호 알고리즘이다. 키는 7비트마다 오류검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트이다. 현재는 취약하여 사용되지 않는다.<br /><br /></li>
</ul>

<h1 id="aria">ARIA</h1>
<ul>
  <li>대칭키(블록)</li>
  <li>학계(Academy) + 연구기관(Research Institute) + 정부(Agency)</li>
  <li>국정원과 산학연구협회가 개발함<br /><br /></li>
</ul>

<h1 id="rsa">RSA</h1>
<ul>
  <li>비대칭키</li>
  <li>수학교수 3명의 앞글자를 땄음 (리베스트, 샤미르, 아들만). 소인수 분해 문제의 어려움을 근거로 함<br /><br /></li>
</ul>

<h1 id="md5">MD5</h1>
<ul>
  <li>해시 암호화</li>
  <li><code class="language-plaintext highlighter-rouge">MD4</code>를 개선한 알고리즘</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="Algorithm" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 DES 미국 NBS (National Bureau of Standards, 현재 NIST)에서 국가 표준으로 정한 암호 알고리즘으로, 64비트 평문을 64비트 암호문으로 암화하는 대칭키 암호 알고리즘이다. 키는 7비트마다 오류검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트이다. 현재는 취약하여 사용되지 않는다.]]></summary></entry><entry><title type="html">Java) 프로그래머스 - 기지국 설치</title><link href="http://localhost:4000/programmers/programmers-coverage-java/" rel="alternate" type="text/html" title="Java) 프로그래머스 - 기지국 설치" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-coverage-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-coverage-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/10302/lessons/62946">https://school.programmers.co.kr/learn/courses/10302/lessons/62946</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다.</li>
  <li>예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.)</li>
  <li>이때, 우리는 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다.</li>
  <li>아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요.</li>
  <li>(문제 전문은 링크에…)<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>N: 200,000,000 이하의 자연수</li>
  <li>stations의 크기: 10,000 이하의 자연수</li>
  <li>stations는 오름차순으로 정렬되어 있고, 배열에 담긴 수는 N보다 같거나 작은 자연수입니다.</li>
  <li>W: 10,000 이하의 자연수<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>
    <p>코테공부를 오래 쉰 거 치고는 생각외로 빠르게 푼 문제… 아직 완전히 감을 잃지는 않았나보다 ㅠㅠ 그리디 기본문제라 쉽긴 했다.<br /><br /></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">n</code>의 최대값이 2억으로 꽤 크기 때문에 완전탐색으로 답을 구하면 효율성 테스트를 통과하지 못 할 것이다.</li>
  <li>
    <p>그래서 기지국을 설치해야 하는 구간의 길이를 구한 다음 기지국 하나의 커버리지 길이로 나눠주면 완전탐색에 비해서는 빠르게 구할 수 있을 것이라 생각하고 코드를 짰다.<br /><br /></p>
  </li>
  <li>설치해야 할 기지국의 개수의 최솟값을 구하려면 먼저 하나의 기지국 당 커버할 수 있는 길이를 구해야 한다.
    <ul>
      <li>문제의 그림을 참고하면 하나의 기지국이 커버할 수 있는 길이는 <code class="language-plaintext highlighter-rouge">w * 2 + 1</code>이다. 기지국이 설치된 위치 기준으로 양 옆 <code class="language-plaintext highlighter-rouge">w</code>만큼 커버할 수 있기 때문에 <code class="language-plaintext highlighter-rouge">w</code>의 2배에 기지국이 설치된 위치 1만큼을 더해주어야 한다.<br /><br /></li>
    </ul>
  </li>
  <li>다음으로 기지국이 커버할 수 없어 비어있는 구간의 길이를 구해야 한다.
    <ul>
      <li>이는 (현재 기지국을 설치해야 하는 빈 구간의 끝점 - 시작점)으로 구할 수 있다.
        <ul>
          <li>빈 구간의 끝점은 빈 구간 다음에 첫 번째로 나오는 기지국의 위치에서 <code class="language-plaintext highlighter-rouge">w + 1</code>만큼을 빼면 구할 수 있다.</li>
          <li>시작점은 설치된 기지국의 위치 + <code class="language-plaintext highlighter-rouge">w + 1</code>로 구할 수 있다.</li>
        </ul>
      </li>
      <li>(끝점 - 시작점)으로 빈 구간의 길이를 구한 다음 위에서 구했던 기지국의 커버리지로 나눠본다.
        <ul>
          <li>나눈 나머지가 0이면 몫만큼 기지국을 설치하면 되지만, 나머지가 0보다 크다면 1개를 추가로 설치해야 모든 구역을 커버할 수 있다.</li>
        </ul>
      </li>
      <li>위의 과정을 기지국의 위치 배열인 <code class="language-plaintext highlighter-rouge">stations</code>의 원소 갯수만큼 반복한다.<br /><br /></li>
    </ul>
  </li>
  <li>두 번째 항목의 반복문이 끝나고 나면 마지막 기지국 뒤에 남아있는 빈 구간이 생길 수 있기 때문에 마지막으로 구했던 끝점이 아파트의 전체 길이보다 작다면 남은 구간에 대해 두 번째 항목을 한 번 더 수행한다.<br /><br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<ul>
  <li>효율성 테스트 결과 평균 <code class="language-plaintext highlighter-rouge">0.7ms</code> 정도에 통과할 수 있었다. 굿굿~~</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/4330cbc0e820660fdb28eca5b24e74a5.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Greedy" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/10302/lessons/62946]]></summary></entry><entry><title type="html">Java) 프로그래머스. 나머지가 1이 되는 수 찾기</title><link href="http://localhost:4000/programmers/programmers-rest1-java/" rel="alternate" type="text/html" title="Java) 프로그래머스. 나머지가 1이 되는 수 찾기" /><published>2022-07-08T00:00:00+09:00</published><updated>2022-07-08T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-rest1-java</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-rest1-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://school.programmers.co.kr/learn/courses/30/lessons/87389">https://school.programmers.co.kr/learn/courses/30/lessons/87389</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>자연수 n이 매개변수로 주어집니다. n을 x로 나눈 나머지가 1이 되도록 하는 가장 작은 자연수 x를 return 하도록 solution 함수를 완성해주세요. 답이 항상 존재함은 증명될 수 있습니다.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>3 ≤ n ≤ 1,000,000<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>한동안 코테준비를 놓았다가 다시 시작해 보면서 프로그래머스의 레벨1부터 시작하기로 했다. 원하는 직무는 자바 개발이니까 자바로 코테를 연습하려 하는데 너~~~무 오랜만이라 그런지 풀이를 떠올리는데 의외로 오래 걸렸다…ㅠ 반성하자…</li>
  <li>시간에 대한 제한이 없고 입력값의 최대치도 그리 큰 수가 아니라 완전탐색으로 풀었다.</li>
  <li>입력으로 주어지는 값의 최소값이 3이니까 반복문으로 3의 나머지를 1로 만들 수 있는 2부터 시작해서 <code class="language-plaintext highlighter-rouge">n</code>보다 1 작을 때까지 증가시키며 모듈러 연산(%)을 사용해서 나머지를 구했다. 이 과정에서 나머지가 1이면 정답으로 저장하고 반복문을 탈출한다.</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/3e9869bda33ee95da0b89724c7f40456.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/87389]]></summary></entry><entry><title type="html">정보처리기사) 데이터베이스 설계 절차</title><link href="http://localhost:4000/certificate/db-step/" rel="alternate" type="text/html" title="정보처리기사) 데이터베이스 설계 절차" /><published>2022-07-06T00:00:00+09:00</published><updated>2022-07-06T00:00:00+09:00</updated><id>http://localhost:4000/certificate/db-step</id><content type="html" xml:base="http://localhost:4000/certificate/db-step/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="데이터베이스-설계-절차">데이터베이스 설계 절차</h1>
<ul>
  <li>요구사항 분석 - 개념적 설계 - 논리적 설계 - 물리적 설계 - 구현</li>
</ul>

<h2 id="요구사항-분석">요구사항 분석</h2>
<ul>
  <li>DB에 저장할 대상, 제약조건, 데이터 처리 등에 대한 요구사항 수집</li>
  <li>개체와 애트리뷰트, 개체 간 관계 파악, 데이터 처리 시 사용되는 주요 연산들, 연산 시 접근하는 데이터 양 등을 요구사항 분석</li>
</ul>

<h2 id="개념적-설계">개념적 설계</h2>
<ul>
  <li>개체 타입, 관계 타입, 속성들을 식별하고, 속성들의 도메인을 결정하고, 후보키와 기본키를 결정</li>
  <li>개념적 스키마(ER 스키마)는 ER 다이어그램으로 표현됨</li>
  <li>현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 과정으로 주요 산출물에는 E-R 다이어그램이 있다.</li>
</ul>

<h2 id="논리적-설계">논리적 설계</h2>
<ul>
  <li>선택한 DBMS의 데이터 모델을 사용하여 논리적 스키마 생성</li>
  <li>트랙잭션 인터페이스 설계, 스키마의 평가 및 설계 수행</li>
  <li>스키마 정제(정규화) : 관계 데이터베이스 스키마를 더 좋은 관계 데이터베이스 스키마로 변환하기 위해서 정규화 과정을 적용</li>
  <li>목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계하는 정규화 과정을 수행한다.</li>
</ul>

<h2 id="물리적-설계">물리적 설계</h2>
<ul>
  <li>데이터 처리 요구사항들을 만족시키기 위해 저장 구조와 접근 경로 등을 결정</li>
  <li>특정 DBMS의 특성 및 성능을 고려하여 데이터베이스 저장 구조로 변환하는 과정으로 결과로 나오는 명세서는 테이블 정의서 등이 있다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="DB" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 데이터베이스 설계 절차 요구사항 분석 - 개념적 설계 - 논리적 설계 - 물리적 설계 - 구현]]></summary></entry><entry><title type="html">정보처리기사) 스키마(Schema)</title><link href="http://localhost:4000/certificate/schema/" rel="alternate" type="text/html" title="정보처리기사) 스키마(Schema)" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/certificate/schema</id><content type="html" xml:base="http://localhost:4000/certificate/schema/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲<br /><br /></li>
</ul>

<h1 id="스키마schema">스키마(Schema)</h1>
<ul>
  <li>데이터베이스의 객체로는 스키마(Schema), 도메인(Domain), 테이블(Table), 뷰(View), 인덱스(Index) 등이 있으며 데이터 정의어(DDL)를 이용하여 객체를 생성(Create), 변경(Alter), 제거(Drop, Truncate)가 가능하다.</li>
  <li>스키마란 데이터베이스의 전체적인 구조와 제약조건에 대한 명세로, 개념 스키마, 내부 스키마, 외부 스키마로 나뉜다.</li>
  <li>스키마는 실세계의 구조를 표현하며 데이터 모델을 사용하여 만들어지며 하나의 조직에서 관심 있는 데이터의 구조를 기술한 언어적이고 그래픽적으로 표현한 시간에 독립적인 고정된 집합체이다.</li>
</ul>

<h2 id="외부external-스키마">외부(External) 스키마</h2>
<ul>
  <li>사용자 관점, 사용자마다 다른 스키마, 개념 스키마의 서브 스키마</li>
</ul>

<h2 id="개념conceptual-스키마">개념(Conceptual) 스키마</h2>
<ul>
  <li>통합 관점, 논리적 구조, 관계, 제약조건</li>
</ul>

<h2 id="내부internal-스키마">내부(Internal) 스키마</h2>
<ul>
  <li>물리저장장치 관점, 파일/레코드 등 물리적 저장 구조<br /><br /></li>
</ul>

<h1 id="도메인domain">도메인(Domain)</h1>
<ul>
  <li>속성의 데이터 타입과 크기, 제약조건 등을 지정한 정보</li>
  <li>속성이 가질 수 있는 값의 범위로 이해 가능<br /><br /></li>
</ul>

<h1 id="테이블table">테이블(Table)</h1>
<ul>
  <li>데이터의 저장 공간<br /><br /></li>
</ul>

<h1 id="뷰view">뷰(View)</h1>
<ul>
  <li>하나 이상의 물리 테이블에서 유도되는 가상의 논리 테이블<br /><br /></li>
</ul>

<h1 id="인덱스index">인덱스(Index)</h1>
<ul>
  <li>검색을 빠르게 하기 위한 데이터 구조<br /><br /></li>
</ul>

<h1 id="데이터-독립성data-independence">데이터 독립성(Data Independence)</h1>
<ul>
  <li>데이터베이스에서 상위 단계의 스키마에 영향을 주지 않으면서 해당 단계의 스키마를 변경할 수 있는 성질<br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="schema" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 스키마(Schema) 데이터베이스의 객체로는 스키마(Schema), 도메인(Domain), 테이블(Table), 뷰(View), 인덱스(Index) 등이 있으며 데이터 정의어(DDL)를 이용하여 객체를 생성(Create), 변경(Alter), 제거(Drop, Truncate)가 가능하다. 스키마란 데이터베이스의 전체적인 구조와 제약조건에 대한 명세로, 개념 스키마, 내부 스키마, 외부 스키마로 나뉜다. 스키마는 실세계의 구조를 표현하며 데이터 모델을 사용하여 만들어지며 하나의 조직에서 관심 있는 데이터의 구조를 기술한 언어적이고 그래픽적으로 표현한 시간에 독립적인 고정된 집합체이다.]]></summary></entry><entry><title type="html">정보처리기사) 정규화와 반정규화</title><link href="http://localhost:4000/certificate/db-normalization/" rel="alternate" type="text/html" title="정보처리기사) 정규화와 반정규화" /><published>2022-07-04T00:00:00+09:00</published><updated>2022-07-04T00:00:00+09:00</updated><id>http://localhost:4000/certificate/db-normalization</id><content type="html" xml:base="http://localhost:4000/certificate/db-normalization/"><![CDATA[<ul>
  <li>최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲</li>
</ul>

<h1 id="정규화normalization">정규화(Normalization)</h1>
<ul>
  <li>중복을 최소화하게 데이터를 구조화하는 작업</li>
  <li>데이터베이스 이상현상의 원인이 되는 데이터 중복성을 제거하여 데이터의 무결성을 보존하는 기법</li>
  <li>
    <p>1NF, 2NF, 3NF, BCNF, 4NF, 5NF로 분류한다. <br /><br /></p>
  </li>
  <li>제1정규화(1NF) : 릴레이션 R의 모든 속성값이 원자값을 가지는 릴레이션</li>
  <li>제2정규화(2NF) : 릴레이션 R이 제1정규형이고 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때</li>
  <li>제3정규화(3NF) : 릴레이션 R이 제2정규형이고 기본키가 아닌 속성이 기본키에 비이행적 non-transitive으로 종속할 때(직접 종속)</li>
  <li>보이스/코드 정규화(BCNF) : 릴레이션 R에서 함수 종속성 X -&gt; Y가 성립할 때 모든 결정자 X가 후보키 일 때</li>
  <li>제4정규화(4NF) : 릴레이션 R에서 MVD A -» B가 존재할 때 R의 모든 속성들이 A에 함수종속(FD)이면 R은 4NF(즉 R의 모든 속성 X에 대해 A -&gt; X이고 A가 후보키)</li>
  <li>제5정규화(5NF) : 릴레이션 R에 존재하는 모든 조인 종속(Join Dependency)이 R의 후보키를 통해 성립되면, R은 5NF
<br /><br /></li>
</ul>

<h1 id="비정규화denormalization">비정규화(Denormalization)</h1>
<ul>
  <li>정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 성능개선을 위하여 의도적으로 정규화 원칙을 위배하는 행위</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Certificate" /><category term="Certificate" /><category term="normalization" /><category term="denormalization" /><category term="study" /><summary type="html"><![CDATA[최근 미뤄뒀던 정보처리기사 실기를 준비하며… 꼭 외워야 하는 내용 정리 🥲 정규화(Normalization) 중복을 최소화하게 데이터를 구조화하는 작업 데이터베이스 이상현상의 원인이 되는 데이터 중복성을 제거하여 데이터의 무결성을 보존하는 기법 1NF, 2NF, 3NF, BCNF, 4NF, 5NF로 분류한다.]]></summary></entry></feed>