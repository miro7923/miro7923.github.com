<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-05T00:16:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">프로젝트) Cafe(웹 사이트) 만들기 1</title><link href="http://localhost:4000/project%20log/cafe-project-01/" rel="alternate" type="text/html" title="프로젝트) Cafe(웹 사이트) 만들기 1" /><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><id>http://localhost:4000/project%20log/cafe-project-01</id><content type="html" xml:base="http://localhost:4000/project%20log/cafe-project-01/"><![CDATA[<h1 id="개발환경">개발환경</h1>
<ul>
  <li>MacBook Air (M1, 2020) 16GB</li>
  <li>JDK 8</li>
  <li>Eclipse 2021-12</li>
  <li>tomcat 8.5<br /><br /><br /></li>
</ul>

<h1 id="시작">시작</h1>
<ul>
  <li>2022.3.4 ~ <br /><br /><br /></li>
</ul>

<h1 id="주제">주제</h1>
<ul>
  <li>국비 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.</li>
  <li>회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 <code class="language-plaintext highlighter-rouge">한 달</code></li>
  <li>나는 <code class="language-plaintext highlighter-rouge">다음 카페</code>를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.</li>
  <li>평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.<br /><br /><br /></li>
</ul>

<h1 id="진행상황">진행상황</h1>
<p align="center"><img src="../../assets/images/cafeProj01.png" /></p>
<p><br /></p>

<ul>
  <li>그래서 오늘 진행한 것은 무료 템플릿 사이트에서 다운받은 템플릿을 이용해 기본적인 사이트 틀을 만들었다.</li>
  <li>메인 페이지를 만들고 로그인 페이지와 회원가입 페이지 폼을 만들어서 연결시키는 것 까지 했다.<br /><br /></li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;servlet&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>CafeFrontController<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;servlet-class&gt;</span>com.project.cafe.CafeFrontController<span class="nt">&lt;/servlet-class&gt;</span>
  <span class="nt">&lt;/servlet&gt;</span>
  
  <span class="nt">&lt;servlet-mapping&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>CafeFrontController<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;url-pattern&gt;</span>*.me<span class="nt">&lt;/url-pattern&gt;</span>
  <span class="nt">&lt;/servlet-mapping&gt;</span>
</code></pre></div></div>

<ul>
  <li>물론 <code class="language-plaintext highlighter-rouge">HTML</code>을 이용해 그냥 연결시키지 않았고 서블릿을 이용해 <code class="language-plaintext highlighter-rouge">Model2 MVC</code> 패턴을 적용시킬 계획이기 때문에 <code class="language-plaintext highlighter-rouge">.xml</code> 페이지에서 서블릿 클래스 매핑을 통해 페이지 경로를 주소창에 노출시키면서 연결하는 것이 아닌, 주소창에는 가상 주소를 보여주도록 하기 위한 틀을 만들었다.</li>
  <li>매핑될 가상주소는 하나로 고정시키는 것이 아닌, 페이지별 용도에 따라 다른 주소를 출력할 수 있도록 <code class="language-plaintext highlighter-rouge">*</code>을 사용해 맨 뒤에 <code class="language-plaintext highlighter-rouge">.me</code>만 붙으면 그 주소를 올바른 것으로 인식하고 대응시킬 수 있도록 했다.<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.RequestDispatcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CafeFrontController</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span>
<span class="o">{</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doProcess</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
	<span class="o">{</span>
		<span class="c1">// 1. 전달되는 가상주소 계산</span>
		<span class="c1">// 매핑된(.me로 끝나는) 주소를 받아옴</span>
		<span class="nc">String</span> <span class="n">requestURI</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"requestURI : "</span> <span class="o">+</span> <span class="n">requestURI</span><span class="o">);</span>
		
		<span class="c1">// 매핑된 해당 프로젝트 주소를 구함</span>
		<span class="nc">String</span> <span class="n">ctxPath</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getContextPath</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ctxPath : "</span> <span class="o">+</span> <span class="n">ctxPath</span><span class="o">);</span>
		
		<span class="c1">// 매핑된 주소 - 프로젝트 주소 = 계속 바뀔 뒷자리 주소 구함</span>
		<span class="nc">String</span> <span class="n">command</span> <span class="o">=</span> <span class="n">requestURI</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">ctxPath</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"command : "</span> <span class="o">+</span> <span class="n">command</span><span class="o">);</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 가상주소 계산 완료\n"</span><span class="o">);</span>
		<span class="c1">// 1. 전달되는 가상주소 계산</span>
		
		
		<span class="c1">// 2. 가상주소 매핑</span>
		<span class="nc">ActionForward</span> <span class="n">forward</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">command</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"/main.me"</span><span class="o">))</span>
		<span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 메인페이지 호출"</span><span class="o">);</span>
			
			<span class="n">forward</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ActionForward</span><span class="o">();</span>
			<span class="n">forward</span><span class="o">.</span><span class="na">setPath</span><span class="o">(</span><span class="s">"./main/main.jsp"</span><span class="o">);</span>
			<span class="n">forward</span><span class="o">.</span><span class="na">setRedirect</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 가상주소 매핑 완료\n"</span><span class="o">);</span>
		<span class="c1">// 2. 가상주소 매핑</span>
		
		
		<span class="c1">// 3. 페이지 이동</span>
		<span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">forward</span><span class="o">)</span> <span class="c1">// 페이지 이동정보가 있을 때</span>
		<span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">forward</span><span class="o">.</span><span class="na">isRedirect</span><span class="o">())</span>
			<span class="o">{</span>
				<span class="n">resp</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="n">forward</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
			<span class="o">}</span>
			<span class="k">else</span> 
			<span class="o">{</span>
				<span class="nc">RequestDispatcher</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="n">forward</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
				<span class="n">dis</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
			<span class="o">}</span>
			
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 페이지 이동 완료"</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="c1">// 3. 페이지 이동</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
	<span class="o">{</span>
		<span class="n">doProcess</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doPost</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
	<span class="o">{</span>
		<span class="n">doProcess</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이런 식으로 서블릿 클래스를 만든 다음<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">language=</span><span class="s">"java"</span><span class="na"> contentType=</span><span class="s">"text/html; charset=UTF-8"</span><span class="na">
    pageEncoding=</span><span class="s">"UTF-8"</span><span class="nt">%&gt;</span>

<span class="nt">&lt;%</span>
  <span class="n">response</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="s">"./main.me"</span><span class="o">);</span>
<span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li>실제 실행시킬 페이지인 <code class="language-plaintext highlighter-rouge">index.jsp</code>에서는 매핑된 서블릿으로 연결시켜서 실행되도록 했다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">language=</span><span class="s">"java"</span><span class="na"> contentType=</span><span class="s">"text/html; charset=UTF-8"</span><span class="na">
    pageEncoding=</span><span class="s">"UTF-8"</span><span class="nt">%&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- Start Head --&gt;</span>
  <span class="nt">&lt;jsp:include </span><span class="na">page=</span><span class="s">"../inc/top.jsp"</span><span class="nt">&gt;&lt;/jsp:include&gt;</span>
<span class="c">&lt;!-- End Head --&gt;</span>

<span class="nt">&lt;body</span> <span class="na">class=</span><span class="s">"modern"</span><span class="nt">&gt;</span>

<span class="c">&lt;!--
START MODULE AREA 2: Menu 1
--&gt;</span>
  <span class="nt">&lt;jsp:include </span><span class="na">page=</span><span class="s">"../inc/subTop.jsp"</span><span class="nt">&gt;&lt;/jsp:include&gt;</span>
<span class="c">&lt;!--
END MODULE AREA 2: Menu 1
--&gt;</span>
</code></pre></div></div>

<ul>
  <li>그리고 이런 식으로 헤더와 푸터 부분은 다른 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지로 분리해서 새로운 페이지가 추가되어도 헤더와 푸터 페이지를 액션 태그를 써서 인클루드만 해 주고 헤더와 푸터 부분에서 수정 사항이 생기면 <code class="language-plaintext highlighter-rouge">top.jsp</code>, <code class="language-plaintext highlighter-rouge">bottom.jsp</code> 페이지만 수정하면 되도록 만들었다.</li>
  <li>이렇게 만들어놓고 나니까 헤더 부분에서 수정할 점이 생겨도 페이지 하나만 수정하면 되니까 정말 편하다.<br /><br /><br /></li>
</ul>

<h1 id="마감까지">마감까지</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">D-30</code></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Project Log" /><category term="Project" /><category term="Cafe" /><category term="Log" /><summary type="html"><![CDATA[개발환경 MacBook Air (M1, 2020) 16GB JDK 8 Eclipse 2021-12 tomcat 8.5]]></summary></entry><entry><title type="html">에러해결 Log) JSP 절대경로 지정하기</title><link href="http://localhost:4000/errorlog/warning-log-02/" rel="alternate" type="text/html" title="에러해결 Log) JSP 절대경로 지정하기" /><published>2022-03-04T00:00:00+09:00</published><updated>2022-03-04T00:00:00+09:00</updated><id>http://localhost:4000/errorlog/warning-log-02</id><content type="html" xml:base="http://localhost:4000/errorlog/warning-log-02/"><![CDATA[<h1 id="사용환경">사용환경</h1>
<ul>
  <li>MacBook Air (M1, 2020) 16GB</li>
  <li>JDK 8</li>
  <li>Eclipse 2021-12</li>
  <li>tomcat 8.5<br /><br /><br /></li>
</ul>

<h1 id="에러의-발생">에러의 발생</h1>
<p align="center"><img src="../../assets/images/pathError.png" width="400" /></p>
<p><br /></p>

<ul>
  <li>역시 여느 때와 같은 <code class="language-plaintext highlighter-rouge">JSP</code> 수업 시간… <code class="language-plaintext highlighter-rouge">Model2 MVC</code> 패턴으로 웹 페이지를 만드는 것을 실습하고 있었는데 서블릿을 통해 가상주소로 페이지를 열다 보니까 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지 자체는 잘 열리는데 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지와 연결된 외부 <code class="language-plaintext highlighter-rouge">css</code>파일의 경로를 제대로 찾질 못해서 기본으로 적용되어 있던 <code class="language-plaintext highlighter-rouge">css</code>가 제대로 적용되질 않았다.</li>
  <li>이걸 해결하고 수업이 끝났다면 좋았겠지만 여기까지 했을 때 마침 수업 시간이 끝나버려서… 다음 수업까지 기다릴 수도 있었겠지만 간단해 보이는 걸 해결 못하니까 너무 신경쓰여서 경로를 온갖 방법으로 지정을 해 줬는데 계속 상대 경로를 지정하는 것이었어서 그런지 페이지로 이동하는 경로에 따라 어떤 경우엔 잘 되고 어떤 경우엔 잘 나오지 않는 등 여러가지로 <code class="language-plaintext highlighter-rouge">css</code> 파일이 완벽하게 로드되지 않았다.</li>
  <li>물론 절대경로도 나름 시도를 해 보았으나 잘못 알고 있었는지 절대경로도 먹히질 않았다…<br /><br /><br /></li>
</ul>

<h1 id="문제-해결">문제 해결</h1>

<ul>
  <li>구글에 <code class="language-plaintext highlighter-rouge">jsp 절대경로</code>를 검색하니까 자료가 많았다.</li>
  <li>절대경로를 설정하는 간단한 방법은 루트를 뜻하는 <code class="language-plaintext highlighter-rouge">/</code>를 입력하고 하위 폴더명을 타고타고 입력하는 것이지만 저게 먹히지 않았기 때문에 다른 방법을 찾았다.</li>
  <li>바로<br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${pageContext.request.contextPath}
</code></pre></div></div>
<p><br />
를 이용해 어느 경우라도 절대경로가 적용될 수 있게 해주는 것이다.</p>
<ul>
  <li>한 시간동안 헤메면서도 생각했지만 jsp 페이지에 직접 접근했을 때와 서블릿을 통해 접근했을 때 상대경로의 기준이 달라져서 그러는 것 같았는데 찾아보니까 진짜였다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"${pageContext.request.contextPath}/css/default.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<ul>
  <li>이런 식으로 찾아가고자 하는 폴더와 파일의 경로를 <code class="language-plaintext highlighter-rouge">el 표현식</code>을 사용한 <code class="language-plaintext highlighter-rouge">contextPath</code> 뒤에 입력해주면 절대경로로 세팅되면서 정상적으로 <code class="language-plaintext highlighter-rouge">css</code> 파일을 찾아가게 된다.</li>
  <li>그런데 방금 적용시켜 보니까 jsp 액션태그의 경로에는 절대경로를 넣으니까 <code class="language-plaintext highlighter-rouge">500 에러</code>가 나서 액션태그는 피하고 <code class="language-plaintext highlighter-rouge">HTML</code> 태그에만 적용시켜 주면 될 거 같다.</li>
</ul>

<p align="center"><img src="../../assets/images/pathSolve.png" width="400" /></p>

<ul>
  <li>짠👏 적용 끝!</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="ErrorLog" /><category term="Error" /><category term="Solve" /><category term="Log" /><summary type="html"><![CDATA[사용환경 MacBook Air (M1, 2020) 16GB JDK 8 Eclipse 2021-12 tomcat 8.5]]></summary></entry><entry><title type="html">C++) BOJ 1049. 기타줄</title><link href="http://localhost:4000/boj/boj1049-cpp/" rel="alternate" type="text/html" title="C++) BOJ 1049. 기타줄" /><published>2022-03-04T00:00:00+09:00</published><updated>2022-03-04T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1049-cpp</id><content type="html" xml:base="http://localhost:4000/boj/boj1049-cpp/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1049">https://www.acmicpc.net/problem/1049</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.</p>
  </li>
  <li>
    <p>끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>브랜드에 상관없이 총 구매 가격이 최소가 되기만 하면 되기 때문에 입력 받으면서 6개 팩 중 가장 싼 가격과 낱개 중 가장 싼 가격을 저장해 놓았다.</li>
  <li>그리고 기타줄의 갯수만큼 사는데 6개 팩으로 사는 것이 더 싸면 정답 변수에 6개 팩의 가격을 더해주고 아나리면 낱개를 남은 기타줄의 갯수만큼 곱해서 더해주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 0 ms</li>
  <li>메모리 : 2020 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/9c5b8c3b800227349339656b3d141e8e.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1049" /><category term="BackTracking" /><category term="C++" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1049 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 2580. 스도쿠</title><link href="http://localhost:4000/boj/boj2508-java/" rel="alternate" type="text/html" title="Java) BOJ 2580. 스도쿠" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2508-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2508-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2580">https://www.acmicpc.net/problem/2580</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.</p>
  </li>
  <li>
    <p>나머지 빈 칸을 채우는 방식은 다음과 같다.</p>
  </li>
  <li>각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li>
  <li>
    <p>굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</p>
  </li>
  <li>게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>
    <p>모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.</p>
  </li>
  <li>
    <p>스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 for문을 여러번 돌려서 n^3에 가깝게 풀었는데 그래서 그런지 시간 초과가 났다…</li>
  <li>
    <p>그래서 시간을 줄여보려고 입력 받으면서 0인 칸만 따로 저장한 뒤 거기만 탐색하는 방식으로도 해 봤지만 역시 1%에서 시간초과가 나서 질문 게시판과 구글링을 참고했다.<br /></p>
  </li>
  <li>스도쿠의 가로세로줄과 3*3 칸을 검사한 뒤 겹치는 숫자가 없도록 넣어야 하기 때문에 이것을 검사하는 함수를 만들어서 0인 위치에 대해서 1~9 까지의 숫자를 넣어서 검사를 실시한 뒤 해당 숫자를 넣을 수 있으면 수를 삽입한 뒤 스도쿠에 숫자를 넣는 함수를 재귀호출한다.</li>
  <li>스도쿠 칸을 채우는 방법이 여러 개가 있을 수 있기 때문에 보드판이 다 채워지는대로 보드판을 출력하고 System.exit(0)을 사용해서 프로그램을 종료한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 672 ms</li>
  <li>메모리 : 28336 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/ec822102bdf365ea40b0cbfa1087e456.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2580" /><category term="BackTracking" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2580 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 9663. N-Queen</title><link href="http://localhost:4000/boj/boj9663-java/" rel="alternate" type="text/html" title="Java) BOJ 9663. N-Queen" /><published>2022-03-02T00:00:00+09:00</published><updated>2022-03-02T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj9663-java</id><content type="html" xml:base="http://localhost:4000/boj/boj9663-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/9663">https://www.acmicpc.net/problem/9663</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 10 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p>
  </li>
  <li>
    <p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15) <br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>어디서 들어본 거 같은데 모르겠어서 구글링했다.</li>
  <li>
    <p>참고 블로그 : <a href="https://st-lab.tistory.com/118">https://st-lab.tistory.com/118</a><br /></p>
  </li>
  <li>체스판 위에 퀸을 놓은 뒤 그 위치의 다음 위치부터 검사해서 어떤 위치가 퀸이 있는 위치에서 상하좌우 대각선 방향에 있는 곳이라면 그냥 넘어가고 아니라면 퀸을 놓기 위한 함수를 재귀호출하는 것이다.</li>
  <li>탐색 위치가 체스판의 끝에 도달하면 재귀 호출을 종료한다. (자세한 건 주석에..)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 5320 ms</li>
  <li>메모리 : 14532 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/db381c63586f1f3e1d73c9dee48ccc2c.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No9663" /><category term="BackTracking" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/9663 제한 시간 제한 : 10 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">에러해결 Log) cvc-id.3 A field of identity constraint ‘web-app-filter-name-uniqueness’ matched element ‘web-app’, but this element does not have a simple type.</title><link href="http://localhost:4000/errorlog/warning-log-01/" rel="alternate" type="text/html" title="에러해결 Log) cvc-id.3 A field of identity constraint ‘web-app-filter-name-uniqueness’ matched element ‘web-app’, but this element does not have a simple type." /><published>2022-03-02T00:00:00+09:00</published><updated>2022-03-02T00:00:00+09:00</updated><id>http://localhost:4000/errorlog/warning-log-01</id><content type="html" xml:base="http://localhost:4000/errorlog/warning-log-01/"><![CDATA[<h1 id="사용환경">사용환경</h1>
<ul>
  <li>MacBook Air (M1, 2020) 16GB</li>
  <li>JDK 8</li>
  <li>Eclipse 2021-12</li>
  <li>tomcat 8<br /><br /><br /></li>
</ul>

<h1 id="에러의-발생">에러의 발생</h1>
<p><img src="../../assets/images/servletError.png" /><br /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JSP</code>수업 중 서블릿 실습을 따라하고 있었는데 분명 방금 전 까지는 실행이 잘 됐는데 새 서블릿 클래스를 만들고 나서 서버를 재시작 하니까 갑자기 무한루프가 돌기 시작했다… 그래서 급히 구글 검색했지만 딱히 만족할만한 결과를 얻지 못해서 <code class="language-plaintext highlighter-rouge">.xml</code> 파일을 뒤져봤다.<br /><br /></li>
</ul>

<p><img src="../../assets/images/xmlError01.png" /><br /></p>

<ul>
  <li>사진에서 17번째 줄에 에러 메시지가 표시되고 있지만 저건 처음부터 저랬는데도 실행하는데 아무 문제가 없었어서 그냥 이클립스 버그인가 보다 하고 넘겼었다.</li>
  <li>심지어 오늘 수업에서 직전까지 하던 실습을 할 때 까지도 잘 됐었음! 그런데 다른 파일들은 에러가 날 만한 부분이 없었고 계속 저기만 문제라고 하고 있어서 에러 메시지를 눌러보았다.<br /><br /></li>
</ul>

<p><img src="../../assets/images/xmlErrorMsg.png" /><br /></p>

<ul>
  <li>눌러보니까 굉장히 긴 메시지가 나오길래 혹시나 싶어서 그대로 복붙해서 구글에 검색해 보니까 역시 이걸 해결하신 분이 계셨다.</li>
  <li>해결방법은 아주 간단했는데 <code class="language-plaintext highlighter-rouge">.xml</code> 파일 상단의 <code class="language-plaintext highlighter-rouge">&lt;wep-app xmlns:xsi="~"</code>로 시작하는 부분에서 저 뒤에 있는 <code class="language-plaintext highlighter-rouge">xsi:schemaLocation="~"</code>에 있는 주소 중 <code class="language-plaintext highlighter-rouge">http://java.sun.com</code> 부분을 <code class="language-plaintext highlighter-rouge">http://JAVA.sun.com</code>으로 고치거나 <code class="language-plaintext highlighter-rouge">http://Java.sun.com</code>으로 고치면 되는.. 아주 간단한 것이었다.<br /><br /></li>
</ul>

<p><img src="../../assets/images/xmlErrorSolve.png" /><br /></p>

<ul>
  <li>바꾸니까 17번째 줄의 에러 메시지도 사라지고 더 이상 무한루프를 돌지 않고 서블릿 실행도 잘 되었다.</li>
  <li>이럴거면 처음에 자동으로 만들어 줄 때 부터 자바를 대문자로 써서 만들어 주면 되지 않았을까… 사람 번거롭게 하네 😔<br /><br /><br /></li>
</ul>

<h1 id="참고">참고</h1>
<ul>
  <li><a href="https://velog.io/@gillog/%EC%97%90%EB%9F%AC%ED%95%B4%EA%B2%B0-web.xml%EC%97%90%EC%84%9C-cvc-id.3-A-field-of-identity-constraint-web-app-filter-name-uniqueness-matched-element-web-app-but-this-element-does-not-have-a-simple-type">[에러해결] web.xml에서 cvc-id.3: A field of identity constraint ‘web-app-filter-name-uniqueness’ matched element ‘web-app’, but this element does not have a simple type.</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="ErrorLog" /><category term="Error" /><category term="Solve" /><category term="Log" /><summary type="html"><![CDATA[사용환경 MacBook Air (M1, 2020) 16GB JDK 8 Eclipse 2021-12 tomcat 8]]></summary></entry><entry><title type="html">DB) 데이터 모델링</title><link href="http://localhost:4000/database/db-04-data-modeling/" rel="alternate" type="text/html" title="DB) 데이터 모델링" /><published>2022-03-01T00:00:00+09:00</published><updated>2022-03-01T00:00:00+09:00</updated><id>http://localhost:4000/database/db-04-data-modeling</id><content type="html" xml:base="http://localhost:4000/database/db-04-data-modeling/"><![CDATA[<h1 id="-데이터베이스-설계">👀 데이터베이스 설계</h1>
<ul>
  <li>사용자의 다양한 요구 사항을 고려하여 데이터베이스를 생성하는 과정</li>
  <li>E-R 모델과 릴레이션 변환 규칙을 이용한 설계 과정은 5단계로 이루어져 있다.</li>
</ul>

<h2 id="1단계--요구-사항-분석">1단계 : 요구 사항 분석</h2>
<ul>
  <li>데이터베이스의 용도 파악</li>
  <li>관련된 현실 세계가 어떻게 구성되어 있는지 파악한다.</li>
  <li>결과물 : 요구 사항 명세서</li>
</ul>

<h2 id="2단계--개념적-설계">2단계 : 개념적 설계</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DBMS</code>에 독립적인 개념적 구조 설계</li>
  <li>현실세계에 있는 정보를 알아보기 쉽게 표시한다.</li>
  <li>결과물 : 개념적 스키마(E-R 다이어그램)</li>
</ul>

<h2 id="3단계--논리적-설계">3단계 : 논리적 설계</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DBMS</code>에 적합한 논리적 구조 설계</li>
  <li>결과물 : 논리적 스키마(릴레이션 스키마)</li>
</ul>

<h2 id="4단계--물리적-설계">4단계 : 물리적 설계</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DBMS</code>로 구현 가능한 물리적 구조 설계</li>
  <li>결과물 : 물리적 스키마</li>
</ul>

<h2 id="5단계--구현">5단계 : 구현</h2>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SQL</code> 문을 작성한 후 이를 <code class="language-plaintext highlighter-rouge">DBMS</code>에서 실행하여 데이터베이스 생성<br /><br /></p>
  </li>
  <li>
    <p>1 ~ 3단계가 가장 핵심이 되는 단계들이며 각 단계의 설계 과정 중에 오류가 발견되어 변경이 필요하면 이전 단계로 되돌아가 설계 내용을 변경할 수 있다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="데이터-모델링data-modeling">데이터 모델링(data modeling)</h1>
<ul>
  <li>현실 세계에 존재하는 데이터를 컴퓨터 세계의 데이터베이스로 옮기는 변환 과정</li>
  <li>데이터베이스 설계의 핵심 과정</li>
  <li>모든 데이터는 특징을 추출하는 <code class="language-plaintext highlighter-rouge">추상화(abstraction)</code> 과정을 거쳐서 데이터베이스로 옮겨진다.</li>
</ul>

<h2 id="개념적-데이터-모델링conceptual-modeling">개념적 데이터 모델링(conceptual modeling)</h2>
<ul>
  <li>현실 세계의 중요 데이터를 추출하여 개념 세계로 옮기는 작업</li>
</ul>

<h2 id="논리적-데이터-모델링logical-modeling">논리적 데이터 모델링(logical modeling)</h2>
<ul>
  <li>개념 세계의 데이터를 데이터베이스에 저장하는 구조로 표현하는 작업</li>
</ul>

<h2 id="데이터-모델data-model">데이터 모델(data model)</h2>
<ul>
  <li>데이터 모델링의 결과물을 표현하는 도구</li>
</ul>

<h3 id="개념적-데이터-모델">개념적 데이터 모델</h3>
<ul>
  <li>사람의 머리로 이해할 수 있도록 현실 세계를 개념적 모델링하여 데이터베이스의 개념적 구조로 표현하는 도구</li>
  <li>예) 개체-관계 모델</li>
</ul>

<h3 id="논리적-데이터-모델">논리적 데이터 모델</h3>
<ul>
  <li>개념적 구조를 논리적 모델링하여 데이터베이스의 논리적 구조로 표현하는 도구</li>
  <li>예) 관계 데이터 모델<br /><br /><br /></li>
</ul>

<h1 id="개체-관계-모델e-r-model-entity-relationship-model">개체-관계 모델(E-R model: Entity-Relationship model)</h1>
<ul>
  <li>피터 첸(Peter Chen)이 제안한 개념적 데이터 모델</li>
  <li>개체와 개체 간의 관계를 이용해 현실 세계를 개념적 구조로 표현</li>
  <li>핵심 요소 : 개체, 속성, 관계</li>
</ul>

<h2 id="개체-관계-다이어그램e-r-diagram">개체-관계 다이어그램(E-R diagram)</h2>
<ul>
  <li>E-R 다이어그램이라고도 하며 개체 - 관계 모델을 이용해 현실 세계를 개념적으로 모델링한 결과물을 그림으로 표현한 것</li>
</ul>

<h2 id="개체entity">개체(entity)</h2>
<ul>
  <li>현실 세계에서 조직을 운영하는 데 꼭 필요한 사람이나 사물과 같이 구별되는 모든 것</li>
  <li>저장할 가치가 있는 중요 데이터를 가지고 있는 사람이나 사물, 개념, 사건 등</li>
  <li>다른 개체와 구별되는 이름을 가지고 있고, 각 개체만의 고유한 특성이나 상태, 즉 속성을 하나 이상 가지고 있음</li>
  <li>예) 서점에 필요한 개체 : 고객, 책</li>
  <li>예) 학교에 필요한 개체 : 학과, 과목</li>
  <li>파일 구조의 레코드(record)와 대응됨</li>
  <li>E-R 다이어그램에서 <code class="language-plaintext highlighter-rouge">사각형</code>으로 표현하고 사각형 안에 이름을 표기한다.</li>
</ul>

<h2 id="속성attribute">속성(attribute)</h2>
<ul>
  <li>개체나 관계가 가지고 있는 고유의 특성</li>
  <li>의미 있는 데이터의 가장 작은 논리적 단위</li>
  <li>파일 구조의 필드(field)와 대응됨</li>
  <li>E-R 다이어그램에서 타원으로 표현하고 타원 안에 이름을 표기</li>
</ul>

<h2 id="개체-타입entity-type">개체 타입(entity type)</h2>
<ul>
  <li>개체를 고유의 이름과 속성들로 정의한 것</li>
  <li>파일 구조의 레코드 타입(record type)에 대응됨</li>
</ul>

<h2 id="개체-인스턴스entity-instance">개체 인스턴스(entity instance)</h2>
<ul>
  <li>개체를 구성하고 있는 속성이 실제 값을 가짐으로써 실체화된 개체</li>
  <li>개체 어커런스(entity occurrence)라고도 함</li>
  <li>파일 구조의 레코드 인스턴스(record instance)에 대응됨</li>
</ul>

<h2 id="개체-집합entity-set">개체 집합(entity set)</h2>
<ul>
  <li>특정 개체 타입에 대한 기체 인스턴스들을 모아놓은 것</li>
</ul>

<h2 id="속성의-분류">속성의 분류</h2>
<h3 id="속성-값의-개수에-따른-분류">속성 값의 개수에 따른 분류</h3>
<h4 id="-단일-값-속성single-valued-attribute">🔸 단일 값 속성(single-valued attribute)</h4>
<ul>
  <li>값을 하나만 가질 수 있는 속성</li>
  <li>예) 고객 개체의 이름, 적립금 속성</li>
</ul>

<h4 id="-다중-값-속성multi-valued-attribute">🔸 다중 값 속성(multi-valued attribute)</h4>
<ul>
  <li>값을 여러 개 가질 수 있는 속성</li>
  <li>예) 고객 개체의 연락처 속성</li>
  <li>예) 책 개체의 저자 속성</li>
  <li>E-R 다이어그램에서 이중 타원으로 표현</li>
</ul>

<h3 id="의미의-분해-가능성에-따른-분류">의미의 분해 가능성에 따른 분류</h3>
<h4 id="-단순-속성simple-attribute">🔸 단순 속성(simple attribute)</h4>
<ul>
  <li>의미를 더는 분해할 수 없는 속성</li>
  <li>예) 고객 개체의 적립금 속성</li>
  <li>예) 책 개체의 이름, ISBN, 가격 속성</li>
</ul>

<h4 id="-복합-속성composite-attribute">🔸 복합 속성(composite attribute)</h4>
<ul>
  <li>의미를 분해할 수 있는 속성</li>
  <li>예) 고객 개체의 주소 속성
    <ul>
      <li>시, 도, 구, 동, 우편번호 등으로 의미를 세분화해서 쪼갤 수 있다.</li>
    </ul>
  </li>
  <li>예) 고객 개체의 생년월일 속성
    <ul>
      <li>연, 월, 일로 의미를 세분화할 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="유도-속성derived-attribute">유도 속성(derived attribute)</h3>
<ul>
  <li>기존의 다른 속성의 값에서 유도되어 결정되는 속성</li>
  <li>값이 별도로 저장되지 않음</li>
  <li>예) 책 개체의 가격과 할인율 속성으로 계산되는 판매가격 속성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">가격 - 할인율 = 책 가격</code>이 되기 때문에 책 개체의 가격은 유도 속성이라 할 수 있다.</li>
    </ul>
  </li>
  <li>예) 고객 개체의 출생연도 속성으로 계산되는 나이 속성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">출생연도를 이용해서 고객의 나이를 계산</code>할 수 있기 때문에 고객 개체의 나이 속성은 유도 속성이라 할 수 있다.</li>
    </ul>
  </li>
  <li>E-R 다이어그램에서 점선 타원으로 표현된다.</li>
</ul>

<h3 id="널-속성null-attribute">널 속성(null attribute)</h3>
<ul>
  <li>널 값이 허용되는 속성</li>
</ul>

<h3 id="널null-값">널(null) 값</h3>
<ul>
  <li>아직 결정되지 않았거나 모르는 값 또는 존재하지 않는 값</li>
  <li>공백이나 0과는 의미가 다른데, 공백이나 0도 공백과 0이라는 값이 있는 것이다. 그래서 <code class="language-plaintext highlighter-rouge">공백, 0 != null</code></li>
  <li>예) 등급 속성이 널 값이라는 의미는 등급이 아직 결정되지 않았음을 의미</li>
</ul>

<h3 id="키-속성key-attribute">키 속성(key attribute)</h3>
<ul>
  <li>각 개체 인스턴스를 식별하는 데 사용되는 속성</li>
  <li>모든 개체 인스턴스의 키 속성 값이 다름</li>
  <li>둘 이상의 속성들로 구성되기도 함</li>
  <li>예) 고객 개체의 고객아이디 속성</li>
  <li>E-R 다이어그램에서 밑줄로 표현한다.</li>
</ul>

<h2 id="관계relationship">관계(relationship)</h2>
<ul>
  <li>개체와 개체가 맺고 있는 의미 있는 연관성</li>
  <li>개체 집합들 사이의 대응 관계, 즉 매핑(mapping)을 의미</li>
  <li>예) 고객 개체와 책 개체 간의 구매 관계 (“고객은 책을 구매한다”)</li>
  <li>E-R 다이어그램에서 마름모로 표현한다.</li>
</ul>

<h3 id="관계의-유형--관계에-참여하는-개체-타입의-수에-따라">관계의 유형 : 관계에 참여하는 개체 타입의 수에 따라</h3>
<ul>
  <li>이항 관계 : 개체 타입 두 개가 맺는 관계</li>
  <li>삼항 관계 : 개체 타입 세 개가 맺는 관계</li>
  <li>순환 관계 : 개체 타입 하나가 자기 자신과 맺는 관계</li>
</ul>

<h3 id="관계의-유형--매핑-카디널리티-기준">관계의 유형 : 매핑 카디널리티 기준</h3>
<h4 id="일대일1--1-관계">일대일(1 : 1) 관계</h4>
<ul>
  <li>개체 A의 각 개체 인스턴스가 개체 B의 개체 인스턴스 <code class="language-plaintext highlighter-rouge">하나</code>와 관계를 맺을 수 있고, 개체 B의 각 개체 인스턴스도 개체 A의 개체 인스턴스 <code class="language-plaintext highlighter-rouge">하나</code>와 관계를 맺을 수 있음</li>
  <li>예) 일처일부제에서의 혼인관계</li>
</ul>

<h4 id="일대다1--n-관계">일대다(1 : n) 관계</h4>
<ul>
  <li>개체 A의 각 개체 인스턴스가 개체 B의 개체 인스턴스 <code class="language-plaintext highlighter-rouge">여러 개</code>와 관계를 맺을 수 있지만, 개체 B의 각 개체 인스턴스는 개체 A의 개체 인스턴스 <code class="language-plaintext highlighter-rouge">하나</code>와 관계를 맺을 수 있음</li>
  <li>예) 하나의 부서에 여러 사원이 소속되어 있는 관계</li>
</ul>

<h4 id="다대다n--m-관계">다대다(n : m) 관계</h4>
<ul>
  <li>개체 A의 각 개체 인스턴스가 개체 B의 개체 인스턴스 <code class="language-plaintext highlighter-rouge">여러 개</code>와 관계를 맺을 수 있고, 개체 B의 각 개체 인스턴스도 개체 A의 개체 인스턴스 <code class="language-plaintext highlighter-rouge">여러 개</code>와 관계를 맺을 수 있음</li>
  <li>고객은 책을 여러 권 살 수 있고 책 또한 여러 고객들에 의해서 구매될 수 있는 관계</li>
</ul>

<h4 id="매핑-카디널리티mapping-cardinality">매핑 카디널리티(mapping cardinality)</h4>
<ul>
  <li>관계를 맺는 두 개체 집합에서, 각 개체 인스턴스가 연관성을 맺고 있는 상대 개체 집합의 인스턴스 개수</li>
</ul>

<h3 id="관계의-참여-특성">관계의 참여 특성</h3>
<h4 id="필수적-참여전체-참여">필수적 참여(전체 참여)</h4>
<ul>
  <li>모든 개체 인스턴스가 관계에 반드시 참여해야 하는 것을 의미</li>
  <li>예) 모든 고객은 책을 반드시 구매해야 한다면 고객 개체가 책 개체와의 구매 관계에 필수적으로 참여하는 것</li>
  <li>E-R 다이어그램에서 이중선으로 표현</li>
</ul>

<h4 id="선택적-참여부분-참여">선택적 참여(부분 참여)</h4>
<ul>
  <li>개체 인스턴스 중 일부만 관계에 참여해도 되는 것을 의미</li>
  <li>예) 고객이 서점에 있는 모든 책을 사야 하는 것은 아니기 때문에 이런 경우엔 책 개체가 고객 개체와의 구매 관계에 선택적으로 참여한다고 할 수 있다.</li>
</ul>

<h3 id="관계의-종속성">관계의 종속성</h3>
<ul>
  <li>약한 개체(weak entity) : 다른 개체의 존재 여부에 의존적인 개체</li>
  <li>오너 개체(owner entity) : 다른 개체의 존재 여부를 결정하는 개체</li>
  <li><code class="language-plaintext highlighter-rouge">오너 개체</code>와 <code class="language-plaintext highlighter-rouge">약한 개체</code>는 일반적으로 <code class="language-plaintext highlighter-rouge">일대다</code>의 관계를 가지고, <code class="language-plaintext highlighter-rouge">약한 개체</code>는 <code class="language-plaintext highlighter-rouge">오너 개체</code>와의 관계에 <code class="language-plaintext highlighter-rouge">필수적으로 참여</code>하는 특징이 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">약한 개체</code>는 <code class="language-plaintext highlighter-rouge">오너 개체</code>의 <code class="language-plaintext highlighter-rouge">키를 포함</code>하여 키를 구성하는 특징이 있다.</li>
  <li>예) 직원 개체와 부양가족 개체 사이의 부양 관계
    <ul>
      <li>직원 개체는 부양가족을 꼭 가지지 않아도 되지만 부양가족은 직원 개체가 꼭 있어야 한다. 그래서 직원 개체는 오너 개체, 부양가족 개체는 약한 개체라 할 수 있다.</li>
    </ul>
  </li>
  <li>E-R 다이어그램에서 약한 개체는 이중 사각형으로 표한하고 약한 개체가 오너 개체와 맺는 관계는 이중 마름모로 표현<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1163794">데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[👀 데이터베이스 설계 사용자의 다양한 요구 사항을 고려하여 데이터베이스를 생성하는 과정 E-R 모델과 릴레이션 변환 규칙을 이용한 설계 과정은 5단계로 이루어져 있다.]]></summary></entry><entry><title type="html">컴퓨터 네트워크) 인터넷 프로토콜</title><link href="http://localhost:4000/computer%20network/computer-network-03-protocol/" rel="alternate" type="text/html" title="컴퓨터 네트워크) 인터넷 프로토콜" /><published>2022-03-01T00:00:00+09:00</published><updated>2022-03-01T00:00:00+09:00</updated><id>http://localhost:4000/computer%20network/computer-network-03-protocol</id><content type="html" xml:base="http://localhost:4000/computer%20network/computer-network-03-protocol/"><![CDATA[<h1 id="-인터넷-프로토콜-구조">👀 인터넷 프로토콜 구조</h1>
<ul>
  <li>컴퓨터 상호간의 데이터 전달을 위한 통신구조로 현재 인터넷에서 사용하는 통신구조</li>
  <li><code class="language-plaintext highlighter-rouge">TCP/IP(Transmission Control Protocol/Internet Protocol</code>라는 프로토콜을 사용하는데 이것은 인터넷과 연결된 컴퓨터들을 공용어라 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">OSI 참조모델</code>과 다르게 5계층으로 구성되어 있다.</li>
</ul>

<h2 id="1-하드웨어-계층">1. 하드웨어 계층</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">OSI 참조모델</code>과 마찬가지로 물리적으로 연결하는 케이블 등 데이터 통신에 관련된 하드웨어로 구성되어 있다.</li>
</ul>

<h2 id="2-네트워크-인터페이스-계층">2. 네트워크 인터페이스 계층</h2>
<ul>
  <li>네트워크 액세스 또는 데이터링크 계층이라고도 한다.</li>
  <li>프레임(Frame)을 네트워크 전송매체로 전달하는 것과 네트워크 전송매체에서 프레임을 받아들이는 과정 담당</li>
  <li><code class="language-plaintext highlighter-rouge">TCP/IP</code>는 네트워크 접근 방법, 프레임 포맷, 매체에 대해 독립적으로 동작하도록 설계</li>
  <li><code class="language-plaintext highlighter-rouge">TCP/IP</code>는 서로 다른 네트워크 형태를 연결하는데 사용 가능
    <ul>
      <li>네트워크 형태로는 이더넷(Ethernet), 토큰버스(Token Bus), 토큰링(Token Ring)과 같은 LAN 기술</li>
      <li>X.25, 프레임 릴레이(Frame Relay)와 같은 WAN 기술을 포함</li>
    </ul>
  </li>
  <li>네트워크 인터페이스 계층은 <code class="language-plaintext highlighter-rouge">OSI 모델</code>에서 데이터 링크 계층에 해당</li>
</ul>

<h2 id="3-인터넷-계층">3. 인터넷 계층</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">OSI 모델</code>의 네트워크 계층에 해당하며 어드레싱(addressing - IP 주소를 만드는 것), 패키징(packaging - 데이터 전송 단위를 만드는 것), 라우팅(routing - 목적지까지 전송할 수 있도록 라우터에서 중개) 기능을 제공</li>
  <li>핵심 프로토콜은 IP, ARP, ICMP, IGMP 등을 포함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IP(Internet Protocol)</code> : IP 주소, 패킷의 라우팅을 책임지는 프로토콜</li>
      <li><code class="language-plaintext highlighter-rouge">ARP(Address Resolution Protocol)</code> : 인터넷 계층의 IP 주소를 네트워크 인터페이스 계층의 주소(MAC 주소 또는 물리적 하드웨어 주소)로 변환</li>
      <li><code class="language-plaintext highlighter-rouge">ICMP(Internet Control Message Protocol)</code> : IP 패킷의 전달에 따른 오류나 상태를 리포트하고 진단하는 기능</li>
      <li><code class="language-plaintext highlighter-rouge">IGMP(Internet Group Management Protocol)</code> : IP 멀티캐스트(multicast) 그룹의 관리</li>
    </ul>
  </li>
</ul>

<h2 id="4-트랜스포트-계층">4. 트랜스포트 계층</h2>
<ul>
  <li>두 호스트 간에 단대단(End-to-End) 통신을 제공</li>
  <li>핵심 프로토콜은 <code class="language-plaintext highlighter-rouge">TCP</code>와 <code class="language-plaintext highlighter-rouge">UDP(User Datagram Protocol)</code></li>
  <li><code class="language-plaintext highlighter-rouge">TCP</code>
    <ul>
      <li>1 대 1 연결 지향(전송 전 송-수신자간 논리적 연결을 먼저 함)</li>
      <li>신뢰성 있는 통신 서비스 제공</li>
      <li><code class="language-plaintext highlighter-rouge">TCP</code> 연결 설정과 보낸 패킷의 확인, 순서화, 전달 중 손상된 패킷을 복구하는 기능 제공</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UDP</code>
    <ul>
      <li>1 대 1, 1 대 다의 비연결 지향</li>
      <li>신뢰할 수 없는 통신 서비스 제공</li>
      <li>주로 전달해야 할 데이터의 크기가 작을 때나, <code class="language-plaintext highlighter-rouge">TCP</code> 연결 확립에 의한 부하를 피하려고 할 때 혹은 상위 프로토콜이 신뢰할 수 있는 전달을 책임지는 경우에 사용</li>
      <li>예) <code class="language-plaintext highlighter-rouge">DNS</code>: 전달해야 할 데이터가 상대적으로 적어서 빠른 응답을 위해 <code class="language-plaintext highlighter-rouge">UDP</code> 사용</li>
    </ul>
  </li>
</ul>

<h2 id="5-응용-계층">5. 응용 계층</h2>
<ul>
  <li>사용자와 가장 밀접한 관계를 가지고 있는 계층</li>
  <li>여러 가지 응용 계층 프로토콜이 존재하며 지속적으로 새로운 프로토콜 개발</li>
  <li>가장 많이 알려진 응용 계층 프로토콜로는
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP(HyperText transfer Protocol)</code> : WWW의 <code class="language-plaintext highlighter-rouge">Web 페이지</code> 파일을 전송하는데 사용</li>
      <li><code class="language-plaintext highlighter-rouge">FTP(File transfer Protocol)</code> : 상호 <code class="language-plaintext highlighter-rouge">파일 전송</code>을 위해 사용</li>
      <li><code class="language-plaintext highlighter-rouge">SMTP(Simple Mail transfer Protocol)</code> : <code class="language-plaintext highlighter-rouge">메일 메시지</code>와 그에 추가된 첨부 파일을 전송하기 위해 사용</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">TCP/IP</code> 네트워크를 관리하거나 지원하는 응용 계층 프로토콜
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DNS(Domain Name System)</code> : 호스트 이름(예 : www.naver.com)을 숫자로 된 IP 주소로 변환하기 위해 사용</li>
      <li><code class="language-plaintext highlighter-rouge">RIP(Routing Information Protocol)</code> : IP 네트워크상에서 라우팅 정보를 교환하기 위해 라우터가 사용하는 프로토콜. 이를 이용해 최상의 라우팅 테이블을 유지하고 이 라우팅 테이블을 통해 가장 적합한 곳으로 패킷을 전송한다.</li>
      <li><code class="language-plaintext highlighter-rouge">SNMP(Simple Network Management Protocol)</code> : 네트워크 관리 콘솔과 네트워크 장비(라우터, 브리지, 지능형 허브)간에 네트워크 관리 정보를 수집, 교환하기 위해 사용. 네트워크 장비를 원격으로 관리할 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="인터넷-프로토콜-구현-환경">인터넷 프로토콜 구현 환경</h2>
<ul>
  <li>시스템 공간(계층 1 ~ 4) : <code class="language-plaintext highlighter-rouge">운영 체제</code>에서 동작(자동으로 설치됨)</li>
  <li>사용자 공간(계층 5) : <code class="language-plaintext highlighter-rouge">사용자 프로그램</code>으로 동작</li>
</ul>

<h2 id="프로토콜-캡슐화encapsulation">프로토콜 캡슐화(Encapsulation)</h2>
<ul>
  <li>인터넷 프로토콜도 <code class="language-plaintext highlighter-rouge">OSI 참조모델</code>의 캡슐화 개념을 동일하게 사용한다.</li>
  <li>그래서 하위 계층으로 내려보내서 물리 계층에 도착하면 상대편에게 보내고 상대편은 물리 계층부터 상위 계층으로 올라가서 사용자에게 최종적으로 메시지를 보여주는 형태와 똑같이 동작한다.</li>
</ul>

<h3 id="-수신측">🔸 수신측</h3>
<ul>
  <li>응용 계층의 메시지(Message)는 트랜스포트 계층으로 전달되고, 트랜스포트 계층은 전달 받은 데이터 앞에 자신의 헤더를 추가한 후 세그먼트(Segment)를 만들어 네트워크 계층으로 전달</li>
  <li>네트워크 계층은 전달 받은 데이터 앞에 자신의 헤더를 추가한 후 데이터그램(Datagram = Packet)을 만들어 링크 계층으로 전달</li>
  <li>링크 계층은 전달 받은 데이터에 자신의 헤더를 추가하여 프레임(Frame)을 만든다.</li>
  <li>마지막으로 프레임은 물리 계층에 해당하는 전송매체를 통해 상대방에게 전송</li>
</ul>

<h3 id="-송신측">🔸 송신측</h3>
<ul>
  <li>물리 계층에서 데이터를 수신하여 상위 계층으로 전달하는 과정 반복</li>
  <li>
    <p>각 계층은 자신의 데이터 단위가 도착하게 되면 프로토콜 동작 수행<br /><br /></p>
  </li>
  <li>그래서 인터넷 프로토콜 또한 상위 계층은 하위 계층의 <code class="language-plaintext highlighter-rouge">서비스 사용자(Service user)</code>이고, 하위 계층은 <code class="language-plaintext highlighter-rouge">서비스 제공자(Service provider)</code>이다.<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=5959f58996c6bd25">데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Network" /><category term="CS" /><category term="Network" /><category term="Protocol" /><summary type="html"><![CDATA[👀 인터넷 프로토콜 구조 컴퓨터 상호간의 데이터 전달을 위한 통신구조로 현재 인터넷에서 사용하는 통신구조 TCP/IP(Transmission Control Protocol/Internet Protocol라는 프로토콜을 사용하는데 이것은 인터넷과 연결된 컴퓨터들을 공용어라 할 수 있다. OSI 참조모델과 다르게 5계층으로 구성되어 있다.]]></summary></entry><entry><title type="html">Java) BOJ 15652. N과 M (4)</title><link href="http://localhost:4000/boj/boj15652-java/" rel="alternate" type="text/html" title="Java) BOJ 15652. N과 M (4)" /><published>2022-03-01T00:00:00+09:00</published><updated>2022-03-01T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj15652-java</id><content type="html" xml:base="http://localhost:4000/boj/boj15652-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/15652">https://www.acmicpc.net/problem/15652</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.</p>
  </li>
  <li>1부터 N까지 자연수 중에서 M개를 고른 수열</li>
  <li>같은 수를 여러 번 골라도 된다.</li>
  <li>고른 수열은 비내림차순이어야 한다.</li>
  <li>길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.</li>
  <li>수열은 사전 순으로 증가하는 순서로 출력해야 한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>순열을 구하는 문제같아서 순열을 구하는 알고리즘으로 풀었다.</li>
  <li>
    <p>참고 블로그 : <a href="https://bcp0109.tistory.com/14">https://bcp0109.tistory.com/14</a><br /></p>
  </li>
  <li>이번 문제는 중복 순열을 구하는데 오름차순인 순열만 구해야 하기 때문에 마지막으로 뽑은 수보다 큰 수만 뽑도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 228 ms</li>
  <li>메모리 : 19616 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/5498e944ba114f34016007348c347ec1.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No15652" /><category term="BackTracking" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/15652 제한 시간 제한 : 1 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 15651. N과 M (3)</title><link href="http://localhost:4000/boj/boj15651-java/" rel="alternate" type="text/html" title="Java) BOJ 15651. N과 M (3)" /><published>2022-03-01T00:00:00+09:00</published><updated>2022-03-01T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj15651-java</id><content type="html" xml:base="http://localhost:4000/boj/boj15651-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/15651">https://www.acmicpc.net/problem/15651</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.</p>
  </li>
  <li>1부터 N까지 자연수 중에서 M개를 고른 수열</li>
  <li>같은 수를 여러 번 골라도 된다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.</li>
  <li>수열은 사전 순으로 증가하는 순서로 출력해야 한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>순열을 구하는 문제같아서 순열을 구하는 알고리즘으로 풀었다.</li>
  <li>
    <p>참고 블로그 : <a href="https://bcp0109.tistory.com/14">https://bcp0109.tistory.com/14</a><br /></p>
  </li>
  <li>이번 문제는 중복 순열을 구해야 하기 때문에 방문 표시를 하지 않고 모든 경우를 탐색하도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 564 ms</li>
  <li>메모리 : 158152 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/a5ef1d7f8e7f5ccb2476b969baf79bfa.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No15651" /><category term="BackTracking" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/15651 제한 시간 제한 : 1 초 메모리 제한 : 512 MB]]></summary></entry></feed>