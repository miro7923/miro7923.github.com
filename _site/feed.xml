<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-07T02:56:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">OS) Process Synchronization</title><link href="http://localhost:4000/operating%20system/OS-06-process-synchronization/" rel="alternate" type="text/html" title="OS) Process Synchronization" /><published>2022-03-07T00:00:00+09:00</published><updated>2022-03-07T00:00:00+09:00</updated><id>http://localhost:4000/operating%20system/OS-06-process-synchronization</id><content type="html" xml:base="http://localhost:4000/operating%20system/OS-06-process-synchronization/"><![CDATA[<h1 id="-process-synchronization-문제">👀 Process Synchronization 문제</h1>
<ul>
  <li>컴퓨터에 저장되어 있는 어떤 데이터를 변경하려면 그 데이터에 접근해서 변경하는 연산을 한 뒤 연산 결과를 다시 그 데이터가 있는 자리에 갱신시켜줘야 한다.</li>
  <li>그런데 이 때 하나의 프로세스만 접근해서 작업을 하면 문제가 없지만 컴퓨터에는 수많은 프로세스가 있고 하나의 데이터에 여러 프로세스가 접근하는 상황이 생길 수 있다.</li>
  <li>이 때 아무런 제어 없이 여러 프로세스가 접근해서 하나의 데이터를 변경시키면 서로 다른 시점에 데이터를 변경하게 될 수 있고 그러다보면 데이터가 사용자의 의도와 다르게 변경될 수 있다(데이터 불일치 문제). 그래서 이걸 막고 데이터의 일관성 유지를 위해서 공유 데이터에 접근할 때 협력 프로세스 간의 실행 순서를 정해주어야 한다.</li>
</ul>

<h2 id="-race-condition">🔸 Race condition</h2>
<ul>
  <li>여러 프로세스들이 동시에 공유 데이터에 접근하는 상황</li>
  <li>데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐</li>
  <li><code class="language-plaintext highlighter-rouge">Race condition</code>을 막기 위해 <code class="language-plaintext highlighter-rouge">concurrent process(동시 접근)</code>는 <code class="language-plaintext highlighter-rouge">동기화(synchronize)</code>되어야 한다.<br /><br /><br /></li>
</ul>

<h1 id="race-condition이-발생하는-상황">Race Condition이 발생하는 상황</h1>
<h2 id="1-커널-수행-중-인터럽트-발생-시">1. 커널 수행 중 인터럽트 발생 시</h2>
<ul>
  <li>커널 데이터를 처리하는 도중에 <code class="language-plaintext highlighter-rouge">인터럽트</code>가 생긴 경우</li>
  <li>해결책 : 먼저 작업 중이던 커널 코드의 작업이 끝나기 전 까지는 <code class="language-plaintext highlighter-rouge">인터럽트</code>를 받지 않는다.</li>
</ul>

<h2 id="2-프로세스가-시스템-콜을-하여-커널-모드로-수행-중인데-context-switch가-일어나는-경우">2. 프로세스가 시스템 콜을 하여 커널 모드로 수행 중인데 context switch가 일어나는 경우</h2>
<ul>
  <li>A 프로세스가 <code class="language-plaintext highlighter-rouge">PC</code>를 증가시키는 도중에 다른 커널 코드 B에게 <code class="language-plaintext highlighter-rouge">CPU</code>를 뺏겼다가 뺏어간 쪽의 작업이 끝난 후 다시 돌려 받으면 A는 B가 증가시키기 전의 <code class="language-plaintext highlighter-rouge">PC</code> 정보를 가지고 있기 때문에 A가 증가시키는 <code class="language-plaintext highlighter-rouge">PC</code>는 정확한 값으로 증가되지 않는다.</li>
  <li>해결책 : 커널 모드에서 수행 중일 때는 <code class="language-plaintext highlighter-rouge">CPU</code>를 <code class="language-plaintext highlighter-rouge">preempt</code>하지 않고 커널 모드에서 사용자 모드로 돌아갈 때 <code class="language-plaintext highlighter-rouge">preempt</code>한다.</li>
</ul>

<h2 id="3-multiprocessor에서-shared-memory-내의-커널-데이터">3. Multiprocessor에서 shared memory 내의 커널 데이터</h2>
<ul>
  <li>위 경우들은 같은 <code class="language-plaintext highlighter-rouge">CPU</code> 내에서만 할 수 있는 동작들이기 때문에 멀티 프로세서 환경에서는 적용이 어렵다.</li>
  <li>여러 프로세스들이 하나의 공유 메모리에 접근해야 할 때 각각의 <code class="language-plaintext highlighter-rouge">CPU</code>에서 동시에 접근해서 데이터를 변경할 수 있다.</li>
  <li>해결책 1 : 한 번에 하나의 <code class="language-plaintext highlighter-rouge">CPU</code>만이 커널에 들어갈 수 있게 하는 방법</li>
  <li>해결책 2 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 <code class="language-plaintext highlighter-rouge">lock/unlock</code>을 하는 방법<br /><br /><br /></li>
</ul>

<h1 id="the-critical-section-problem">The Critical-Section Problem</h1>
<ul>
  <li>n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우</li>
  <li>각 프로세스의 <code class="language-plaintext highlighter-rouge">code segment</code>에는 공유 데이터를 접근하는 코드인 <code class="language-plaintext highlighter-rouge">critical section</code>이 존재</li>
  <li>하나의 프로세스가 <code class="language-plaintext highlighter-rouge">critical section</code>에 있을 때 다른 모든 프로세스는 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어갈 수 없어야 한다.</li>
</ul>

<h2 id="프로그램적-해결법의-충족-조건">프로그램적 해결법의 충족 조건</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Mutual Exclusion(상호 배제/배타적 접근)</code>
    <ul>
      <li>프로세스 Pirk <code class="language-plaintext highlighter-rouge">critical section</code> 부분을 수행 중이면 다른 모든 프로세스들은 그들의 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어가면 안 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Progress(진행)</code>
    <ul>
      <li>아무도 <code class="language-plaintext highlighter-rouge">critical section</code>에 있지 않은 상태에서 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어가고자 하는 프로세스가 있으면 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어가게 해 주어야 한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Bounded Waiting(유한 대기)</code>
    <ul>
      <li>프로세스가 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어가는 횟수에 한계가 있어야 한다.</li>
      <li>무한대로 기다리지 않게 해서 <code class="language-plaintext highlighter-rouge">starvation</code>을 방지<br /></li>
    </ul>
  </li>
  <li>가정
    <ul>
      <li>모든 프로세스의 수행 속도는 0보다 크다.</li>
      <li>프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.</li>
    </ul>
  </li>
</ul>

<h2 id="기본적인-해결-방법">기본적인 해결 방법</h2>
<ul>
  <li>두 개의 프로세스 <code class="language-plaintext highlighter-rouge">P0</code>, <code class="language-plaintext highlighter-rouge">P1</code>이 있다고 가정했을 때</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">entry</span> <span class="n">section</span>   <span class="cm">/* lock */</span>
    <span class="n">critical</span> <span class="n">section</span>
    <span class="n">exti</span> <span class="n">section</span>    <span class="cm">/* unlock */</span>
    <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>프로세스들은 수행의 동기화를 위해 몇몇 변수를 공유할 수 있다. - <code class="language-plaintext highlighter-rouge">Synchronization variable</code></li>
</ul>

<h3 id="algorithm-1">Algorithm 1</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>   <span class="cm">/* 누구 차례인지 표시할 변수.  Synchronization variable */</span>
<span class="n">initially</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>  <span class="cm">/* 내 턴이 아닌 동안 대기 */</span>
    <span class="n">critical</span> <span class="n">section</span>
    <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* 상대편으로 턴 넘김 */</span>
    <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>위 코드대로만 진행되면 문제가 없어 보이지만 반드시 상대 프로세스가 들어와서 <code class="language-plaintext highlighter-rouge">turn</code>을 바꿔 주어야만 다른 프로세스가 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어갈 수 있기 때문에 만약 A 프로세스가 더 빈번하게 <code class="language-plaintext highlighter-rouge">critical section</code>에 들어가야 하는 경우 B 프로세스는 상대적으로 덜 들어가기 때문에 <code class="language-plaintext highlighter-rouge">turn</code>이 바뀌지 않아 A 프로세스가 들어갈 수 없는 상황이 생긴다.</li>
</ul>

<h3 id="algorithm-2">Algorithm 2</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/* critical section에 들어가고자 하는 의중을 표시하는 flag */</span>
<span class="n">initially</span> <span class="n">flag</span><span class="p">[</span><span class="err">모두</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* 처음엔 critical section에 아무도 없음 */</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>     <span class="cm">/* 진입 표시 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>    <span class="cm">/* 상대 프로세스도 진입해 있으면 대기 */</span>
    <span class="n">critical</span> <span class="n">section</span>
    <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>    <span class="cm">/* 나왔다고 표시 */</span>
    <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>위 코드에서는 만약 A 프로세스가 첫번째 줄만 실행하고 <code class="language-plaintext highlighter-rouge">CPU</code>를 뺏긴 경우 상대 프로세스도 첫번째 줄을 실행하고 두번째 줄에서 대기하게 될 것이다. 즉 둘 다 무한히 대기하게 된다.</li>
</ul>

<h3 id="algorithm-3-petersons-algorithm">Algorithm 3 (Peterson’s Algorithm)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>     <span class="cm">/* 진입 표시 */</span>
    <span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>           <span class="cm">/* 상대편으로 턴 변경 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">);</span>   <span class="cm">/* 들어가고자 하는 프로세스와 턴 모두 확인 */</span>
    <span class="n">critical</span> <span class="n">section</span>
    <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>알고리즘 1과 2를 합친 방법으로 앞선 두 가지 방법에서 있었던 문제들을 모두 해결할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Busy Waiting(= spin lock)</code>
    <ul>
      <li>하지만 <code class="language-plaintext highlighter-rouge">critical section</code>에 프로세스가 이미 있어서 못 들어가는 것이 확실한 상황에서도 계속 <code class="language-plaintext highlighter-rouge">CPU</code>를 얻어서 <code class="language-plaintext highlighter-rouge">while</code>문 조건을 확인해야 하기 때문에 지속적으로 <code class="language-plaintext highlighter-rouge">CPU</code>와 <code class="language-plaintext highlighter-rouge">memory</code>를 소모하게 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="하드웨어적으로-해결하기">하드웨어적으로 해결하기</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Instruction</code> 하나로 <code class="language-plaintext highlighter-rouge">Synchronization variable</code> 읽기와 쓰기를 동시에 실행하면 위의 알고리즘으로 해결하고자 했던 문제들을 간단히 해결할 수 있다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">Test_and_set</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span> <span class="cm">/* lock이 걸려있다면 lock을 걸고 기다릴 것이고 걸려있지 않다면 lock을 걸고 들어갈 것임 */</span>
    <span class="n">critical</span> <span class="n">section</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>
<p><br /><br /></p>

<h2 id="semaphores">Semaphores</h2>
<ul>
  <li>프로그래머가 매번 앞의 작업들을 하려면 귀찮으니까 그 작업들을 추상화시킨 것</li>
  <li><code class="language-plaintext highlighter-rouge">integer variable</code> 형태로 자원의 갯수를 가지고 있다.</li>
  <li>아래의 두 가지 <code class="language-plaintext highlighter-rouge">atomic</code> 연산에 의해서만 접근할 수 있다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* P(S) : 공유 데이터를 획득하는 연산 */</span>
<span class="k">while</span> <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="n">wait</span><span class="p">;</span> <span class="cm">/* 사용할 수 있는 자원이 없으면 대기 */</span>
<span class="n">S</span><span class="o">--</span><span class="p">;</span>

<span class="cm">/* V(S) : 공유 데이터를 사용 후 반납 */</span>
<span class="n">S</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="세마포어를-이용한-코드---busy-wait">세마포어를 이용한 코드 - Busy-wait</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span> <span class="n">mutex</span><span class="p">;</span>    <span class="cm">/* initially 1 : 1개가 critical section에 들어갈 수 있다 */</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>   <span class="cm">/* 자원이 남아 있으면 하나 감소시키고 입장 */</span>
    <span class="n">critical</span> <span class="n">section</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>   <span class="cm">/* 자원 반납 및 증가 */</span>
    <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>대기하는 프로세스가 있으면 자원이 생겼는지 계속 확인해야 하기 때문에 <code class="language-plaintext highlighter-rouge">busy-wait</code>하게 된다.</li>
</ul>

<h3 id="세마포어를-이용한-코드---block--wekeup">세마포어를 이용한 코드 - Block &amp; wekeup</h3>
<ul>
  <li>세마포어를 다음과 같이 정의한다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>          <span class="cm">/* semaphore */</span>
    <span class="k">struct</span> <span class="n">process</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>  <span class="cm">/* 프로세스 대기열 */</span>
<span class="p">}</span> <span class="n">semaphore</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">block</code>과 <code class="language-plaintext highlighter-rouge">wakeup</code>을 다음과 같이 가정한다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">block</code> : 커널은 <code class="language-plaintext highlighter-rouge">block</code>을 호출한 프로세스를 <code class="language-plaintext highlighter-rouge">suspend</code> 시킨 후 이 프로세스의 <code class="language-plaintext highlighter-rouge">PCB</code>를 세마포어에 대한 대기열에 넣음</li>
      <li><code class="language-plaintext highlighter-rouge">wakeup</code> : <code class="language-plaintext highlighter-rouge">block</code>된 프로세스를 <code class="language-plaintext highlighter-rouge">wakeup</code> 시킨 후 이 프로세스의 <code class="language-plaintext highlighter-rouge">PCB</code>를 <code class="language-plaintext highlighter-rouge">ready queue</code>로 옮김</li>
    </ul>
  </li>
  <li>세마포어 연산 정의</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* P(S) */</span>
<span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>  <span class="cm">/* 입장 전에 자원의 수를 감소시킴 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>    <span class="cm">/* 현재 쓸 수 있는 자원이 없으면 대기시킨다 */</span>
<span class="p">{</span>
    <span class="n">add</span> <span class="n">this</span> <span class="n">process</span> <span class="n">to</span> <span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">;</span>
    <span class="n">block</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* V(S) */</span>
<span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>   <span class="cm">/* P 연산에서 자원을 미리 감소시키고 들어가기 때문에 자원을 반납했는데도 갯수가 0 이하라면 기다리고 있는 프로세스가 있는 것 */</span>
<span class="p">{</span>
    <span class="n">remove</span> <span class="n">a</span> <span class="n">process</span> <span class="n">P</span> <span class="n">from</span> <span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">;</span>
    <span class="n">wakeup</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="-busy-wait-vs-blockwakeup">👀 Busy-wait vs. Block/wakeup</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">critical section</code>의 길이가 긴 경우 <code class="language-plaintext highlighter-rouge">Block/wakeup</code>이 적당</li>
  <li><code class="language-plaintext highlighter-rouge">critical section</code>의 길이가 매우 짧은 경우 <code class="language-plaintext highlighter-rouge">Block/wakeup</code> 오버헤드가 <code class="language-plaintext highlighter-rouge">Busy-wait</code> 오버헤드보다 더 커질 수 있다.</li>
  <li>일반적으로는 <code class="language-plaintext highlighter-rouge">Block/wakeup</code> 방식이 좋다.<br /><br /></li>
</ul>

<h2 id="세마포어의-두-종류">세마포어의 두 종류</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Counting semaphore</code>
    <ul>
      <li>도메인이 0 이상인 임의의 정수값</li>
      <li>주로 리소스의 갯수를 세는 데 사용한다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Binary semaphore</code>
    <ul>
      <li>0 또는 1 값만 가질 수 있는 세마포어</li>
      <li>주로 <code class="language-plaintext highlighter-rouge">mutual exclusion (lock/unlock)</code>에 사용</li>
    </ul>
  </li>
</ul>

<h2 id="deadlock-and-starvation">Deadlock and Starvation</h2>
<h3 id="deadlock">Deadlock</h3>
<ul>
  <li>둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상</li>
  <li>1과 2 두 개의 자원을 얻어야 하는 A 프로세스가 있을 때 만약 A 프로세스가 1번 자원만 얻고 B 프로세스에게 <code class="language-plaintext highlighter-rouge">CPU</code>를 뺏긴 후 B 프로세스가 2번 자원을 얻으면 A 프로세스는 <code class="language-plaintext highlighter-rouge">CPU</code>를 다시 돌려받아도 2번 자원을 얻지 못해서 다음으로 진행할 수 없다. B 프로세스 또한 1번 자원이 필요하다면 영원히 기다리게 된다.</li>
  <li>이러한 현상을 해결하기 위해서 자원을 획득하는 순서를 정해줘서 1번 자원을 먼저 얻어야만 2번 자원을 얻을 수 있게 하는 방식을 사용할 수 있다.</li>
</ul>

<h3 id="starvation">Starvation</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">indefinite blocking</code></li>
  <li>프로세스가 <code class="language-plaintext highlighter-rouge">suspend</code>된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상<br /><br /><br /></li>
</ul>

<h1 id="classical-problems-of-synchronization">Classical Problems of Synchronization</h1>
<h2 id="-bounded-buffer-problem">🔸 Bounded buffer problem</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Producer-Consumer Problem</code>이라고도 하며 데이터 입력을 위한 버퍼를 생성하는 생산자와 그 버퍼를 읽어서 수정된 데이터를 반영할 소비자로 나누는 개념이다.</li>
  <li>생산자는 빈 버퍼가 있는지 확인 후(없으면 기다림) 공유데이터에 lock을 걸고 버퍼에 데이터를 입력한 다음 lock을 풀고 든 버퍼를 하나 증가시킨다.</li>
  <li>소비자는 든 버퍼가 있는지 확인 후(없으면 기다림) 공유데이터에 lock을 걸고 버퍼에서 데이터를 꺼낸 뒤 lock을 풀고 빈 버퍼를 하나 증가시킨다.</li>
</ul>

<h3 id="공유-데이터">공유 데이터</h3>
<ul>
  <li>버퍼 및 버퍼 조작 변수(empty/full buffer의 시작 위치)</li>
</ul>

<h3 id="동기화-변수">동기화 변수</h3>
<ul>
  <li>mutual exclusion : 공유데이터의 mutual exclusion을 위해 필요</li>
  <li>resource count : 남은 empty/full buffer의 수를 표시하기 위해 필요</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Producer */</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">produce</span> <span class="n">an</span> <span class="n">item</span> <span class="n">in</span> <span class="n">x</span>
    <span class="p">...</span>
    <span class="n">P</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">add</span> <span class="n">x</span> <span class="n">to</span> <span class="n">buffer</span>
    <span class="p">...</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">V</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="cm">/* Consumer */</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">P</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">remove</span> <span class="n">an</span> <span class="n">item</span> <span class="n">from</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">y</span>
    <span class="p">...</span>
    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">V</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">consume</span> <span class="n">the</span> <span class="n">item</span> <span class="n">in</span> <span class="n">y</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="-readers-writers-problem">🔸 Readers-Writers Problem</h2>
<ul>
  <li>한 프로세스가 <code class="language-plaintext highlighter-rouge">DB</code>에 <code class="language-plaintext highlighter-rouge">write</code> 중일 때 다른 프로세스가 접근하면 안 됨</li>
  <li><code class="language-plaintext highlighter-rouge">read</code>는 동시에 여럿이 해도 됨</li>
  <li>solution
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Writer</code>가 <code class="language-plaintext highlighter-rouge">DB</code>에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기 중인 <code class="language-plaintext highlighter-rouge">Reader</code>들을 다 <code class="language-plaintext highlighter-rouge">DB</code>에 접근하게 해준다.</li>
      <li><code class="language-plaintext highlighter-rouge">Writer</code>는 대기 중인 <code class="language-plaintext highlighter-rouge">Reader</code>가 하나도 없을 때 <code class="language-plaintext highlighter-rouge">DB</code> 접근이 허용된다.</li>
      <li>일단 <code class="language-plaintext highlighter-rouge">Writer</code>가 <code class="language-plaintext highlighter-rouge">DB</code>에 접근 중이면 <code class="language-plaintext highlighter-rouge">Reader</code>들은 접근이 금지된다.</li>
      <li><code class="language-plaintext highlighter-rouge">Writer</code>가 <code class="language-plaintext highlighter-rouge">DB</code>에서 빠져 나가야만 <code class="language-plaintext highlighter-rouge">Reader</code>의 접근이 허용된다.</li>
    </ul>
  </li>
</ul>

<h3 id="공유-데이터-1">공유 데이터</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DB</code> 자체</li>
  <li><code class="language-plaintext highlighter-rouge">readcount</code> : 현재 <code class="language-plaintext highlighter-rouge">DB</code>에 접근 중인 <code class="language-plaintext highlighter-rouge">Reader</code>의 수</li>
</ul>

<h3 id="동기화-변수-1">동기화 변수</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mutex</code> : 공유 변수 <code class="language-plaintext highlighter-rouge">readcount</code>를 접근하는 코드(critical section)의 <code class="language-plaintext highlighter-rouge">mutual exclusion</code> 보장을 위해 사용</li>
  <li><code class="language-plaintext highlighter-rouge">db</code> : <code class="language-plaintext highlighter-rouge">Reader</code>와 <code class="language-plaintext highlighter-rouge">Writer</code>가 공유 <code class="language-plaintext highlighter-rouge">DB</code> 자체를 올바르게 접근하는 역할</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">readcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">DB</span> <span class="err">자체</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">db</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* Writer */</span>
<span class="n">P</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">writing</span> <span class="n">DB</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">V</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>

<span class="cm">/* Reader */</span>
<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">readcount</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">readcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">P</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>  <span class="cm">/* Writer 대기시킴 */</span>
<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">reading</span> <span class="n">DB</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">readcount</span><span class="o">--</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">readcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">V</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>  <span class="cm">/* Writer 입장 가능 */</span>
<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>하지만 위 코드대로만 하면 <code class="language-plaintext highlighter-rouge">Reader</code>가 계속 들어와서 <code class="language-plaintext highlighter-rouge">Writer</code>가 영원히 기다리게 될 수 있기 때문에(starvation) <code class="language-plaintext highlighter-rouge">Writer</code>의 우선순위를 높여줘서 너무 오래 기다리지 않게 한다.</li>
</ul>

<h2 id="-dining-philosophers-problem">🔸 Dining-Philosophers Problem</h2>
<ul>
  <li>다섯 명의 철학자가 원형 테이블에 앉아서 생각과 식사를 반복하는데 젓가락이 5개(2개 세트 아님)밖에 없음</li>
  <li>철학자는 내 양 옆에 있는 젓가락을 옆에 있는 철학자들이 쓰고 있지 않아야 젓가락을 사용해 밥을 먹을 수 있다.</li>
  <li>이 때 어떤 철학자의 양 옆에 있는 철학자들이 계속 밥을 먹어서 어떤 철학자가 젓가락을 영원히 쓰지 못하면 굶어 죽는다는.. 그런 문제이다.</li>
  <li>해결 방안
    <ul>
      <li>4명의 철학자만 테이블에 동시에 앉을 수 있도록 한다.</li>
      <li>젓가락을 두 개 모두 집을 수 있을 때에만 젓가락을 집을 수 있게 한다.</li>
      <li>비대칭 : 짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록 한다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="monitor">Monitor</h1>
<h2 id="세마포어의-문제점">세마포어의 문제점</h2>
<ul>
  <li>코딩하기 힘들다. - 문제가 생겼을 때 버그 잡기 힘듦</li>
  <li>정확성(correctness)의 입증이 어렵다.</li>
  <li>자발적 협력(voluntary cooperation)이 필요하다.</li>
  <li>한 번의 실수가 모든 시스템이 치명적인 영향을 끼친다.</li>
</ul>

<h3 id="예">예</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>V(mutex)
critical section
P(mutex)
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Mutual exclusion</code>이 깨짐<br /></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P(mutex)
critical section
P(mutex)
</code></pre></div></div>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Deadlock</code><br /></p>
  </li>
  <li>
    <p>위 경우들처럼 순서가 바뀌거나 같은 연산을 두 번 쓰는 실수가 생기면 오작동이 생긴다.</p>
  </li>
</ul>

<h2 id="monitor-1">Monitor</h2>
<ul>
  <li>동시 수행 중인 프로세스 사이에서 <code class="language-plaintext highlighter-rouge">abstract data type</code>의 안전한 공유를 보장하기 위한 <code class="language-plaintext highlighter-rouge">high-level synchronization construct</code></li>
  <li>객체 지향 프로그래밍에서 <code class="language-plaintext highlighter-rouge">class</code>에 멤버 변수와 함수를 담아서 사용하듯이 공유 데이터를 모니터 안에 선언하고 공유 데이터에 접근하려면 모니터 내부의 함수를 통해서만 하도록 하는 방법</li>
  <li>모니터 내의 함수는 한 번에 하나만 실행할 수 있기 때문에 <code class="language-plaintext highlighter-rouge">lock</code>을 걸 필요가 없다. 그래서 프로그래머 입장에서는 좀 더 간편하게 프로그램을 짤 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Operating System" /><category term="CS" /><category term="OS" /><category term="Process" /><category term="Synchronization" /><summary type="html"><![CDATA[👀 Process Synchronization 문제 컴퓨터에 저장되어 있는 어떤 데이터를 변경하려면 그 데이터에 접근해서 변경하는 연산을 한 뒤 연산 결과를 다시 그 데이터가 있는 자리에 갱신시켜줘야 한다. 그런데 이 때 하나의 프로세스만 접근해서 작업을 하면 문제가 없지만 컴퓨터에는 수많은 프로세스가 있고 하나의 데이터에 여러 프로세스가 접근하는 상황이 생길 수 있다. 이 때 아무런 제어 없이 여러 프로세스가 접근해서 하나의 데이터를 변경시키면 서로 다른 시점에 데이터를 변경하게 될 수 있고 그러다보면 데이터가 사용자의 의도와 다르게 변경될 수 있다(데이터 불일치 문제). 그래서 이걸 막고 데이터의 일관성 유지를 위해서 공유 데이터에 접근할 때 협력 프로세스 간의 실행 순서를 정해주어야 한다.]]></summary></entry><entry><title type="html">C++) BOJ 21921. 블로그</title><link href="http://localhost:4000/boj/boj21921-cpp/" rel="alternate" type="text/html" title="C++) BOJ 21921. 블로그" /><published>2022-03-06T00:00:00+09:00</published><updated>2022-03-06T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj21921-cpp</id><content type="html" xml:base="http://localhost:4000/boj/boj21921-cpp/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/21921">https://www.acmicpc.net/problem/21921</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>찬솔이는 블로그를 시작한 지 벌써 N일이 지났다.</p>
  </li>
  <li>
    <p>요즘 바빠서 관리를 못 했다가 방문 기록을 봤더니 벌써 누적 방문 수가 6만을 넘었다.</p>
  </li>
  <li>
    <p>찬솔이는 X일 동안 가장 많이 들어온 방문자 수와 그 기간들을 알고 싶다.</p>
  </li>
  <li>
    <p>찬솔이를 대신해서 X일 동안 가장 많이 들어온 방문자 수와 기간이 몇 개 있는지 구해주자.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>
    <p>첫째 줄에 블로그를 시작하고 지난 일수 N와 X가 공백으로 구분되어 주어진다.</p>
  </li>
  <li>
    <p>둘째 줄에는 블로그 시작 1일차부터 N일차까지 하루 방문자 수가 공백으로 구분되어 주어진다.<br /><br /></p>
  </li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>
    <p>첫째 줄에 X일 동안 가장 많이 들어온 방문자 수를 출력한다. 만약 최대 방문자 수가 0명이라면 SAD를 출력한다.</p>
  </li>
  <li>
    <p>만약 최대 방문자 수가 0명이 아닌 경우 둘째 줄에 기간이 몇 개 있는지 출력한다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력 배열의 처음부터 X일만큼의 합을 구하면서 한 칸씩 뒤로 이동하는데 그 중 합계가 가장 높은 경우와 그 일수들을 따로 저장해 주었다.</li>
  <li>N개 중 X개의 합을 매번 구하면 좀 비효율적이란 생각이 들어 처음에 N 배열의 0번 원소부터 X개의 합을 구한 뒤 그것을 최대값으로 설정한 다음 다른 X개의 합을 구하는 반복문에서는 i가 1부터 시작하면서 i-1번째 원소는 합계에서 빼고 i+(X-1)번째 원소를 더해주며 부분 합계를 구했다.</li>
  <li>그 과정에서 현재 최대값과 같은 값이 나오면 최대 일수를 계산하는 카운트를 증가시키고 현재 최대값보다 큰 값이 나오면 카운트를 1로 초기화한 뒤 최대값을 갱신해 주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 20 ms</li>
  <li>메모리 : 2876 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/0030cd127d490d3935f573b1750e5db2.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No21921" /><category term="Sliding Window" /><category term="C++" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/21921 제한 시간 제한 : 1 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">프로젝트) Cafe(웹 사이트) 만들기 2</title><link href="http://localhost:4000/project%20log/cafe-project-02/" rel="alternate" type="text/html" title="프로젝트) Cafe(웹 사이트) 만들기 2" /><published>2022-03-06T00:00:00+09:00</published><updated>2022-03-06T00:00:00+09:00</updated><id>http://localhost:4000/project%20log/cafe-project-02</id><content type="html" xml:base="http://localhost:4000/project%20log/cafe-project-02/"><![CDATA[<h1 id="개발환경">개발환경</h1>
<ul>
  <li>MacBook Air (M1, 2020) 16GB</li>
  <li>JDK 8</li>
  <li>Eclipse 2021-12</li>
  <li>tomcat 8.5<br /><br /><br /></li>
</ul>

<h1 id="시작">시작</h1>
<ul>
  <li>2022.3.4 ~ <br /><br /><br /></li>
</ul>

<h1 id="주제">주제</h1>
<ul>
  <li>국비 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.</li>
  <li>회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 <code class="language-plaintext highlighter-rouge">한 달</code></li>
  <li>나는 <code class="language-plaintext highlighter-rouge">다음 카페</code>를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.</li>
  <li>평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.<br /><br /><br /></li>
</ul>

<h1 id="진행상황">진행상황</h1>
<p align="center"><img src="../../assets/images/e-r-Diagram.png" /></p>
<p><br /></p>

<ul>
  <li>오늘은 좀 더 진행하기 전에 <code class="language-plaintext highlighter-rouge">E-R 다이어그램</code>을 만들면서 <code class="language-plaintext highlighter-rouge">DB 테이블</code>을 정리하고 가는 것이 좋을 거 같아서 내 프로젝트에 필요한 <code class="language-plaintext highlighter-rouge">E-R 다이어그램</code>을 만들었다.</li>
  <li>회원은 게시판에 글과 댓글을 쓰지 않을 수도 있지만 쓴다면 여러 개 쓸 수 있고 게시글과 댓글은 회원이 쓸 때에만 생성될 수 있다. 그리고 댓글 또한 게시글이 없으면 생성될 수 없고 한 게시글에 댓글이 달리지 않을 수도, 여러 개의 댓글이 달릴 수도 있다.</li>
  <li>일단 이 정도로 틀을 잡아놓고 테이블들을 생성했다.</li>
</ul>

<h2 id="1-회원-테이블cafe_members">1. 회원 테이블(cafe_members)</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">cafe_members</span> <span class="p">(</span>
    <span class="n">member_num</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span><span class="p">,</span>
    <span class="n">id</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">unique</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">pass</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">birth</span> <span class="nb">date</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">age</span> <span class="nb">int</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">gender</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">address</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
    <span class="n">phone</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">email</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span>
    <span class="n">regdate</span> <span class="nb">timestamp</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>
</code></pre></div></div>

<p align="center"><img src="../../assets/images/memberTable.png" /></p>
<p><br /></p>

<ul>
  <li>member_num : 회원 번호. 1부터 차례대로 증가하며 회원의 고유 식별자로 사용</li>
  <li>id : 회원 아이디. 중복되지 않도록 <code class="language-plaintext highlighter-rouge">unique</code> 조건을 걸어주었다.</li>
  <li>pass : 회원 비밀번호</li>
  <li>name : 회원 이름</li>
  <li>birth : 회원의 생년월일</li>
  <li>age : 회원 나이</li>
  <li>gender : 회원 성별</li>
  <li>address : 회원의 거주지 주소</li>
  <li>phone : 회원 휴대폰 번호</li>
  <li>email : 회원 이메일 주소</li>
  <li>regdate : 회원이 가입한 날짜. <code class="language-plaintext highlighter-rouge">timestamp</code>로 가입하는 당시의 날짜와 시간으로 자동 저장</li>
</ul>

<h2 id="2-게시글post">2. 게시글(post)</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">post</span> <span class="p">(</span>
    <span class="n">num</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span><span class="p">,</span>
    <span class="n">writer</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">title</span> <span class="nb">longtext</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">content</span> <span class="nb">longtext</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">posted_date</span> <span class="nb">datetime</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">);</span>
</code></pre></div></div>

<p align="center"><img src="../../assets/images/postTable.png" /></p>
<p><br /></p>

<ul>
  <li>num : 게시글 번호. 1부터 차례대로 증가하며 고유 식별자로 사용</li>
  <li>writer : 작성자 아이디</li>
  <li>title : 게시글 제목</li>
  <li>content : 게시글 내용</li>
  <li>posted_date : 최초로 작성된 날짜. YYYY-MM-DD 형식</li>
</ul>

<h2 id="3-댓글comment">3. 댓글(comment)</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="k">comment</span> <span class="p">(</span>
	<span class="n">num</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span> <span class="n">auto_increment</span><span class="p">,</span>
    <span class="n">post_num</span> <span class="nb">int</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
	<span class="n">writer</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">content</span> <span class="nb">longtext</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">commented_date</span> <span class="nb">datetime</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">parent</span> <span class="nb">int</span> <span class="k">default</span> <span class="mi">0</span>
<span class="p">);</span>
</code></pre></div></div>

<p align="center"><img src="../../assets/images/commentTable.png" /></p>
<p><br /></p>

<ul>
  <li>num : 댓글 번호. 1부터 차례대로 증가하며 고유 식별자로 사용</li>
  <li>post_num : 댓글이 등록된 글 번호</li>
  <li>writer : 댓글 작성자 아이디</li>
  <li>content : 댓글 내용</li>
  <li>commented_date : 댓글이 작성된 날짜</li>
  <li>parent : 만약 이 댓글이 대댓글이라면 대댓글을 단 원래 댓글의 댓글 번호. 모든 댓글이 대댓글이 되는 것은 아니기 때문에 디폴트값은 0으로 둔다. 0이라면 상위 댓글을 의미한다.<br /><br /><br /></li>
</ul>

<h1 id="마감까지">마감까지</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">D-29</code></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Project Log" /><category term="Project" /><category term="Cafe" /><category term="Log" /><summary type="html"><![CDATA[개발환경 MacBook Air (M1, 2020) 16GB JDK 8 Eclipse 2021-12 tomcat 8.5]]></summary></entry><entry><title type="html">프로젝트) Cafe(웹 사이트) 만들기 1</title><link href="http://localhost:4000/project%20log/cafe-project-01/" rel="alternate" type="text/html" title="프로젝트) Cafe(웹 사이트) 만들기 1" /><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><id>http://localhost:4000/project%20log/cafe-project-01</id><content type="html" xml:base="http://localhost:4000/project%20log/cafe-project-01/"><![CDATA[<h1 id="개발환경">개발환경</h1>
<ul>
  <li>MacBook Air (M1, 2020) 16GB</li>
  <li>JDK 8</li>
  <li>Eclipse 2021-12</li>
  <li>tomcat 8.5<br /><br /><br /></li>
</ul>

<h1 id="시작">시작</h1>
<ul>
  <li>2022.3.4 ~ <br /><br /><br /></li>
</ul>

<h1 id="주제">주제</h1>
<ul>
  <li>국비 수업 중 중간 과제로 개인 프로젝트를 진행하게 되었다.</li>
  <li>회원가입/로그인/탈퇴 등 기본적인 회원관리 시스템을 가진 웹 사이트를 만드는 것이다. 주어진 기한은 <code class="language-plaintext highlighter-rouge">한 달</code></li>
  <li>나는 <code class="language-plaintext highlighter-rouge">다음 카페</code>를 소규모로 만들어 보기로 했다. 평소 자주 이용하기도 했고 과제의 평가 기준에서 요구하는 기능들을 다 담고 있기도 했기 때문에 이번 기회에 구현해 보면 그동안 배운 것들을 활용하기에 좋을 거 같았다.</li>
  <li>평가 기준에 사이트의 디자인 구현(HTML/CSS 등 프론트엔드)은 포함되지 않기 때문에 본인이 쓰고 싶은 HTML/CSS 템플릿을 구한 뒤 회원 관리 기능을 구현하면 된다.<br /><br /><br /></li>
</ul>

<h1 id="진행상황">진행상황</h1>
<p align="center"><img src="../../assets/images/cafeProj01.png" /></p>
<p><br /></p>

<ul>
  <li>그래서 오늘 진행한 것은 무료 템플릿 사이트에서 다운받은 템플릿을 이용해 기본적인 사이트 틀을 만들었다.</li>
  <li>메인 페이지를 만들고 로그인 페이지와 회원가입 페이지 폼을 만들어서 연결시키는 것 까지 했다.<br /><br /></li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;servlet&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>CafeFrontController<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;servlet-class&gt;</span>com.project.cafe.CafeFrontController<span class="nt">&lt;/servlet-class&gt;</span>
  <span class="nt">&lt;/servlet&gt;</span>
  
  <span class="nt">&lt;servlet-mapping&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>CafeFrontController<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;url-pattern&gt;</span>*.me<span class="nt">&lt;/url-pattern&gt;</span>
  <span class="nt">&lt;/servlet-mapping&gt;</span>
</code></pre></div></div>

<ul>
  <li>물론 <code class="language-plaintext highlighter-rouge">HTML</code>을 이용해 그냥 연결시키지 않았고 서블릿을 이용해 <code class="language-plaintext highlighter-rouge">Model2 MVC</code> 패턴을 적용시킬 계획이기 때문에 <code class="language-plaintext highlighter-rouge">.xml</code> 페이지에서 서블릿 클래스 매핑을 통해 페이지 경로를 주소창에 노출시키면서 연결하는 것이 아닌, 주소창에는 가상 주소를 보여주도록 하기 위한 틀을 만들었다.</li>
  <li>매핑될 가상주소는 하나로 고정시키는 것이 아닌, 페이지별 용도에 따라 다른 주소를 출력할 수 있도록 <code class="language-plaintext highlighter-rouge">*</code>을 사용해 맨 뒤에 <code class="language-plaintext highlighter-rouge">.me</code>만 붙으면 그 주소를 올바른 것으로 인식하고 대응시킬 수 있도록 했다.<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.RequestDispatcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CafeFrontController</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span>
<span class="o">{</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doProcess</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
	<span class="o">{</span>
		<span class="c1">// 1. 전달되는 가상주소 계산</span>
		<span class="c1">// 매핑된(.me로 끝나는) 주소를 받아옴</span>
		<span class="nc">String</span> <span class="n">requestURI</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"requestURI : "</span> <span class="o">+</span> <span class="n">requestURI</span><span class="o">);</span>
		
		<span class="c1">// 매핑된 해당 프로젝트 주소를 구함</span>
		<span class="nc">String</span> <span class="n">ctxPath</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getContextPath</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ctxPath : "</span> <span class="o">+</span> <span class="n">ctxPath</span><span class="o">);</span>
		
		<span class="c1">// 매핑된 주소 - 프로젝트 주소 = 계속 바뀔 뒷자리 주소 구함</span>
		<span class="nc">String</span> <span class="n">command</span> <span class="o">=</span> <span class="n">requestURI</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">ctxPath</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"command : "</span> <span class="o">+</span> <span class="n">command</span><span class="o">);</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 가상주소 계산 완료\n"</span><span class="o">);</span>
		<span class="c1">// 1. 전달되는 가상주소 계산</span>
		
		
		<span class="c1">// 2. 가상주소 매핑</span>
		<span class="nc">ActionForward</span> <span class="n">forward</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		
		<span class="k">if</span> <span class="o">(</span><span class="n">command</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"/main.me"</span><span class="o">))</span>
		<span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 메인페이지 호출"</span><span class="o">);</span>
			
			<span class="n">forward</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ActionForward</span><span class="o">();</span>
			<span class="n">forward</span><span class="o">.</span><span class="na">setPath</span><span class="o">(</span><span class="s">"./main/main.jsp"</span><span class="o">);</span>
			<span class="n">forward</span><span class="o">.</span><span class="na">setRedirect</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 가상주소 매핑 완료\n"</span><span class="o">);</span>
		<span class="c1">// 2. 가상주소 매핑</span>
		
		
		<span class="c1">// 3. 페이지 이동</span>
		<span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">forward</span><span class="o">)</span> <span class="c1">// 페이지 이동정보가 있을 때</span>
		<span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">forward</span><span class="o">.</span><span class="na">isRedirect</span><span class="o">())</span>
			<span class="o">{</span>
				<span class="n">resp</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="n">forward</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
			<span class="o">}</span>
			<span class="k">else</span> 
			<span class="o">{</span>
				<span class="nc">RequestDispatcher</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="n">forward</span><span class="o">.</span><span class="na">getPath</span><span class="o">());</span>
				<span class="n">dis</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
			<span class="o">}</span>
			
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C : 페이지 이동 완료"</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="c1">// 3. 페이지 이동</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
	<span class="o">{</span>
		<span class="n">doProcess</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doPost</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
	<span class="o">{</span>
		<span class="n">doProcess</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이런 식으로 서블릿 클래스를 만든 다음<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">language=</span><span class="s">"java"</span><span class="na"> contentType=</span><span class="s">"text/html; charset=UTF-8"</span><span class="na">
    pageEncoding=</span><span class="s">"UTF-8"</span><span class="nt">%&gt;</span>

<span class="nt">&lt;%</span>
  <span class="n">response</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="s">"./main.me"</span><span class="o">);</span>
<span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li>실제 실행시킬 페이지인 <code class="language-plaintext highlighter-rouge">index.jsp</code>에서는 매핑된 서블릿으로 연결시켜서 실행되도록 했다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">language=</span><span class="s">"java"</span><span class="na"> contentType=</span><span class="s">"text/html; charset=UTF-8"</span><span class="na">
    pageEncoding=</span><span class="s">"UTF-8"</span><span class="nt">%&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="c">&lt;!-- Start Head --&gt;</span>
  <span class="nt">&lt;jsp:include </span><span class="na">page=</span><span class="s">"../inc/top.jsp"</span><span class="nt">&gt;&lt;/jsp:include&gt;</span>
<span class="c">&lt;!-- End Head --&gt;</span>

<span class="nt">&lt;body</span> <span class="na">class=</span><span class="s">"modern"</span><span class="nt">&gt;</span>

<span class="c">&lt;!--
START MODULE AREA 2: Menu 1
--&gt;</span>
  <span class="nt">&lt;jsp:include </span><span class="na">page=</span><span class="s">"../inc/subTop.jsp"</span><span class="nt">&gt;&lt;/jsp:include&gt;</span>
<span class="c">&lt;!--
END MODULE AREA 2: Menu 1
--&gt;</span>
</code></pre></div></div>

<ul>
  <li>그리고 이런 식으로 헤더와 푸터 부분은 다른 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지로 분리해서 새로운 페이지가 추가되어도 헤더와 푸터 페이지를 액션 태그를 써서 인클루드만 해 주고 헤더와 푸터 부분에서 수정 사항이 생기면 <code class="language-plaintext highlighter-rouge">top.jsp</code>, <code class="language-plaintext highlighter-rouge">bottom.jsp</code> 페이지만 수정하면 되도록 만들었다.</li>
  <li>이렇게 만들어놓고 나니까 헤더 부분에서 수정할 점이 생겨도 페이지 하나만 수정하면 되니까 정말 편하다.<br /><br /><br /></li>
</ul>

<h1 id="마감까지">마감까지</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">D-30</code></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Project Log" /><category term="Project" /><category term="Cafe" /><category term="Log" /><summary type="html"><![CDATA[개발환경 MacBook Air (M1, 2020) 16GB JDK 8 Eclipse 2021-12 tomcat 8.5]]></summary></entry><entry><title type="html">C++) BOJ 1149. RGB거리</title><link href="http://localhost:4000/boj/boj1149-cpp/" rel="alternate" type="text/html" title="C++) BOJ 1149. RGB거리" /><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1149-cpp</id><content type="html" xml:base="http://localhost:4000/boj/boj1149-cpp/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1149">https://www.acmicpc.net/problem/1149</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 0.5 초 (추가 시간 없음)</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.</p>
  </li>
  <li>
    <p>집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.</p>
  </li>
  <li>1번 집의 색은 2번 집의 색과 같지 않아야 한다.</li>
  <li>N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.</li>
  <li>i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 현재 집까지 칠했을 때 비용과 이번에 칠할 수 있는 색 중 더 가격이 싼 색을 더한 가격을 dp 배열에 합산해서 마지막 인덱스 중 최소값을 출력했는데 마지막 예제가 통과하지 못했다.</li>
  <li>질문 게시판 보니까 현재 최소값이 최종적으로 최소값이 되지 않을 수 있는 경우 때문이었다. ㅠㅠ</li>
  <li>근데 문제는 알아도 해결할 방법이 떠오르질 않아서 질문 게시판을 더 찾아봤는데 어떤 분이 주어지는 행렬에서 각 행에 숫자를 하나 골라서 인접하지 않은 수들과의 합 중 최소값을 구하는 것이라고 써 놓은 것을 보고 아이디어를 얻어서 수정하니까 통과되었다.<br /></li>
</ul>

<p>3<br />
 26 40 83<br />
 49 60 57<br />
 13 89 99<br /></p>
<ul>
  <li>여기서 수직 방향으로는 합을 구하지 않고 대각선 방향(\/)에 있는 수들과 현재 행의 수의 합 중 최소를 구하는 것임
 <br /></li>
  <li>풀고 나니까 왜 실버1인지 알 거 같기도 했다… 쓸데없이 어렵게 생각해서 시간 날림 ㅠ<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 0 ms</li>
  <li>메모리 : 2044 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/35d2200aab10e021888277fc50975c31.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1149" /><category term="DP" /><category term="C++" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1149 제한 시간 제한 : 0.5 초 (추가 시간 없음) 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">C++) BOJ 2864. 5와 6의 차이</title><link href="http://localhost:4000/boj/boj2864-cpp/" rel="alternate" type="text/html" title="C++) BOJ 2864. 5와 6의 차이" /><published>2022-03-05T00:00:00+09:00</published><updated>2022-03-05T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2864-cpp</id><content type="html" xml:base="http://localhost:4000/boj/boj2864-cpp/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2864">https://www.acmicpc.net/problem/2864</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>상근이는 2863번에서 표를 너무 열심히 돌린 나머지 5와 6을 헷갈리기 시작했다.</p>
  </li>
  <li>
    <p>상근이가 숫자 5를 볼 때, 5로 볼 때도 있지만, 6으로 잘못 볼 수도 있고, 6을 볼 때는, 6으로 볼 때도 있지만, 5로 잘못 볼 수도 있다.</p>
  </li>
  <li>
    <p>두 수 A와 B가 주어졌을 때, 상근이는 이 두 수를 더하려고 한다. 이때, 상근이가 구할 수 있는 두 수의 가능한 합 중, 최솟값과 최댓값을 구해 출력하는 프로그램을 작성하시오.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 두 정수 A와 B가 주어진다. (1 &lt;= A,B &lt;= 1,000,000)<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 상근이가 구할 수 있는 두 수의 합 중 최솟값과 최댓값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>한 자리씩 검사하면서 5라면 6으로 만들었을 때의 합을 구하고(최대값) 6이라면 5로 만들었을 때의 합(최소값)을 구했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 0 ms</li>
  <li>메모리 : 2024 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/6b82fcadc7ae10357bafb90bb2508e8c.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2864" /><category term="BackTracking" /><category term="C++" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2864 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">에러해결 Log) JSP 절대경로 지정하기</title><link href="http://localhost:4000/errorlog/warning-log-02/" rel="alternate" type="text/html" title="에러해결 Log) JSP 절대경로 지정하기" /><published>2022-03-04T00:00:00+09:00</published><updated>2022-03-04T00:00:00+09:00</updated><id>http://localhost:4000/errorlog/warning-log-02</id><content type="html" xml:base="http://localhost:4000/errorlog/warning-log-02/"><![CDATA[<h1 id="사용환경">사용환경</h1>
<ul>
  <li>MacBook Air (M1, 2020) 16GB</li>
  <li>JDK 8</li>
  <li>Eclipse 2021-12</li>
  <li>tomcat 8.5<br /><br /><br /></li>
</ul>

<h1 id="에러의-발생">에러의 발생</h1>
<p align="center"><img src="../../assets/images/pathError.png" width="400" /></p>
<p><br /></p>

<ul>
  <li>역시 여느 때와 같은 <code class="language-plaintext highlighter-rouge">JSP</code> 수업 시간… <code class="language-plaintext highlighter-rouge">Model2 MVC</code> 패턴으로 웹 페이지를 만드는 것을 실습하고 있었는데 서블릿을 통해 가상주소로 페이지를 열다 보니까 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지 자체는 잘 열리는데 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지와 연결된 외부 <code class="language-plaintext highlighter-rouge">css</code>파일의 경로를 제대로 찾질 못해서 기본으로 적용되어 있던 <code class="language-plaintext highlighter-rouge">css</code>가 제대로 적용되질 않았다.</li>
  <li>이걸 해결하고 수업이 끝났다면 좋았겠지만 여기까지 했을 때 마침 수업 시간이 끝나버려서… 다음 수업까지 기다릴 수도 있었겠지만 간단해 보이는 걸 해결 못하니까 너무 신경쓰여서 경로를 온갖 방법으로 지정을 해 줬는데 계속 상대 경로를 지정하는 것이었어서 그런지 페이지로 이동하는 경로에 따라 어떤 경우엔 잘 되고 어떤 경우엔 잘 나오지 않는 등 여러가지로 <code class="language-plaintext highlighter-rouge">css</code> 파일이 완벽하게 로드되지 않았다.</li>
  <li>물론 절대경로도 나름 시도를 해 보았으나 잘못 알고 있었는지 절대경로도 먹히질 않았다…<br /><br /><br /></li>
</ul>

<h1 id="문제-해결">문제 해결</h1>

<ul>
  <li>구글에 <code class="language-plaintext highlighter-rouge">jsp 절대경로</code>를 검색하니까 자료가 많았다.</li>
  <li>절대경로를 설정하는 간단한 방법은 루트를 뜻하는 <code class="language-plaintext highlighter-rouge">/</code>를 입력하고 하위 폴더명을 타고타고 입력하는 것이지만 저게 먹히지 않았기 때문에 다른 방법을 찾았다.</li>
  <li>바로<br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${pageContext.request.contextPath}
</code></pre></div></div>
<p><br />
를 이용해 어느 경우라도 절대경로가 적용될 수 있게 해주는 것이다.</p>
<ul>
  <li>한 시간동안 헤메면서도 생각했지만 jsp 페이지에 직접 접근했을 때와 서블릿을 통해 접근했을 때 상대경로의 기준이 달라져서 그러는 것 같았는데 찾아보니까 진짜였다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"${pageContext.request.contextPath}/css/default.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">type=</span><span class="s">"text/css"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<ul>
  <li>이런 식으로 찾아가고자 하는 폴더와 파일의 경로를 <code class="language-plaintext highlighter-rouge">el 표현식</code>을 사용한 <code class="language-plaintext highlighter-rouge">contextPath</code> 뒤에 입력해주면 절대경로로 세팅되면서 정상적으로 <code class="language-plaintext highlighter-rouge">css</code> 파일을 찾아가게 된다.</li>
  <li>그런데 방금 적용시켜 보니까 jsp 액션태그의 경로에는 절대경로를 넣으니까 <code class="language-plaintext highlighter-rouge">500 에러</code>가 나서 액션태그는 피하고 <code class="language-plaintext highlighter-rouge">HTML</code> 태그에만 적용시켜 주면 될 거 같다.</li>
</ul>

<p align="center"><img src="../../assets/images/pathSolve.png" width="400" /></p>

<ul>
  <li>짠👏 적용 끝!</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="ErrorLog" /><category term="Error" /><category term="Solve" /><category term="Log" /><summary type="html"><![CDATA[사용환경 MacBook Air (M1, 2020) 16GB JDK 8 Eclipse 2021-12 tomcat 8.5]]></summary></entry><entry><title type="html">C++) BOJ 1049. 기타줄</title><link href="http://localhost:4000/boj/boj1049-cpp/" rel="alternate" type="text/html" title="C++) BOJ 1049. 기타줄" /><published>2022-03-04T00:00:00+09:00</published><updated>2022-03-04T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1049-cpp</id><content type="html" xml:base="http://localhost:4000/boj/boj1049-cpp/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1049">https://www.acmicpc.net/problem/1049</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.</p>
  </li>
  <li>
    <p>끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>브랜드에 상관없이 총 구매 가격이 최소가 되기만 하면 되기 때문에 입력 받으면서 6개 팩 중 가장 싼 가격과 낱개 중 가장 싼 가격을 저장해 놓았다.</li>
  <li>그리고 기타줄의 갯수만큼 사는데 6개 팩으로 사는 것이 더 싸면 정답 변수에 6개 팩의 가격을 더해주고 아나리면 낱개를 남은 기타줄의 갯수만큼 곱해서 더해주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 0 ms</li>
  <li>메모리 : 2020 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/9c5b8c3b800227349339656b3d141e8e.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1049" /><category term="BackTracking" /><category term="C++" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1049 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 2580. 스도쿠</title><link href="http://localhost:4000/boj/boj2508-java/" rel="alternate" type="text/html" title="Java) BOJ 2580. 스도쿠" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2508-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2508-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2580">https://www.acmicpc.net/problem/2580</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.</p>
  </li>
  <li>
    <p>나머지 빈 칸을 채우는 방식은 다음과 같다.</p>
  </li>
  <li>각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li>
  <li>
    <p>굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</p>
  </li>
  <li>게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>
    <p>모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.</p>
  </li>
  <li>
    <p>스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 for문을 여러번 돌려서 n^3에 가깝게 풀었는데 그래서 그런지 시간 초과가 났다…</li>
  <li>
    <p>그래서 시간을 줄여보려고 입력 받으면서 0인 칸만 따로 저장한 뒤 거기만 탐색하는 방식으로도 해 봤지만 역시 1%에서 시간초과가 나서 질문 게시판과 구글링을 참고했다.<br /></p>
  </li>
  <li>스도쿠의 가로세로줄과 3*3 칸을 검사한 뒤 겹치는 숫자가 없도록 넣어야 하기 때문에 이것을 검사하는 함수를 만들어서 0인 위치에 대해서 1~9 까지의 숫자를 넣어서 검사를 실시한 뒤 해당 숫자를 넣을 수 있으면 수를 삽입한 뒤 스도쿠에 숫자를 넣는 함수를 재귀호출한다.</li>
  <li>스도쿠 칸을 채우는 방법이 여러 개가 있을 수 있기 때문에 보드판이 다 채워지는대로 보드판을 출력하고 System.exit(0)을 사용해서 프로그램을 종료한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 672 ms</li>
  <li>메모리 : 28336 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/ec822102bdf365ea40b0cbfa1087e456.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2580" /><category term="BackTracking" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2580 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 9663. N-Queen</title><link href="http://localhost:4000/boj/boj9663-java/" rel="alternate" type="text/html" title="Java) BOJ 9663. N-Queen" /><published>2022-03-02T00:00:00+09:00</published><updated>2022-03-02T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj9663-java</id><content type="html" xml:base="http://localhost:4000/boj/boj9663-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/9663">https://www.acmicpc.net/problem/9663</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 10 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p>
  </li>
  <li>
    <p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15) <br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>어디서 들어본 거 같은데 모르겠어서 구글링했다.</li>
  <li>
    <p>참고 블로그 : <a href="https://st-lab.tistory.com/118">https://st-lab.tistory.com/118</a><br /></p>
  </li>
  <li>체스판 위에 퀸을 놓은 뒤 그 위치의 다음 위치부터 검사해서 어떤 위치가 퀸이 있는 위치에서 상하좌우 대각선 방향에 있는 곳이라면 그냥 넘어가고 아니라면 퀸을 놓기 위한 함수를 재귀호출하는 것이다.</li>
  <li>탐색 위치가 체스판의 끝에 도달하면 재귀 호출을 종료한다. (자세한 건 주석에..)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 5320 ms</li>
  <li>메모리 : 14532 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/db381c63586f1f3e1d73c9dee48ccc2c.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No9663" /><category term="BackTracking" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/9663 제한 시간 제한 : 10 초 메모리 제한 : 128 MB]]></summary></entry></feed>