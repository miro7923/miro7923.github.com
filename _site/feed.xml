<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-27T20:05:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">컴퓨터 네트워크) OSI 참조모델</title><link href="http://localhost:4000/computer%20network/computer-network-03-OSI/" rel="alternate" type="text/html" title="컴퓨터 네트워크) OSI 참조모델" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/computer%20network/computer-network-03-OSI</id><content type="html" xml:base="http://localhost:4000/computer%20network/computer-network-03-OSI/"><![CDATA[<h1 id="-osi-참조모델">👀 OSI 참조모델</h1>
<ul>
  <li>예전엔 제조사별로 각자 통신 모델을 만들어 썼기 때문에 서로 호환이 되지 않아 통신이 되지 않는 경우가 많았다.</li>
  <li>그래서 1970년대 후반에 국제 표준화 기구 ISO(Open System Interconnection)가 네트워크 설계의 호환성을 증진시키기 위해 개방시스템 상호접속 참조모델(OSI) 구조를 제안함</li>
  <li><code class="language-plaintext highlighter-rouge">OSI</code>란 말은 타사의 시스템 간이라도 데이터를 교환하기 위한 표준을 가질 수 있다는 것을 의미함</li>
  <li><code class="language-plaintext highlighter-rouge">OSI</code>는 <code class="language-plaintext highlighter-rouge">7계층</code>으로 이루어져 있다.</li>
</ul>

<h2 id="계층-구조의-장점">계층 구조의 장점</h2>
<ul>
  <li>크고 복잡한 시스템을 기능별로 나누어 개발 과정을 단순화 하는데 매우 유용하게 사용(모듈화)</li>
  <li>각 계층이 제공하는 서비스를 변경하기 쉬움(한 계층을 변경해도 나머지 계층에 영향을 주지 않아 유지 보수가 쉽다)</li>
</ul>

<h2 id="osi-참조모델의-계층">OSI 참조모델의 계층</h2>
<ul>
  <li>N 계층의 프로토콜 모듈은 상대방의 동일 계층 프로토콜 모듈과 통신을 하며 동일 계층에 있는 N 계층 끼리의 통신 규약을 N 계층 프로토콜이라 함</li>
  <li>N 계층 프로토콜이 상대방의 동일 계층에 데이터를 직접 전달하는 것이 아니라 하위 계층(N - 1)으로 전달해서 맨 아래 계층인 물리 계층까지 도달하면 케이블을 통해 상대 호스트의 물리 계층으로 데이터를 전달한다.</li>
  <li>상대 호스트는 물리 계층에서 받은 데이터를 하나씩 확인하며 상위 계층(N + 1)으로 올려 보낸다.</li>
  <li>결과적으로, OSI 7계층 모델에서 상위 계층은 하위 계층의 서비스 사용자(Service User)가 되며, 하위 계층은 상위 계층의 서비스 제공자(Service Provider)가 된다.</li>
</ul>

<h2 id="서비스-프리미티브service-primitive">서비스 프리미티브(Service Primitive)</h2>
<ul>
  <li>동일 호스트상의 서비스 사용자(N + 1계층)와 서비스 제공자(N계층)간에 주고 받는 데이터</li>
  <li>N 계층의 서비스는 N 서비스 프리미티브와 이 프리미티브에 관련된 파라미터로 규정</li>
  <li>N 서비스 프리미티브는 요청(Request), 통지(Indicator), 응답(Response), 확인(Confirm)으로 구분</li>
  <li>송신측에서 수신측으로 <code class="language-plaintext highlighter-rouge">Request</code>를 보내면 수신측의 하위 계층에서 <code class="language-plaintext highlighter-rouge">Indicator</code>를 발생시킨 뒤 송신측으로 <code class="language-plaintext highlighter-rouge">Response</code>를 보낸다. 송신측은 받은 데이터를 확인(<code class="language-plaintext highlighter-rouge">Confirm</code>)하며 하위계층에서 상위계층으로 올려보낸다.</li>
  <li>송신측에서 데이터를 전송할 때 서비스 프리미티브를 사용하여 N + 1 계층의 송신 데이터(PDU : Protocol Data Unit)는 N 계층의 서비스 데이터 단위(SDU : Service Data Unit)로 N 계층에 넘겨진다.</li>
  <li>N 계층에서는 <code class="language-plaintext highlighter-rouge">PDU</code>에 프로토콜 제어 정보(PCI : Protocol Control Information)를 헤더로 붙여 N 계층 <code class="language-plaintext highlighter-rouge">PDU</code>로 만든 뒤 하위 계층으로 내려보내고 하위 계층에서도 이걸 반복한다.</li>
  <li>이러한 계층간 데이터의 전달 과정을 캡슐화(Encapsulation)라고 한다.</li>
</ul>

<h2 id="osi-참조모델의-7계층">OSI 참조모델의 7계층</h2>
<h3 id="물리-계층physical-layer">물리 계층(Physical Layer)</h3>
<ul>
  <li>계층 1에 해당하며 전송매체에 대한 전기적, 기계적인 인터페이스를 다룸</li>
  <li>전송하고자 하는 데이터를 전송매체에 적합한 전기적 신호로 바꾸는 기능</li>
  <li>하드웨어로 구현되며 계층 2 이상은 대부분 소프트웨어로 구현된다.</li>
  <li>물리 계층 관련 장치들
    <ul>
      <li>리피터(Repeater), 허브(Hub), 케이블, 이더넷(Ethernet) 등과 같은 하드웨어 장치</li>
      <li>LAN에서 사용하는 UTP(Unshieled Twisted Pair), STP(Shieled Twisted Pair)와 같은 케이블</li>
      <li>LAN의 UTP 케이블에 연결하는 RJ-45 커넥터(흔히 사용하는 인터넷 랜선 커넥터)</li>
    </ul>
  </li>
</ul>

<h3 id="데이터링크-계층datalink-layer">데이터링크 계층(Datalink Layer)</h3>
<ul>
  <li>물리 계층을 통해 전송되는 데이터의 오류 문제를 해결하여 신뢰성 있는 데이터 전송 기능을 제공하는데 <code class="language-plaintext highlighter-rouge">호스트 - 라우터 간 오류 문제만</code> 제어한다.</li>
  <li>이를 통해 상위 계층인 네트워크 계층에게 오류 문제에 대한 부담을 줄임</li>
  <li>데이터링크 계층에서 전송하는 데이터 단위를 <code class="language-plaintext highlighter-rouge">프레임(Frame)</code>이라 한다.</li>
  <li>데이터링크 계층의 주요 기능
    <ul>
      <li>순서 제어 : 데이터의 순차적 전송을 위해 프레임 번호 부여</li>
      <li>오류 제어 : 오류 검출과 교정 (가장 중요한 기능)</li>
      <li>흐름 제어 : 연속적인 프레임을 전송할 때 수신측이 수신이 가능한지 여부를 제어. 호스트 간 <code class="language-plaintext highlighter-rouge">CPU</code> 성능이 다를 때 느린 쪽이 빠른 쪽의 속도에 어느정도 맞춰 받을 수 있는지 서로 확인한 후 전송하는 등의 제어를 한다.</li>
      <li>프레임 동기화 : 데이터 전송시 프레임 단위로 전송</li>
    </ul>
  </li>
</ul>

<h3 id="네트워크-계층network-layer">네트워크 계층(Network Layer)</h3>
<ul>
  <li>네트워크 상에 존재하는 라우터와 같은 노드(Node)를 거칠 때마다 목적지로의 경로를 찾아주는 라우팅(Routing) 역할을 하는 계층</li>
  <li>네트워크 계층의 데이터 전송 단위를 패킷(Packet)이라 부르며 패킷 내에는 송신 호스트의 주소와 목적지 호스트의 주소를 포함</li>
  <li>라우터에 패킷이 도착하면 패킷의 목적지 주소에 따라 적합한 라우터로 중개하며 이러한 과정을 통해 목적지에 도착</li>
  <li>라우터가 패킷을 중개할 때 자신이 관리하고 있는 라우팅 테이블(Routing Table)을 사용해서 패킷을 어디로 보낼지 결정한다.</li>
  <li>네트워크 계층의 예
    <ul>
      <li>인터넷의 <code class="language-plaintext highlighter-rouge">IP</code>(IP 주소가 이 계층에서 사용하는 주소)</li>
      <li><code class="language-plaintext highlighter-rouge">OSI</code>의 X.25</li>
    </ul>
  </li>
</ul>

<h3 id="트랜스포트-계층transport-layer">트랜스포트 계층(Transport Layer)</h3>
<ul>
  <li>라우터와 같은 노드와는 상관없이 단대단(End-to-end) 신뢰성 있는 데이터 전송 기능을 제공</li>
  <li>이를 위해 단대단 오류 복구, 흐름 제어 기능 등을 포함하는데 트랜스포트 계층에서의 제어 기능들은 <code class="language-plaintext highlighter-rouge">A 호스트에서 B 호스트까지 가는 모든 경로의 오류 및 흐름</code>을 제어한다.</li>
  <li>트랜스포트 계층은 호스트 내에서 동작하는 <code class="language-plaintext highlighter-rouge">프로세스(Process)에서 프로세스</code>로 데이터를 전송한다.
    <ul>
      <li>네트워크 계층은 <code class="language-plaintext highlighter-rouge">호스트에서 호스트</code>로의 데이터 전송에 관계함</li>
      <li>네트워크 계층에서 보내는 IP 주소 만으로는 상대 호스트의 어떤 프로세스에서 이 데이터를 보냈는지 알 수 없다. 그래서 각 프로세스별로 포트(Port) 번호를 사용해서 어떤 프로세스에서 보낸 데이터인지 구분한다.</li>
      <li>그래서 단대단 전송이라는 용어는 프로세스와 프로세스 간의 전송을 의미한다.</li>
    </ul>
  </li>
  <li>트랜스포트 계층의 데이터 전송 단위(PDU : Protocol Data Unit)에는 송신측 포트 번호와 수신측 포트 번호를 포함한다.</li>
  <li>포트 번호는 특정 프로세스를 나타내기 위해 트랜스포트 계층에서 사용하는 주소라 할 수 있다.</li>
  <li>인터넷 통신구조에서 <code class="language-plaintext highlighter-rouge">TCP</code>와 <code class="language-plaintext highlighter-rouge">UDP</code>가 트랜스포트 계층에 해당한다.</li>
</ul>

<h3 id="세션-계층session-layer">세션 계층(Session Layer)</h3>
<ul>
  <li>양끝단에 있는 응용 프로세스간의 통신을 제어하는 기능 제공</li>
  <li>응용 프로세스간 대화를 위해 세션을 설정하여 사용하는 기능 제공</li>
  <li>제공 기능
    <ul>
      <li>대화(Dialogue) 형태 : 단방향, 반이중, 전이중</li>
      <li>복구(Recovery) 기능 : 체크포인트(Checkpoint) 기능을 제공하여 체크포인트 사이에 오류가 있을 때 마지막 체크포인트 이후의 모든 데이터를 세션 계층이 재전송하는 기능</li>
    </ul>
  </li>
</ul>

<h3 id="표현-계층presentation-layer">표현 계층(Presentation Layer)</h3>
<ul>
  <li>호스트간에 교환되는 데이터의 표현방법(Syntax)과 의미(Semantic)를 다루는 계층</li>
  <li>즉 양쪽 호스트의 데이터 표현 방식이 다를 때 송신 호스트는 양쪽 호스트가 이해할 수 있는 표준화 된 형식으로 인코딩(Encoding)하고, 수신 호스트는 표준화 된 형식을 수신측에 적합한 형식으로 디코딩(Decoding)하는 기능</li>
  <li>이외에도 데이터의 안전하고 효율적인 전송을 위해 암호화(Encryption)하거나 압축(Compression)하는 기능 제공</li>
</ul>

<h3 id="응용-계층application-layer">응용 계층(Application Layer)</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">OSI 7계층</code> 중에서 최상위 계층에 있으며 사용자에게 필요한 응용 서비스를 제공하는 계층</li>
  <li>응용 계층에 해당하는 프로토콜
    <ul>
      <li>FTAM(File Transfer Access and Management) : 파일 전송 프로토콜이며 인터넷의 FTP와 유사한 서비스</li>
      <li>VT(Virtual Terminal) : 가상 단말 서비스 프로토콜이며 인터넷의 Telnet과 유사<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="sdu와-pdu의-차이">SDU와 PDU의 차이</h2>
<ul>
  <li>SDU(Service Data Unit) : 상하위 계층간 데이터 전송을 위해 사용하는 데이터 단위</li>
  <li>PDU(Protocol Data Unit) : 상대방과의 통신을 위해 사용되는 데이터 단위<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=5959f58996c6bd25">데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Network" /><category term="CS" /><category term="Network" /><category term="OSI" /><summary type="html"><![CDATA[👀 OSI 참조모델 예전엔 제조사별로 각자 통신 모델을 만들어 썼기 때문에 서로 호환이 되지 않아 통신이 되지 않는 경우가 많았다. 그래서 1970년대 후반에 국제 표준화 기구 ISO(Open System Interconnection)가 네트워크 설계의 호환성을 증진시키기 위해 개방시스템 상호접속 참조모델(OSI) 구조를 제안함 OSI란 말은 타사의 시스템 간이라도 데이터를 교환하기 위한 표준을 가질 수 있다는 것을 의미함 OSI는 7계층으로 이루어져 있다.]]></summary></entry><entry><title type="html">Java) BOJ 18870. 좌표 압축</title><link href="http://localhost:4000/boj/boj18870-java/" rel="alternate" type="text/html" title="Java) BOJ 18870. 좌표 압축" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj18870-java</id><content type="html" xml:base="http://localhost:4000/boj/boj18870-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/18870">https://www.acmicpc.net/problem/18870</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.</p>
  </li>
  <li>
    <p>Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.</p>
  </li>
  <li>
    <p>X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N이 주어진다.</li>
  <li>둘째 줄에는 공백 한 칸으로 구분된 X1, X2, …, XN이 주어진다.</li>
  <li>1 ≤ N ≤ 1,000,000</li>
  <li>-109 ≤ Xi ≤ 109<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 X’1, X’2, …, X’N을 공백 한 칸으로 구분해서 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력받은 수 배열에서 i번째 수보다 작은 수의 갯수를 세어서 i번째에 출력하면 되는데 i번째 수보다 작은 수가 몇 개인지 알려면 오름차순으로 정렬을 해 봐야 한다.</li>
  <li>오름차순으로 정렬을 해 보면 i번째 수의 앞에 있는 수들은 다 작은 수들이니까 배열을 순회하면서 그 수가 몇 개인지 세면 i번째 수를 압축한 수가 된다.</li>
  <li>
    <p>정답 출력 형식을 보면 입력된 숫자의 순서대로 압축한 수를 출력해야 하는데 입력 배열을 정렬해 버리면 순서가 흐트러져서 정답 형식으로 출력할 수 없다. 그래서 입력 배열과 같은 임시 배열을 만들어 정렬한다.<br /></p>
  </li>
  <li>그런데 최대 백만개가 입력으로 주어지는데 2중 for문을 통해 하나씩 비교하는 <code class="language-plaintext highlighter-rouge">O(n^2)</code> 알고리즘을 사용하면 시간초과를 받을 것이기 때문에 정렬 알고리즘은 <code class="language-plaintext highlighter-rouge">O(n log n)</code> 시간복잡도를 가지는 것을 쓰는 것이 좋다.</li>
  <li>그리고 입력으로 중복된 수가 들어오는데 예제의 답을 보면 중복된 수는 카운트하지 않는다.</li>
  <li>즉 1, 1, 2 일 때 2보다 작은 수인 1이 2개 있는데 이럴 경우 답은 0, 0, 1이 되어야 한다. 2보다 작은 수는 1개가 되어야 한다.</li>
  <li>
    <p>그래서 오름차순으로 정렬하고 난 후 중복되는 숫자들은 제거해 주어야 한다. 중복 숫자를 제거하지 않으면 i번째 수보다 작은 수를 셀 때 오차가 생길 것이다.<br /></p>
  </li>
  <li>중복된 숫자들을 제거하고 나면 &lt;i번째 숫자, i번째 숫자보다 작은 숫자의 갯수&gt; pair를 저장하는 map을 만들어서 각 원소를 삽입해준다.</li>
  <li>
    <p>그 다음 마지막으로 입력 원본 배열을 순회하면서 map에서 i번째 원소를 key로 가지는 value를 찾아 출력하면 된다.<br /></p>
  </li>
  <li>시간제한이 2초인데 2788ms로 통과된 거 보면 자바는 느려서 시간을 좀 더 주는 것 같다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 2788 ms</li>
  <li>메모리 : 254876 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/1cd7a372bd0ad6186aadcb222ca3afc6.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No18870" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/18870 제한 시간 제한 : 2 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 1181. 단어 정렬</title><link href="http://localhost:4000/boj/boj1181-java/" rel="alternate" type="text/html" title="Java) BOJ 1181. 단어 정렬" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1181-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1181-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1181">https://www.acmicpc.net/problem/1181</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</li>
</ul>

<ol>
  <li>길이가 짧은 것부터</li>
  <li>길이가 같으면 사전 순으로<br /><br /></li>
</ol>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>Collections.sort와 Comparator 람다식을 이용해 구현했다.</li>
  <li>마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 392 ms</li>
  <li>메모리 : 23208 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/55e1fca4233f64a9249c59ee80aeb16f.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1181" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1181 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11651. 좌표 정렬하기2</title><link href="http://localhost:4000/boj/boj11651-java/" rel="alternate" type="text/html" title="Java) BOJ 11651. 좌표 정렬하기2" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11651-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11651-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11651">https://www.acmicpc.net/problem/11651</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>11650번에서 썼던 Comparator 함수에서 기준값을 x에서 y로만 바꿔주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 860 ms</li>
  <li>메모리 : 49896 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/bafcfe58127991148c9f70bab678805d.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11651" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11651 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11650. 좌표 정렬하기</title><link href="http://localhost:4000/boj/boj11650-java/" rel="alternate" type="text/html" title="Java) BOJ 11650. 좌표 정렬하기" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11650-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11650-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11650">https://www.acmicpc.net/problem/11650</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 <code class="language-plaintext highlighter-rouge">Pair</code> 클래스에서 <code class="language-plaintext highlighter-rouge">Comparable</code>을 구현해서 썼는데 리턴값을 잘못 설정했는지 계속 7%에서 틀렸다 ㅠ.ㅠ</li>
  <li>그래서 구글링해서 Comparator 람다식으로 바꾸고 통과함<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 800 ms</li>
  <li>메모리 : 51232 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/49b9efbb416fe3905a7e48e17b4d3990.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11650" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11650 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 10814. 나이순 정렬</title><link href="http://localhost:4000/boj/boj10814-java/" rel="alternate" type="text/html" title="Java) BOJ 10814. 나이순 정렬" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10814-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10814-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10814">https://www.acmicpc.net/problem/10814</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</li>
</ul>

<ol>
  <li>길이가 짧은 것부터</li>
  <li>길이가 같으면 사전 순으로<br /><br /></li>
</ol>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>Collections.sort와 Comparator 람다식을 이용해 구현했다.</li>
  <li>마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 392 ms</li>
  <li>메모리 : 23208 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/978be8ad9674667c38e12894cd1c7144.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10814" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10814 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">JSP) 서블릿</title><link href="http://localhost:4000/jsp/JSP-servlet/" rel="alternate" type="text/html" title="JSP) 서블릿" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-servlet</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-servlet/"><![CDATA[<h1 id="-서블릿servlet이란">👀 서블릿(Servlet)이란?</h1>
<ul>
  <li>자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 <code class="language-plaintext highlighter-rouge">JSP</code> 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다.</li>
  <li>즉 <code class="language-plaintext highlighter-rouge">JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class)</code> 이런 과정을 거치게 된다.</li>
</ul>

<h2 id="서블릿-작성-규칙">서블릿 작성 규칙</h2>
<p>1) javax.servlet.Servlet 인터페이스 구현<br />
2) 1)의 구현이 어려운 경우 javax.servlet.http.HttpServlet 클래스 상속(일반적으로 사용)<br />
3) doGet()/ doPost() 생성(오버라이딩), HttpServletRequest/ HttpServletResponse 객체 구현<br />
4) IOException/ ServletException을 처리해야 함<br />
5) web.xml 파일을 통해서 주소 매핑 (어노테이션 처리)<br /></p>

<h2 id="서블릿-실행-구조">서블릿 실행 구조</h2>

<p><img src="../../assets/images/servletProcess.png" /><br /><br /><br /></p>

<h1 id="서블릿-클래스-만들기">서블릿 클래스 만들기</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.RequestDispatcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.itwillbs.test.Student</span><span class="o">;</span>

<span class="c1">// 서블릿 - jsp코드 + java코드를 함께 수행할 수 있는 파일</span>
<span class="c1">// 서블릿 클래스 상속받으면 서블릿이 됨</span>

<span class="c1">// http://localhost:8090/JSP6/ex1</span>
<span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/ex1"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> 
<span class="o">{</span>
    <span class="c1">// 폼태그에서 get method를 썼을 때 호출되는 함수</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"doGet() 호출"</span><span class="o">);</span>
		
        <span class="c1">// 응답정보의 내용의 형태는 html문서로 표현하겠다.</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html; charset=UTF-8"</span><span class="o">);</span>

        <span class="c1">// response를 통해서 출력가능한 통로를 생성하겠다.</span>
<span class="c1">//	    PrintWriter out = response.getWriter();</span>
<span class="c1">//</span>
<span class="c1">//	    // 서블릿을 이용한 JSP 페이지 표현 - 사용하진 않을 것임</span>
<span class="c1">//	    out.print("&lt;html&gt;");</span>
<span class="c1">//	    out.print("&lt;head&gt;");</span>
<span class="c1">//	    out.print("&lt;/head&gt;");</span>
<span class="c1">//	    out.print("&lt;body&gt;");</span>
<span class="c1">//	    out.print("&lt;h1&gt; 서블릿을 활용한 JSP페이지 만들기&lt;/h1&gt;");</span>
<span class="c1">//	    out.print("&lt;/body&gt;");</span>
<span class="c1">//	    out.print("&lt;/html&gt;");</span>
<span class="c1">//	    out.close();</span>

        <span class="c1">// 포워딩 전 request 영역에 정보를 저장</span>
        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"itwill"</span><span class="o">,</span> <span class="s">"busan"</span><span class="o">);</span>

        <span class="c1">// 객체정보를 전달</span>
        <span class="nc">Student</span> <span class="n">kim</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"김학생"</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setKor</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setEng</span><span class="o">(</span><span class="mi">90</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setMath</span><span class="o">(</span><span class="mi">76</span><span class="o">);</span>
        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"Student"</span><span class="o">,</span> <span class="n">kim</span><span class="o">);</span>

        <span class="nc">Student</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"사용자"</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setKor</span><span class="o">(</span><span class="mi">45</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setEng</span><span class="o">(</span><span class="mi">70</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setMath</span><span class="o">(</span><span class="mi">98</span><span class="o">);</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">memberList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;();</span>
        <span class="n">memberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">kim</span><span class="o">);</span>
        <span class="n">memberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"memberList"</span><span class="o">,</span> <span class="n">memberList</span><span class="o">);</span>

        <span class="c1">// 서블릿 코드를 사용한 화면 출력 X</span>
        <span class="c1">// =&gt; 포워딩을 사용한 화면 출력 O</span>

        <span class="c1">// 자바 코드를 이용한 포워딩 방식 - 외우기</span>
<span class="c1">//	    &lt;jsp:forward/&gt; 사용불가 - JSP 페이지가 아닌 자바파일이라서 못 씀</span>
        <span class="c1">// 이동할 경로 설정</span>
        <span class="nc">RequestDispatcher</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">"/jstl/coreSet2.jsp"</span><span class="o">);</span>

        <span class="n">dis</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
	<span class="o">}</span> <span class="c1">// doGet()</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이렇게 만들면 되는데 사용할 함수들을 다 오버라이딩 하기 때문에 일일이 작성하지 않아도 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">HttpServlet</code>을 상속받고 나면 이클립스가 구현해야 하는 함수들을 다 만들어 준다.</li>
  <li>우리는 형태가 만들어진 함수의 내부만 채우면 된다.<br /><br /><br /></li>
</ul>

<h1 id="jsp-페이지에서-서블릿을-활용한-정보-전달">JSP 페이지에서 서블릿을 활용한 정보 전달</h1>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 서블릿에서 저장된 정보(request.setAttribute("itwill", "busan");) 출력 --&gt;</span>
  itwill : <span class="nt">&lt;%=</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"itwill"</span><span class="o">)</span> <span class="nt">%&gt;&lt;br&gt;</span>
  itwill : ${itwill }<span class="nt">&lt;br&gt;</span>
  itwill : ${requestScope.itwill }<span class="nt">&lt;br&gt;</span>
  
<span class="c">&lt;!-- 앞으로는 보안을 위해 주소에 정보가 처리되는 jsp 페이지를 나타내지 않을 것임
  		자바 서블릿 코드를 이용해 jsp 페이지 작성(가상주소 생성) --&gt;</span>
</code></pre></div></div>

<ul>
  <li>자바 서블릿 코드를 이용해 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지를 작성할 것이기 때문에 서블릿 클래스를 실행하면 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지로 연결되어 액션을 수행하지만 주소창에는 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지가 나타나지 않고 어노테이션 <code class="language-plaintext highlighter-rouge">@WebServlet("/ex1")</code>에 쓴 <code class="language-plaintext highlighter-rouge">/ex1</code>가 맨 뒤에 붙어 주소창에는 <code class="language-plaintext highlighter-rouge">http://localhost:8090/JSP6/ex1</code> 와 같은 형태로 나타나게 된다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${Student}<span class="nt">&lt;br&gt;</span>
학생 이름 : ${Student.getName() }<span class="nt">&lt;br&gt;</span>
국어 : ${Student.getKor() }<span class="nt">&lt;br&gt;</span>
영어 : ${Student.getEng() }<span class="nt">&lt;br&gt;</span>
수학 : ${Student.getMath() }<span class="nt">&lt;br&gt;</span>
  
<span class="nt">&lt;%</span>
  <span class="nc">Student</span> <span class="n">kim</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"Student"</span><span class="o">);</span>
<span class="nt">%&gt;</span>
<span class="nt">&lt;%=</span><span class="n">kim</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="nt">%&gt;&lt;br&gt;</span>
${Student.name }<span class="nt">&lt;br&gt;</span><span class="c">&lt;!-- el 표현식에서는 내부적으로 get/set 메서드를 자동으로 구현해 사용함. 그래서 변수명으로도 접근가능 --&gt;</span>
  
<span class="c">&lt;!-- 좀 더 간단하게 쓰기 --&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"kim"</span><span class="na"> value=</span><span class="s">"</span><span class="si">${</span><span class="nc">Student</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  
${kim.name }
  
<span class="nt">&lt;hr&gt;</span>
  
${requestScope.memberList }<span class="nt">&lt;br&gt;</span>
${requestScope.memberList[0].name }
</code></pre></div></div>

<ul>
  <li>그리고 아까 서블릿에서 함께 저장했던 클래스 객체도 위와 같이 <code class="language-plaintext highlighter-rouge">el 표현식</code>을 사용해서 출력할 수 있다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="Servlet" /><summary type="html"><![CDATA[👀 서블릿(Servlet)이란? 자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 JSP 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다. 즉 JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class) 이런 과정을 거치게 된다.]]></summary></entry><entry><title type="html">JSP) JSTL</title><link href="http://localhost:4000/jsp/JSP-jstl/" rel="alternate" type="text/html" title="JSP) JSTL" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-jstl</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-jstl/"><![CDATA[<h1 id="-jstljsp-standard-tag-library이란">👀 JSTL(JSP Standard Tag Library)이란?</h1>
<ul>
  <li>자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태</li>
  <li>
    <p>태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.</p>
  </li>
  <li>CORE 라이브러리 : 기본적인 동작 제공
    <ul>
      <li>변수 선언, 조건문, 반복문 코드를 처리하는 태그</li>
      <li>페이지 이동처리 태그 (태그만 사용해서 반복문 처리를 할 수 있음)</li>
    </ul>
  </li>
  <li>Formatting 라이브러리
    <ul>
      <li>데이터 국제화 처리 (다국어) 태그</li>
      <li>형식화 (날짜, 숫자, 시간) 태그</li>
    </ul>
  </li>
  <li>DB 라이브러리 : sql구문처리 동작
    <ul>
      <li>CRUD 동작 수행 태그</li>
    </ul>
  </li>
  <li>XML 라이브러리
    <ul>
      <li>XML 문서 읽고 처리하는 태그</li>
    </ul>
  </li>
</ul>

<h2 id="다운로드-및-설치">다운로드 및 설치</h2>
<ul>
  <li>톰캣 홈페이지에서 taglibs 메뉴에 들어가서 하단에</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taglibs-standard-jstlel-1.2.5.jar
taglibs-standard-spec-1.2.5.jar
taglibs-standard-impl-1.2.5.jar
</code></pre></div></div>

<ul>
  <li>세 파일을 다운받는다.</li>
  <li>다운받은 파일들을 <code class="language-plaintext highlighter-rouge">WEB-INF/lib</code>에 복붙하면 설치 완료<br /><br /><br /></li>
</ul>

<h1 id="core-라이브러리">CORE 라이브러리</h1>
<h2 id="변수-선언-및-사용">변수 선언 및 사용</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"c"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/core"</span> <span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li>먼저 페이지 상단에 라이브러리 인클루드 해 주어야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">prefix</code>는 태그의 접두사를 지정해 주는 것으로 <code class="language-plaintext highlighter-rouge">prefix</code>에 지정한 문자를 쓰고 <code class="language-plaintext highlighter-rouge">:</code>을 쓰면 태그 예약어들을 사용할 수 있다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;%-- &lt;c:set var="변수명" value="값"/&gt; --%&gt;</span>
  <span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"num3"</span><span class="na"> value=</span><span class="s">"300"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"num4"</span><span class="na"> value=</span><span class="s">"400"</span><span class="nt">/&gt;</span>
  
  <span class="c">&lt;!-- 변수값 출력할 때엔 el 표현식 사용 --&gt;</span>
  <span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">num3</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">num4</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;hr&gt;</span>
  
  ${num3 } + ${num4 } = ${num3 + num4 }
</code></pre></div></div>

<ul>
  <li>태그 속에서 변수를 선언하고 값을 넣어줄 수 있다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> value=</span><span class="s">"S22"</span><span class="na"> scope=</span><span class="s">"request"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>스크립틀릿을 이용해서 자바 코드로 변수를 선언하면 지역변수로 인식되어서 선언한 페이지에서만 쓸 수 있는데 <code class="language-plaintext highlighter-rouge">JSTL</code> 태그를 사용하면 변수의 영역도 지정해 줄 수 있어서 자바 코드를 사용하는 것에 비해 훨씬 활용도를 높일 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">scope : page, request, session, application</code> 네 영역 모두 설정해 줄 수 있다. <code class="language-plaintext highlighter-rouge">scope</code>를 설정하지 않으면 기본값은 <code class="language-plaintext highlighter-rouge">page</code>라서 선언한 페이지에서만 쓸 수 있다.</li>
</ul>

<h2 id="출력">출력</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"안녕하세요 JSTL입니다."</span><span class="nt">&gt;&lt;/c:out&gt;</span>
</code></pre></div></div>

<ul>
  <li>만약 <code class="language-plaintext highlighter-rouge">null</code>값을 출력하는 경우 빈공백으로 처리된다. (JSP 표현식은 컴파일 에러남)</li>
  <li>컴파일 에러난 페이지를 보여주는 것 보다는 <code class="language-plaintext highlighter-rouge">null</code>값을 출력하는게 사용자 신뢰도에는 더 좋다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;</span> <span class="nt">abc&gt;</span>태그는 abc입니다.<span class="nt">&lt;hr&gt;</span>

<span class="ni">&amp;lt;</span>abc&gt;태그는 abc입니다.<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"&lt;abc&gt;태그는 abc입니다."</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>만약 태그 자체를 출력하고 싶다면 위 세 가지 방법으로 출력이 가능하다.</li>
</ul>

<h2 id="조건문">조건문</h2>
<h3 id="if">if</h3>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- jstl 변수 2개 생성(속성) --&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> value=</span><span class="s">"itwill"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"tel"</span><span class="na"> value=</span><span class="s">"010-1234-5678"</span><span class="nt">/&gt;</span>

<span class="c">&lt;!-- 사용자의 이름이 "itwill"인지 체크 --&gt;</span>
<span class="nt">&lt;c:if </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">name</span> <span class="o">==</span> <span class="l">'itwill'</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span><span class="c">&lt;!-- 표현식 안에서는 작은 따옴표를 써야 함(큰 따옴표 쓰면 밖에 따옴표랑 반응함) --&gt;</span>
  사용자 이름 : ${name }<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:if&gt;</span>

<span class="nt">&lt;c:if </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="mi">100</span> <span class="n">lt</span> <span class="mi">200</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span><span class="c">&lt;!-- lt : 비교연산자(&lt;)와 같은 역할을 하는 예약어 --&gt;</span>
  200이 더 크다.<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:if&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HTML</code> 태그처럼 태그 사이에 출력하고 싶은 문구를 작성할 수 있다.<br /><br /></li>
</ul>

<h3 id="switch-case">switch ~case</h3>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:choose&gt;</span>
  <span class="nt">&lt;c:when </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">param</span><span class="o">.</span><span class="na">num1</span> <span class="n">le</span> <span class="n">param</span><span class="o">.</span><span class="na">num2</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span>
    num1! <span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:when&gt;</span>
  <span class="nt">&lt;c:when </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">param</span><span class="o">.</span><span class="na">num1</span> <span class="n">lt</span> <span class="n">param</span><span class="o">.</span><span class="na">num2</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span>
    num2! <span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:when&gt;</span>
  <span class="nt">&lt;c:otherwise&gt;</span>
    그 외 나머지<span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:otherwise&gt;</span>
<span class="nt">&lt;/c:choose&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">choose</code> 태그를 사용해서 <code class="language-plaintext highlighter-rouge">switch ~case</code>문을 작성할 수 있다.<br /><br /></li>
</ul>

<h2 id="반복문">반복문</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:forEach </span><span class="na">var=</span><span class="s">"i"</span><span class="na"> begin=</span><span class="s">"1"</span><span class="na"> end=</span><span class="s">"10"</span><span class="na"> step=</span><span class="s">"1"</span><span class="nt">&gt;</span>
  ${i }
<span class="nt">&lt;/c:forEach&gt;</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 <code class="language-plaintext highlighter-rouge">for</code>문에서 변수를 선언하고 조건식, 증감식을 설정해 줄 수 있는데 저렇게는 잘 안 쓴다.(단순 순회할 때 <code class="language-plaintext highlighter-rouge">for</code>문에서 귀찮은 것들을 덜어내고 쓰는 것이 <code class="language-plaintext highlighter-rouge">foreach</code>니까…)<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="o">{</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
<span class="nt">%&gt;</span>
<span class="c">&lt;!-- 이 형태를 많이 쓴다.(items 자리엔 jsp 표현식보다는 el 표현식을 쓴다.) --&gt;</span>
<span class="nt">&lt;c:forEach </span><span class="na">var=</span><span class="s">"test"</span><span class="na"> items=</span><span class="s">"&lt;%=arr %&gt;"</span><span class="nt">&gt;</span>
  ${test } 
<span class="nt">&lt;/c:forEach&gt;</span>
</code></pre></div></div>

<ul>
  <li>위와 같은 형태로 배열을 순회할 때 많이 사용한다.<br /><br /></li>
</ul>

<h2 id="문자열-parsing">문자열 Parsing</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:forTokens </span><span class="na">var=</span><span class="s">"abc"</span><span class="na"> items=</span><span class="s">"a,b,c,d,e,f,g,h"</span><span class="na"> delims=</span><span class="s">","</span><span class="nt">&gt;</span>
  ${abc } 
<span class="nt">&lt;/c:forTokens&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"data"</span><span class="na"> value=</span><span class="s">"자바 디비 웹 JSP"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;c:forTokens </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> items=</span><span class="s">"</span><span class="si">${</span><span class="n">data</span> <span class="si">}</span><span class="s">"</span><span class="na"> delims=</span><span class="s">" "</span><span class="nt">&gt;</span>
  ${name }<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:forTokens&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">delims</code>에 넣은 인자값을 기준으로 문자열을 자를 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="formatting-라이브러리">Formatting 라이브러리</h1>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"c"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/core"</span><span class="nt">%&gt;</span>
<span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"fmt"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/fmt"</span><span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Formatting</code> 라이브러리는 일반적으로 <code class="language-plaintext highlighter-rouge">fmt</code> 접두사를 쓴다.</li>
</ul>

<h2 id="날짜-출력하기">날짜 출력하기</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"today"</span><span class="na"> value=</span><span class="s">"&lt;%=new Date() %&gt;"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- time: 시간정보 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- both: 날짜 &amp; 시간정보 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"both"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"long"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"medium"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"short"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"both"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="na"> timeStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"long"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"medium"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"short"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;h3&gt;</span>2022/2/25(금) (오전) 11:50:00 형식으로 표현하기<span class="nt">&lt;/h3&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> pattern=</span><span class="s">"yyyy/MM/dd(E)"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> pattern=</span><span class="s">"(a)hh:mm:ss"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dateStyle</code>에 넣은 값만큼 출력되는 날짜 정보의 갯수를 조절할 수 있다.</li>
</ul>

<h2 id="통화-출력하기">통화 출력하기</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"today"</span><span class="na"> value=</span><span class="s">"&lt;%=new Date() %&gt;"</span><span class="nt">/&gt;</span>
${today }
<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"ko_kr"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"en_us"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"zh_cn"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"ja_jp"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="숫자-출력">숫자 출력</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"100000000"</span><span class="na"> groupingUsed=</span><span class="s">"false"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"100000000"</span><span class="na"> groupingUsed=</span><span class="s">"true"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;h2&gt;</span>소수점 자리 표현<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="mf">2.12345676</span> <span class="si">}</span><span class="s">"</span><span class="na"> pattern=</span><span class="s">"#.####"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- 0은 .뒤에 0을 채워줌 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"20.0"</span><span class="na"> pattern=</span><span class="s">"##.00"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"0.5"</span><span class="na"> type=</span><span class="s">"percent"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- 통화 심볼도 바꿀 수 있다 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"10000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="na"> currencySymbol=</span><span class="s">"@"</span><span class="nt">/&gt;&lt;br&gt;</span>
</code></pre></div></div>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="JSTL" /><summary type="html"><![CDATA[👀 JSTL(JSP Standard Tag Library)이란? 자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태 태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.]]></summary></entry><entry><title type="html">JSP) 커넥션 풀</title><link href="http://localhost:4000/jsp/JSP-connection-pool/" rel="alternate" type="text/html" title="JSP) 커넥션 풀" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-connection-pool</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-connection-pool/"><![CDATA[<h1 id="-커넥션-풀-connection-pool이란">👀 커넥션 풀 (Connection Pool)이란?</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">JDBC</code>를 연동하기 위해서는 드라이버를 로드하고 <code class="language-plaintext highlighter-rouge">JDBC URL</code>로 접속하여 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 얻어오는 단계를 거쳐야 한다.</li>
  <li>커넥션 풀은 데이터베이스와 연결된 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다.</li>
  <li>사용자가 웹 사이트에 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다.</li>
  <li>하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.</li>
</ul>

<h2 id="커넥션풀의-연결전략">커넥션풀의 연결전략</h2>
<p>1) DB연결이 필요한 JSP 페이지 (service()) 실행시 DB연결 요청당 1개씩 할당<br />
2) 커넥션의 개수를 제한<br />
3) 커넥션의 사용을 다 한 경우 (객체관리자가 자원을 모두 다 쓰면) 자원 회수<br /></p>

<h2 id="실제-동작-구현">실제 동작 구현</h2>
<ol>
  <li>웹브라우저 요청<br /></li>
  <li>할당될 커넥션 객체가 있는지 없는지 체크<br /><br /></li>
</ol>

<p>2-1. 있을 때<br />
    3. 커넥션 객체 할당 (pool에 저장된 정보 전달)<br />
    4. 객체 사용<br />
    5. 객체 사용 반환 (자원해제 X, pool에 저장)<br /></p>

<p>2-2. 없을 때<br />
    1. 커넥션 객체를 기다림 (커넥션이 반환될 때 까지)<br />
    2. 임시 커넥션 객체 생성 -&gt; 사용 -&gt; 반환 (사라짐)<br /><br /><br /></p>

<h1 id="jndi-java-namming-and-directory-interface">JNDI (Java Namming and Directory Interface)</h1>
<ul>
  <li>명명 서비스 및 디렉토리 서비스에 접근하기 위한 API. 즉 특정 자원에 접근하기 위한 이름으로 사용된다.</li>
  <li><a href="https://commons.apache.org/">아파치 홈페이지</a>에 가서 <code class="language-plaintext highlighter-rouge">collections</code>, <code class="language-plaintext highlighter-rouge">DBCP</code>, <code class="language-plaintext highlighter-rouge">Pool</code> 다운받기
    <ul>
      <li>압축 풀어서 <code class="language-plaintext highlighter-rouge">commons-collections4-4.4.jar</code> 처럼 옆에 잡다한 이름 안 붙은걸로 복사해서 <code class="language-plaintext highlighter-rouge">WEB-INF/lib</code>에 붙여넣기</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">API</code>를 설치했으면 <code class="language-plaintext highlighter-rouge">xml</code> 파일을 만들어야 한다.</li>
</ul>

<h2 id="xml">XML</h2>
<ul>
  <li>태그 형태로 데이터를 저장하는 페이지로 <code class="language-plaintext highlighter-rouge">HTML</code> 태그 형태는 아니지만 지정된 태그를 통해서 데이터를 저장하고 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">src/main/webapp/META-INF</code>에 <code class="language-plaintext highlighter-rouge">content.xml</code> 파일을 생성하고 서버에 공유할 리소스를 정의한다.</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="nt">&lt;Context&gt;</span>
  <span class="nt">&lt;Resource</span> 
    <span class="na">name=</span><span class="s">"jdbc/mysql"</span> 
    <span class="na">auth=</span><span class="s">"Container"</span> 
    <span class="na">type=</span><span class="s">"javax.sql.DataSource"</span> 
    <span class="na">username=</span><span class="s">"root"</span> 
    <span class="na">password=</span><span class="s">"1234"</span> 
    <span class="na">driverClassName=</span><span class="s">"com.mysql.cj.jdbc.Driver"</span> 
    <span class="na">url=</span><span class="s">"jdbc:mysql://localhost:3306/jspdb"</span> 
    <span class="na">maxActive=</span><span class="s">"500"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Context&gt;</span>
</code></pre></div></div>

<ul>
  <li>이렇게 작성하면 되는데 각 코드 라인의 의미는 다음과 같다.</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Context&gt;</span>
  <span class="c">&lt;!-- Context : 프로젝트 --&gt;</span>
  <span class="nt">&lt;Resource</span> 
    <span class="na">name=</span><span class="s">"디비에 접근하기 위한 이름"</span> 
    <span class="na">auth=</span><span class="s">"컨테이너 자원 관리자 설정 - Application or Container"</span> 
    <span class="na">type=</span><span class="s">"리소스를 사용할 때 실제로 사용되는 클래스 타입"</span> 
    <span class="na">username=</span><span class="s">"디비 아이디"</span> 
    <span class="na">password=</span><span class="s">"디비 비밀번호"</span> 
    <span class="na">driverClassName=</span><span class="s">"드라이버 주소"</span> 
    <span class="na">url=</span><span class="s">"디비 연결 주소"</span> 
    <span class="na">maxActive=</span><span class="s">"커넥션 회수 대기시간"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Context&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xml</code> 파일에서도 주석문 사용이 가능하지만 사용하지 않는 것이 좋다.</li>
  <li>왜냐면 주석 처리한 코드가 실행되는 경우가 있는데 이 때 에러가 나도 컴파일 에러가 표시되지 않고 단순 서버 에러라고만 나오기 때문에 원인 찾기가 매우매우 힘들다.</li>
  <li><code class="language-plaintext highlighter-rouge">xml</code> 파일까지 만들었다면 <code class="language-plaintext highlighter-rouge">MemberDAO</code> 클래스를 커넥션 풀을 사용하도록 수정해야 한다.<br /><br /><br /></li>
</ul>

<h1 id="memberdao-클래스를-커넥션-풀을-쓰도록-수정하기">MemberDAO 클래스를 커넥션 풀을 쓰도록 수정하기</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getConnect()</code> 함수를 아래와 같이 수정한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Connection</span> <span class="nf">getConnect</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">try</span> 
    <span class="o">{</span>
        <span class="c1">// 커넥션풀을 사용한 디비연결</span>
        
        <span class="c1">// 업캐스팅이라 인터페이스인데 객체 생성 가능</span>
        <span class="c1">// 프로젝트(CTX)정보 초기화</span>
        <span class="nc">Context</span> <span class="n">initCTX</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InitialContext</span><span class="o">();</span>
        
<span class="c1">//	Context envCTX = (Context) initCTX.lookup("java:comp/env");</span>
<span class="c1">//				envCTX.lookup("jdbc/mysql"); // 이거랑 아래 한 문장이랑 같은 의미</span>
        <span class="c1">// java:comp/env/ 여기까지는 항상 고정 &amp; 뒤에 xml 파일의 name에 쓴 내용 넣기</span>
        <span class="c1">// type="javax.sql.DataSource" 에서 정해준 데이터타입으로 다운캐스팅 해줘야 함</span>
        <span class="nc">DataSource</span> <span class="n">ds</span> <span class="o">=</span> <span class="o">(</span><span class="nc">DataSource</span><span class="o">)</span> <span class="n">initCTX</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"java:comp/env/jdbc/mysql"</span><span class="o">);</span>
        
        <span class="c1">// ds에 연결정보가 다 들어있으니까 getConnection만 실행</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 커넥션풀을 사용한 디비연결 성공"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : "</span> <span class="o">+</span> <span class="n">con</span><span class="o">);</span>
    <span class="o">}</span> 
    <span class="k">catch</span> <span class="o">(</span><span class="nc">NamingException</span> <span class="n">e</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> 
    <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">con</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이후 사용하는 것은 기존과 같이 사용하면 된다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="ConnectionPool" /><summary type="html"><![CDATA[👀 커넥션 풀 (Connection Pool)이란? JDBC를 연동하기 위해서는 드라이버를 로드하고 JDBC URL로 접속하여 Connection 객체를 얻어오는 단계를 거쳐야 한다. 커넥션 풀은 데이터베이스와 연결된 Connection 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 Connection 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다. 사용자가 웹 사이트에 Connection 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다. 하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.]]></summary></entry><entry><title type="html">컴퓨터 네트워크) 데이터 통신</title><link href="http://localhost:4000/computer%20network/computer-network-02/" rel="alternate" type="text/html" title="컴퓨터 네트워크) 데이터 통신" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/computer%20network/computer-network-02</id><content type="html" xml:base="http://localhost:4000/computer%20network/computer-network-02/"><![CDATA[<h1 id="전송-모드">전송 모드</h1>
<h2 id="병렬-전송parallel-transfer">병렬 전송(Parallel Transfer)</h2>
<ul>
  <li>여러 전송라인을 통해 여러 비트들을 동시에 전송</li>
  <li>두 장치들간의 거리가 짧은 경우에 일반적으로 사용
    <ul>
      <li>예) PC에서 프린터로 전송하는 것</li>
      <li>예) 컴퓨터와 주변 장치들간의 연결</li>
    </ul>
  </li>
  <li>긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.</li>
</ul>

<h2 id="직렬-전송serial-transfer">직렬 전송(Serial Transfer)</h2>
<ul>
  <li>하나의 전송라인을 사용하여 하나씩 모든 비트를 보낸다.</li>
  <li>긴 거리를 전송할 때 병렬 전송에 비해 적은 비용이 들고 신뢰성 증가</li>
  <li>하지만 비트를 하나씩 보내는 만큼 병렬 전송에 비해 느리다.</li>
</ul>

<h2 id="비동기식-전송">비동기식 전송</h2>
<ul>
  <li>한 번에 한 문자씩 보내거나 받는 방식</li>
  <li>문자는 7~8 비트로 구성되며, 문자의 앞에 시작비트(Start bit)를, 끝에는 정지비트(Stop bit)를 첨가해서 보냄</li>
  <li>송신측과 수신측 사이에 동기를 맞추기 위한 클럭 신호를 사용하지 않음</li>
  <li>시작비트는 수신측에 문자에 해당하는 비트가 따라올 것이라는 것을 알려주는 역할</li>
  <li>문자 비트들을 모두 수신하면 정지비트가 뒤따른다.</li>
  <li>키보드와 프린터 같이 느린 장치들을 위해 사용되며 높은 오버헤드를 가진다.</li>
</ul>

<h2 id="동기식-전송">동기식 전송</h2>
<ul>
  <li>정해진 수 만큼의 문자들을 하나의 그룹(프레임)으로 만들어서 일시에 전송하는 방법</li>
  <li>일반적으로 비동기식 전송에 비해서 더 빠르다.</li>
  <li>송신측과 수신측이 하나의 기준 클럭으로 동기신호를 맞추어 동작</li>
  <li>동기화를 위한 클럭라인이 필요하다.</li>
  <li>일반적으로 많이 사용하는 방식</li>
</ul>

<h3 id="바이트기반-전송byte-oriented-transmission">바이트기반 전송(Byte-Oriented Transmission)</h3>
<ul>
  <li>각 프레임을 바이트(문자)의 연속으로 간주하는 방식</li>
  <li>STX(Start of Text), ETX(End of Text), DLE(Data-Link Escape)로 프레임의 시작과 끝을 구분</li>
  <li>예) BISYNC, PPP, DDCMP 등</li>
</ul>

<h3 id="비트기반-전송bit-oriented-transmission">비트기반 전송(Bit-Oriented Transmission)</h3>
<ul>
  <li>일반적으로 많이 사용하는 방식</li>
  <li>각 프레임을 비트의 연속으로 간주하는 방식</li>
  <li>프레임의 시작과 끝을 알리기 위해 플래그(Flag)라고 하는 특수한 비트 패턴, “01111110”을 사용</li>
  <li>예) 인터넷에서의 이더넷(Ethernet)과 HDLC(High-level Data Link Control) 등<br /><br /></li>
</ul>

<h2 id="비트-스터핑bit-stuffing">비트 스터핑(Bit Stuffing)</h2>
<ul>
  <li>비트기반 전송에서 프레임의 시작과 끝이 아닌 데이터 필드에 프레임의 시작과 끝을 알리는 플래그가 포함될 수 있다. 그러면 전송이 아직 끝나지 않았는데 수신측에서는 전송이 끝난 것으로 간주하고 데이터 받기를 중단할 것이다.</li>
  <li>그래서 이걸 해결하기 위해 사용하는 기법이 비트 스터핑 기법이다.</li>
</ul>

<h3 id="비트-스터핑-방법">비트 스터핑 방법</h3>
<ul>
  <li>송신측 : 보낼 프레임의 데이터 필드에서 연속된 5개의 1을 발견하면 다섯 번째 1 뒤에 0을 추가함. 이렇게 하면 시작과 끝 부분 외에는 1이 연속해서 6개 위치하는 경우가 없어진다.</li>
  <li>수신측 : 연속되는 5개의 1이 수신되고 나서 0이 수신되면 이 0은 비트 스터핑 된 것이라 간주하고 제거함<br /><br /><br /></li>
</ul>

<h2 id="단방향-반이중-전이중">단방향, 반이중, 전이중</h2>
<h3 id="단방향simplex">단방향(Simplex)</h3>
<ul>
  <li>한 방향으로만 신호 전송이 가능한 형태</li>
  <li>예) 공항 모니터, 프린터, TV 방송</li>
</ul>

<h3 id="반이중half-duplex">반이중(Half duplex)</h3>
<ul>
  <li>양쪽 방향에서 보내고 받을 수 있지만 교대로 전송만 가능</li>
  <li>예) 무전기</li>
</ul>

<h3 id="전이중full-duplex">전이중(Full duplex)</h3>
<ul>
  <li>양쪽 호스트가 동시에 데이터전송 가능</li>
  <li>예) 인터넷<br /><br /><br /></li>
</ul>

<h1 id="교환-기술">교환 기술</h1>
<ul>
  <li>N개의 통신 장비를 각각 직접 연결하면 필요한 연결선의 갯수가 너무 많아진다.</li>
  <li>이것에 대한 해결방안으로 각각의 장비들은 통신망에 연결한 뒤 통신망을 이용해 서로 데이터를 주고 받는데 이걸 좀 더 효과적으로 운영하기 위해 교환 기술(Switching Technology)을 사용한다.</li>
</ul>

<h2 id="회선-교환circuit-switching">회선 교환(Circuit Switching)</h2>
<ul>
  <li>공중 전화 망에서 사용</li>
  <li>데이터 전송 과정 : 회선 설정 - 데이터 전송 - 회선 해제</li>
  <li>단점 : 회선을 설정하고 해제할 때까지 채널의 대역폭을 독점하기 때문에 다른 회선을 동시에 사용할 수 없다.</li>
  <li>장점 : 단점의 이유로 신뢰성 있는 데이터 전송이 가능하며 일정한 데이터 전송률로 데이터를 전송한다.</li>
  <li>회선 설정(call setup) 시간이 필요하며 링크 및 스위칭 장비가 성능에 영향을 미친다.<br /><br /><br /></li>
</ul>

<h1 id="오류-검출과-교정기법">오류 검출과 교정기법</h1>
<h2 id="해밍코드오류-교정-코드">해밍코드(오류 교정 코드)</h2>
<ul>
  <li>N 비트의 데이터에 k개의 패리티 비트를 더하여 (n+k)비트의 코드워드(Codeword)를 생성</li>
  <li>일종의 비트마스킹 기법으로 오류를 검출할 수 있다.</li>
  <li>N개의 비트를 사용해서 오류가 생긴 비트를 검출할 것이기 때문에 N 비트 데이터와 k개의 패리티 비트를 사용한다고 할 때 <code class="language-plaintext highlighter-rouge">2^k &gt;= n + k + 1</code> 라는 수식이 성립해야 한다.(1을 더해주는 이유는 오류가 생기지 않는 경우도 표현하기 위해서)</li>
  <li>수신측은 <code class="language-plaintext highlighter-rouge">XOR</code> 연산을 통해 syndrome을 계산해서 syndrome을 10진수로 바꾼 값이 오류발생 위치(syndrome의 모든 비트가 0이면 오류가 없음)<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=5959f58996c6bd25">데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Network" /><category term="CS" /><category term="Network" /><summary type="html"><![CDATA[전송 모드 병렬 전송(Parallel Transfer) 여러 전송라인을 통해 여러 비트들을 동시에 전송 두 장치들간의 거리가 짧은 경우에 일반적으로 사용 예) PC에서 프린터로 전송하는 것 예) 컴퓨터와 주변 장치들간의 연결 긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.]]></summary></entry></feed>