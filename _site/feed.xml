<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-17T15:12:44+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 10872. 팩토리얼</title><link href="http://localhost:4000/boj/boj10872-java/" rel="alternate" type="text/html" title="Java) BOJ 10872. 팩토리얼" /><published>2022-02-17T00:00:00+09:00</published><updated>2022-02-17T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10872-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10872-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10872">https://www.acmicpc.net/problem/10872</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 정수 N(0 ≤ N ≤ 12)이 주어진다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 N!을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>N팩토리얼이 1부터 N까지의 누적곱이기 때문에 누적합을 구하는 코드에서 곱하기로만 바꿨다.
단 구한 팩토리얼을 저장할 변수가 0부터 시작하면 무슨 수를 곱해도 0이 되어버리기 때문에 1부터 시작해야 하는 것만 주의하면 된다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 128 ms</li>
  <li>메모리 : 14220 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/da7ed92be7ff49728b3582171ca25fe8.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10872" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10872 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">컴퓨터 하드웨어) 제어 장치</title><link href="http://localhost:4000/computer%20science/CS-14/" rel="alternate" type="text/html" title="컴퓨터 하드웨어) 제어 장치" /><published>2022-02-17T00:00:00+09:00</published><updated>2022-02-17T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS-14</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS-14/"><![CDATA[<h1 id="-제어-장치란">👀 제어 장치란?</h1>
<ul>
  <li>프로그램에 의해 주어진 연산의 순서를 실행해 나가기 위하여 기억 장치, 연산 장치, 입,출력 장치에 신호를 보내고, 또 이들 장치로부터 신호를 받아 다음에 수행해야 할 조작을 결정하는 부분</li>
  <li>컴퓨터의 중추선이라 할 수 있다.</li>
  <li>컴퓨터의 자료 처리 속도를 <code class="language-plaintext highlighter-rouge">MIPS(Million Instructions Per Second)</code>로 나타내는데 <code class="language-plaintext highlighter-rouge">1MIPS</code>는 1초에 백만 개의 명령어가 처리될 수 있다는 것을 의미한다.<br /><br /><br /></li>
</ul>

<h1 id="제어-장치의-구성">제어 장치의 구성</h1>
<ul>
  <li>제어 장치(control unit)는 주기억 장치에 연결되어 있는 명령어를 순서대로 호출하고 해독하여 그 결과에 따라 연산 장치, 기억 장치, 입,출력 장치에 제어 신호를 보내 원하고자 하는 동작을 유도한다.<br /><br /></li>
</ul>

<p><img src="../../assets/images/controlUnit.jpg" alt="controlUnit" /></p>

<h2 id="1-프로그램-계수기pc--program-counter">1. 프로그램 계수기(PC : Program Counter)</h2>
<ul>
  <li>명령의 실행 순서를 정하기 위하여 다음에 실행될 명령이 들어 있는 번지를 기억해 두는 레지스터</li>
  <li>명령어 계수기(IC : Instruction Counter) 혹은 위치 계수기(LC : Location Counter)라고도 한다.<br /><br /></li>
</ul>

<h2 id="2-명령-레지스터ir--instruction-register">2. 명령 레지스터(IR : Instruction Register)</h2>
<ul>
  <li>프로그램 계수기(<code class="language-plaintext highlighter-rouge">PC</code>)가 지정한 번지에 기억되어 있는 명령을 꺼내어 이 명령을 해석하기 위하여 임시로 보관하여 두는 레지스터</li>
  <li>명령부와 번지부로 구성되어 있다.
    <ul>
      <li>명령부 : 실행 명령 코드(operation code)가 들어 있다.</li>
      <li>번지부 : 데이터가 기억되어 있는 번지(operand)가 들어 있다.</li>
    </ul>
  </li>
  <li>명령부의 명령 코드가 해독기에 옮겨져 해독되며 번지부의 번지가 번지 해독기에 이송되어 해독된다.<br /><br /></li>
</ul>

<h2 id="3-명령어-해독기instruction-decoder와-기계-사이클-부호기">3. 명령어 해독기(Instruction Decoder)와 기계 사이클 부호기</h2>
<ul>
  <li>명령어 해독기 : 명령 레지스터의 명령부에 있는 명령 코드를 해독하여 기계 사이클 부호기에 그 신호를 보내는 장치</li>
  <li>기계 사이클 부호기 : 명령어 해독기로부터 보내져 온 명령을 실행하는 데 필요한 신호를 만들어 시간 통제 및 제어 장치에 보낸다.<br /><br /></li>
</ul>

<h2 id="4-시간-통제-및-제어-장치timming-and-control-unit">4. 시간 통제 및 제어 장치(Timming and Control Unit)</h2>
<ul>
  <li>기계 사이클 부호기에서 수신된 신호를 기계 사이클의 클럭에 따라 동기시켜 필요한 최종 신호를 만들어 순서대로 각 장치들로 송출<br /><br /></li>
</ul>

<h2 id="5-범용-레지스터general-register">5. 범용 레지스터(General Register)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CPU</code> 내에서 자료를 처리하는 과정에 자료를 일시적으로 보관하는 장치<br /><br /></li>
</ul>

<h2 id="6-작업-레지스터working-register">6. 작업 레지스터(Working Register)</h2>
<ul>
  <li>산술 논리를 수행하는 레지스터로 처리 결과를 보관하는 장치<br /><br /></li>
</ul>

<h2 id="7-플래그-레지스터flag-register">7. 플래그 레지스터(Flag Register)</h2>
<ul>
  <li>상태 레지스터(Status register)라고도 하며 <code class="language-plaintext highlighter-rouge">CPU</code>의 연산 결과 상태를 저장</li>
  <li>처리 결과 0(zero), 부호(sign), 오버플로우(overflow), 자리올림(carry), 인터럽트(interrupt) 등의 발생 여부를 나타내는 특수 목적 레지스터<br /><br /><br /></li>
</ul>

<h1 id="제어-장치의-동작">제어 장치의 동작</h1>
<ol>
  <li><code class="language-plaintext highlighter-rouge">기억 장치</code>에 있는 명령을 꺼낸다(인출 사이클(fecth cycle))</li>
  <li><code class="language-plaintext highlighter-rouge">PC</code>(프로그램 계수기)에 초기 번지를 저장하면 주기억 장치의 명령이 그림의 <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code> 순서로 명령 레지스터(<code class="language-plaintext highlighter-rouge">IR</code>)에 옮겨온다.</li>
  <li>레지스터에는 1개의 명령 내용인 명령 코드와 번지부가 기억된다. 명령 해독기와 기계 사이클 부호기를 통해 해독된다.</li>
  <li>각 장치에 신호를 보내고, 시간 통제 및 제어 장치를 통해 외부 장치들에게 제어 신호를 송출한다.</li>
  <li>이 과정에서 <code class="language-plaintext highlighter-rouge">PC</code>의 주기억 장치의 번지는 자동으로 증가된다.<br /><br /></li>
</ol>

<h2 id="1-인출-사이클fetch-cycle">1. 인출 사이클(Fetch cycle)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">기억 장치</code>의 번지를 확인하여 명령을 읽어낼 때까지의 단계로 이 기간 동안에 명령이 <code class="language-plaintext highlighter-rouge">주기억 장치</code>에서 제어 장치 내의 <code class="language-plaintext highlighter-rouge">레지스터</code>로 옮겨진다.</li>
</ul>

<h3 id="-인출-사이클-진행-과정">🔸 인출 사이클 진행 과정</h3>
<ol>
  <li>현 <code class="language-plaintext highlighter-rouge">PC</code>(프로그램 계수기)의 내용을 <code class="language-plaintext highlighter-rouge">CPU</code> 내부 버스를 통하여 <code class="language-plaintext highlighter-rouge">MAR</code>(메모리 주소 레지스터)로 전송한다.</li>
  <li><code class="language-plaintext highlighter-rouge">MAR</code>의 값에 의해 주어진 메모리 주소의 내용(명령어)을 데이터 버스를 통하여 <code class="language-plaintext highlighter-rouge">MBR</code>(메모리 버퍼 레지스터)에 저장한다.</li>
  <li><code class="language-plaintext highlighter-rouge">PC</code>의 값이 증가한다.</li>
  <li><code class="language-plaintext highlighter-rouge">MBR</code>의 내용(명령어 코드)을 <code class="language-plaintext highlighter-rouge">IR</code>(명령 레지스터)로 이동한다.<br /><br /></li>
</ol>

<h2 id="2-실행-사이클execution-cycle">2. 실행 사이클(Execution cycle)</h2>
<ul>
  <li>읽어진 명령에 의해 필요한 신호를 만들어 결과를 얻을 때까지의 단계</li>
  <li><code class="language-plaintext highlighter-rouge">명령 레지스터</code>의 <code class="language-plaintext highlighter-rouge">명령 코드</code> 내용이 명령 해독기에 의해 <code class="language-plaintext highlighter-rouge">해독</code>되고, 해독된 내용은 부호기에 의해 각 장치로 신호를 보내게 된다.</li>
  <li>해독된 내용이 가산 명령이면 부호기의 신호에 의해 누산기(accumulator)의 내용이 소거되고, 명령 레지스터의 번지부가 주기억 장치의 번지 지정에서 산출되어 기억 레지스터로 옮긴 후 누산기와 가산기의 연산에 의해 계산된 결과는 누산기에 임시 저장된다.</li>
  <li>여기까지 끝나면 실행 사이클이 끝나고 다시 인출 사이클이 시작된다. 이러한 과정을 기계 사이클(machine cycle)이라 한다.<br /><br /></li>
</ul>

<h2 id="3-인터럽트interrupt">3. 인터럽트(Interrupt)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>의 플래그 레지스터는 인터럽트에 관한 정보를 포함한다.</li>
  <li>인터럽트가 <code class="language-plaintext highlighter-rouge">CPU</code>에 가해지면 현재 처리 프로그램을 일단 중지시키고, 인터럽트 프로그램을 수행시킨다.</li>
  <li>인터럽트는 <code class="language-plaintext highlighter-rouge">CPU</code>의 제어 버스에 속하며, 인터럽트용 전기 신호 단자에 의해 <code class="language-plaintext highlighter-rouge">CPU</code>가 인지하게 된다.</li>
  <li>어떤 처리 프로그램의 실행중에 제어 프로그램의 서비스를 요구하는 예기치 못한 일이 발생했을 때에 이걸 하드웨어로 포착해서 감시 프로그램(Supervisor)에게 제어권을 인도하기 위한 기능</li>
  <li>인터럽트가 발생하여 제어권이 제어 프로그램(Control program)에 주어지면 제어 프로그램이 중에 준비된 인터럽트 처리 루틴(Interrupt handling routine)이 실행된다. 이 루틴의 처리가 끝나면 시스템은 인터럽트가 발생하기 전 상태로 되돌아가서 먼저 실행되던 프로그램의 실행을 다시 시작한다.<br /><br /></li>
</ul>

<h3 id="-인터럽트-종류">🔸 인터럽트 종류</h3>
<h4 id="1-기계-체크-인터럽트machine-check-interrupt">1. 기계 체크 인터럽트(Machine check interrupt)</h4>
<ul>
  <li>어떤 프로그램 실행중에 장치 착오로 인하여 발생하는 인터럽트</li>
  <li>기계에 착오가 발생했을 경우에 인터럽트가 일어나 제어 프로그램으로 제어권이 넘어간다.</li>
  <li>제어 프로그램 내의 인터럽트 처리 루틴이 <code class="language-plaintext highlighter-rouge">CPU</code>의 제어권을 인도받아서 필요한 진단이나 착오 정정의 처리를 수행한 후 제어권을 다시 처리 프로그램에 되돌려 준다.<br /><br /></li>
</ul>

<h4 id="2-외부-인터럽트external-interrupt">2. 외부 인터럽트(External interrupt)</h4>
<ul>
  <li>오퍼레이터가 필요에 의해서 콘솔에 있는 인터럽트 키를 누를 때 발생하는 인터럽트</li>
  <li>오퍼레이터가 시스템에 어떤 요구나 응답을 할 때 필요하다.</li>
  <li>인터럽트 키를 누름으로써 인터럽트가 발생하여 오퍼레이터가 필요한 내용의 명령을 손으로 조작할 수 있다.<br /><br /></li>
</ul>

<h4 id="3-프로그램-인터럽트program-interrupt">3. 프로그램 인터럽트(Program interrupt)</h4>
<ul>
  <li>프로그램 실행중에 프로그램 상의 착오나 예외 상태가 발생했을 경우 일어나는 인터럽트<br /><br /></li>
</ul>

<h4 id="4-입출력-인터럽트io-interrupt">4. 입,출력 인터럽트(I/O interrupt)</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>는 입,출력 조작의 계시를 명령하는 것 뿐이지 실제로 입,출력 조작을 지시하는 것은 채널에서 이루어진다. 그래서 채널이 입,출력 조작을 함과 동시에 <code class="language-plaintext highlighter-rouge">CPU</code>는 다른 처리를 한다.</li>
  <li>입,출력 조작이 끝나거나 입,출력 착오가 발생되면 <code class="language-plaintext highlighter-rouge">CPU</code>의 서비스가 필요해지므로 채널이 인터럽트 신호를 발생시킨다.</li>
  <li>이 때 <code class="language-plaintext highlighter-rouge">CPU</code>는 제어 프로그램 중의 인터럽트 처리 루틴(I/O Interrupt handling routine)이 실행된다.<br /><br /></li>
</ul>

<h4 id="5-제어감시-프로그램-호출-인터럽트supervisor-call-interrupt">5. 제어(감시) 프로그램 호출 인터럽트(Supervisor call interrupt)</h4>
<ul>
  <li>시스템에 의하여 자동적으로 발생하는 인터럽트가 아닌 프로그램 내에서 특정한 서비스를 요구하는 명령으로 인터럽트를 일으키는 경우<br /><br /><br /></li>
</ul>

<h2 id="출처">출처</h2>
<ul>
  <li>컴퓨터 사이언스(김철 저)</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><category term="Computer Hardware" /><category term="Control Unit" /><summary type="html"><![CDATA[👀 제어 장치란? 프로그램에 의해 주어진 연산의 순서를 실행해 나가기 위하여 기억 장치, 연산 장치, 입,출력 장치에 신호를 보내고, 또 이들 장치로부터 신호를 받아 다음에 수행해야 할 조작을 결정하는 부분 컴퓨터의 중추선이라 할 수 있다. 컴퓨터의 자료 처리 속도를 MIPS(Million Instructions Per Second)로 나타내는데 1MIPS는 1초에 백만 개의 명령어가 처리될 수 있다는 것을 의미한다.]]></summary></entry><entry><title type="html">Mac) Java OpenJDK 버전 여러개 설치해 놓고 돌려가며 쓰기</title><link href="http://localhost:4000/java/set-java-version/" rel="alternate" type="text/html" title="Mac) Java OpenJDK 버전 여러개 설치해 놓고 돌려가며 쓰기" /><published>2022-02-15T00:00:00+09:00</published><updated>2022-02-15T00:00:00+09:00</updated><id>http://localhost:4000/java/set-java-version</id><content type="html" xml:base="http://localhost:4000/java/set-java-version/"><![CDATA[<p>👀 터미널에서 단어 하나만 입력하면 <code class="language-plaintext highlighter-rouge">OpenJDK 8</code> 버전과 <code class="language-plaintext highlighter-rouge">OpenJDK 11</code> 버전을 그 때 그 때 기본으로 세팅할 수 있다.</p>

<h1 id="homebrew로-openjdk-설치">Homebrew로 OpenJDK 설치</h1>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">ruby</span> <span class="o">-</span><span class="n">e</span> <span class="s">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Homebrew</code>가 설치되어 있지 않다면 위 명령어를 터미널에 입력해서 설치한다.</li>
  <li>처음엔 그림도 없고 <code class="language-plaintext highlighter-rouge">CLI</code> 환경이라 겁 먹었는데 적응되니까 세상에서 젤 편한 브루~ 😄
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">brew</span> <span class="n">install</span> <span class="o">--</span><span class="n">cask</span> <span class="n">adoptopenjdk</span>
</code></pre></div></div>
<ul>
  <li>브루용 터미널을 켠 다음에 위 명령어를 입력하면 현재 <code class="language-plaintext highlighter-rouge">OpenJDK</code>의 최신버전을 설치할 수 있다.</li>
  <li>현재 17, 18 버전까지 나와있는데 많이 사용하는 버전은 8과 11 버전인 거 같다.</li>
  <li>그래서 나도 8과 11 버전만 설치할 것이다.</li>
</ul>

<h2 id="버전별-명령어-리스트">버전별 명령어 리스트</h2>
<p><img src="../../assets/images/openjdkVersions.png" alt="openjdkVersions" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">brew</span> <span class="n">tap</span> <span class="nc">AdoptOpenJDK</span><span class="o">/</span><span class="n">openjdk</span>
<span class="n">brew</span> <span class="n">install</span> <span class="o">--</span><span class="n">cask</span> <span class="n">adoptopenjdk11</span>
</code></pre></div></div>
<ul>
  <li>현재 8버전은 깔려 있어서 11버전만 추가로 설치했다.</li>
  <li>위 목록에서 설치하고 싶은 버전을 <code class="language-plaintext highlighter-rouge">--cask</code> 뒤에 입력하면 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Homebrew</code>를 통해 설치하는 것은 정식 루트를 통하는 것은 아니고 커뮤니티에 배포되어 있는 것을 사용하는 것이라고 하는데 오라클 JDK가 유료화 된 이후로 다 이렇게 써서 문제 되는 것은 없다고 한다. 
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">🍺</span>  <span class="n">adoptopenjdk11</span> <span class="n">was</span> <span class="n">successfully</span> <span class="n">installed</span><span class="o">!</span>
</code></pre></div></div>
<ul>
  <li>정상적으로 설치가 되면 마지막에 성공적으로 설치되었다는 메세지를 볼 수 있다. 
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">java</span> <span class="o">-</span><span class="n">version</span>
<span class="n">openjdk</span> <span class="n">version</span> <span class="s">"1.8.0_302"</span>
<span class="nc">OpenJDK</span> <span class="nc">Runtime</span> <span class="nf">Environment</span> <span class="o">(</span><span class="nc">Temurin</span><span class="o">)(</span><span class="n">build</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_302</span><span class="o">-</span><span class="n">b08</span><span class="o">)</span>
<span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nf">VM</span> <span class="o">(</span><span class="nc">Temurin</span><span class="o">)(</span><span class="n">build</span> <span class="mf">25.302</span><span class="o">-</span><span class="n">b08</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>현재 사용중인 자바의 버전을 확인해보면 기존에 사용하던 것이 있어서 8버전이 나온다.
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="no">V</span>
<span class="nc">Matching</span> <span class="nc">Java</span> <span class="nc">Virtual</span> <span class="nf">Machines</span> <span class="o">(</span><span class="mi">3</span><span class="o">):</span>
    <span class="mf">11.0</span><span class="o">.</span><span class="mi">11</span> <span class="o">(</span><span class="n">x86_64</span><span class="o">)</span> <span class="s">"AdoptOpenJDK"</span> <span class="o">-</span> <span class="s">"AdoptOpenJDK 11"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">adoptopenjdk</span><span class="o">-</span><span class="mi">11</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_312</span> <span class="o">(</span><span class="n">arm64</span><span class="o">)</span> <span class="s">"Azul Systems, Inc."</span> <span class="o">-</span> <span class="s">"Zulu 8.58.0.13"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">zulu</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_302</span> <span class="o">(</span><span class="n">x86_64</span><span class="o">)</span> <span class="s">"Eclipse Temurin"</span> <span class="o">-</span> <span class="s">"Eclipse Temurin 8"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">temurin</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
</code></pre></div></div>
<ul>
  <li>설치된 모든 자바 버전을 보고 싶으면 <code class="language-plaintext highlighter-rouge">/usr/libexec/java_home -V</code> 명령어를 입력하면 된다.</li>
  <li>사용중이던 8버전 외에 11버전도 추가로 잘 설치된 것을 볼 수 있다. <br /><br /></li>
</ul>

<h1 id="그런데-실리콘-맥용이-아니라서-다시-설치">그런데… 실리콘 맥용이 아니라서 다시 설치</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">M1</code> 맥북을 사용중인데 설치하고 보니까 인텔맥 버전(x86_64)이라 왠지 최적화가 좀 덜 될 거 같아서 지우고 실리콘 맥용으로 다시 설치했다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">cd</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span>
<span class="nc">JavaVirtualMachines</span> <span class="o">%</span> <span class="n">ls</span>  
<span class="n">adoptopenjdk</span><span class="o">-</span><span class="mi">11</span><span class="o">.</span><span class="na">jdk</span>	<span class="n">temurin</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span>		<span class="n">zulu</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">JVM</code> 폴더로 이동해서 <code class="language-plaintext highlighter-rouge">ls</code> 명령어로 설치된 <code class="language-plaintext highlighter-rouge">JDK</code>들을 확인해 보면 목록들이 나온다.
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">sudo</span> <span class="n">rm</span> <span class="o">-</span><span class="n">rf</span> <span class="n">adoptopenjdk</span><span class="o">-</span><span class="mi">11</span><span class="o">.</span><span class="na">jdk</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">rm</code> 명령어를 사용해 삭제하고 싶은 버전을 입력하면 삭제할 수 있다.
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">ls</span>
<span class="n">temurin</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span>	<span class="n">zulu</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span>
</code></pre></div></div>
<ul>
  <li>다시 확인해보면 없다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="no">V</span>
<span class="nc">Matching</span> <span class="nc">Java</span> <span class="nc">Virtual</span> <span class="nf">Machines</span> <span class="o">(</span><span class="mi">2</span><span class="o">):</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_312</span> <span class="o">(</span><span class="n">arm64</span><span class="o">)</span> <span class="s">"Azul Systems, Inc."</span> <span class="o">-</span> <span class="s">"Zulu 8.58.0.13"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">zulu</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_302</span> <span class="o">(</span><span class="n">x86_64</span><span class="o">)</span> <span class="s">"Eclipse Temurin"</span> <span class="o">-</span> <span class="s">"Eclipse Temurin 8"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">temurin</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
</code></pre></div></div>
<p><br /><br /></p>

<h2 id="zulu-jdk-다운로드">Zulu JDK 다운로드</h2>
<ul>
  <li><a href="https://www.azul.com/downloads/?version=java-11-lts&amp;os=macos&amp;architecture=arm-64-bit&amp;package=jdk">Azul JDK</a></li>
  <li><code class="language-plaintext highlighter-rouge">Azul Systems</code> 홈페이지에 가면 <code class="language-plaintext highlighter-rouge">Arm Architecture</code>용으로 나온 <code class="language-plaintext highlighter-rouge">JDK</code>를 다운받을 수 있다.</li>
  <li>11버전을 선택해서 다운로드한다. (<code class="language-plaintext highlighter-rouge">.dmg</code> 파일이 편해서 사용)</li>
  <li>더블클릭 후 다음만 누르면 설치가 완료된다.</li>
</ul>

<h2 id="zulu-jdk-설치-확인">Zulu JDK 설치 확인</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="no">V</span>
<span class="nc">Matching</span> <span class="nc">Java</span> <span class="nc">Virtual</span> <span class="nf">Machines</span> <span class="o">(</span><span class="mi">3</span><span class="o">):</span>
    <span class="mf">11.0</span><span class="o">.</span><span class="mi">14</span> <span class="o">(</span><span class="n">arm64</span><span class="o">)</span> <span class="s">"Azul Systems, Inc."</span> <span class="o">-</span> <span class="s">"Zulu 11.54.23"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">zulu</span><span class="o">-</span><span class="mi">11</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_312</span> <span class="o">(</span><span class="n">arm64</span><span class="o">)</span> <span class="s">"Azul Systems, Inc."</span> <span class="o">-</span> <span class="s">"Zulu 8.58.0.13"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">zulu</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
    <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_302</span> <span class="o">(</span><span class="n">x86_64</span><span class="o">)</span> <span class="s">"Eclipse Temurin"</span> <span class="o">-</span> <span class="s">"Eclipse Temurin 8"</span> <span class="o">/</span><span class="nc">Library</span><span class="o">/</span><span class="nc">Java</span><span class="o">/</span><span class="nc">JavaVirtualMachines</span><span class="o">/</span><span class="n">temurin</span><span class="o">-</span><span class="mi">8</span><span class="o">.</span><span class="na">jdk</span><span class="o">/</span><span class="nc">Contents</span><span class="o">/</span><span class="nc">Home</span>
</code></pre></div></div>
<ul>
  <li>11 버전도 <code class="language-plaintext highlighter-rouge">arm64</code>로 잘 설치되었다.<br /><br /></li>
</ul>

<h1 id="단어-하나로-기본으로-사용할-openjdk-버전-바꾸기">단어 하나로 기본으로 사용할 OpenJDK 버전 바꾸기</h1>
<ul>
  <li>컴퓨터에 설치된 자바가 하나뿐이라면 그게 자동으로 기본값으로 설정이 되지만 나는 사정상 11로 완전 갈아타면 안 되고 8버전도 써야 하기 때문에 두 개를 바꿔가며 써야 하는데 매번 환경설정을 해주려면 참 귀찮을거 같아서 좀 미뤄왔었다.</li>
  <li>그런데 구글링 해 보니까 완전 편한 방법이 있었다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">export</span> <span class="no">JAVA_HOME</span><span class="o">=</span><span class="err">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.8</span><span class="o">)</span>
<span class="n">export</span> <span class="no">PATH</span><span class="o">=</span><span class="s">"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/sbin:$JAVA_HOME"</span>
<span class="n">alias</span> <span class="n">setJava8</span><span class="o">=</span><span class="err">'</span><span class="n">export</span> <span class="no">JAVA_HOME</span><span class="o">=</span><span class="err">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.8</span><span class="o">)</span><span class="err">'</span>
<span class="n">alias</span> <span class="n">setJava11</span><span class="o">=</span><span class="err">'</span><span class="n">export</span> <span class="no">JAVA_HOME</span><span class="o">=</span><span class="err">$</span><span class="o">(/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">java_home</span> <span class="o">-</span><span class="n">v</span> <span class="mi">11</span><span class="o">)</span><span class="err">'</span>
</code></pre></div></div>
<ul>
  <li>위 명령어를 한 줄씩 복붙해서 실행하면 자바 버전별로 <code class="language-plaintext highlighter-rouge">앨리어스</code>를 지정해 사용할 수 있다.
<br /><br /></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span> <span class="n">setJava11</span>
<span class="o">%</span> <span class="n">java</span> <span class="o">-</span><span class="n">version</span>
<span class="n">openjdk</span> <span class="n">version</span> <span class="s">"11.0.14"</span> <span class="mi">2022</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">18</span> <span class="no">LTS</span>
<span class="nc">OpenJDK</span> <span class="nc">Runtime</span> <span class="nc">Environment</span> <span class="nc">Zulu11</span><span class="o">.</span><span class="mi">54</span><span class="o">+</span><span class="mi">23</span><span class="o">-</span><span class="no">CA</span> <span class="o">(</span><span class="n">build</span> <span class="mf">11.0</span><span class="o">.</span><span class="mi">14</span><span class="o">+</span><span class="mi">9</span><span class="o">-</span><span class="no">LTS</span><span class="o">)</span>
<span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="no">VM</span> <span class="nc">Zulu11</span><span class="o">.</span><span class="mi">54</span><span class="o">+</span><span class="mi">23</span><span class="o">-</span><span class="no">CA</span> <span class="o">(</span><span class="n">build</span> <span class="mf">11.0</span><span class="o">.</span><span class="mi">14</span><span class="o">+</span><span class="mi">9</span><span class="o">-</span><span class="no">LTS</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>

<span class="o">%</span> <span class="n">setJava8</span>
<span class="o">%</span> <span class="n">java</span> <span class="o">-</span><span class="n">version</span>
<span class="n">openjdk</span> <span class="n">version</span> <span class="s">"1.8.0_312"</span>
<span class="nc">OpenJDK</span> <span class="nc">Runtime</span> <span class="nf">Environment</span> <span class="o">(</span><span class="nc">Zulu</span> <span class="mf">8.58</span><span class="o">.</span><span class="mf">0.13</span><span class="o">-</span><span class="no">CA</span><span class="o">-</span><span class="n">macos</span><span class="o">-</span><span class="n">aarch64</span><span class="o">)</span> <span class="o">(</span><span class="n">build</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0_312</span><span class="o">-</span><span class="n">b07</span><span class="o">)</span>
<span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nf">VM</span> <span class="o">(</span><span class="nc">Zulu</span> <span class="mf">8.58</span><span class="o">.</span><span class="mf">0.13</span><span class="o">-</span><span class="no">CA</span><span class="o">-</span><span class="n">macos</span><span class="o">-</span><span class="n">aarch64</span><span class="o">)</span> <span class="o">(</span><span class="n">build</span> <span class="mf">25.312</span><span class="o">-</span><span class="n">b07</span><span class="o">,</span> <span class="n">mixed</span> <span class="n">mode</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>이제 터미널에서 <code class="language-plaintext highlighter-rouge">setJava11</code>만 입력하면 11버전으로 바꿀 수 있다! 8로 돌아가는 것도 마찬가지
<br /><br /></li>
</ul>

<h2 id="출처">출처</h2>
<ul>
  <li><a href="https://yonguri.tistory.com/119">[Mac] OpenJDK 버전별로 여러개 설치하기 ( using Homebrew )</a></li>
  <li><a href="https://velog.io/@jsoh/%EC%98%A4%EB%9D%BC%ED%81%B4-JDK%EB%A5%BC-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B3%A0-OpenJDK-11-%EC%84%A4%EC%B9%98">MacOS에서 오라클 JDK를 삭제하고 OpenJDK 11 설치</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Java" /><category term="Java" /><category term="OpenJDK" /><category term="Homebrew" /><summary type="html"><![CDATA[👀 터미널에서 단어 하나만 입력하면 OpenJDK 8 버전과 OpenJDK 11 버전을 그 때 그 때 기본으로 세팅할 수 있다.]]></summary></entry><entry><title type="html">Java) BOJ 1002. 터렛</title><link href="http://localhost:4000/boj/boj1002-java/" rel="alternate" type="text/html" title="Java) BOJ 1002. 터렛" /><published>2022-02-15T00:00:00+09:00</published><updated>2022-02-15T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1002-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1002-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1002">https://www.acmicpc.net/problem/1002</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.</li>
  <li>이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다.</li>
  <li>조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.</li>
  <li>조규현의 좌표 (x1, y1)와 백승환의 좌표 (x2, y2)가 주어지고, 조규현이 계산한 류재명과의 거리 r1과 백승환이 계산한 류재명과의 거리 r2가 주어졌을 때,</li>
  <li>류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.</li>
  <li>한 줄에 x1, y1, r1, x2, y2, r2가 주어진다. x1, y1, x2, y2는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이고,</li>
  <li>r1, r2는 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는 -1을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 무슨 문제인가 싶어서 질문게시판을 보니까 두 원 사이의 접점을 구하는 문제였다.</li>
  <li>두 원의 관계는 내접하는 경우, 외접하는 경우, 만나지 않는 경우, 겹쳐지는 경우가 있는데</li>
  <li>내접과 외접하는 경우에는 접점이 1개이다. (원 그려보면 됨)</li>
  <li>만나지 않는 경우에는 접점이 0이다. 이 땐 서로 멀리 떨어져 있거나 큰 원 안에 작은 원이 있는데 두 원 사이의 접점이 없는 경우이다.</li>
  <li>겹쳐지는 경우에는 완전히 똑같이 겹쳐지느냐 조금 겹쳐지느냐에 따라 달라지는데</li>
  <li>원점의 위치가 똑같고 반지름도 똑같으면 완전히 겹쳐진다. 이럴 때엔 원의 테두리 어디에든 존재할 수 있으니 무한대이다.</li>
  <li>
    <p>조금 겹쳐지는 경우엔 접점이 항상 2개이다. (이것도 원 그려보면 됨)<br /><br /></p>
  </li>
  <li>원이 서로 내접하는지 아닌지 보려면 두 원점 사이의 거리를 구해야 하는데 이것은 피타고라스의 정리로 구했다.</li>
  <li>그런데 피타고라스의 정리를 사용하면 거리는 원래 거리의 제곱값이 나오기 때문에 이것의 제곱근을 구하기 위해 sqrt 함수를 사용했는데 여기서 오차가 생겨서 틀렸다.</li>
  <li>4의 제곱근을 구하는 경우라면 문제 없지만 5의 제곱근을 구하는 경우에는 정수로 나눠 떨어지지 않으니까… 여기서 오차가 생긴다.</li>
  <li>
    <p>그래서 두 원점 사이의 거리는 제곱한 상태로 사용해야 한다.<br /><br /></p>
  </li>
  <li>그래서 위의 케이스들을 잘 나눠서 분기처리를 해주면 되는데 처음에는 내접하는 경우와 큰 원 안에 작은 원이 있는데 접점이 없는 경우를 생각하지 못해서 틀렸다.</li>
  <li>처음에는 두 원점 사이의 거리와 두 반지름의 합만을 이용해서 연산을 했기 때문에 내접하거나 큰 원 안에 작은 원이 있는제 접점이 없는 경우를 처리할 수 없었다.</li>
  <li>(다 귀찮아서 원을 안 그려봐서 생긴 일…)</li>
  <li>그래서 또 질문게시판을 참고해서 원을 그려보니까 두 반지름의 차도 이용을 해야 완벽하게 답을 구할 수 있다는 것을 알게 되었다.</li>
  <li>두 원점 사이의 거리와 두 반지름의 차가 같으면 내접하고 (거리와 합이 같으면 외접)</li>
  <li>두 원점 사이의 거리가 두 반지름의 차보다 작으면 큰 원 안의 작은 원이 접점이 없는 경우였다. (합보다 작으면 서로 겹침)</li>
  <li>
    <p>=&gt; 이거 해결하고 통과했다.<br /><br /></p>
  </li>
  <li>그래서 최종적인 분기처리는
    <ol>
      <li>두 원의 원점이 같고 반지름도 같으면 -1</li>
      <li>원점이 같지만 반지름이 다르면 -1</li>
      <li>거리의 제곱이 반지름 합의 제곱과 같거나 반지름 차의 제곱과 같으면 1</li>
      <li>거리의 제곱이 반지름 합의 제곱보다 크거나 반지름 차의 제곱보다 작으면 0</li>
      <li>나머지 경우는 2<br /><br /></li>
    </ol>
  </li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 136 ms</li>
  <li>메모리 : 14292 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8d5e174a8b0e3b6d4b77580e1424b9c7.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1002" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1002 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 1085. 직사각형에서 탈출</title><link href="http://localhost:4000/boj/boj9020-java/" rel="alternate" type="text/html" title="Java) BOJ 1085. 직사각형에서 탈출" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj9020-java</id><content type="html" xml:base="http://localhost:4000/boj/boj9020-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1085">https://www.acmicpc.net/problem/1085</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다.</li>
  <li>직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 x, y, w, h가 주어진다.</li>
  <li>1 ≤ w, h ≤ 1,000</li>
  <li>1 ≤ x ≤ w-1</li>
  <li>1 ≤ y ≤ h-1</li>
  <li>x, y, w, h는 정수<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 문제의 정답을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>예제를 보니까 (x, y)에서 가로와 세로 직선 방향으로 직사각형의 변으로 가면 되는 것이라</li>
  <li>x는 x와 w - x 값 중 더 작은 값을, y는 y와 h - y 중 더 작은 값을 찾은 다음에 저 둘 중 더 작은 값을 최종 출력하면 정답인 거 같아서 그대로 썼는데 통과되었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 140 ms</li>
  <li>메모리 : 14216 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/842a7990b2c0aeee814beb998cd21d67.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1085" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1085 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 3053. 택시 기하학</title><link href="http://localhost:4000/boj/boj3053-java/" rel="alternate" type="text/html" title="Java) BOJ 3053. 택시 기하학" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj3053-java</id><content type="html" xml:base="http://localhost:4000/boj/boj3053-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/3053">https://www.acmicpc.net/problem/3053</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>19세기 독일 수학자 헤르만 민코프스키는 비유클리드 기하학 중 택시 기하학을 고안했다.</li>
  <li>택시 기하학에서 두 점 T1(x1,y1), T2(x2,y2) 사이의 거리는 다음과 같이 구할 수 있다.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>D(T1,T2) =</td>
          <td>x1-x2</td>
          <td>+</td>
          <td>y1-y2</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>두 점 사이의 거리를 제외한 나머지 정의는 유클리드 기하학에서의 정의와 같다.</li>
  <li>따라서 택시 기하학에서 원의 정의는 유클리드 기하학에서 원의 정의와 같다.</li>
  <li>원: 평면 상의 어떤 점에서 거리가 일정한 점들의 집합</li>
  <li>반지름 R이 주어졌을 때, 유클리드 기하학에서 원의 넓이와, 택시 기하학에서 원의 넓이를 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 반지름 R이 주어진다. R은 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를, 둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다. 정답과의 오차는 0.0001까지 허용한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>유클리드 기하학이랑 택시 기하학이 처음 보는 단어여서 이해하는데 시간이 좀 걸렸는데</li>
  <li>유클리드 기하학은 학교 다닐 때 배웠던 것처럼 <code class="language-plaintext highlighter-rouge">반지름 r의 제곱 * 파이(3.14....)</code>였고</li>
  <li>택시 기하학은 <code class="language-plaintext highlighter-rouge">반지름 r의 제곱 * 2</code> 였다.</li>
  <li>저렇게 구현해서 통과했는데 파이는 무한대로 이어지는 값이라서 <code class="language-plaintext highlighter-rouge">Math</code>에 있는 <code class="language-plaintext highlighter-rouge">PI</code>를 썼다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 132 ms</li>
  <li>메모리 : 14556 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/13217f334d41da7de8cc2eef964c6af6.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No3053" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/3053 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 3009. 네 번째 점</title><link href="http://localhost:4000/boj/boj3009-java/" rel="alternate" type="text/html" title="Java) BOJ 3009. 네 번째 점" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj3009-java</id><content type="html" xml:base="http://localhost:4000/boj/boj3009-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/3009">https://www.acmicpc.net/problem/3009</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>직사각형의 네 번째 점의 좌표를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>x와 y의 값이 서로 다른 점끼리 더한 값이 같아야 하기 때문에</li>
  <li>입력 받으면서 이전 x와 현재 x의 값이 같지 않으면 두 수를 더해주고 아니라면 수를 보관해 뒀다가 이전 x와 현재 x가 같지 않은 두 수의 합에서 빼 주었다.</li>
  <li>(x, y 각각 적용)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 148 ms</li>
  <li>메모리 : 16056 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/afe7a25ef643fea5a5cb6861ef93fcb8.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No3009" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/3009 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 4153. 직각삼각형</title><link href="http://localhost:4000/boj/boj4153-java/" rel="alternate" type="text/html" title="Java) BOJ 4153. 직각삼각형" /><published>2022-02-14T00:00:00+09:00</published><updated>2022-02-14T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj4153-java</id><content type="html" xml:base="http://localhost:4000/boj/boj4153-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/4153">https://www.acmicpc.net/problem/4153</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>과거 이집트인들은 각 변들의 길이가 3, 4, 5인 삼각형이 직각 삼각형인것을 알아냈다. 주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>입력은 여러개의 테스트케이스로 주어지며 마지막줄에는 0 0 0이 입력된다. 각 테스트케이스는 모두 30,000보다 작은 양의 정수로 주어지며, 각 입력은 변의 길이를 의미한다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 입력에 대해 직각 삼각형이 맞다면 “right”, 아니라면 “wrong”을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>피타고라스의 정리로 풀었는데 예제에는 입력이 오름차순으로만 주어져 있어서 처음엔 (a의 제곱 + b의 제곱 = c의 제곱) 수식을 썼는데</li>
  <li>중간에 입력이 오름차순으로 들어오지 않는 경우가 있는지 틀렸다.</li>
  <li>문제에 오름차순으로 입력이 들어온다는 말이 없어서 예상했긴 하지만… 처음부터 그냥 예외처리 해서 쓸 걸 그랬다.</li>
  <li>세 수 중 최대값과 나머지 두 수를 찾아서 피타고라스의 정리 수식을 적용해 주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 124 ms</li>
  <li>메모리 : 14012 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/196d69b177d3d418eaaa0638d14ae211.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No4153" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/4153 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 4948. 베르트랑 공준</title><link href="http://localhost:4000/boj/boj4948-java/" rel="alternate" type="text/html" title="Java) BOJ 4948. 베르트랑 공준" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj4948-java</id><content type="html" xml:base="http://localhost:4000/boj/boj4948-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/4948">https://www.acmicpc.net/problem/4948</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.</li>
  <li>이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.</li>
  <li>예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)</li>
  <li>자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.</li>
  <li>입력의 마지막에는 0이 주어진다. 1 ≤ n ≤ 123,456<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>n초과 2n이하의 수들을 소수를 판별하는 연산을 해서 소수면 카운트해서 2n까지 판별이 끝나면 총 개수를 출력했다.</li>
  <li>하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.</li>
  <li>i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.</li>
  <li>예를 들어 i=16라면</li>
  <li>1*16</li>
  <li>2*8</li>
  <li>4*4</li>
  <li>8*2</li>
  <li>16*1</li>
  <li>위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.</li>
  <li>
    <p>그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.<br /><br /></p>
  </li>
  <li><a href="https://notepad96.tistory.com/entry/C-%EC%86%8C%EC%88%98-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0">소수 구하기</a></li>
  <li>예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 696 ms</li>
  <li>메모리 : 14660 KB</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/aefd8a5c816d3e500f28493fdae88fbe.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No4948" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/4948 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 1978. 소수 찾기</title><link href="http://localhost:4000/boj/boj1978-java/" rel="alternate" type="text/html" title="Java) BOJ 1978. 소수 찾기" /><published>2022-02-13T00:00:00+09:00</published><updated>2022-02-13T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1978-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1978-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1978">https://www.acmicpc.net/problem/1978</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.  <br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>주어진 수들 중 소수의 개수를 출력한다.  <br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>소수 구하기는 프로그래밍을 처음 배울 때 풀어봤던 문제이기도 하고 예전에 몇 번 풀어봐서 풀이를 떠올리는 것은 어렵지 않았다.</li>
  <li>하지만 정직하게 2부터 i까지의 수의 나머지를 구하면서 소수를 판별하면 시간이 오래 걸리기 때문에 i의 제곱근 만큼만 반복하는 알고리즘을 썼다.</li>
  <li>i의 제곱근만큼만 반복해도 소수인지 판별이 되는 이유는 제곱근을 넘어가는 수 부터는 앞전에 구했던 곱해서 i가 되는 수들이 순서만 바뀌어서 똑같이 나오기 때문이다.</li>
  <li>예를 들어 i=16라면</li>
  <li>1*16</li>
  <li>2*8</li>
  <li>4*4</li>
  <li>8*2</li>
  <li>16*1</li>
  <li>위와 같이 16의 제곱근인 4를 기점으로 앞전에 나왔던 수들이 순서만 바뀌어서 나온다.</li>
  <li>
    <p>그래서 제곱근을 초과하는 수에 대해 소수를 판별하는 연산을 하는 것은 생략해도 결과에 영향이 없다.<br /><br /></p>
  </li>
  <li><a href="https://notepad96.tistory.com/entry/C-%EC%86%8C%EC%88%98-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0">C++ 소수 판별하기</a></li>
  <li>예전에 참고했던 글인데 언어 상관없이 개념적으로 참고하기 좋은 글이다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 132 ms</li>
  <li>메모리 : 14152 KB</li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/afc35a36d6fd638ec39bc1c5be251d8f.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1978" /><category term="Math" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1978 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry></feed>