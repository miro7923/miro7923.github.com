<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-26T02:57:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 1436. 영화감독 숌</title><link href="http://localhost:4000/boj/boj1436-java/" rel="alternate" type="text/html" title="Java) BOJ 1436. 영화감독 숌" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1436-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1436-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1436">https://www.acmicpc.net/problem/1436</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.</li>
  <li>조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고,</li>
  <li>
    <p>피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.</p>
  </li>
  <li>
    <p>하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.</p>
  </li>
  <li>
    <p>종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, …. 과 같다.</p>
  </li>
  <li>따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.</li>
  <li>
    <p>일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.</p>
  </li>
  <li>숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>브루트포스로 666부터 하나씩 증가시켜가면서 N번째 수를 구하려 했으나 처음에 생각을 잘못 하는 바람에… 틀려서 구글링 참고해서 풀었다.</li>
  <li>현재 수에 666이 포함되어 있으면 cnt를 증가시키고 cnt가 N과 같다면 현재 수를 리턴하고 그렇지 않다면 현재 수를 증가시키면서 또 666이 포함되어 있는지 확인한다.</li>
  <li>이 때 수를 문자열로 바꿔서 666이 연속되어 있는지 확인해도 되서 처음엔 그렇게 확인하는 함수를 구현했는데 구글링 하니까 자바에는 contains 함수가 있어서 편하게 그걸 썼다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 320 ms</li>
  <li>메모리 : 86524 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/cd9086d9b051383331645a51c0164abb.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1436" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1436 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 10989. 수 정렬하기3</title><link href="http://localhost:4000/boj/boj10989-java/" rel="alternate" type="text/html" title="Java) BOJ 10989. 수 정렬하기3" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10989-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10989-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10989">https://www.acmicpc.net/problem/10989</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 3 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>자바는 제한시간 3초에 메모리 제한은 512라 컬렉션을 쓸 수 없었다.(처음에 컬렉션 sort 써 봤는데 메모리 초과됨 ㅠ)</li>
  <li>int 배열 메모리 계산해 보니까 합병정렬을 할 수 있을 정도가 되어서 합병정렬을 구현했다.</li>
  <li>N의 최대값 10,000,000 * 4byte(int) = 40,000,000byte = 39,062kb = 약 38mb</li>
  <li>합병정렬은 정렬할 배열과 같은 크기의 배열이 하나 더 필요하기 때문에 38 * 2 = 약 76mb</li>
  <li>그래서 자바에서 기본적으로 잡아먹는 메모리를 더해도 통과할 수 있을거 같아서 합병정렬로 풀었는데 시간이 좀 아슬아슬했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 2948 ms</li>
  <li>메모리 : 383572 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/f9f2c1a27acf0a5bba1e0a65de41e81a.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10989" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10989 제한 시간 제한 : 3 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 2751. 수 정렬하기2</title><link href="http://localhost:4000/boj/boj2751-java/" rel="alternate" type="text/html" title="Java) BOJ 2751. 수 정렬하기2" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2751-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2751-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2751">https://www.acmicpc.net/problem/2751</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>제한시간 2초에 N 최대값이 백만이라 n log n 정렬 알고리즘을 써야 했는데 합병정렬을 쓰면 좋겠지만 구현하기 귀찮기도 하고… 자바에 구현되어 있는 sort 함수 사용법도 익힐겸 저걸 썼다.</li>
  <li>처음에는 Arrays.sort를 썼는데 1700ms 가 나와서 시간복잡도를 알아보니까 평균 n log n이지만 최악의 경우에는 n^2이었다.</li>
  <li>그래서 최악의 경우에도 n log n을 보장한다는 Collections.sort를 써 봤는데 1600ms 정도가 나와서 크게 시간 차이가 나지는 않았다.</li>
  <li>합병정렬 기억을 되살릴 겸 한 번 구현해 보는 것이 좋을 거 같다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 1636 ms</li>
  <li>메모리 : 171216 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/944a523911f3218c3088e59d5a8d6048.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2751" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2751 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 2750. 수 정렬하기</title><link href="http://localhost:4000/boj/boj2750-java/" rel="alternate" type="text/html" title="Java) BOJ 2750. 수 정렬하기" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2750-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2750-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2750">https://www.acmicpc.net/problem/2750</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>제한시간 1초에 N 최대값이 1,000이라 N^2 정렬 알고리즘으로 풀었다.(삽입정렬 사용)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 188 ms</li>
  <li>메모리 : 16936 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8845c43c6d3be9195cad397c8c3e2984.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2750" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2750 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">OS) Process Management</title><link href="http://localhost:4000/operating%20system/OS-04-Process-Management/" rel="alternate" type="text/html" title="OS) Process Management" /><published>2022-02-25T00:00:00+09:00</published><updated>2022-02-25T00:00:00+09:00</updated><id>http://localhost:4000/operating%20system/OS-04-Process-Management</id><content type="html" xml:base="http://localhost:4000/operating%20system/OS-04-Process-Management/"><![CDATA[<h1 id="-프로세스-생성-process-creation">👀 프로세스 생성 (Process Creation)</h1>
<ul>
  <li>부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다.</li>
  <li>복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다.</li>
  <li>프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다.</li>
  <li>프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.</li>
</ul>

<h2 id="자원의-공유">자원의 공유</h2>
<ul>
  <li>부모와 자식이 모든 자원을 공유하는 모델</li>
  <li>일부를 공유하는 모델</li>
  <li>전혀 공유하지 않는 모델 (일반적)</li>
</ul>

<h2 id="수행-execution">수행 (Execution)</h2>
<ul>
  <li>부모와 자식은 공존하며 수행되는 모델</li>
  <li>자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델</li>
</ul>

<h2 id="주소-공간-address-space">주소 공간 (Address space)</h2>
<ul>
  <li>자식은 부모의 공간을 복사함 (binary and OS data)</li>
  <li>자식은 그 공간에 새로운 프로그램을 올린다.(덮어씌움)</li>
</ul>

<h3 id="유닉스의-예">유닉스의 예</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">fork()</code> 시스템 콜이 새로운 프로세스를 생성
    <ul>
      <li>부모를 그대로 복사 후 주소 공간 할당</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fork</code> 다음에 이어지는 <code class="language-plaintext highlighter-rouge">exec()</code> 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 (덮어씌우는 단계)</li>
  <li><code class="language-plaintext highlighter-rouge">fork</code>와 <code class="language-plaintext highlighter-rouge">exec</code>은 독립적으로 이루어지기 때문에 둘 중 하나만 실행될 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스-종료-process-termination">프로세스 종료 (Process Termination)</h1>
<ul>
  <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.</li>
  <li>그래서 단계적인 종료를 통해 모든 자식 프로세스가 먼저 종료된 후 부모가 종료되어야 한다.</li>
</ul>

<h2 id="system-call을-통해-자발적으로-종료되는-경우">System call을 통해 자발적으로 종료되는 경우</h2>
<ul>
  <li>프로세스가 마지막 명령을 수행한 후 이를 운영체제에게 알려준다.(<code class="language-plaintext highlighter-rouge">exit</code>)</li>
  <li>자식이 부모에게 output data를 보냄 (via <code class="language-plaintext highlighter-rouge">wait</code>)</li>
  <li>프로세스의 각종 자원들이 운영체제에게 반납됨</li>
</ul>

<h2 id="비자발적으로-종료되는-경우">비자발적으로 종료되는 경우</h2>
<ul>
  <li>부모 프로세스가 자식 프로세스의 수행을 강제로 종료시킨다.(<code class="language-plaintext highlighter-rouge">abort</code>)</li>
  <li>자식이 할당 자원의 한계치를 넘어선 경우</li>
  <li>자식에게 할당된 태스크가 더 이상 필요하지 않은 경우</li>
  <li>부모가 종료(exit)하는 경우<br /><br /><br /></li>
</ul>

<h1 id="fork-시스템-콜">fork() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span> <span class="c1">// 부모와 자식을 구분하기 위한 값</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// 새로운 자식 프로세스가 생성되면 여기 다음 줄부터 실행한다.(부모의 문맥을 복사하기 때문)</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a child</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a child!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a parent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>자식 프로세스를 생성하기 위한 시스템 콜로 부모와 자식을 구분하기 위해 부모의 <code class="language-plaintext highlighter-rouge">pid</code>는 0보다 큰 값을 가지고 자식의 <code class="language-plaintext highlighter-rouge">pid</code>는 0을 가진다.<br /><br /><br /></li>
</ul>

<h1 id="exec-시스템-콜">exec() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a child</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a child! Now I'll run date </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a parent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>어떤 프로그램을 새로운 프로세스로 바꿔주기 때문에 <code class="language-plaintext highlighter-rouge">execlp()</code>가 호출되는 순간 이후의 코드들은 실행되지 않는다.<br /><br /><br /></li>
</ul>

<h1 id="wait-시스템-콜">wait() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">childPID</span><span class="p">;</span>
    <span class="n">S1</span><span class="p">;</span>
    
    <span class="n">childPID</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">childPID</span><span class="p">)</span>
        <span class="c1">// child 프로세스 코드 실행</span>
    <span class="k">else</span> 
        <span class="n">wait</span><span class="p">();</span>
        
    <span class="n">S2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>프로세스 A가 <code class="language-plaintext highlighter-rouge">wait()</code> 시스템 콜을 호출하면 커널은 <code class="language-plaintext highlighter-rouge">child</code>가 종료될 때까지 프로세스 A를 <code class="language-plaintext highlighter-rouge">sleep</code>시킨다.(block 상태)</li>
  <li>자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다.(ready 상태)<br /><br /><br /></li>
</ul>

<h1 id="exit-시스템-콜">exit() 시스템 콜</h1>
<h2 id="프로세스의-자발적-종료">프로세스의 자발적 종료</h2>
<ul>
  <li>마지막 statement 수행 후 <code class="language-plaintext highlighter-rouge">exit()</code> 시스템 콜을 통해 종료</li>
  <li>프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌</li>
</ul>

<h2 id="프로세스의-비자발적-종료">프로세스의 비자발적 종료</h2>
<ul>
  <li>부모 프로세스가 자식 프로세스를 강제 종료시킴
    <ul>
      <li>자식 프로세스가 한계치를 넘어서는 자원 요청시</li>
      <li>자식에게 할당된 태스크가 더 이상 필요하지 않을 때</li>
    </ul>
  </li>
  <li>키보드로 <code class="language-plaintext highlighter-rouge">kill</code>, <code class="language-plaintext highlighter-rouge">break</code>등을 친 경우</li>
  <li>부모가 종료하는 경우 부모 프로세스가 종료되기 전 자식 프로세스들이 먼저 종료된다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스-간-협력">프로세스 간 협력</h1>
<h2 id="독립적-프로세스-independent-process">독립적 프로세스 (Independent process)</h2>
<ul>
  <li>프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.</li>
</ul>

<h2 id="협력-프로세스-cooperating-process">협력 프로세스 (Cooperating process)</h2>
<ul>
  <li>프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.</li>
</ul>

<h2 id="프로세스-간-협력-메커니즘-ipc-interprocess-communication">프로세스 간 협력 메커니즘 (<code class="language-plaintext highlighter-rouge">IPC</code>: Interprocess Communication)</h2>
<h3 id="-메시지를-전달하는-방법">🔸 메시지를 전달하는 방법</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">message passing</code> : 커널을 통해 메시지 전달</li>
</ul>

<h4 id="-주소-공간을-공유하는-방법">🔸 주소 공간을 공유하는 방법</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">shared memory</code> : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음</li>
  <li>물리적 메모리에 매핑할 때 일부 주소공간을 공유하도록 매핑한다.(사전에 시스템 콜을 통해 운영체제에게 보고되어야 한다)</li>
</ul>

<h4 id="-thread">🔸 thread</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">thread</code>는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드들 간에는 주소 공간을 공유하기 때문에 협력이 가능하다. <br /><br /><br /></li>
</ul>

<h1 id="message-passing">Message Passing</h1>
<ul>
  <li>사용자 프로그램끼리는 메시지를 주고받는 것이 불가능하기 때문에 운영체제 커널을 통해서 메시지를 주고받는다.</li>
</ul>

<h2 id="message-system">Message system</h2>
<ul>
  <li>프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템</li>
</ul>

<h2 id="direct-communication">Direct Communication</h2>
<ul>
  <li>통신하려는 프로세스의 이름을 명시적으로 표시해서 메시지를 주고받는 것</li>
</ul>

<h2 id="indirect-communication">Indirect Communication</h2>
<ul>
  <li>mailbox(또는 port)를 통해 메시지를 간접 전달하는 방식<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Operating System" /><category term="CS" /><category term="OS" /><category term="Process" /><summary type="html"><![CDATA[👀 프로세스 생성 (Process Creation) 부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다. 복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다. 프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다. 프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.]]></summary></entry><entry><title type="html">Java) BOJ 1018. 체스판 다시 칠하기</title><link href="http://localhost:4000/boj/boj1018-java/" rel="alternate" type="text/html" title="Java) BOJ 1018. 체스판 다시 칠하기" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1018-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1018-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1018">https://www.acmicpc.net/problem/1018</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다.</li>
  <li>
    <p>지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.</p>
  </li>
  <li>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다.</li>
  <li>
    <p>따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.</p>
  </li>
  <li>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다.</li>
  <li>당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 좀 어렵게 생각해서 체스판을 앞에서부터도 확인하고 뒤에서부터도 확인하고 첫번째줄부터, 맨 아랫줄부터 거꾸로 올라가면서 확인하기 등 불필요한 탐색을 하는 코드를 작성했다.</li>
  <li>
    <p>그러다 답이 안 나와서 구글링 참고함</p>
  </li>
  <li>
    <p><a href="https://st-lab.tistory.com/101">https://st-lab.tistory.com/101</a></p>
  </li>
  <li>8<em>8 체스판을 순회하면서 현재 위치부터 +8칸까지가 체스판 색깔을 만족하는지 검사하는 함수 search()를 작성한 후
메인함수에서 입력 크기만큼 8</em>8씩 이동하면서 search()를 수행하도록 반복문을 작성한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 132 ms</li>
  <li>메모리 : 14312 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/76e4ade331283b450828b10a5fa4c69b.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1018" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1018 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 7568. 덩치</title><link href="http://localhost:4000/boj/boj7568-java/" rel="alternate" type="text/html" title="Java) BOJ 7568. 덩치" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj7568-java</id><content type="html" xml:base="http://localhost:4000/boj/boj7568-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/7568">https://www.acmicpc.net/problem/7568</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다.</li>
  <li>두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 “더 크다”고 말한다.</li>
  <li>예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다.</li>
  <li>
    <p>예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, “덩치”로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.</p>
  </li>
  <li>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.</li>
  <li>이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.</li>
</ul>

<p>이름	(몸무게, 키)	덩치 등수<br />
A	(55, 185)	2<br />
B	(58, 183)	2<br />
C	(88, 186)	1<br />
D	(60, 175)	2<br />
E	(46, 155)	5<br /></p>
<ul>
  <li>위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다.</li>
  <li>그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.</li>
  <li>2 ≤ N ≤ 50</li>
  <li>10 ≤ x, y ≤ 200<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음에 너무 어렵게 생각해서 덩치 순서대로 배열을 정렬한 다음 정렬한 배열을 다시 순회하면서 정렬된 순서대로 등수를 매기는 방법을 썼는데 틀렸다.</li>
  <li>
    <p>그 후 질문게시판 반례를 찾아보니까 어렵게 생각할 문제가 아니라 내 앞에 있는 사람이 몇 명인지 세는 문제여서 그렇게 수정하니까 통과되었다.<br /><br /></p>
  </li>
  <li>통과 후 배열 순회 횟수 추가 유무에 따라 실행속도가 궁금해져서</li>
  <li>등수를 배열에 저장한 다음 마지막에 배열을 순회하면서 출력하는 방식 - 14268KB	124ms</li>
  <li>등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 BufferedWriter로 출력하는 방식 - 14416KB 	132ms</li>
  <li>등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 StringBuilder에 저장한 후 출력하는 방식으로 풀어 봤는데 - 15904KB	 144ms</li>
  <li>첫번째가 메모리를 가장 적게 쓰고 속도도 가장 빨랐다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 124 ms</li>
  <li>메모리 : 14268 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/709f749418093dd0e36f58f3c87f37e3.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No7568" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/7568 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">DB) 데이터베이스 관리 시스템</title><link href="http://localhost:4000/database/db-02-management-system/" rel="alternate" type="text/html" title="DB) 데이터베이스 관리 시스템" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/db-02-management-system</id><content type="html" xml:base="http://localhost:4000/database/db-02-management-system/"><![CDATA[<h1 id="데이터베이스-관리-시스템의-등장-배경">데이터베이스 관리 시스템의 등장 배경</h1>
<h2 id="파일-시스템file-system">파일 시스템(file system)</h2>
<ul>
  <li>과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어</li>
  <li>응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함</li>
</ul>

<h3 id="파일-시스템의-문제점">파일 시스템의 문제점</h3>
<ul>
  <li>같은 내용의 데이터가 여러 파일에 중복 저장된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">데이터 중복성</code></li>
      <li>저장 공간의 낭비는 물론 <code class="language-plaintext highlighter-rouge">데이터 일관성</code>과 <code class="language-plaintext highlighter-rouge">데이터 무결성</code> 유지가 어렵다.<br /><br /></li>
    </ul>
  </li>
  <li>응용 프로그램이 데이터 파일에 종속적이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">데이터 종속성</code></li>
      <li>사용하는 파일의 구조를 변경하면 응용 프로그램도 함께 변경해야 한다.<br /><br /></li>
    </ul>
  </li>
  <li>데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.</li>
  <li>응용 프로그램 개발이 쉽지 않다.<br /><br /><br /></li>
</ul>

<h1 id="데이터베이스-관리-시스템의-정의-및-특성">데이터베이스 관리 시스템의 정의 및 특성</h1>
<h2 id="데이터베이스-관리-시스템dbms-database-management-system">데이터베이스 관리 시스템(DBMS, DataBase Management System)</h2>
<ul>
  <li>파일 시스템의 문제를 해결하기 위해 제시된 소프트웨어</li>
  <li>조직에 필요한 데이터를 데이터베이스에 통합하여 저장하고 관리한다.</li>
</ul>

<h2 id="데이터베이스-관리-시스템의-주요-기능">데이터베이스 관리 시스템의 주요 기능</h2>
<ul>
  <li>정의 기능 : 데이터베이스 구조를 정의하거나 수정할 수 있다.</li>
  <li>조작 기능 : 데이터를 삽입, 삭제, 수정, 검색하는 연산을 할 수 있다.</li>
  <li>제어 기능 : 데이터를 항상 정확하고 안전하게 유지할 수 있다.</li>
</ul>

<h3 id="장점">장점</h3>
<ul>
  <li>데이터 중복을 통제할 수 있다.</li>
  <li>데이터 독립성이 확보된다.</li>
  <li>데이터를 동시 공유할 수 있다.</li>
  <li>데이터 보안이 향상된다.</li>
  <li>데이터 무결성을 유지할 수 있다.</li>
  <li>표준화할 수 있다.</li>
  <li>장애 발생 시 회복이 가능하다.</li>
  <li>응용 프로그램 개발 비용이 줄어든다.</li>
</ul>

<h3 id="단점">단점</h3>
<ul>
  <li>(경제적, 컴퓨터 자원 포함)비용이 많이 든다.</li>
  <li>백업과 회복 방법이 복잡하다.</li>
  <li>중앙 집중 관리로 인한 취약점이 존재한다.<br /><br /><br /></li>
</ul>

<h1 id="데이터베이스-관리-시스템의-발전-과정">데이터베이스 관리 시스템의 발전 과정</h1>
<h2 id="1세대--네트워크-dbms-계층-dbms-1960--1970">1세대 : 네트워크 DBMS, 계층 DBMS (1960 ~ 1970)</h2>
<ul>
  <li>네트워크 DBMS : 데이터베이스를 계층 형태로 구성
    <ul>
      <li>변경이 어렵다.</li>
      <li>예) IDS(Integrated Data Store)<br /><br /></li>
    </ul>
  </li>
  <li>계층 DBMS : 데이터베이스를 트리 형태로 구성
    <ul>
      <li>구조변경 및 복잡한 현실세계 반영이 어렵다.</li>
      <li>예) IMS(Information Management System)<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="2세대--관계-dbms-1980-">2세대 : 관계 DBMS (1980 ~)</h2>
<ul>
  <li>관계 DBMS : 데이터베이스를 테이블 형태로 구성
    <ul>
      <li>이해하기 쉽다.</li>
      <li>예) 오라클(Oracle), MS SQL 서버, 액세스(Access), 인포믹스(Informix), MySQL<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="3세대--객체지향-dbms-1980-후반--객체관계-dbms-1990-후반-">3세대 : 객체지향 DBMS (1980 후반 ~), 객체관계 DBMS (1990 후반 ~)</h2>
<ul>
  <li>객체지향 DBMS : 객체를 이용해 데이터베이스 구성
    <ul>
      <li>예) 오투(O2), 온투스(ONTOS), 젬스톤(GemStone)<br /><br /></li>
    </ul>
  </li>
  <li>
    <p>객체관계 DBMS : 객체 DBMS + 관계 DBMS<br /><br /></p>
  </li>
  <li>현대에는 이해하기 쉬운 2세대 RDBMS를 주로 사용하지만 객체지향 DBMS의 점유율도 점차 높아지고 있다.<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1163794">데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><category term="DBMS" /><category term="RDBMS" /><summary type="html"><![CDATA[데이터베이스 관리 시스템의 등장 배경 파일 시스템(file system) 과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어 응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함]]></summary></entry><entry><title type="html">SQL) 데이터조작어(DML)</title><link href="http://localhost:4000/database/SQL-DML/" rel="alternate" type="text/html" title="SQL) 데이터조작어(DML)" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/SQL-DML</id><content type="html" xml:base="http://localhost:4000/database/SQL-DML/"><![CDATA[<ul>
  <li>테이블에 저장되어 있는 데이터를 다루는 명령어<br /><br /><br /></li>
</ul>

<h1 id="1-insert-구문">1. INSERT 구문</h1>
<ul>
  <li>테이블에 새로운 행 추가</li>
</ul>

<h2 id="️-문법">☑️ 문법</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table</span> <span class="p">[(</span><span class="k">column</span> <span class="p">[,</span> <span class="k">column</span><span class="p">...])]</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="n">value</span> <span class="p">[,</span> <span class="n">value</span><span class="p">...]);</span>
</code></pre></div></div>

<h2 id="예제">예제</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">departments</span><span class="p">(</span><span class="n">department_name</span><span class="p">,</span> <span class="n">namager_id</span><span class="p">,</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">location_id</span><span class="p">)</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="s1">'Java'</span><span class="p">,</span> <span class="mi">201</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">1700</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">departments</span><span class="p">(</span><span class="n">department_id</span><span class="p">,</span> <span class="n">department_name</span><span class="p">)</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="s1">'Jsp'</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>테이블명 다음에 설정한 컬럼수만큼 <code class="language-plaintext highlighter-rouge">values</code>에 값을 채워준다. 나머지는 자동으로 <code class="language-plaintext highlighter-rouge">null</code>값이 들어간다.<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">departments</span>
<span class="k">VALUES</span>      <span class="p">(</span><span class="mi">310</span><span class="p">,</span> <span class="s1">'Web'</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>아니면 <code class="language-plaintext highlighter-rouge">null</code>을 넣고 싶은 필드를 직접 지정해 줄 수도 있다.<br /><br /><br /></li>
</ul>

<h1 id="2-update-구문">2. UPDATE 구문</h1>
<ul>
  <li>테이블이 기존 행 수정</li>
</ul>

<h2 id="️-문법-1">☑️ 문법</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="k">table</span>
<span class="k">SET</span>    <span class="k">column</span> <span class="o">=</span> <span class="n">value</span> <span class="p">[,</span> <span class="k">column</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="p">...]</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">condition</span><span class="p">];</span>
</code></pre></div></div>

<h2 id="예제-1">예제</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">employees</span>
<span class="k">SET</span>    <span class="n">department_id</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">113</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>이렇게 쓰면 특정 <code class="language-plaintext highlighter-rouge">row</code>만 데이터 변경<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">employees</span>
<span class="k">SET</span>    <span class="n">department_id</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>이렇게 쓰면 해당 테이블 내의 모든 <code class="language-plaintext highlighter-rouge">row</code>의 데이터가 바뀐다. 이렇게 쓸 일은 거의 없으니까 <code class="language-plaintext highlighter-rouge">UPDATE</code> 사용시에는 <code class="language-plaintext highlighter-rouge">WHERE</code> 조건을 잘 확인하자.<br /><br /></li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">copy_emp</span>
<span class="k">SET</span>    <span class="n">job_id</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">job_id</span>
                 <span class="k">FROM</span>   <span class="n">copy_emp</span>
                 <span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">205</span><span class="p">),</span>
       <span class="n">salary</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">salary</span>
                 <span class="k">FROM</span>   <span class="n">copy_emp</span>
                 <span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">205</span><span class="p">)</span>
<span class="k">WHERE</span>  <span class="n">employee_id</span> <span class="o">=</span> <span class="mi">113</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>수정할 데이터 구문에서 서브쿼리도 사용 가능<br /><br /><br /></li>
</ul>

<h2 id="3-delete-구문">3. DELETE 구문</h2>
<ul>
  <li>테이블의 기존 행 삭제</li>
</ul>

<h2 id="️-문법-2">☑️ 문법</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="p">[</span><span class="k">FROM</span><span class="p">]</span> <span class="k">table</span>
<span class="p">[</span><span class="k">WHERE</span>        <span class="n">condition</span><span class="p">];</span>
</code></pre></div></div>

<h2 id="예제-2">예제</h2>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">departments</span>
<span class="k">WHERE</span>       <span class="n">department_id</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">copy_emp</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>이렇게 쓰면 전체 삭제<br /><br /><br /></li>
</ul>

<h2 id="4-트랜잭션transaction">4. 트랜잭션(Transaction)</h2>
<ul>
  <li>논리적인 작업 단위</li>
  <li>여러 <code class="language-plaintext highlighter-rouge">DML</code>이 모여서 하나의 트랜잭션이 구성된다.</li>
  <li><code class="language-plaintext highlighter-rouge">DML</code> 작업을 통해 변경한 내용들은 모두 <code class="language-plaintext highlighter-rouge">임시저장</code> 되어 있는 상태이다.</li>
  <li>그래서 <code class="language-plaintext highlighter-rouge">DML</code> 작업 후 <code class="language-plaintext highlighter-rouge">commit</code>(<code class="language-plaintext highlighter-rouge">DB</code>에 작업내용 최종 저장), <code class="language-plaintext highlighter-rouge">rollback</code>(<code class="language-plaintext highlighter-rouge">DB</code> 최종 저장 전에 작업내용 되돌리기)으로 트랜잭션을 종료해야 한다.<br /><br /></li>
</ul>

<h3 id="4-1-트랜잭션-구성">4-1) 트랜잭션 구성</h3>
<ul>
  <li>여러 <code class="language-plaintext highlighter-rouge">DML</code> 구문이 하나의 트랜잭션 (<code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">insert</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">delete</code>)</li>
  <li>하나의 <code class="language-plaintext highlighter-rouge">DDL</code> 구문이 하나의 트랜잭션 (<code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">alter</code>, <code class="language-plaintext highlighter-rouge">drop</code>, <code class="language-plaintext highlighter-rouge">truncate</code>)</li>
  <li>하나의 <code class="language-plaintext highlighter-rouge">DCL</code> 구문이 하나의 트랜잭션 (<code class="language-plaintext highlighter-rouge">grant</code>, <code class="language-plaintext highlighter-rouge">revoke</code>)<br /><br /></li>
</ul>

<h3 id="4-2-트랜잭션-시작-및-종료">4-2) 트랜잭션 시작 및 종료</h3>
<h4 id="-시작">🔸 시작</h4>
<ul>
  <li>첫 번째 <code class="language-plaintext highlighter-rouge">DML</code> 구문 실행 시</li>
</ul>

<h4 id="-종료">🔸 종료</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">COMMIT</code> 또는 <code class="language-plaintext highlighter-rouge">ROLLBACK</code> 실행 시
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DML</code> 쓰다가 <code class="language-plaintext highlighter-rouge">DDL/DCL</code> 작성하면 <code class="language-plaintext highlighter-rouge">autocommit</code> 되면서 위에 썼던 <code class="language-plaintext highlighter-rouge">DML</code>도 같이 커밋된다.(트랜잭션 끝)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DDL</code> 또는 <code class="language-plaintext highlighter-rouge">DCL</code> 구문 실행 시(<code class="language-plaintext highlighter-rouge">autocommit</code>)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DDL</code>과 <code class="language-plaintext highlighter-rouge">DCL</code>은 <code class="language-plaintext highlighter-rouge">autocommit</code>을 내포하고 있기 때문에 실행하는 순간 <code class="language-plaintext highlighter-rouge">commit</code>되고 트랜잭션이 끝난다.</li>
      <li>그래서 <code class="language-plaintext highlighter-rouge">rollback</code>이 불가하기 때문에 신중하게 작업하는 것이 좋다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">SQL *PLUS</code> 정상 종료 시(<code class="language-plaintext highlighter-rouge">autocommit</code>)
    <ul>
      <li>그래픽창의 <code class="language-plaintext highlighter-rouge">X</code>를 눌러 끄는 것은 비정상 종료다.</li>
      <li>터미널에서 <code class="language-plaintext highlighter-rouge">exit</code> 명령어 입력이나 그래픽 툴의 <code class="language-plaintext highlighter-rouge">exit</code> 버튼을 눌러서 끄는 것이 정상 종료이다.</li>
      <li>비정상 종료 시 <code class="language-plaintext highlighter-rouge">autorollback</code> 처리된다.</li>
    </ul>
  </li>
</ul>

<h4 id="-savepoint와-rollback-to">🔸 SAVEPOINT와 ROLLBACK TO</h4>
<ul>
  <li>최종 <code class="language-plaintext highlighter-rouge">commit</code> 전에 작업하던 중간 중간으로 되돌아 갈 수 있도록 <code class="language-plaintext highlighter-rouge">SAVEPOINT</code>를 만들 수 있다.</li>
  <li>하지만 만든 세이브포인트를 확인할 수 있는 명령어는 없기 때문에 만든 사람이 기억하고 있어야 한다.</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span><span class="p">...</span>
<span class="n">SAVEPOINT</span> <span class="n">update_done</span> <span class="c1">-- 세이브 포인트 생성</span>

<span class="p">...</span>

<span class="k">INSERT</span><span class="p">...</span>
<span class="k">ROLLBACK</span> <span class="k">TO</span> <span class="n">update_done</span><span class="p">;</span> <span class="c1">-- 세이브 포인트로 되돌리기</span>
</code></pre></div></div>

<ul>
  <li>세이브 포인트를 만들었다고 그 전까지 했던 작업들이 <code class="language-plaintext highlighter-rouge">COMMIT</code> 되는 것은 아니다.</li>
  <li>그렇기 때문에 모든 <code class="language-plaintext highlighter-rouge">DML</code> 작업이 끝났다면 최종 확인 후 꼭 <code class="language-plaintext highlighter-rouge">COMMIT</code>을 해 주어야 한다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><category term="SQL" /><category term="DML" /><summary type="html"><![CDATA[테이블에 저장되어 있는 데이터를 다루는 명령어]]></summary></entry><entry><title type="html">DB) 데이터베이스 기본개념</title><link href="http://localhost:4000/database/db-01/" rel="alternate" type="text/html" title="DB) 데이터베이스 기본개념" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/db-01</id><content type="html" xml:base="http://localhost:4000/database/db-01/"><![CDATA[<h1 id="데이터베이스의-필요성">데이터베이스의 필요성</h1>
<ul>
  <li>데이터(data) : 의미가 부여되지는 않았지만 현실 세계에서 단순히 관찰하거나 측정해 수집한 사실이나 값</li>
  <li>정보(information) : 의사 결정에 유용하게 활용할 수 있도록 데이터를 처리한 결과물</li>
</ul>

<h2 id="데이터-분류">데이터 분류</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Wisdom</code> : 지식을 활용할 수 있는 지혜로운 아이디어</li>
  <li><code class="language-plaintext highlighter-rouge">Knowledge</code> : 정보를 의미있게 처리, 활용한 것</li>
  <li><code class="language-plaintext highlighter-rouge">Information</code> : 가공된 의미있는 2차 데이터</li>
  <li><code class="language-plaintext highlighter-rouge">Data</code> : 가공 전의 순수한 데이터</li>
</ul>

<h2 id="빅데이터-시대">빅데이터 시대</h2>
<ul>
  <li>현대는 빅데이터 시대라 할 수 있는데 데이터를 이용해 정보화시킬 수 있는 범위와 능력이 증대되었기 때문이다.</li>
  <li>그만큼 데이터를 가공하는 역량이 중요한 시대가 되었다.<br /><br /></li>
</ul>

<h2 id="정보처리">정보처리</h2>
<ul>
  <li>데이터에서 정보를 추출하는 과정 또는 방법<br /><br /></li>
</ul>

<h2 id="정보-시스템과-데이터베이스">정보 시스템과 데이터베이스</h2>
<h3 id="정보-시스템information-system">정보 시스템(information system)</h3>
<ul>
  <li>조직 운영에 필요한 데이터를 수집하여 저장해두었다가 필요할 때 유용한 정보를 만들어 주는 수단</li>
</ul>

<h3 id="데이터베이스">데이터베이스</h3>
<ul>
  <li>정보 시스템 안에서 저장하고 있다가 필요할 때 제공하는 역할을 담당</li>
  <li>여러 가지 업무에 <code class="language-plaintext highlighter-rouge">공동</code>으로 필요한 데이터를 유기적으로 결합하여 저장한 집합체. 데이터를 <code class="language-plaintext highlighter-rouge">효율</code>적으로 처리하기 위하여 개발된 것으로, 같은 데이터가 <code class="language-plaintext highlighter-rouge">중복</code>되는 문제를 없앨 수 있으며 업무가 확대되어도 새로 파일을 준비할 필요가 없다는 장점이 있다.<br /><br /><br /></li>
</ul>

<h2 id="데이터베이스db-database">데이터베이스(DB, Database)</h2>
<ul>
  <li>특정 조직의 여러 사용자가 <code class="language-plaintext highlighter-rouge">공유</code>하여 사용할 수 있도록 <code class="language-plaintext highlighter-rouge">통합</code>해서 <code class="language-plaintext highlighter-rouge">저장</code>한 <code class="language-plaintext highlighter-rouge">운영</code> 데이터의 집합</li>
</ul>

<h3 id="데이터베이스의-정의">데이터베이스의 정의</h3>
<ul>
  <li>통합 데이터(integrated data) : 최소의 중복과 통제가능한 중복만 허용하는 데이터</li>
  <li>저장 데이터(stored data) : 컴퓨터가 접근할 수 있는 매체에 저장된 데이터</li>
  <li>공유 데이터(shared data) : 특정 조직의 여러 사용자가 함께 소유하고 이용할 수 있는 공용 데이터</li>
  <li>운영 데이터(operational data) : 조직의 주요 기능을 수행하기 위해 지속적으로(조직이 문 닫을 때까지) 유지해야 하는 데이터</li>
</ul>

<h3 id="데이터베이스의-특성">데이터베이스의 특성</h3>
<ul>
  <li>실시간 접근(real-time accessibility) : 사용자의 데이터 요구에 실시간으로 응답</li>
  <li>계속 변화(continuous evolution) : 데이터의 계속적인 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지
    <ul>
      <li>예) 사원의 입사, 퇴사에 따른 변화를 반영</li>
    </ul>
  </li>
  <li>내용 기반 참조(contents reference) : 데이터가 저장된 주소나 위치가 아닌 내용으로 참조
    <ul>
      <li>예) 연봉이 5000만원 이상이며 과장급 이상인 사원을 검색하시오.</li>
    </ul>
  </li>
  <li>동시 공유(concurrent sharing) : 서로 다른 데이터의 동시 사용뿐만 아니라 같은 데이터의 동시 사용도 지원</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><summary type="html"><![CDATA[데이터베이스의 필요성 데이터(data) : 의미가 부여되지는 않았지만 현실 세계에서 단순히 관찰하거나 측정해 수집한 사실이나 값 정보(information) : 의사 결정에 유용하게 활용할 수 있도록 데이터를 처리한 결과물]]></summary></entry></feed>