<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-26T23:11:01+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 2108. 통계학</title><link href="http://localhost:4000/boj/boj2108-java/" rel="alternate" type="text/html" title="Java) BOJ 2108. 통계학" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2108-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2108-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2108">https://www.acmicpc.net/problem/2108</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.</p>
  </li>
  <li>산술평균 : N개의 수들의 합을 N으로 나눈 값</li>
  <li>중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값</li>
  <li>최빈값 : N개의 수들 중 가장 많이 나타나는 값</li>
  <li>범위 : N개의 수들 중 최댓값과 최솟값의 차이</li>
  <li>N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>
    <p>첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.</p>
  </li>
  <li>
    <p>둘째 줄에는 중앙값을 출력한다.</p>
  </li>
  <li>
    <p>셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.</p>
  </li>
  <li>
    <p>넷째 줄에는 범위를 출력한다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>각 알고리즘 자체는 어렵지 않았는데 종류가 많아서 그런가 구현에 시간이 걸렸다.</li>
  <li>중앙값 구하는 알고리즘을 더 손에 익히면 좋겠다.</li>
  <li>중앙값은 최대힙과 최소힙을 사용해서 중앙값보다 더 큰 수는 최소힙에 저장하고 작은 수는 최대힙에 저장한 후</li>
  <li>
    <p>최대힙과 최소힙의 길이가 같은 경우 top 평균을 구하고 최대힙이 더 크면 최대힙의 top을 반환하고 최소힙이 더 크면 최소힙의 top을 반환하도록 했다.<br /></p>
  </li>
  <li>최빈값은 배열 인덱스에 1:1로 매핑시켜서 빈도를 구하는 방식은 입력값의 범위가 커서 비효율적일 거 같아서 map을 사용했다.</li>
  <li>입력값을 &lt; 입력값, 빈도 &gt; 로 map에 저장한 후 입력이 끝나면 map을 순회하면서 가장 높은 빈도수를 구한 다음</li>
  <li>
    <p>가장 높은 빈도수와 일치하는 키값이 하나라면 그걸 바로 리턴하고 여러 개라면 그 수를 모두 배열에 저장한 뒤 오름차순으로 정렬해서 두번째로 작은 수를 구해서 리턴했다.<br /></p>
  </li>
  <li>범위는 입력 받으면서 최댓값과 최솟값을 구해서 두 값의 차를 출력하면 되는데 입력값이 음수도 들어오기 때문에 최댓값을 저장하는 변수의 초기값은 0이 아닌 Integer의 가장 작은 value로 설정하면 된다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 1028 ms</li>
  <li>메모리 : 105020 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/a66774c083b6bb3d29c76517e5342bbc.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2108" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2108 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">컴퓨터구조) Instructions</title><link href="http://localhost:4000/computer%20science/computer-architecture-03/" rel="alternate" type="text/html" title="컴퓨터구조) Instructions" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/computer-architecture-03</id><content type="html" xml:base="http://localhost:4000/computer%20science/computer-architecture-03/"><![CDATA[<h1 id="instruction-set">Instruction Set</h1>
<ul>
  <li>프로세서에서 지원하는 명령어들의 집합</li>
  <li>다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다.</li>
  <li>현대 컴퓨터는 대부분 간단한 명령어셋(<code class="language-plaintext highlighter-rouge">MIPS</code> - <code class="language-plaintext highlighter-rouge">RISK</code> 방식)을 가지고 있다.</li>
</ul>

<h2 id="instruction-set-architecture-isa">Instruction Set Architecture (ISA)</h2>
<ul>
  <li>하드웨어와 낮은 레벨의 소프트웨어를 연결하는 인터페이스로 시스템 소프트웨어(운영체제)라 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">ISA</code>가 같으면 같은 소프트웨어를 여러 개의 <code class="language-plaintext highlighter-rouge">CPU</code>에서 실행할 수 있다.</li>
</ul>

<h2 id="abi">ABI</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ISA</code>와 운영체제 인터페이스를 합친 것</li>
  <li><code class="language-plaintext highlighter-rouge">ABI</code>만 같으면 같은 프로그램이 어디에서든 실행될 수 있다.</li>
  <li>윈도우 운영체제를 쓰는 컴퓨터들은 어떤 컴퓨터를 쓰든 같은 프로그램을 실행할 수 있는 것<br /><br /><br /></li>
</ul>

<h1 id="design-principle">Design Principle</h1>
<h2 id="1-정규화규칙화해서-간단하게-만들기">1. 정규화(규칙화)해서 간단하게 만들기</h2>
<ul>
  <li>간단할수록 저비용으로 고성능을 만들기가 쉽다.</li>
</ul>

<h2 id="2-메모리-용량이-작은-것이-빠르다">2. 메모리 용량이 작은 것이 빠르다</h2>
<ul>
  <li>메모리 용량을 작은 레지스터를 최대한 활용하는 것이 성능 향상에 도움이 된다.</li>
</ul>

<h2 id="3-공통-케이스는-빠르게-만들기">3. 공통 케이스는 빠르게 만들기</h2>
<ul>
  <li>자주 사용하고 비중이 높은 연산은 빠르게 처리하도록 만드는 것이 성능 향상에 좋다.</li>
</ul>

<h2 id="4-좋은-디자인을-위해-최대한-통일하기">4. 좋은 디자인을 위해 최대한 통일하기</h2>
<ul>
  <li>명령어의 포맷 가짓수는 최대한 줄이고 통일하는 것이 좋다.</li>
  <li>포맷이 다르면 디코딩 하는 데 복잡해지고 이것은 성능 하락으로 이어지기 때문이다. <br /><br /><br /></li>
</ul>

<h1 id="operations-of-the-computer-hardware">Operations of the Computer Hardware</h1>
<h2 id="arithmetic-operations-산술연산">Arithmetic Operations (산술연산)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">register</code> 간 연산으로 <code class="language-plaintext highlighter-rouge">RISK</code> 프로세서 방식</li>
  <li><code class="language-plaintext highlighter-rouge">add</code>와 <code class="language-plaintext highlighter-rouge">subtract</code>, 더하기와 빼기로 이루어져 있으며 피연산자 3개가 필요하다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add a, b, c
</code></pre></div></div>

<ul>
  <li>위와 같이 쓰면 <code class="language-plaintext highlighter-rouge">b</code>와 <code class="language-plaintext highlighter-rouge">c</code>를 더한 값을 <code class="language-plaintext highlighter-rouge">a</code>에 저장해라는 의미<br /><br /><br /></li>
</ul>

<h1 id="operands-of-the-computer-hardware">Operands of the Computer Hardware</h1>
<h2 id="register-operands">Register Operands</h2>
<ul>
  <li>자주 사용하는 데이터에 빠르게 접근하기 위해서 레지스터를 사용한다.</li>
  <li>32개의 <code class="language-plaintext highlighter-rouge">bit</code>로 이루어져 있으며 <code class="language-plaintext highlighter-rouge">word</code>라 부른다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>는 32개의 <code class="language-plaintext highlighter-rouge">32bit</code> 레지스터 파일을 가지고 있다.</li>
</ul>

<h2 id="byte-addresses">Byte Addresses</h2>
<ul>
  <li>대부분의 아키텍처는 <code class="language-plaintext highlighter-rouge">byte</code> 단위로 메모리를 관리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">word</code>는 <code class="language-plaintext highlighter-rouge">4bytes</code>로 이루어져 있으며 이것은 하나의 명령어 단위가 된다.</li>
  <li>레지스터에 있는 데이터를 메모리에 저장할 때 자리수가 큰 게 최하위 비트(LSB)에 오면 <code class="language-plaintext highlighter-rouge">Big Endian</code>, 자리수가 제일 작은 것이 최하위 비트에 오면 <code class="language-plaintext highlighter-rouge">Little Endian</code>이라 한다.</li>
</ul>

<h2 id="memory-operands">Memory Operands</h2>
<ul>
  <li>메인 메모리는 자료의 집합을 이용한다.</li>
  <li>산술 연산을 하기 위해서 메모리에 접근할 수 있는 명령어가 지정되어 있다.(<code class="language-plaintext highlighter-rouge">Load/Store</code>)</li>
  <li>메모리는 <code class="language-plaintext highlighter-rouge">8bit</code> 크기의 주소로 이루어져 있다.</li>
  <li>모든 명령어의 크기는 <code class="language-plaintext highlighter-rouge">4bytes</code>이기 때문에 메모리 주소 또한 <code class="language-plaintext highlighter-rouge">4bytes</code> 간격으로 나열되어 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>는 빅 엔디안 방식을 사용한다.</li>
</ul>

<h2 id="registers-vs-memory">Registers vs. Memory</h2>
<ul>
  <li>레지스터가 메모리에 접근하는 것 보다 훨씬 빠르다.</li>
  <li>그래서 메모리 접근을 최대한 줄이고 레지스터에서 연산하는 것이 성능 향상에 좋은데 그렇다고 너무 레지스터만 써도 성능이 떨어지니까 자주 쓰지 않는 데이터는 메모리로 내려주는 것이 좋다.</li>
  <li>한 주소는 <code class="language-plaintext highlighter-rouge">32bit</code>로 이루어져 있는데 레지스터 하나는 <code class="language-plaintext highlighter-rouge">5bit</code> 크기이기 때문에 메모리에 접근하는 것 보다는 레지스터를 최대한 사용하는 것이 한 번에 처리할 수 있는 코드가 많아진다.</li>
</ul>

<h2 id="immediate-operands">Immediate Operands</h2>
<ul>
  <li>피연산자 중에 하나가 상수일 때 사용하는 명령어</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $s3 , $s3, 4 // 동작은 add와 같음
addi $s2, $s1, -1 // 뺄셈은 -1 사용
</code></pre></div></div>

<ul>
  <li>상수를 레지스터에서 만들어 쓰지 않으면 메모리에 접근해서 가져와야 하는데 이러면 느리다.</li>
  <li>그래서 0 같이 자주 사용되는 상수는 메모리에 접근할 필요 없이 레지스터에서 바로 연산하면 훨씬 빠르다.</li>
</ul>

<h2 id="constant-zero">Constant Zero</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$zero</code>라고 표시하며 <code class="language-plaintext highlighter-rouge">read only</code>로만 사용할 수 있다.</li>
  <li>주로 레지스터간 <code class="language-plaintext highlighter-rouge">move</code>연산을 할 때 사용하는데</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add $t1, $s1, $zero
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">move</code>와 같은 명령어를 따로 만들어서 사용하는 것 보다 <code class="language-plaintext highlighter-rouge">add</code>연산을 하는데 나머지 연산자를 0으로 만들어서 사용하면 <code class="language-plaintext highlighter-rouge">move/copy</code>와 같은 효과를 낼 수 있어서 명령어를 따로 만들지 않고 이렇게 쓴다.</li>
  <li>왜냐면 명령어 셋은 최대한 간단한 것이 성능 향상에 좋기 때문이다.</li>
  <li>어떤 특정 연산 처리만을 위한 명령어를 많이 만들어 쓰다 보면 구현 자체도 쉽지 않지만 구현해도 그 명령어를 처리하는 시간이 다른 쉬운 명령어보다 늘어나는데, 그 늘어난 시간은 다른 간단한 명령어의 실행 시간에도 영향을 미쳐서 다 같이 느려진다.<br /><br /><br /></li>
</ul>

<h1 id="logical-operations">Logical Operations</h1>
<h2 id="시프트-연산자">시프트 연산자</h2>
<ul>
  <li>왼쪽 시프트
    <ul>
      <li>시프트하면서 생기는 빈 비트는 0으로 채운다.</li>
      <li>원래 값에 2^i 을 곱한 효과(음수, 양수 둘 다 적용)</li>
    </ul>
  </li>
  <li>오른쪽 시프트
    <ul>
      <li>시프트하면서 생기는 빈 비트는 0으로 채운다.</li>
      <li>원래 값을 2^i 만큼 나눈 효과(양수에만 적용됨)</li>
    </ul>
  </li>
</ul>

<h2 id="비트-연산자">비트 연산자</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">nor</code> 연산자를 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>에는 NOT 연산자가 없기 때문에 대신 <code class="language-plaintext highlighter-rouge">nor</code> 연산자(a도 아니고 b도 아니다)를 사용해서 NOT 연산자와 같은 효과를 낸다.<br /><br /><br /></li>
</ul>

<h1 id="instructinos-for-making-decisions">Instructinos for Making Decisions</h1>
<h2 id="conditional-operations">Conditional Operations</h2>
<ul>
  <li>어떤 조건이 <code class="language-plaintext highlighter-rouge">true</code>인 경우에 이름지어져 있는 명령어로 분기를 나누고 <code class="language-plaintext highlighter-rouge">false</code>라면 다음 명령어를 계속 실행하는 것 (if ~ else문)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beq rs, rt, L1 // rs와 rt가 같으면 L1에 있는 명령어 실행
bne rs, rt, L2 // rs와 rt가 같지 않으면 L1에 있는 명령어 실행
j L1 // 무조건 L1으로 Jump하는 것
</code></pre></div></div>
<ul>
  <li>어떤 수들의 대소관계 비교도 전용 명령어를 따로 만들지 않고 <code class="language-plaintext highlighter-rouge">beq</code>를 비롯한 여러 명령어들을 조합해서 쓰는 것이 성능 면에서 더 좋기 때문에 조합해서 쓴다.<br /><br /><br /></li>
</ul>

<h1 id="명령-실행-단계">명령 실행 단계</h1>
<p>1) <code class="language-plaintext highlighter-rouge">caller</code>가 <code class="language-plaintext highlighter-rouge">callee</code>에게 파라미터를 넘긴다.
2) <code class="language-plaintext highlighter-rouge">caller</code>가 <code class="language-plaintext highlighter-rouge">callee</code>에게 제어권을 넘긴다.(실행)
3) <code class="language-plaintext highlighter-rouge">callee</code>가 스택에 메모리를 할당한다.
4) <code class="language-plaintext highlighter-rouge">callee</code>가 태스크를 수행한다.
5) <code class="language-plaintext highlighter-rouge">callee</code>가 <code class="language-plaintext highlighter-rouge">caller</code>가 접근할 수 있는 곳에 결과를 둔다.
6) <code class="language-plaintext highlighter-rouge">callee</code>가 <code class="language-plaintext highlighter-rouge">caller</code>에게 제어권을 넘긴다.<br /><br /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Procedure</code> 실행에는 <code class="language-plaintext highlighter-rouge">Leaf</code>와 <code class="language-plaintext highlighter-rouge">Non-Leaf</code> 방식이 있는데 <code class="language-plaintext highlighter-rouge">Leaf</code>는 자기 자신을 포함한 어떤 함수도 호출하지 않는 것이고 <code class="language-plaintext highlighter-rouge">Non-Leaf</code>는 자기 자신을 포함한 함수를 호출하는 것이다.</li>
  <li>프로그래밍 할 때 흔히 작성하는 값 하나를 리턴하고 끝나는 함수는 <code class="language-plaintext highlighter-rouge">Leaf</code> 방식이고 재귀 함수와 같은 형태는 <code class="language-plaintext highlighter-rouge">Non-Leaf</code>로 이루어진다.</li>
</ul>

<h2 id="메모리-영역">메모리 영역</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Text</code> : 프로그램 코드(명령어)가 있는 영역</li>
  <li><code class="language-plaintext highlighter-rouge">Static data</code> : 전역 변수가 있는 영역</li>
  <li><code class="language-plaintext highlighter-rouge">Dynamic data</code> : <code class="language-plaintext highlighter-rouge">heap</code> 영역이라고도 하며 동적으로 할당된 메모리가 있는 영역. 메모리 주소를 가리키는 포인터는 아래에서 위로 이동한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code> : 함수가 호출되면 생기는 지역 변수가 있는 영역. 메모리 주소를 가리키는 포인터는 위에서 아래로 이동한다.<br /><br /><br /></li>
</ul>

<h1 id="코드가-실행되는-과정">코드가 실행되는 과정</h1>
<p>1) 프로그래밍 언어로 프로그램을 작성한다.
2) 컴파일러가 어셈블리어로 번역한다.
3) 어셈블러가 기계어로 번역한다.
4) 기계어로 번역하면서 내가 쓴 코드를 이용해서 만든 기계어 오브젝트와 라이브러리에서 가져오는 코드로 만든 오브젝트가 생기는데 링커가 두 오브젝트 코드들을 합쳐서 실행파일로 만든다.
5) 로더가 실행파일을 메모리에 올려서 실행상태로 만든다.<br /><br /><br /></p>

<h1 id="알고리즘과-수행속도">알고리즘과 수행속도</h1>
<ul>
  <li>명령어 수와 <code class="language-plaintext highlighter-rouge">CPI</code>가 낮은 것이 무조건 성능이 좋은 것은 아니다. 성능에 영향을 미치는 것은 여러가지 요인이 있다.</li>
  <li>컴파일러 최적화는 알고리즘에 영향을 많이 받는다.</li>
  <li>그렇기 때문에 뭐니뭐니해도 알고리즘이 효율적이어야 성능이 좋아진다.<br /><br /><br /></li>
</ul>

<h1 id="배열과-포인터">배열과 포인터</h1>
<ul>
  <li>둘 다 배열을 다룰 때 사용할 수 있지만 배열 인덱스에 접근하려면 내부적으로 인덱스의 주소값을 계산하는 과정이 필요하다. (시작 주소에서부터 몇 칸 떨어져 있는지…)</li>
  <li>하지만 포인터는 그런 연산이 필요없이 그냥 4씩 더해주면서 다음 메모리 주소로 이동하면 된다.</li>
  <li>그렇지만… 최신 컴파일러는 내가 직접 포인터 연산하는 코드를 쓰는 것과 배열 인덱스로 접근하는 코드가 같은 성능을 낼 수 있도록 최적화를 다 해 준다.</li>
  <li>그래서 같은 동작을 수행하는 코드라면 배열 인덱스를 사용하는 코드를 써도 무방하며 포인터를 사용한 코드보다 이해하기도 더 쉽다. 포인터에 비해 버그를 일으키는 코드를 작성할 확률도 줄어드니까 그냥 배열을 쓰자.<br /><br /><br /></li>
</ul>

<h1 id="x86-instructions">x86 Instructions</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>와는 명령어 셋이 다르며 설계 면에서도 차이가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>에 비해 다소 복잡하게 설계되어 있어 고성능으로 만들기 어려운 <code class="language-plaintext highlighter-rouge">CISK</code> 아키텍처다.</li>
  <li>그래서 고성능을 내기 위해 하드웨어가 내부적으로 복잡한 원래 명령어를 간단한 명령어들로 쪼갠 다음에 실행하는 방식을 쓴다.(결국 <code class="language-plaintext highlighter-rouge">RISC</code>와 같은 매커니즘으로 실행되게 된다고 볼 수 있다)</li>
  <li>이렇게 보면 인텔은 진작에 망했어야 할 거 같지만 시장 점유율을 성공적으로 높이면서 자리잡았기 때문에 인텔 프로세서에서 실행되는 프로그램들이 많다보니 여전히 높은 점유율을 차지하며 지금까지 오고 있는 것이다.<br /><br /><br /></li>
</ul>

<h1 id="결론">결론</h1>
<ul>
  <li>명령어 여러 개를 한꺼번에 처리하면 효율적이겠지만 그만큼 하드웨어 게이트(로직) 수가 많아지면서 실행 속도가 느려진다. 그리고 다른 명령어도 같이 느려진다.</li>
  <li>그래서 간단한 명령어를 여러개 조합해서 쓰는 것이 효율적이다. (<code class="language-plaintext highlighter-rouge">RISK Processor</code> 철학)</li>
  <li>어셈블리 코드를 쓰면 기계어와 가까워서 좋은 성능을 낼 수 있지만 최신 컴파일러는 <code class="language-plaintext highlighter-rouge">C</code> 언어와 같은 고급 언어로 쓴 코드도 어셈블리어와 비슷한 성능을 낼 수 있도록 최적화를 다 해 주기 때문에 그냥 고급 언어를 쓰는 것이 생산성이 더 높고 좋다. (어셈블리어는 생산성이 낮다)<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=16bd07027739ad22">컴퓨터구조 - 영남대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><category term="Instruction" /><summary type="html"><![CDATA[Instruction Set 프로세서에서 지원하는 명령어들의 집합 다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다. 현대 컴퓨터는 대부분 간단한 명령어셋(MIPS - RISK 방식)을 가지고 있다.]]></summary></entry><entry><title type="html">Java) BOJ 10989. 수 정렬하기3</title><link href="http://localhost:4000/boj/boj10989-java/" rel="alternate" type="text/html" title="Java) BOJ 10989. 수 정렬하기3" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10989-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10989-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10989">https://www.acmicpc.net/problem/10989</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 3 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>자바는 제한시간 3초에 메모리 제한은 512라 컬렉션을 쓸 수 없었다.(처음에 컬렉션 sort 써 봤는데 메모리 초과됨 ㅠ)</li>
  <li>int 배열 메모리 계산해 보니까 합병정렬을 할 수 있을 정도가 되어서 합병정렬을 구현했다.</li>
  <li>N의 최대값 10,000,000 * 4byte(int) = 40,000,000byte = 39,062kb = 약 38mb</li>
  <li>합병정렬은 정렬할 배열과 같은 크기의 배열이 하나 더 필요하기 때문에 38 * 2 = 약 76mb</li>
  <li>그래서 자바에서 기본적으로 잡아먹는 메모리를 더해도 통과할 수 있을거 같아서 합병정렬로 풀었는데 시간이 좀 아슬아슬했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 2948 ms</li>
  <li>메모리 : 383572 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/f9f2c1a27acf0a5bba1e0a65de41e81a.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10989" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10989 제한 시간 제한 : 3 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 2750. 수 정렬하기</title><link href="http://localhost:4000/boj/boj2750-java/" rel="alternate" type="text/html" title="Java) BOJ 2750. 수 정렬하기" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2750-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2750-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2750">https://www.acmicpc.net/problem/2750</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>제한시간 1초에 N 최대값이 1,000이라 N^2 정렬 알고리즘으로 풀었다.(삽입정렬 사용)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 188 ms</li>
  <li>메모리 : 16936 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8845c43c6d3be9195cad397c8c3e2984.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2750" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2750 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 2751. 수 정렬하기2</title><link href="http://localhost:4000/boj/boj2751-java/" rel="alternate" type="text/html" title="Java) BOJ 2751. 수 정렬하기2" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2751-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2751-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2751">https://www.acmicpc.net/problem/2751</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>제한시간 2초에 N 최대값이 백만이라 n log n 정렬 알고리즘을 써야 했는데 합병정렬을 쓰면 좋겠지만 구현하기 귀찮기도 하고… 자바에 구현되어 있는 sort 함수 사용법도 익힐겸 저걸 썼다.</li>
  <li>처음에는 Arrays.sort를 썼는데 1700ms 가 나와서 시간복잡도를 알아보니까 평균 n log n이지만 최악의 경우에는 n^2이었다.</li>
  <li>그래서 최악의 경우에도 n log n을 보장한다는 Collections.sort를 써 봤는데 1600ms 정도가 나와서 크게 시간 차이가 나지는 않았다.</li>
  <li>합병정렬 기억을 되살릴 겸 한 번 구현해 보는 것이 좋을 거 같다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 1636 ms</li>
  <li>메모리 : 171216 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/944a523911f3218c3088e59d5a8d6048.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2751" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2751 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 1436. 영화감독 숌</title><link href="http://localhost:4000/boj/boj1436-java/" rel="alternate" type="text/html" title="Java) BOJ 1436. 영화감독 숌" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1436-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1436-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1436">https://www.acmicpc.net/problem/1436</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.</li>
  <li>조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고,</li>
  <li>
    <p>피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.</p>
  </li>
  <li>
    <p>하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.</p>
  </li>
  <li>
    <p>종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, …. 과 같다.</p>
  </li>
  <li>따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.</li>
  <li>
    <p>일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.</p>
  </li>
  <li>숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>브루트포스로 666부터 하나씩 증가시켜가면서 N번째 수를 구하려 했으나 처음에 생각을 잘못 하는 바람에… 틀려서 구글링 참고해서 풀었다.</li>
  <li>현재 수에 666이 포함되어 있으면 cnt를 증가시키고 cnt가 N과 같다면 현재 수를 리턴하고 그렇지 않다면 현재 수를 증가시키면서 또 666이 포함되어 있는지 확인한다.</li>
  <li>이 때 수를 문자열로 바꿔서 666이 연속되어 있는지 확인해도 되서 처음엔 그렇게 확인하는 함수를 구현했는데 구글링 하니까 자바에는 contains 함수가 있어서 편하게 그걸 썼다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 320 ms</li>
  <li>메모리 : 86524 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/cd9086d9b051383331645a51c0164abb.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1436" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1436 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">OS) Process Management</title><link href="http://localhost:4000/operating%20system/OS-04-Process-Management/" rel="alternate" type="text/html" title="OS) Process Management" /><published>2022-02-25T00:00:00+09:00</published><updated>2022-02-25T00:00:00+09:00</updated><id>http://localhost:4000/operating%20system/OS-04-Process-Management</id><content type="html" xml:base="http://localhost:4000/operating%20system/OS-04-Process-Management/"><![CDATA[<h1 id="-프로세스-생성-process-creation">👀 프로세스 생성 (Process Creation)</h1>
<ul>
  <li>부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다.</li>
  <li>복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다.</li>
  <li>프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다.</li>
  <li>프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.</li>
</ul>

<h2 id="자원의-공유">자원의 공유</h2>
<ul>
  <li>부모와 자식이 모든 자원을 공유하는 모델</li>
  <li>일부를 공유하는 모델</li>
  <li>전혀 공유하지 않는 모델 (일반적)</li>
</ul>

<h2 id="수행-execution">수행 (Execution)</h2>
<ul>
  <li>부모와 자식은 공존하며 수행되는 모델</li>
  <li>자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델</li>
</ul>

<h2 id="주소-공간-address-space">주소 공간 (Address space)</h2>
<ul>
  <li>자식은 부모의 공간을 복사함 (binary and OS data)</li>
  <li>자식은 그 공간에 새로운 프로그램을 올린다.(덮어씌움)</li>
</ul>

<h3 id="유닉스의-예">유닉스의 예</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">fork()</code> 시스템 콜이 새로운 프로세스를 생성
    <ul>
      <li>부모를 그대로 복사 후 주소 공간 할당</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fork</code> 다음에 이어지는 <code class="language-plaintext highlighter-rouge">exec()</code> 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 (덮어씌우는 단계)</li>
  <li><code class="language-plaintext highlighter-rouge">fork</code>와 <code class="language-plaintext highlighter-rouge">exec</code>은 독립적으로 이루어지기 때문에 둘 중 하나만 실행될 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스-종료-process-termination">프로세스 종료 (Process Termination)</h1>
<ul>
  <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.</li>
  <li>그래서 단계적인 종료를 통해 모든 자식 프로세스가 먼저 종료된 후 부모가 종료되어야 한다.</li>
</ul>

<h2 id="system-call을-통해-자발적으로-종료되는-경우">System call을 통해 자발적으로 종료되는 경우</h2>
<ul>
  <li>프로세스가 마지막 명령을 수행한 후 이를 운영체제에게 알려준다.(<code class="language-plaintext highlighter-rouge">exit</code>)</li>
  <li>자식이 부모에게 output data를 보냄 (via <code class="language-plaintext highlighter-rouge">wait</code>)</li>
  <li>프로세스의 각종 자원들이 운영체제에게 반납됨</li>
</ul>

<h2 id="비자발적으로-종료되는-경우">비자발적으로 종료되는 경우</h2>
<ul>
  <li>부모 프로세스가 자식 프로세스의 수행을 강제로 종료시킨다.(<code class="language-plaintext highlighter-rouge">abort</code>)</li>
  <li>자식이 할당 자원의 한계치를 넘어선 경우</li>
  <li>자식에게 할당된 태스크가 더 이상 필요하지 않은 경우</li>
  <li>부모가 종료(exit)하는 경우<br /><br /><br /></li>
</ul>

<h1 id="fork-시스템-콜">fork() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span> <span class="c1">// 부모와 자식을 구분하기 위한 값</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// 새로운 자식 프로세스가 생성되면 여기 다음 줄부터 실행한다.(부모의 문맥을 복사하기 때문)</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a child</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a child!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a parent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>자식 프로세스를 생성하기 위한 시스템 콜로 부모와 자식을 구분하기 위해 부모의 <code class="language-plaintext highlighter-rouge">pid</code>는 0보다 큰 값을 가지고 자식의 <code class="language-plaintext highlighter-rouge">pid</code>는 0을 가진다.<br /><br /><br /></li>
</ul>

<h1 id="exec-시스템-콜">exec() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a child</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a child! Now I'll run date </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a parent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>어떤 프로그램을 새로운 프로세스로 바꿔주기 때문에 <code class="language-plaintext highlighter-rouge">execlp()</code>가 호출되는 순간 이후의 코드들은 실행되지 않는다.<br /><br /><br /></li>
</ul>

<h1 id="wait-시스템-콜">wait() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">childPID</span><span class="p">;</span>
    <span class="n">S1</span><span class="p">;</span>
    
    <span class="n">childPID</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">childPID</span><span class="p">)</span>
        <span class="c1">// child 프로세스 코드 실행</span>
    <span class="k">else</span> 
        <span class="n">wait</span><span class="p">();</span>
        
    <span class="n">S2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>프로세스 A가 <code class="language-plaintext highlighter-rouge">wait()</code> 시스템 콜을 호출하면 커널은 <code class="language-plaintext highlighter-rouge">child</code>가 종료될 때까지 프로세스 A를 <code class="language-plaintext highlighter-rouge">sleep</code>시킨다.(block 상태)</li>
  <li>자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다.(ready 상태)<br /><br /><br /></li>
</ul>

<h1 id="exit-시스템-콜">exit() 시스템 콜</h1>
<h2 id="프로세스의-자발적-종료">프로세스의 자발적 종료</h2>
<ul>
  <li>마지막 statement 수행 후 <code class="language-plaintext highlighter-rouge">exit()</code> 시스템 콜을 통해 종료</li>
  <li>프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌</li>
</ul>

<h2 id="프로세스의-비자발적-종료">프로세스의 비자발적 종료</h2>
<ul>
  <li>부모 프로세스가 자식 프로세스를 강제 종료시킴
    <ul>
      <li>자식 프로세스가 한계치를 넘어서는 자원 요청시</li>
      <li>자식에게 할당된 태스크가 더 이상 필요하지 않을 때</li>
    </ul>
  </li>
  <li>키보드로 <code class="language-plaintext highlighter-rouge">kill</code>, <code class="language-plaintext highlighter-rouge">break</code>등을 친 경우</li>
  <li>부모가 종료하는 경우 부모 프로세스가 종료되기 전 자식 프로세스들이 먼저 종료된다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스-간-협력">프로세스 간 협력</h1>
<h2 id="독립적-프로세스-independent-process">독립적 프로세스 (Independent process)</h2>
<ul>
  <li>프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.</li>
</ul>

<h2 id="협력-프로세스-cooperating-process">협력 프로세스 (Cooperating process)</h2>
<ul>
  <li>프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.</li>
</ul>

<h2 id="프로세스-간-협력-메커니즘-ipc-interprocess-communication">프로세스 간 협력 메커니즘 (<code class="language-plaintext highlighter-rouge">IPC</code>: Interprocess Communication)</h2>
<h3 id="-메시지를-전달하는-방법">🔸 메시지를 전달하는 방법</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">message passing</code> : 커널을 통해 메시지 전달</li>
</ul>

<h4 id="-주소-공간을-공유하는-방법">🔸 주소 공간을 공유하는 방법</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">shared memory</code> : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음</li>
  <li>물리적 메모리에 매핑할 때 일부 주소공간을 공유하도록 매핑한다.(사전에 시스템 콜을 통해 운영체제에게 보고되어야 한다)</li>
</ul>

<h4 id="-thread">🔸 thread</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">thread</code>는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드들 간에는 주소 공간을 공유하기 때문에 협력이 가능하다. <br /><br /><br /></li>
</ul>

<h1 id="message-passing">Message Passing</h1>
<ul>
  <li>사용자 프로그램끼리는 메시지를 주고받는 것이 불가능하기 때문에 운영체제 커널을 통해서 메시지를 주고받는다.</li>
</ul>

<h2 id="message-system">Message system</h2>
<ul>
  <li>프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템</li>
</ul>

<h2 id="direct-communication">Direct Communication</h2>
<ul>
  <li>통신하려는 프로세스의 이름을 명시적으로 표시해서 메시지를 주고받는 것</li>
</ul>

<h2 id="indirect-communication">Indirect Communication</h2>
<ul>
  <li>mailbox(또는 port)를 통해 메시지를 간접 전달하는 방식<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Operating System" /><category term="CS" /><category term="OS" /><category term="Process" /><summary type="html"><![CDATA[👀 프로세스 생성 (Process Creation) 부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다. 복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다. 프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다. 프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.]]></summary></entry><entry><title type="html">Java) BOJ 1018. 체스판 다시 칠하기</title><link href="http://localhost:4000/boj/boj1018-java/" rel="alternate" type="text/html" title="Java) BOJ 1018. 체스판 다시 칠하기" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1018-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1018-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1018">https://www.acmicpc.net/problem/1018</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다.</li>
  <li>
    <p>지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.</p>
  </li>
  <li>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다.</li>
  <li>
    <p>따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.</p>
  </li>
  <li>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다.</li>
  <li>당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 좀 어렵게 생각해서 체스판을 앞에서부터도 확인하고 뒤에서부터도 확인하고 첫번째줄부터, 맨 아랫줄부터 거꾸로 올라가면서 확인하기 등 불필요한 탐색을 하는 코드를 작성했다.</li>
  <li>
    <p>그러다 답이 안 나와서 구글링 참고함</p>
  </li>
  <li>
    <p><a href="https://st-lab.tistory.com/101">https://st-lab.tistory.com/101</a></p>
  </li>
  <li>8<em>8 체스판을 순회하면서 현재 위치부터 +8칸까지가 체스판 색깔을 만족하는지 검사하는 함수 search()를 작성한 후
메인함수에서 입력 크기만큼 8</em>8씩 이동하면서 search()를 수행하도록 반복문을 작성한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 132 ms</li>
  <li>메모리 : 14312 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/76e4ade331283b450828b10a5fa4c69b.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1018" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1018 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 7568. 덩치</title><link href="http://localhost:4000/boj/boj7568-java/" rel="alternate" type="text/html" title="Java) BOJ 7568. 덩치" /><published>2022-02-24T00:00:00+09:00</published><updated>2022-02-24T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj7568-java</id><content type="html" xml:base="http://localhost:4000/boj/boj7568-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/7568">https://www.acmicpc.net/problem/7568</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다.</li>
  <li>두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 “더 크다”고 말한다.</li>
  <li>예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다.</li>
  <li>
    <p>예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, “덩치”로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.</p>
  </li>
  <li>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 “큰 덩치”의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.</li>
  <li>이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.</li>
</ul>

<p>이름	(몸무게, 키)	덩치 등수<br />
A	(55, 185)	2<br />
B	(58, 183)	2<br />
C	(88, 186)	1<br />
D	(60, 175)	2<br />
E	(46, 155)	5<br /></p>
<ul>
  <li>위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다.</li>
  <li>그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.</li>
  <li>2 ≤ N ≤ 50</li>
  <li>10 ≤ x, y ≤ 200<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음에 너무 어렵게 생각해서 덩치 순서대로 배열을 정렬한 다음 정렬한 배열을 다시 순회하면서 정렬된 순서대로 등수를 매기는 방법을 썼는데 틀렸다.</li>
  <li>
    <p>그 후 질문게시판 반례를 찾아보니까 어렵게 생각할 문제가 아니라 내 앞에 있는 사람이 몇 명인지 세는 문제여서 그렇게 수정하니까 통과되었다.<br /><br /></p>
  </li>
  <li>통과 후 배열 순회 횟수 추가 유무에 따라 실행속도가 궁금해져서</li>
  <li>등수를 배열에 저장한 다음 마지막에 배열을 순회하면서 출력하는 방식 - 14268KB	124ms</li>
  <li>등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 BufferedWriter로 출력하는 방식 - 14416KB 	132ms</li>
  <li>등수를 저장하는 배열을 사용하지 않고 등수를 구하는 즉시 StringBuilder에 저장한 후 출력하는 방식으로 풀어 봤는데 - 15904KB	 144ms</li>
  <li>첫번째가 메모리를 가장 적게 쓰고 속도도 가장 빨랐다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 124 ms</li>
  <li>메모리 : 14268 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/709f749418093dd0e36f58f3c87f37e3.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No7568" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/7568 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">DB) 데이터베이스 관리 시스템</title><link href="http://localhost:4000/database/db-02-management-system/" rel="alternate" type="text/html" title="DB) 데이터베이스 관리 시스템" /><published>2022-02-23T00:00:00+09:00</published><updated>2022-02-23T00:00:00+09:00</updated><id>http://localhost:4000/database/db-02-management-system</id><content type="html" xml:base="http://localhost:4000/database/db-02-management-system/"><![CDATA[<h1 id="데이터베이스-관리-시스템의-등장-배경">데이터베이스 관리 시스템의 등장 배경</h1>
<h2 id="파일-시스템file-system">파일 시스템(file system)</h2>
<ul>
  <li>과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어</li>
  <li>응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함</li>
</ul>

<h3 id="파일-시스템의-문제점">파일 시스템의 문제점</h3>
<ul>
  <li>같은 내용의 데이터가 여러 파일에 중복 저장된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">데이터 중복성</code></li>
      <li>저장 공간의 낭비는 물론 <code class="language-plaintext highlighter-rouge">데이터 일관성</code>과 <code class="language-plaintext highlighter-rouge">데이터 무결성</code> 유지가 어렵다.<br /><br /></li>
    </ul>
  </li>
  <li>응용 프로그램이 데이터 파일에 종속적이다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">데이터 종속성</code></li>
      <li>사용하는 파일의 구조를 변경하면 응용 프로그램도 함께 변경해야 한다.<br /><br /></li>
    </ul>
  </li>
  <li>데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.</li>
  <li>응용 프로그램 개발이 쉽지 않다.<br /><br /><br /></li>
</ul>

<h1 id="데이터베이스-관리-시스템의-정의-및-특성">데이터베이스 관리 시스템의 정의 및 특성</h1>
<h2 id="데이터베이스-관리-시스템dbms-database-management-system">데이터베이스 관리 시스템(DBMS, DataBase Management System)</h2>
<ul>
  <li>파일 시스템의 문제를 해결하기 위해 제시된 소프트웨어</li>
  <li>조직에 필요한 데이터를 데이터베이스에 통합하여 저장하고 관리한다.</li>
</ul>

<h2 id="데이터베이스-관리-시스템의-주요-기능">데이터베이스 관리 시스템의 주요 기능</h2>
<ul>
  <li>정의 기능 : 데이터베이스 구조를 정의하거나 수정할 수 있다.</li>
  <li>조작 기능 : 데이터를 삽입, 삭제, 수정, 검색하는 연산을 할 수 있다.</li>
  <li>제어 기능 : 데이터를 항상 정확하고 안전하게 유지할 수 있다.</li>
</ul>

<h3 id="장점">장점</h3>
<ul>
  <li>데이터 중복을 통제할 수 있다.</li>
  <li>데이터 독립성이 확보된다.</li>
  <li>데이터를 동시 공유할 수 있다.</li>
  <li>데이터 보안이 향상된다.</li>
  <li>데이터 무결성을 유지할 수 있다.</li>
  <li>표준화할 수 있다.</li>
  <li>장애 발생 시 회복이 가능하다.</li>
  <li>응용 프로그램 개발 비용이 줄어든다.</li>
</ul>

<h3 id="단점">단점</h3>
<ul>
  <li>(경제적, 컴퓨터 자원 포함)비용이 많이 든다.</li>
  <li>백업과 회복 방법이 복잡하다.</li>
  <li>중앙 집중 관리로 인한 취약점이 존재한다.<br /><br /><br /></li>
</ul>

<h1 id="데이터베이스-관리-시스템의-발전-과정">데이터베이스 관리 시스템의 발전 과정</h1>
<h2 id="1세대--네트워크-dbms-계층-dbms-1960--1970">1세대 : 네트워크 DBMS, 계층 DBMS (1960 ~ 1970)</h2>
<ul>
  <li>네트워크 DBMS : 데이터베이스를 계층 형태로 구성
    <ul>
      <li>변경이 어렵다.</li>
      <li>예) IDS(Integrated Data Store)<br /><br /></li>
    </ul>
  </li>
  <li>계층 DBMS : 데이터베이스를 트리 형태로 구성
    <ul>
      <li>구조변경 및 복잡한 현실세계 반영이 어렵다.</li>
      <li>예) IMS(Information Management System)<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="2세대--관계-dbms-1980-">2세대 : 관계 DBMS (1980 ~)</h2>
<ul>
  <li>관계 DBMS : 데이터베이스를 테이블 형태로 구성
    <ul>
      <li>이해하기 쉽다.</li>
      <li>예) 오라클(Oracle), MS SQL 서버, 액세스(Access), 인포믹스(Informix), MySQL<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="3세대--객체지향-dbms-1980-후반--객체관계-dbms-1990-후반-">3세대 : 객체지향 DBMS (1980 후반 ~), 객체관계 DBMS (1990 후반 ~)</h2>
<ul>
  <li>객체지향 DBMS : 객체를 이용해 데이터베이스 구성
    <ul>
      <li>예) 오투(O2), 온투스(ONTOS), 젬스톤(GemStone)<br /><br /></li>
    </ul>
  </li>
  <li>
    <p>객체관계 DBMS : 객체 DBMS + 관계 DBMS<br /><br /></p>
  </li>
  <li>현대에는 이해하기 쉬운 2세대 RDBMS를 주로 사용하지만 객체지향 DBMS의 점유율도 점차 높아지고 있다.<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1163794">데이터베이스의 원리와 응용 - 한양대학교 KOCW 공개 강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Database" /><category term="DB" /><category term="DBMS" /><category term="RDBMS" /><summary type="html"><![CDATA[데이터베이스 관리 시스템의 등장 배경 파일 시스템(file system) 과거에 이용하던 시스템으로 데이터를 파일로 관리하기 위하여 파일을 생성, 삭제, 수정, 검색하는 기능을 제공하는 소프트웨어 응용 프로그램마다 필요한 데이터를 별도의 파일로 관리함]]></summary></entry></feed>