<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-28T02:19:33+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">OS) CPU Scheduling</title><link href="http://localhost:4000/operating%20system/OS-05-Cpu-scheduling/" rel="alternate" type="text/html" title="OS) CPU Scheduling" /><published>2022-02-28T00:00:00+09:00</published><updated>2022-02-28T00:00:00+09:00</updated><id>http://localhost:4000/operating%20system/OS-05-Cpu-scheduling</id><content type="html" xml:base="http://localhost:4000/operating%20system/OS-05-Cpu-scheduling/"><![CDATA[<h1 id="-cpu-burst-time">👀 CPU-Burst time</h1>
<ul>
  <li>프로세스의 실행은 <code class="language-plaintext highlighter-rouge">CPU</code>를 얻어서 작업을 수행하는 것과 <code class="language-plaintext highlighter-rouge">I/O</code> 작업을 수행하는 것으로 나눌 수 있다.</li>
  <li>이 때 <code class="language-plaintext highlighter-rouge">CPU</code>만 쓰면서 <code class="language-plaintext highlighter-rouge">Instruction</code>을 실행하는 단계는 <code class="language-plaintext highlighter-rouge">CPU burst</code>라 하고 <code class="language-plaintext highlighter-rouge">I/O</code>만 실행하는 단계는 <code class="language-plaintext highlighter-rouge">I/O burst</code>라 한다.</li>
  <li>현재 프로세스가 <code class="language-plaintext highlighter-rouge">CPU</code>를 사용중이라면 다른 프로세스는 사용이 끝날 때까지 기다려야 하겠지만 <code class="language-plaintext highlighter-rouge">I/O</code> 작업중이라면 다른 프로세스가 <code class="language-plaintext highlighter-rouge">CPU</code>를 쓸 수 있다.</li>
  <li>프로세스의 종류는 여러 가지가 있기 때문에 시스템 자원을 효율적으로 쓸 수 있도록 <code class="language-plaintext highlighter-rouge">CPU 스케줄링</code>이 필요하다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스의-특성-분류">프로세스의 특성 분류</h1>
<h2 id="io-bound-process">I/O-bound process</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>를 잡고 계산하는 시간보다 <code class="language-plaintext highlighter-rouge">I/O</code>에 많은 시간이 필요한 job (CPU burst가 아주 짧다)</li>
  <li>주로 사람과 Interactive하는 job</li>
</ul>

<h2 id="cpu-bound-process">CPU-bound process</h2>
<ul>
  <li>계산 위주의 job (CPU burst가 아주 길다)<br /><br /><br /></li>
</ul>

<h1 id="cpu-scheduler">CPU Scheduler</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Ready</code> 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.</li>
</ul>

<h2 id="dispatcher">Dispatcher</h2>
<ul>
  <li>CPU의 제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘긴다.</li>
  <li>이 과정을 context switch(문맥 교환)라 한다.</li>
</ul>

<h2 id="cpu-스케줄링이-필요한-경우">CPU 스케줄링이 필요한 경우</h2>
<ul>
  <li>Running -&gt; Blocked (예: I/O 요청하는 시스템 콜)</li>
  <li>Running -&gt; Ready (예: 할당시간 만료로 timer interrupt)</li>
  <li>Blocked -&gt; Ready (얘: I/O 완료 후 인터럽트)</li>
  <li>
    <p>Terminate<br /><br /></p>
  </li>
  <li>스케줄링에는 강제로 빼앗지 않고 자진 반납하는 <code class="language-plaintext highlighter-rouge">non-preemptive</code>와 강제로 빼앗는 <code class="language-plaintext highlighter-rouge">preemptive</code>가 있다.</li>
  <li>현대 대부분의 프로세서는 <code class="language-plaintext highlighter-rouge">preemptive</code>를 사용한다.<br /><br /><br /></li>
</ul>

<h1 id="스케줄링-성능-척도">스케줄링 성능 척도</h1>
<ul>
  <li>CPU utilization(이용률) : <code class="language-plaintext highlighter-rouge">CPU</code>가 얼마나 쉼 없이 일하는지</li>
  <li>Throughput(처리량) : 단위 시간동안 처리하는 작업의 양이 얼마나 많은지</li>
  <li>Turnaround time(소요시간, 반환시간) : 프로세스가 CPU를 얻어서 작업을 시작하고 끝날 때까지 걸린 총 시간(대기시간 포함)</li>
  <li>Waiting time(대기 시간) : Ready queue에서 CPU를 얻을 때까지 기다린 시간. 작업 시간은 제외하고 순수하게 기다린 시간만 본다.</li>
  <li>Response tiem(응답 시간) : (time-sharing 시스템에서) 처음으로 CPU를 얻어서 작업을 시작하기까지 걸린 시간<br /><br /><br /></li>
</ul>

<h1 id="스케줄링-알고리즘">스케줄링 알고리즘</h1>
<h2 id="fcfs-first-come-first-serve">FCFS (First-Come First-Serve)</h2>
<ul>
  <li>선착순 방식으로 먼저 온 순서대로 CPU를 얻어서 작업을 시작하고 나중에 온 프로세스들은 이전 작업이 끝날 때까지 기다린다.</li>
  <li>오래 걸리는 작업이 먼저 와서 계속 수행되고 시간이 짧은 작업들이 뒤에서 기다리고 있는 경우에는 효율적이지 않다. 이런 경우엔 평균 대기 시간이 길어짐</li>
  <li>짧은 작업이 먼저 와서 처리된 후 오래 걸리는 작업을 처리하게 되면 평균 대기 시간이 짧아지지만 늘 이렇게 프로세스가 도착하지는 않을 것이니까 일반적으로는 효율적이지 않은 방식이라고 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Convoy effect</code> : 수행 시간이 긴 작업이 먼저 와서 처리되는 동안 짧은 작업들은 수행되지 못하고 기다리고 있는 현상</li>
</ul>

<h2 id="sjf-shortest-job-first">SJF (Shortest-Job-First)</h2>
<ul>
  <li>도착하는 프로세스마다 CPU burst time을 예측해서 CPU burst time이 가장 짧은 프로세스를 제일 먼저 스케줄한다. 그래서 평균 대기시간이 가장 짧다.</li>
  <li>두 가지 방식이 있다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Non-preemptive</code> : 일단 CPU를 잡으면 다음 작업이 지금 수행 중인 작업보다 실행 시간이 더 짧아도 지금 작업이 완료되기 전 까지는 CPU를 넘겨주지 않는다.</li>
      <li><code class="language-plaintext highlighter-rouge">Preemptive</code> : 현재 수행 중인 프로세스 다음에 온 프로세스의 수행 시간이 더 짧으면 CPU를 뺏어서 시간이 더 짧은 프로세스에게 넘긴다. 근데 이러다보면 수행 시간이 긴 프로세스는 평생 CPU를 얻지 못 할 수도 있어서(<code class="language-plaintext highlighter-rouge">starvation</code> 기아 현상) 아주 좋은 방법은 아니다.</li>
    </ul>
  </li>
</ul>

<h3 id="다음-cpu-burst-time-예측-방법">다음 CPU Burst time 예측 방법</h3>
<ul>
  <li>완벽하게 계산하기 보다는 과거 데이터로부터 추정(estimate)하는 방식을 사용한다.</li>
  <li>n번째 프로세스의 실제 CPU 사용 시간과 n번째 프로세스의 CPU 사용 시간을 예측했던 값들을 일정 비율씩 곱해서 더해주는 방식으로 n + 1번째 프로세스의 CPU burst time을 예측한다.</li>
</ul>

<h2 id="priority-scheduling">Priority Scheduling</h2>
<ul>
  <li>우선순위 스케줄링이라 하며 프로세스에게 부여된 우선순위가 높은 순서대로 CPU를 할당한다.</li>
  <li>이것 또한 나중에 도착했지만 우선순위가 더 높은 프로세스에 대해 <code class="language-plaintext highlighter-rouge">Preemptive</code>와 <code class="language-plaintext highlighter-rouge">Non-preemptive</code> 방식으로 나뉜다.</li>
  <li>우선순위 스케줄링의 문제점 또한 우선순위가 낮은 프로세스는 평생 CPU를 얻지 못하는 <code class="language-plaintext highlighter-rouge">Starvation</code> 현상이 생길 수 있다는 것이다.</li>
  <li>그래서 <code class="language-plaintext highlighter-rouge">Aging</code> 기법을 통해 우선순위가 낮아도 오래 기다렸으면 우선순위를 높여주는 방식을 쓴다.</li>
</ul>

<h2 id="round-robin-rr">Round Robin (RR)</h2>
<ul>
  <li>대부분의 운영체제에서 사용하는 방식으로 각 프로세스는 동일한 크기의 <code class="language-plaintext highlighter-rouge">CPU 할당 시간(time quantum)</code>을 가지고 할당된 시간이 끝나면 <code class="language-plaintext highlighter-rouge">CPU</code>를 다음 프로세스에게 넘겨주고 <code class="language-plaintext highlighter-rouge">Ready queue</code>의 맨 뒤에 가서 다시 줄을 서는 방식이다.</li>
  <li>그래서 모든 프로세스는 <code class="language-plaintext highlighter-rouge">Ready queue</code>의 크기만큼 기다리게 되는데 수행 시간이 짧은 프로세스는 그만큼 빨리 <code class="language-plaintext highlighter-rouge">CPU</code>를 쓰고 <code class="language-plaintext highlighter-rouge">Ready queue</code>에서 빠져나가기 때문에 각 프로세스의 대기 시간은 본인의 <code class="language-plaintext highlighter-rouge">CPU</code> 사용 시간에 비례하게 된다.</li>
  <li>할당 시간이 너무 크면 <code class="language-plaintext highlighter-rouge">FCFS</code>와 다를 바가 없고 너무 작으면 <code class="language-plaintext highlighter-rouge">context switch</code>가 자주 일어나 오버헤드가 커지기 때문에 적절한 중간값을 찾는 것이 좋다.</li>
</ul>

<h2 id="multilevel-queue">Multilevel Queue</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Ready queue</code>를 작업의 종류에 따라 여러 개로 분할해서 각 큐마다 다른 스케줄링 알고리즘을 적용한다.</li>
  <li>예를 들어 <code class="language-plaintext highlighter-rouge">interactive</code>한 작업들이 담긴 큐라면 <code class="language-plaintext highlighter-rouge">RR</code> 스케줄링을 적용하고 <code class="language-plaintext highlighter-rouge">CPU burst</code> 작업들이 담긴 큐라면 <code class="language-plaintext highlighter-rouge">FCFS</code> 스케줄링을 적용하는 것이다.</li>
  <li>이 때 <code class="language-plaintext highlighter-rouge">Starvation</code>을 방지하기 위해서 각 큐에 <code class="language-plaintext highlighter-rouge">CPU time</code>을 적절한 비율로 할당한다.
    <ul>
      <li>예) <code class="language-plaintext highlighter-rouge">RR</code> 스케줄링 큐에는 80%를 할당하고 <code class="language-plaintext highlighter-rouge">FCFS</code> 스케줄링 큐에는 20% 할당</li>
    </ul>
  </li>
</ul>

<h2 id="multilevel-feedback-queue">Multilevel Feedback Queue</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Multilevel Queue</code>에서는 한 번 큐가 결정되면 다른 큐로 이동할 수 없어서 나중에 프로세스의 <code class="language-plaintext highlighter-rouge">burst time</code>이 바뀌게 되어도 계속 맞지 않는 큐에 있어야 할 수 있다.</li>
  <li>이것을 보완한 것이 <code class="language-plaintext highlighter-rouge">Multilevel Feedback Queue</code>인데 프로세스가 다른 큐로 이동이 가능하다.</li>
  <li><code class="language-plaintext highlighter-rouge">Aging</code>을 이런 방식으로 구현할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Multilevel Feedback Queue scheduler</code>를 정의하는 파라미터들
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Queue</code>에 있는 작업의 수 : 작업의 수가 적은 큐에 먼저 할당</li>
      <li>각 큐의 스케줄링 알고리즘</li>
      <li>프로세스를 상위 큐로 보내는 기준 (예: <code class="language-plaintext highlighter-rouge">CPU</code> 사용시간이 짧을 수록)</li>
      <li>프로세스를 하위 큐로 보내는 기준 (예: <code class="language-plaintext highlighter-rouge">CPU</code> 사용시간이 길수록)</li>
      <li>프로세스가 <code class="language-plaintext highlighter-rouge">CPU</code> 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준</li>
    </ul>
  </li>
</ul>

<h2 id="multiple-processor-schduling">Multiple-Processor Schduling</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CPU</code>가 여러 개인 경우 스케줄링이 더욱 복잡해진다.</li>
  <li><code class="language-plaintext highlighter-rouge">Homogeneous processor</code>(동종)인 경우
    <ul>
      <li>큐에 한 줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.</li>
      <li>반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 더 복잡해짐</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Load sharing</code>
    <ul>
      <li>일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요</li>
      <li>별개의 큐를 두는 방법 vs. 공동 큐를 사용하는 방법</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Symmetric Multiprocessing (SMP)</code>
    <ul>
      <li>각 프로세서가 각자 알아서 스케줄링 결정</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Asymmetric multiprocessing</code>
    <ul>
      <li>하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름</li>
    </ul>
  </li>
</ul>

<h2 id="real-time-scheduling">Real-Time Scheduling</h2>
<ul>
  <li>데드 라인이 있는 작업들에 적용되는 스케줄링</li>
  <li><code class="language-plaintext highlighter-rouge">Hard real-time systems</code> : 반드시 정해진 시간 안에 끝내도록 스케줄링</li>
  <li><code class="language-plaintext highlighter-rouge">Soft real-time computing</code> : 데드 라인을 조금 어겨도 괜찮기 때문에 <code class="language-plaintext highlighter-rouge">Soft real-time task</code>는 일반 프로세스에 비해 높은 우선순위를 갖게 한다.</li>
</ul>

<h2 id="thread-scheduling">Thread Scheduling</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Local Scheduling</code> : <code class="language-plaintext highlighter-rouge">User level thread</code>일 경우 사용자 수준의 스레드 라이브러리에 의해 어떤 스레드를 스케줄 할 지 결정</li>
  <li><code class="language-plaintext highlighter-rouge">Global Scheduling</code> : <code class="language-plaintext highlighter-rouge">Kernal level thread</code>인 경우 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 스레드를 스케줄 할 지 결정</li>
</ul>

<h2 id="스케줄링-알고리즘-평가">스케줄링 알고리즘 평가</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Queueing models</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">확률 분포</code>로 주어지는 <code class="language-plaintext highlighter-rouge">arrival rate</code>와 <code class="language-plaintext highlighter-rouge">service rate</code> 등을 통해 각종 <code class="language-plaintext highlighter-rouge">performance index</code> 값을 계산하는데 요즘은 잘 안 쓴다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Implementation (구현) &amp; Measurement (성능 측정)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">실제 시스템</code>에 알고리즘을 <code class="language-plaintext highlighter-rouge">구현</code>하여 실제 작업(<code class="language-plaintext highlighter-rouge">workload</code>)에 대해서 성능을 <code class="language-plaintext highlighter-rouge">측정</code> 비교하는 방식으로 많이 쓰는 방식</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Simulation (모의 실험)</code>
    <ul>
      <li>알고리즘을 <code class="language-plaintext highlighter-rouge">모의 프로그램</code>으로 작성 후 <code class="language-plaintext highlighter-rouge">trace</code>를 입력으로 하여 결고 비교<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Operating System" /><category term="CS" /><category term="OS" /><category term="CpuScheduling" /><summary type="html"><![CDATA[👀 CPU-Burst time 프로세스의 실행은 CPU를 얻어서 작업을 수행하는 것과 I/O 작업을 수행하는 것으로 나눌 수 있다. 이 때 CPU만 쓰면서 Instruction을 실행하는 단계는 CPU burst라 하고 I/O만 실행하는 단계는 I/O burst라 한다. 현재 프로세스가 CPU를 사용중이라면 다른 프로세스는 사용이 끝날 때까지 기다려야 하겠지만 I/O 작업중이라면 다른 프로세스가 CPU를 쓸 수 있다. 프로세스의 종류는 여러 가지가 있기 때문에 시스템 자원을 효율적으로 쓸 수 있도록 CPU 스케줄링이 필요하다.]]></summary></entry><entry><title type="html">컴퓨터 네트워크) 데이터 통신</title><link href="http://localhost:4000/computer%20network/computer-network-02/" rel="alternate" type="text/html" title="컴퓨터 네트워크) 데이터 통신" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/computer%20network/computer-network-02</id><content type="html" xml:base="http://localhost:4000/computer%20network/computer-network-02/"><![CDATA[<h1 id="전송-모드">전송 모드</h1>
<h2 id="병렬-전송parallel-transfer">병렬 전송(Parallel Transfer)</h2>
<ul>
  <li>여러 전송라인을 통해 여러 비트들을 동시에 전송</li>
  <li>두 장치들간의 거리가 짧은 경우에 일반적으로 사용
    <ul>
      <li>예) PC에서 프린터로 전송하는 것</li>
      <li>예) 컴퓨터와 주변 장치들간의 연결</li>
    </ul>
  </li>
  <li>긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.</li>
</ul>

<h2 id="직렬-전송serial-transfer">직렬 전송(Serial Transfer)</h2>
<ul>
  <li>하나의 전송라인을 사용하여 하나씩 모든 비트를 보낸다.</li>
  <li>긴 거리를 전송할 때 병렬 전송에 비해 적은 비용이 들고 신뢰성 증가</li>
  <li>하지만 비트를 하나씩 보내는 만큼 병렬 전송에 비해 느리다.</li>
</ul>

<h2 id="비동기식-전송">비동기식 전송</h2>
<ul>
  <li>한 번에 한 문자씩 보내거나 받는 방식</li>
  <li>문자는 7~8 비트로 구성되며, 문자의 앞에 시작비트(Start bit)를, 끝에는 정지비트(Stop bit)를 첨가해서 보냄</li>
  <li>송신측과 수신측 사이에 동기를 맞추기 위한 클럭 신호를 사용하지 않음</li>
  <li>시작비트는 수신측에 문자에 해당하는 비트가 따라올 것이라는 것을 알려주는 역할</li>
  <li>문자 비트들을 모두 수신하면 정지비트가 뒤따른다.</li>
  <li>키보드와 프린터 같이 느린 장치들을 위해 사용되며 높은 오버헤드를 가진다.</li>
</ul>

<h2 id="동기식-전송">동기식 전송</h2>
<ul>
  <li>정해진 수 만큼의 문자들을 하나의 그룹(프레임)으로 만들어서 일시에 전송하는 방법</li>
  <li>일반적으로 비동기식 전송에 비해서 더 빠르다.</li>
  <li>송신측과 수신측이 하나의 기준 클럭으로 동기신호를 맞추어 동작</li>
  <li>동기화를 위한 클럭라인이 필요하다.</li>
  <li>일반적으로 많이 사용하는 방식</li>
</ul>

<h3 id="바이트기반-전송byte-oriented-transmission">바이트기반 전송(Byte-Oriented Transmission)</h3>
<ul>
  <li>각 프레임을 바이트(문자)의 연속으로 간주하는 방식</li>
  <li>STX(Start of Text), ETX(End of Text), DLE(Data-Link Escape)로 프레임의 시작과 끝을 구분</li>
  <li>예) BISYNC, PPP, DDCMP 등</li>
</ul>

<h3 id="비트기반-전송bit-oriented-transmission">비트기반 전송(Bit-Oriented Transmission)</h3>
<ul>
  <li>일반적으로 많이 사용하는 방식</li>
  <li>각 프레임을 비트의 연속으로 간주하는 방식</li>
  <li>프레임의 시작과 끝을 알리기 위해 플래그(Flag)라고 하는 특수한 비트 패턴, “01111110”을 사용</li>
  <li>예) 인터넷에서의 이더넷(Ethernet)과 HDLC(High-level Data Link Control) 등<br /><br /></li>
</ul>

<h2 id="비트-스터핑bit-stuffing">비트 스터핑(Bit Stuffing)</h2>
<ul>
  <li>비트기반 전송에서 프레임의 시작과 끝이 아닌 데이터 필드에 프레임의 시작과 끝을 알리는 플래그가 포함될 수 있다. 그러면 전송이 아직 끝나지 않았는데 수신측에서는 전송이 끝난 것으로 간주하고 데이터 받기를 중단할 것이다.</li>
  <li>그래서 이걸 해결하기 위해 사용하는 기법이 비트 스터핑 기법이다.</li>
</ul>

<h3 id="비트-스터핑-방법">비트 스터핑 방법</h3>
<ul>
  <li>송신측 : 보낼 프레임의 데이터 필드에서 연속된 5개의 1을 발견하면 다섯 번째 1 뒤에 0을 추가함. 이렇게 하면 시작과 끝 부분 외에는 1이 연속해서 6개 위치하는 경우가 없어진다.</li>
  <li>수신측 : 연속되는 5개의 1이 수신되고 나서 0이 수신되면 이 0은 비트 스터핑 된 것이라 간주하고 제거함<br /><br /><br /></li>
</ul>

<h2 id="단방향-반이중-전이중">단방향, 반이중, 전이중</h2>
<h3 id="단방향simplex">단방향(Simplex)</h3>
<ul>
  <li>한 방향으로만 신호 전송이 가능한 형태</li>
  <li>예) 공항 모니터, 프린터, TV 방송</li>
</ul>

<h3 id="반이중half-duplex">반이중(Half duplex)</h3>
<ul>
  <li>양쪽 방향에서 보내고 받을 수 있지만 교대로 전송만 가능</li>
  <li>예) 무전기</li>
</ul>

<h3 id="전이중full-duplex">전이중(Full duplex)</h3>
<ul>
  <li>양쪽 호스트가 동시에 데이터전송 가능</li>
  <li>예) 인터넷<br /><br /><br /></li>
</ul>

<h1 id="교환-기술">교환 기술</h1>
<ul>
  <li>N개의 통신 장비를 각각 직접 연결하면 필요한 연결선의 갯수가 너무 많아진다.</li>
  <li>이것에 대한 해결방안으로 각각의 장비들은 통신망에 연결한 뒤 통신망을 이용해 서로 데이터를 주고 받는데 이걸 좀 더 효과적으로 운영하기 위해 교환 기술(Switching Technology)을 사용한다.</li>
</ul>

<h2 id="회선-교환circuit-switching">회선 교환(Circuit Switching)</h2>
<ul>
  <li>공중 전화 망에서 사용</li>
  <li>데이터 전송 과정 : 회선 설정 - 데이터 전송 - 회선 해제</li>
  <li>단점 : 회선을 설정하고 해제할 때까지 채널의 대역폭을 독점하기 때문에 다른 회선을 동시에 사용할 수 없다.</li>
  <li>장점 : 단점의 이유로 신뢰성 있는 데이터 전송이 가능하며 일정한 데이터 전송률로 데이터를 전송한다.</li>
  <li>회선 설정(call setup) 시간이 필요하며 링크 및 스위칭 장비가 성능에 영향을 미친다.<br /><br /><br /></li>
</ul>

<h1 id="오류-검출과-교정기법">오류 검출과 교정기법</h1>
<h2 id="해밍코드오류-교정-코드">해밍코드(오류 교정 코드)</h2>
<ul>
  <li>N 비트의 데이터에 k개의 패리티 비트를 더하여 (n+k)비트의 코드워드(Codeword)를 생성</li>
  <li>일종의 비트마스킹 기법으로 오류를 검출할 수 있다.</li>
  <li>N개의 비트를 사용해서 오류가 생긴 비트를 검출할 것이기 때문에 N 비트 데이터와 k개의 패리티 비트를 사용한다고 할 때 <code class="language-plaintext highlighter-rouge">2^k &gt;= n + k + 1</code> 라는 수식이 성립해야 한다.(1을 더해주는 이유는 오류가 생기지 않는 경우도 표현하기 위해서)</li>
  <li>수신측은 <code class="language-plaintext highlighter-rouge">XOR</code> 연산을 통해 syndrome을 계산해서 syndrome을 10진수로 바꾼 값이 오류발생 위치(syndrome의 모든 비트가 0이면 오류가 없음)<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=5959f58996c6bd25">데이터 통신과 컴퓨터 네트워크 - 동서대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Network" /><category term="CS" /><category term="Network" /><summary type="html"><![CDATA[전송 모드 병렬 전송(Parallel Transfer) 여러 전송라인을 통해 여러 비트들을 동시에 전송 두 장치들간의 거리가 짧은 경우에 일반적으로 사용 예) PC에서 프린터로 전송하는 것 예) 컴퓨터와 주변 장치들간의 연결 긴 거리를 병렬 전송으로 전송하면 비용이 많이 들어서 효율적이지 않다.]]></summary></entry><entry><title type="html">Java) BOJ 18870. 좌표 압축</title><link href="http://localhost:4000/boj/boj18870-java/" rel="alternate" type="text/html" title="Java) BOJ 18870. 좌표 압축" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj18870-java</id><content type="html" xml:base="http://localhost:4000/boj/boj18870-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/18870">https://www.acmicpc.net/problem/18870</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>수직선 위에 N개의 좌표 X1, X2, …, XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.</p>
  </li>
  <li>
    <p>Xi를 좌표 압축한 결과 X’i의 값은 Xi &gt; Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.</p>
  </li>
  <li>
    <p>X1, X2, …, XN에 좌표 압축을 적용한 결과 X’1, X’2, …, X’N를 출력해보자.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 N이 주어진다.</li>
  <li>둘째 줄에는 공백 한 칸으로 구분된 X1, X2, …, XN이 주어진다.</li>
  <li>1 ≤ N ≤ 1,000,000</li>
  <li>-109 ≤ Xi ≤ 109<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 X’1, X’2, …, X’N을 공백 한 칸으로 구분해서 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력받은 수 배열에서 i번째 수보다 작은 수의 갯수를 세어서 i번째에 출력하면 되는데 i번째 수보다 작은 수가 몇 개인지 알려면 오름차순으로 정렬을 해 봐야 한다.</li>
  <li>오름차순으로 정렬을 해 보면 i번째 수의 앞에 있는 수들은 다 작은 수들이니까 배열을 순회하면서 그 수가 몇 개인지 세면 i번째 수를 압축한 수가 된다.</li>
  <li>
    <p>정답 출력 형식을 보면 입력된 숫자의 순서대로 압축한 수를 출력해야 하는데 입력 배열을 정렬해 버리면 순서가 흐트러져서 정답 형식으로 출력할 수 없다. 그래서 입력 배열과 같은 임시 배열을 만들어 정렬한다.<br /></p>
  </li>
  <li>그런데 최대 백만개가 입력으로 주어지는데 2중 for문을 통해 하나씩 비교하는 <code class="language-plaintext highlighter-rouge">O(n^2)</code> 알고리즘을 사용하면 시간초과를 받을 것이기 때문에 정렬 알고리즘은 <code class="language-plaintext highlighter-rouge">O(n log n)</code> 시간복잡도를 가지는 것을 쓰는 것이 좋다.</li>
  <li>그리고 입력으로 중복된 수가 들어오는데 예제의 답을 보면 중복된 수는 카운트하지 않는다.</li>
  <li>즉 1, 1, 2 일 때 2보다 작은 수인 1이 2개 있는데 이럴 경우 답은 0, 0, 1이 되어야 한다. 2보다 작은 수는 1개가 되어야 한다.</li>
  <li>
    <p>그래서 오름차순으로 정렬하고 난 후 중복되는 숫자들은 제거해 주어야 한다. 중복 숫자를 제거하지 않으면 i번째 수보다 작은 수를 셀 때 오차가 생길 것이다.<br /></p>
  </li>
  <li>중복된 숫자들을 제거하고 나면 &lt;i번째 숫자, i번째 숫자보다 작은 숫자의 갯수&gt; pair를 저장하는 map을 만들어서 각 원소를 삽입해준다.</li>
  <li>
    <p>그 다음 마지막으로 입력 원본 배열을 순회하면서 map에서 i번째 원소를 key로 가지는 value를 찾아 출력하면 된다.<br /></p>
  </li>
  <li>시간제한이 2초인데 2788ms로 통과된 거 보면 자바는 느려서 시간을 좀 더 주는 것 같다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 2788 ms</li>
  <li>메모리 : 254876 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/1cd7a372bd0ad6186aadcb222ca3afc6.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No18870" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/18870 제한 시간 제한 : 2 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 1181. 단어 정렬</title><link href="http://localhost:4000/boj/boj1181-java/" rel="alternate" type="text/html" title="Java) BOJ 1181. 단어 정렬" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1181-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1181-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1181">https://www.acmicpc.net/problem/1181</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</li>
</ul>

<ol>
  <li>길이가 짧은 것부터</li>
  <li>길이가 같으면 사전 순으로<br /><br /></li>
</ol>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>Collections.sort와 Comparator 람다식을 이용해 구현했다.</li>
  <li>마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 392 ms</li>
  <li>메모리 : 23208 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/55e1fca4233f64a9249c59ee80aeb16f.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1181" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1181 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11651. 좌표 정렬하기2</title><link href="http://localhost:4000/boj/boj11651-java/" rel="alternate" type="text/html" title="Java) BOJ 11651. 좌표 정렬하기2" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11651-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11651-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11651">https://www.acmicpc.net/problem/11651</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>11650번에서 썼던 Comparator 함수에서 기준값을 x에서 y로만 바꿔주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 860 ms</li>
  <li>메모리 : 49896 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/bafcfe58127991148c9f70bab678805d.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11651" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11651 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11650. 좌표 정렬하기</title><link href="http://localhost:4000/boj/boj11650-java/" rel="alternate" type="text/html" title="Java) BOJ 11650. 좌표 정렬하기" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11650-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11650-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11650">https://www.acmicpc.net/problem/11650</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 <code class="language-plaintext highlighter-rouge">Pair</code> 클래스에서 <code class="language-plaintext highlighter-rouge">Comparable</code>을 구현해서 썼는데 리턴값을 잘못 설정했는지 계속 7%에서 틀렸다 ㅠ.ㅠ</li>
  <li>그래서 구글링해서 Comparator 람다식으로 바꾸고 통과함<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 800 ms</li>
  <li>메모리 : 51232 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/49b9efbb416fe3905a7e48e17b4d3990.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11650" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11650 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 10814. 나이순 정렬</title><link href="http://localhost:4000/boj/boj10814-java/" rel="alternate" type="text/html" title="Java) BOJ 10814. 나이순 정렬" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10814-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10814-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10814">https://www.acmicpc.net/problem/10814</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.</li>
</ul>

<ol>
  <li>길이가 짧은 것부터</li>
  <li>길이가 같으면 사전 순으로<br /><br /></li>
</ol>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>Collections.sort와 Comparator 람다식을 이용해 구현했다.</li>
  <li>마지막에 정렬한 값을 출력할 때엔 equals를 통한 value 비교를 해서 중복값은 걸러지도록 했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 392 ms</li>
  <li>메모리 : 23208 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/978be8ad9674667c38e12894cd1c7144.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10814" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10814 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">JSP) 서블릿</title><link href="http://localhost:4000/jsp/JSP-servlet/" rel="alternate" type="text/html" title="JSP) 서블릿" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-servlet</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-servlet/"><![CDATA[<h1 id="-서블릿servlet이란">👀 서블릿(Servlet)이란?</h1>
<ul>
  <li>자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 <code class="language-plaintext highlighter-rouge">JSP</code> 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다.</li>
  <li>즉 <code class="language-plaintext highlighter-rouge">JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class)</code> 이런 과정을 거치게 된다.</li>
</ul>

<h2 id="서블릿-작성-규칙">서블릿 작성 규칙</h2>
<p>1) javax.servlet.Servlet 인터페이스 구현<br />
2) 1)의 구현이 어려운 경우 javax.servlet.http.HttpServlet 클래스 상속(일반적으로 사용)<br />
3) doGet()/ doPost() 생성(오버라이딩), HttpServletRequest/ HttpServletResponse 객체 구현<br />
4) IOException/ ServletException을 처리해야 함<br />
5) web.xml 파일을 통해서 주소 매핑 (어노테이션 처리)<br /></p>

<h2 id="서블릿-실행-구조">서블릿 실행 구조</h2>

<p><img src="../../assets/images/servletProcess.png" /><br /><br /><br /></p>

<h1 id="서블릿-클래스-만들기">서블릿 클래스 만들기</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.RequestDispatcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.itwillbs.test.Student</span><span class="o">;</span>

<span class="c1">// 서블릿 - jsp코드 + java코드를 함께 수행할 수 있는 파일</span>
<span class="c1">// 서블릿 클래스 상속받으면 서블릿이 됨</span>

<span class="c1">// http://localhost:8090/JSP6/ex1</span>
<span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/ex1"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> 
<span class="o">{</span>
    <span class="c1">// 폼태그에서 get method를 썼을 때 호출되는 함수</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> 
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"doGet() 호출"</span><span class="o">);</span>
		
        <span class="c1">// 응답정보의 내용의 형태는 html문서로 표현하겠다.</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html; charset=UTF-8"</span><span class="o">);</span>

        <span class="c1">// response를 통해서 출력가능한 통로를 생성하겠다.</span>
<span class="c1">//	    PrintWriter out = response.getWriter();</span>
<span class="c1">//</span>
<span class="c1">//	    // 서블릿을 이용한 JSP 페이지 표현 - 사용하진 않을 것임</span>
<span class="c1">//	    out.print("&lt;html&gt;");</span>
<span class="c1">//	    out.print("&lt;head&gt;");</span>
<span class="c1">//	    out.print("&lt;/head&gt;");</span>
<span class="c1">//	    out.print("&lt;body&gt;");</span>
<span class="c1">//	    out.print("&lt;h1&gt; 서블릿을 활용한 JSP페이지 만들기&lt;/h1&gt;");</span>
<span class="c1">//	    out.print("&lt;/body&gt;");</span>
<span class="c1">//	    out.print("&lt;/html&gt;");</span>
<span class="c1">//	    out.close();</span>

        <span class="c1">// 포워딩 전 request 영역에 정보를 저장</span>
        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"itwill"</span><span class="o">,</span> <span class="s">"busan"</span><span class="o">);</span>

        <span class="c1">// 객체정보를 전달</span>
        <span class="nc">Student</span> <span class="n">kim</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"김학생"</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setKor</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setEng</span><span class="o">(</span><span class="mi">90</span><span class="o">);</span>
        <span class="n">kim</span><span class="o">.</span><span class="na">setMath</span><span class="o">(</span><span class="mi">76</span><span class="o">);</span>
        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"Student"</span><span class="o">,</span> <span class="n">kim</span><span class="o">);</span>

        <span class="nc">Student</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"사용자"</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setKor</span><span class="o">(</span><span class="mi">45</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setEng</span><span class="o">(</span><span class="mi">70</span><span class="o">);</span>
        <span class="n">user</span><span class="o">.</span><span class="na">setMath</span><span class="o">(</span><span class="mi">98</span><span class="o">);</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">memberList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;();</span>
        <span class="n">memberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">kim</span><span class="o">);</span>
        <span class="n">memberList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"memberList"</span><span class="o">,</span> <span class="n">memberList</span><span class="o">);</span>

        <span class="c1">// 서블릿 코드를 사용한 화면 출력 X</span>
        <span class="c1">// =&gt; 포워딩을 사용한 화면 출력 O</span>

        <span class="c1">// 자바 코드를 이용한 포워딩 방식 - 외우기</span>
<span class="c1">//	    &lt;jsp:forward/&gt; 사용불가 - JSP 페이지가 아닌 자바파일이라서 못 씀</span>
        <span class="c1">// 이동할 경로 설정</span>
        <span class="nc">RequestDispatcher</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">"/jstl/coreSet2.jsp"</span><span class="o">);</span>

        <span class="n">dis</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
	<span class="o">}</span> <span class="c1">// doGet()</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이렇게 만들면 되는데 사용할 함수들을 다 오버라이딩 하기 때문에 일일이 작성하지 않아도 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">HttpServlet</code>을 상속받고 나면 이클립스가 구현해야 하는 함수들을 다 만들어 준다.</li>
  <li>우리는 형태가 만들어진 함수의 내부만 채우면 된다.<br /><br /><br /></li>
</ul>

<h1 id="jsp-페이지에서-서블릿을-활용한-정보-전달">JSP 페이지에서 서블릿을 활용한 정보 전달</h1>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 서블릿에서 저장된 정보(request.setAttribute("itwill", "busan");) 출력 --&gt;</span>
  itwill : <span class="nt">&lt;%=</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"itwill"</span><span class="o">)</span> <span class="nt">%&gt;&lt;br&gt;</span>
  itwill : ${itwill }<span class="nt">&lt;br&gt;</span>
  itwill : ${requestScope.itwill }<span class="nt">&lt;br&gt;</span>
  
<span class="c">&lt;!-- 앞으로는 보안을 위해 주소에 정보가 처리되는 jsp 페이지를 나타내지 않을 것임
  		자바 서블릿 코드를 이용해 jsp 페이지 작성(가상주소 생성) --&gt;</span>
</code></pre></div></div>

<ul>
  <li>자바 서블릿 코드를 이용해 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지를 작성할 것이기 때문에 서블릿 클래스를 실행하면 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지로 연결되어 액션을 수행하지만 주소창에는 <code class="language-plaintext highlighter-rouge">jsp</code> 페이지가 나타나지 않고 어노테이션 <code class="language-plaintext highlighter-rouge">@WebServlet("/ex1")</code>에 쓴 <code class="language-plaintext highlighter-rouge">/ex1</code>가 맨 뒤에 붙어 주소창에는 <code class="language-plaintext highlighter-rouge">http://localhost:8090/JSP6/ex1</code> 와 같은 형태로 나타나게 된다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${Student}<span class="nt">&lt;br&gt;</span>
학생 이름 : ${Student.getName() }<span class="nt">&lt;br&gt;</span>
국어 : ${Student.getKor() }<span class="nt">&lt;br&gt;</span>
영어 : ${Student.getEng() }<span class="nt">&lt;br&gt;</span>
수학 : ${Student.getMath() }<span class="nt">&lt;br&gt;</span>
  
<span class="nt">&lt;%</span>
  <span class="nc">Student</span> <span class="n">kim</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Student</span><span class="o">)</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"Student"</span><span class="o">);</span>
<span class="nt">%&gt;</span>
<span class="nt">&lt;%=</span><span class="n">kim</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="nt">%&gt;&lt;br&gt;</span>
${Student.name }<span class="nt">&lt;br&gt;</span><span class="c">&lt;!-- el 표현식에서는 내부적으로 get/set 메서드를 자동으로 구현해 사용함. 그래서 변수명으로도 접근가능 --&gt;</span>
  
<span class="c">&lt;!-- 좀 더 간단하게 쓰기 --&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"kim"</span><span class="na"> value=</span><span class="s">"</span><span class="si">${</span><span class="nc">Student</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  
${kim.name }
  
<span class="nt">&lt;hr&gt;</span>
  
${requestScope.memberList }<span class="nt">&lt;br&gt;</span>
${requestScope.memberList[0].name }
</code></pre></div></div>

<ul>
  <li>그리고 아까 서블릿에서 함께 저장했던 클래스 객체도 위와 같이 <code class="language-plaintext highlighter-rouge">el 표현식</code>을 사용해서 출력할 수 있다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="Servlet" /><summary type="html"><![CDATA[👀 서블릿(Servlet)이란? 자바를 이용해서 웹 개발을 하기 위한 기술로 동적인 데이터를 처리하는 페이지인 JSP 파일을 최종적으로 사용하려면 자바 클래스 파일로 만들어야 하는데 서블릿은 그 중간 과정이라 할 수 있다. 즉 JSP(.jsp) -&gt; Servlet(.java) -&gt; 클래스파일(.class) 이런 과정을 거치게 된다.]]></summary></entry><entry><title type="html">JSP) JSTL</title><link href="http://localhost:4000/jsp/JSP-jstl/" rel="alternate" type="text/html" title="JSP) JSTL" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-jstl</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-jstl/"><![CDATA[<h1 id="-jstljsp-standard-tag-library이란">👀 JSTL(JSP Standard Tag Library)이란?</h1>
<ul>
  <li>자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태</li>
  <li>
    <p>태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.</p>
  </li>
  <li>CORE 라이브러리 : 기본적인 동작 제공
    <ul>
      <li>변수 선언, 조건문, 반복문 코드를 처리하는 태그</li>
      <li>페이지 이동처리 태그 (태그만 사용해서 반복문 처리를 할 수 있음)</li>
    </ul>
  </li>
  <li>Formatting 라이브러리
    <ul>
      <li>데이터 국제화 처리 (다국어) 태그</li>
      <li>형식화 (날짜, 숫자, 시간) 태그</li>
    </ul>
  </li>
  <li>DB 라이브러리 : sql구문처리 동작
    <ul>
      <li>CRUD 동작 수행 태그</li>
    </ul>
  </li>
  <li>XML 라이브러리
    <ul>
      <li>XML 문서 읽고 처리하는 태그</li>
    </ul>
  </li>
</ul>

<h2 id="다운로드-및-설치">다운로드 및 설치</h2>
<ul>
  <li>톰캣 홈페이지에서 taglibs 메뉴에 들어가서 하단에</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taglibs-standard-jstlel-1.2.5.jar
taglibs-standard-spec-1.2.5.jar
taglibs-standard-impl-1.2.5.jar
</code></pre></div></div>

<ul>
  <li>세 파일을 다운받는다.</li>
  <li>다운받은 파일들을 <code class="language-plaintext highlighter-rouge">WEB-INF/lib</code>에 복붙하면 설치 완료<br /><br /><br /></li>
</ul>

<h1 id="core-라이브러리">CORE 라이브러리</h1>
<h2 id="변수-선언-및-사용">변수 선언 및 사용</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"c"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/core"</span> <span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li>먼저 페이지 상단에 라이브러리 인클루드 해 주어야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">prefix</code>는 태그의 접두사를 지정해 주는 것으로 <code class="language-plaintext highlighter-rouge">prefix</code>에 지정한 문자를 쓰고 <code class="language-plaintext highlighter-rouge">:</code>을 쓰면 태그 예약어들을 사용할 수 있다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;%-- &lt;c:set var="변수명" value="값"/&gt; --%&gt;</span>
  <span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"num3"</span><span class="na"> value=</span><span class="s">"300"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"num4"</span><span class="na"> value=</span><span class="s">"400"</span><span class="nt">/&gt;</span>
  
  <span class="c">&lt;!-- 변수값 출력할 때엔 el 표현식 사용 --&gt;</span>
  <span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">num3</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">num4</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;hr&gt;</span>
  
  ${num3 } + ${num4 } = ${num3 + num4 }
</code></pre></div></div>

<ul>
  <li>태그 속에서 변수를 선언하고 값을 넣어줄 수 있다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> value=</span><span class="s">"S22"</span><span class="na"> scope=</span><span class="s">"request"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>스크립틀릿을 이용해서 자바 코드로 변수를 선언하면 지역변수로 인식되어서 선언한 페이지에서만 쓸 수 있는데 <code class="language-plaintext highlighter-rouge">JSTL</code> 태그를 사용하면 변수의 영역도 지정해 줄 수 있어서 자바 코드를 사용하는 것에 비해 훨씬 활용도를 높일 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">scope : page, request, session, application</code> 네 영역 모두 설정해 줄 수 있다. <code class="language-plaintext highlighter-rouge">scope</code>를 설정하지 않으면 기본값은 <code class="language-plaintext highlighter-rouge">page</code>라서 선언한 페이지에서만 쓸 수 있다.</li>
</ul>

<h2 id="출력">출력</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"안녕하세요 JSTL입니다."</span><span class="nt">&gt;&lt;/c:out&gt;</span>
</code></pre></div></div>

<ul>
  <li>만약 <code class="language-plaintext highlighter-rouge">null</code>값을 출력하는 경우 빈공백으로 처리된다. (JSP 표현식은 컴파일 에러남)</li>
  <li>컴파일 에러난 페이지를 보여주는 것 보다는 <code class="language-plaintext highlighter-rouge">null</code>값을 출력하는게 사용자 신뢰도에는 더 좋다.<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;</span> <span class="nt">abc&gt;</span>태그는 abc입니다.<span class="nt">&lt;hr&gt;</span>

<span class="ni">&amp;lt;</span>abc&gt;태그는 abc입니다.<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;c:out </span><span class="na">value=</span><span class="s">"&lt;abc&gt;태그는 abc입니다."</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li>만약 태그 자체를 출력하고 싶다면 위 세 가지 방법으로 출력이 가능하다.</li>
</ul>

<h2 id="조건문">조건문</h2>
<h3 id="if">if</h3>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- jstl 변수 2개 생성(속성) --&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> value=</span><span class="s">"itwill"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"tel"</span><span class="na"> value=</span><span class="s">"010-1234-5678"</span><span class="nt">/&gt;</span>

<span class="c">&lt;!-- 사용자의 이름이 "itwill"인지 체크 --&gt;</span>
<span class="nt">&lt;c:if </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">name</span> <span class="o">==</span> <span class="l">'itwill'</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span><span class="c">&lt;!-- 표현식 안에서는 작은 따옴표를 써야 함(큰 따옴표 쓰면 밖에 따옴표랑 반응함) --&gt;</span>
  사용자 이름 : ${name }<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:if&gt;</span>

<span class="nt">&lt;c:if </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="mi">100</span> <span class="n">lt</span> <span class="mi">200</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span><span class="c">&lt;!-- lt : 비교연산자(&lt;)와 같은 역할을 하는 예약어 --&gt;</span>
  200이 더 크다.<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:if&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HTML</code> 태그처럼 태그 사이에 출력하고 싶은 문구를 작성할 수 있다.<br /><br /></li>
</ul>

<h3 id="switch-case">switch ~case</h3>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:choose&gt;</span>
  <span class="nt">&lt;c:when </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">param</span><span class="o">.</span><span class="na">num1</span> <span class="n">le</span> <span class="n">param</span><span class="o">.</span><span class="na">num2</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span>
    num1! <span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:when&gt;</span>
  <span class="nt">&lt;c:when </span><span class="na">test=</span><span class="s">"</span><span class="si">${</span><span class="n">param</span><span class="o">.</span><span class="na">num1</span> <span class="n">lt</span> <span class="n">param</span><span class="o">.</span><span class="na">num2</span> <span class="si">}</span><span class="s">"</span><span class="nt">&gt;</span>
    num2! <span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:when&gt;</span>
  <span class="nt">&lt;c:otherwise&gt;</span>
    그 외 나머지<span class="nt">&lt;br&gt;</span>
  <span class="nt">&lt;/c:otherwise&gt;</span>
<span class="nt">&lt;/c:choose&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">choose</code> 태그를 사용해서 <code class="language-plaintext highlighter-rouge">switch ~case</code>문을 작성할 수 있다.<br /><br /></li>
</ul>

<h2 id="반복문">반복문</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:forEach </span><span class="na">var=</span><span class="s">"i"</span><span class="na"> begin=</span><span class="s">"1"</span><span class="na"> end=</span><span class="s">"10"</span><span class="na"> step=</span><span class="s">"1"</span><span class="nt">&gt;</span>
  ${i }
<span class="nt">&lt;/c:forEach&gt;</span>
</code></pre></div></div>

<ul>
  <li>위와 같이 <code class="language-plaintext highlighter-rouge">for</code>문에서 변수를 선언하고 조건식, 증감식을 설정해 줄 수 있는데 저렇게는 잘 안 쓴다.(단순 순회할 때 <code class="language-plaintext highlighter-rouge">for</code>문에서 귀찮은 것들을 덜어내고 쓰는 것이 <code class="language-plaintext highlighter-rouge">foreach</code>니까…)<br /><br /></li>
</ul>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
  <span class="o">{</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
  <span class="o">}</span>
<span class="nt">%&gt;</span>
<span class="c">&lt;!-- 이 형태를 많이 쓴다.(items 자리엔 jsp 표현식보다는 el 표현식을 쓴다.) --&gt;</span>
<span class="nt">&lt;c:forEach </span><span class="na">var=</span><span class="s">"test"</span><span class="na"> items=</span><span class="s">"&lt;%=arr %&gt;"</span><span class="nt">&gt;</span>
  ${test } 
<span class="nt">&lt;/c:forEach&gt;</span>
</code></pre></div></div>

<ul>
  <li>위와 같은 형태로 배열을 순회할 때 많이 사용한다.<br /><br /></li>
</ul>

<h2 id="문자열-parsing">문자열 Parsing</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:forTokens </span><span class="na">var=</span><span class="s">"abc"</span><span class="na"> items=</span><span class="s">"a,b,c,d,e,f,g,h"</span><span class="na"> delims=</span><span class="s">","</span><span class="nt">&gt;</span>
  ${abc } 
<span class="nt">&lt;/c:forTokens&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"data"</span><span class="na"> value=</span><span class="s">"자바 디비 웹 JSP"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;c:forTokens </span><span class="na">var=</span><span class="s">"name"</span><span class="na"> items=</span><span class="s">"</span><span class="si">${</span><span class="n">data</span> <span class="si">}</span><span class="s">"</span><span class="na"> delims=</span><span class="s">" "</span><span class="nt">&gt;</span>
  ${name }<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;/c:forTokens&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">delims</code>에 넣은 인자값을 기준으로 문자열을 자를 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="formatting-라이브러리">Formatting 라이브러리</h1>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"c"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/core"</span><span class="nt">%&gt;</span>
<span class="nt">&lt;%@ taglib </span><span class="na">prefix=</span><span class="s">"fmt"</span><span class="na"> uri=</span><span class="s">"http://java.sun.com/jsp/jstl/fmt"</span><span class="nt">%&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Formatting</code> 라이브러리는 일반적으로 <code class="language-plaintext highlighter-rouge">fmt</code> 접두사를 쓴다.</li>
</ul>

<h2 id="날짜-출력하기">날짜 출력하기</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"today"</span><span class="na"> value=</span><span class="s">"&lt;%=new Date() %&gt;"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- time: 시간정보 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- both: 날짜 &amp; 시간정보 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"both"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"long"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"medium"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"short"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"both"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="na"> timeStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"long"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"medium"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> timeStyle=</span><span class="s">"short"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;h3&gt;</span>2022/2/25(금) (오전) 11:50:00 형식으로 표현하기<span class="nt">&lt;/h3&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> pattern=</span><span class="s">"yyyy/MM/dd(E)"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> type=</span><span class="s">"time"</span><span class="na"> pattern=</span><span class="s">"(a)hh:mm:ss"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dateStyle</code>에 넣은 값만큼 출력되는 날짜 정보의 갯수를 조절할 수 있다.</li>
</ul>

<h2 id="통화-출력하기">통화 출력하기</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;c:set </span><span class="na">var=</span><span class="s">"today"</span><span class="na"> value=</span><span class="s">"&lt;%=new Date() %&gt;"</span><span class="nt">/&gt;</span>
${today }
<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"ko_kr"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"en_us"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"zh_cn"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>

<span class="nt">&lt;hr&gt;</span>
<span class="nt">&lt;fmt:setLocale </span><span class="na">value=</span><span class="s">"ja_jp"</span><span class="nt">/&gt;</span><span class="c">&lt;!-- 한국으로 기본 세팅되어 있어서 생략 가능 --&gt;</span>
<span class="nt">&lt;fmt:formatDate </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="n">today</span> <span class="si">}</span><span class="s">"</span><span class="na"> dateStyle=</span><span class="s">"full"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 년 월 일 요일 표시 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"1000000000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="nt">/&gt;&lt;br&gt;</span><span class="c">&lt;!-- 숫자 자동으로 ,콤마 넣어서 표시/ currency는 통화도 넣어줌 --&gt;</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="숫자-출력">숫자 출력</h2>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"100000000"</span><span class="na"> groupingUsed=</span><span class="s">"false"</span><span class="nt">/&gt;&lt;br&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"100000000"</span><span class="na"> groupingUsed=</span><span class="s">"true"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;hr&gt;</span>

<span class="nt">&lt;h2&gt;</span>소수점 자리 표현<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"</span><span class="si">${</span><span class="mf">2.12345676</span> <span class="si">}</span><span class="s">"</span><span class="na"> pattern=</span><span class="s">"#.####"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- 0은 .뒤에 0을 채워줌 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"20.0"</span><span class="na"> pattern=</span><span class="s">"##.00"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"0.5"</span><span class="na"> type=</span><span class="s">"percent"</span><span class="nt">/&gt;&lt;br&gt;</span>

<span class="c">&lt;!-- 통화 심볼도 바꿀 수 있다 --&gt;</span>
<span class="nt">&lt;fmt:formatNumber </span><span class="na">value=</span><span class="s">"10000000"</span><span class="na"> type=</span><span class="s">"currency"</span><span class="na"> currencySymbol=</span><span class="s">"@"</span><span class="nt">/&gt;&lt;br&gt;</span>
</code></pre></div></div>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="JSTL" /><summary type="html"><![CDATA[👀 JSTL(JSP Standard Tag Library)이란? 자카르타(아파치)에서 제공하는 자주 사용되는 태그를 모아놓은 형태 태그를 이용해서 프로그래밍 언어로 코드를 쓰는 것과 같은 동작을 할 수 있다.]]></summary></entry><entry><title type="html">JSP) 커넥션 풀</title><link href="http://localhost:4000/jsp/JSP-connection-pool/" rel="alternate" type="text/html" title="JSP) 커넥션 풀" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/jsp/JSP-connection-pool</id><content type="html" xml:base="http://localhost:4000/jsp/JSP-connection-pool/"><![CDATA[<h1 id="-커넥션-풀-connection-pool이란">👀 커넥션 풀 (Connection Pool)이란?</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">JDBC</code>를 연동하기 위해서는 드라이버를 로드하고 <code class="language-plaintext highlighter-rouge">JDBC URL</code>로 접속하여 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 얻어오는 단계를 거쳐야 한다.</li>
  <li>커넥션 풀은 데이터베이스와 연결된 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다.</li>
  <li>사용자가 웹 사이트에 <code class="language-plaintext highlighter-rouge">Connection</code> 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다.</li>
  <li>하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.</li>
</ul>

<h2 id="커넥션풀의-연결전략">커넥션풀의 연결전략</h2>
<p>1) DB연결이 필요한 JSP 페이지 (service()) 실행시 DB연결 요청당 1개씩 할당<br />
2) 커넥션의 개수를 제한<br />
3) 커넥션의 사용을 다 한 경우 (객체관리자가 자원을 모두 다 쓰면) 자원 회수<br /></p>

<h2 id="실제-동작-구현">실제 동작 구현</h2>
<ol>
  <li>웹브라우저 요청<br /></li>
  <li>할당될 커넥션 객체가 있는지 없는지 체크<br /><br /></li>
</ol>

<p>2-1. 있을 때<br />
    3. 커넥션 객체 할당 (pool에 저장된 정보 전달)<br />
    4. 객체 사용<br />
    5. 객체 사용 반환 (자원해제 X, pool에 저장)<br /></p>

<p>2-2. 없을 때<br />
    1. 커넥션 객체를 기다림 (커넥션이 반환될 때 까지)<br />
    2. 임시 커넥션 객체 생성 -&gt; 사용 -&gt; 반환 (사라짐)<br /><br /><br /></p>

<h1 id="jndi-java-namming-and-directory-interface">JNDI (Java Namming and Directory Interface)</h1>
<ul>
  <li>명명 서비스 및 디렉토리 서비스에 접근하기 위한 API. 즉 특정 자원에 접근하기 위한 이름으로 사용된다.</li>
  <li><a href="https://commons.apache.org/">아파치 홈페이지</a>에 가서 <code class="language-plaintext highlighter-rouge">collections</code>, <code class="language-plaintext highlighter-rouge">DBCP</code>, <code class="language-plaintext highlighter-rouge">Pool</code> 다운받기
    <ul>
      <li>압축 풀어서 <code class="language-plaintext highlighter-rouge">commons-collections4-4.4.jar</code> 처럼 옆에 잡다한 이름 안 붙은걸로 복사해서 <code class="language-plaintext highlighter-rouge">WEB-INF/lib</code>에 붙여넣기</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">API</code>를 설치했으면 <code class="language-plaintext highlighter-rouge">xml</code> 파일을 만들어야 한다.</li>
</ul>

<h2 id="xml">XML</h2>
<ul>
  <li>태그 형태로 데이터를 저장하는 페이지로 <code class="language-plaintext highlighter-rouge">HTML</code> 태그 형태는 아니지만 지정된 태그를 통해서 데이터를 저장하고 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">src/main/webapp/META-INF</code>에 <code class="language-plaintext highlighter-rouge">content.xml</code> 파일을 생성하고 서버에 공유할 리소스를 정의한다.</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="nt">&lt;Context&gt;</span>
  <span class="nt">&lt;Resource</span> 
    <span class="na">name=</span><span class="s">"jdbc/mysql"</span> 
    <span class="na">auth=</span><span class="s">"Container"</span> 
    <span class="na">type=</span><span class="s">"javax.sql.DataSource"</span> 
    <span class="na">username=</span><span class="s">"root"</span> 
    <span class="na">password=</span><span class="s">"1234"</span> 
    <span class="na">driverClassName=</span><span class="s">"com.mysql.cj.jdbc.Driver"</span> 
    <span class="na">url=</span><span class="s">"jdbc:mysql://localhost:3306/jspdb"</span> 
    <span class="na">maxActive=</span><span class="s">"500"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Context&gt;</span>
</code></pre></div></div>

<ul>
  <li>이렇게 작성하면 되는데 각 코드 라인의 의미는 다음과 같다.</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Context&gt;</span>
  <span class="c">&lt;!-- Context : 프로젝트 --&gt;</span>
  <span class="nt">&lt;Resource</span> 
    <span class="na">name=</span><span class="s">"디비에 접근하기 위한 이름"</span> 
    <span class="na">auth=</span><span class="s">"컨테이너 자원 관리자 설정 - Application or Container"</span> 
    <span class="na">type=</span><span class="s">"리소스를 사용할 때 실제로 사용되는 클래스 타입"</span> 
    <span class="na">username=</span><span class="s">"디비 아이디"</span> 
    <span class="na">password=</span><span class="s">"디비 비밀번호"</span> 
    <span class="na">driverClassName=</span><span class="s">"드라이버 주소"</span> 
    <span class="na">url=</span><span class="s">"디비 연결 주소"</span> 
    <span class="na">maxActive=</span><span class="s">"커넥션 회수 대기시간"</span>
  <span class="nt">/&gt;</span>
<span class="nt">&lt;/Context&gt;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xml</code> 파일에서도 주석문 사용이 가능하지만 사용하지 않는 것이 좋다.</li>
  <li>왜냐면 주석 처리한 코드가 실행되는 경우가 있는데 이 때 에러가 나도 컴파일 에러가 표시되지 않고 단순 서버 에러라고만 나오기 때문에 원인 찾기가 매우매우 힘들다.</li>
  <li><code class="language-plaintext highlighter-rouge">xml</code> 파일까지 만들었다면 <code class="language-plaintext highlighter-rouge">MemberDAO</code> 클래스를 커넥션 풀을 사용하도록 수정해야 한다.<br /><br /><br /></li>
</ul>

<h1 id="memberdao-클래스를-커넥션-풀을-쓰도록-수정하기">MemberDAO 클래스를 커넥션 풀을 쓰도록 수정하기</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getConnect()</code> 함수를 아래와 같이 수정한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">Connection</span> <span class="nf">getConnect</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">try</span> 
    <span class="o">{</span>
        <span class="c1">// 커넥션풀을 사용한 디비연결</span>
        
        <span class="c1">// 업캐스팅이라 인터페이스인데 객체 생성 가능</span>
        <span class="c1">// 프로젝트(CTX)정보 초기화</span>
        <span class="nc">Context</span> <span class="n">initCTX</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InitialContext</span><span class="o">();</span>
        
<span class="c1">//	Context envCTX = (Context) initCTX.lookup("java:comp/env");</span>
<span class="c1">//				envCTX.lookup("jdbc/mysql"); // 이거랑 아래 한 문장이랑 같은 의미</span>
        <span class="c1">// java:comp/env/ 여기까지는 항상 고정 &amp; 뒤에 xml 파일의 name에 쓴 내용 넣기</span>
        <span class="c1">// type="javax.sql.DataSource" 에서 정해준 데이터타입으로 다운캐스팅 해줘야 함</span>
        <span class="nc">DataSource</span> <span class="n">ds</span> <span class="o">=</span> <span class="o">(</span><span class="nc">DataSource</span><span class="o">)</span> <span class="n">initCTX</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"java:comp/env/jdbc/mysql"</span><span class="o">);</span>
        
        <span class="c1">// ds에 연결정보가 다 들어있으니까 getConnection만 실행</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : 커넥션풀을 사용한 디비연결 성공"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DAO : "</span> <span class="o">+</span> <span class="n">con</span><span class="o">);</span>
    <span class="o">}</span> 
    <span class="k">catch</span> <span class="o">(</span><span class="nc">NamingException</span> <span class="n">e</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> 
    <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">con</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>이후 사용하는 것은 기존과 같이 사용하면 된다.</li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="JSP" /><category term="JSP" /><category term="ConnectionPool" /><summary type="html"><![CDATA[👀 커넥션 풀 (Connection Pool)이란? JDBC를 연동하기 위해서는 드라이버를 로드하고 JDBC URL로 접속하여 Connection 객체를 얻어오는 단계를 거쳐야 한다. 커넥션 풀은 데이터베이스와 연결된 Connection 객체를 미리 생성하여 풀(Pool)에 저장해 두고 필요할 때마다 풀에 접근하여 Connection 객체를 사용하고 사용이 끝나면 다시 반환하는 것을 말한다. 사용자가 웹 사이트에 Connection 객체를 생성하게 되면 메모리 소모가 많고 시간도 오래 걸린다. 하지만 풀에 저장해서 사용한다면 미리 생성된 객체를 쓰기 때문에 생성에 시간이 걸리지도 않고 또 쓰지 않는 객체는 다시 풀 속에 넣어뒀다가 필요할 때 꺼내 쓰면 되기 때문에 불필요한 메모리 낭비가 없어 프로그램 효율과 성능이 전체적으로 증가하게 된다.]]></summary></entry></feed>