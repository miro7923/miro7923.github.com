<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-27T00:16:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Java) BOJ 11651. 좌표 정렬하기2</title><link href="http://localhost:4000/boj/boj11651-java/" rel="alternate" type="text/html" title="Java) BOJ 11651. 좌표 정렬하기2" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11651-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11651-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11651">https://www.acmicpc.net/problem/11651</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>11650번에서 썼던 Comparator 함수에서 기준값을 x에서 y로만 바꿔주었다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 860 ms</li>
  <li>메모리 : 49896 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/bafcfe58127991148c9f70bab678805d.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11651" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11651 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 11650. 좌표 정렬하기</title><link href="http://localhost:4000/boj/boj11650-java/" rel="alternate" type="text/html" title="Java) BOJ 11650. 좌표 정렬하기" /><published>2022-02-27T00:00:00+09:00</published><updated>2022-02-27T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj11650-java</id><content type="html" xml:base="http://localhost:4000/boj/boj11650-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/11650">https://www.acmicpc.net/problem/11650</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>2차원 평면 위의 점 N개가 주어진다. 좌표를 x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 <code class="language-plaintext highlighter-rouge">Pair</code> 클래스에서 <code class="language-plaintext highlighter-rouge">Comparable</code>을 구현해서 썼는데 리턴값을 잘못 설정했는지 계속 7%에서 틀렸다 ㅠ.ㅠ</li>
  <li>그래서 구글링해서 Comparator 람다식으로 바꾸고 통과함<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 800 ms</li>
  <li>메모리 : 51232 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/49b9efbb416fe3905a7e48e17b4d3990.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No11650" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/11650 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">컴퓨터구조) Instructions</title><link href="http://localhost:4000/computer%20science/computer-architecture-03/" rel="alternate" type="text/html" title="컴퓨터구조) Instructions" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/computer-architecture-03</id><content type="html" xml:base="http://localhost:4000/computer%20science/computer-architecture-03/"><![CDATA[<h1 id="instruction-set">Instruction Set</h1>
<ul>
  <li>프로세서에서 지원하는 명령어들의 집합</li>
  <li>다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다.</li>
  <li>현대 컴퓨터는 대부분 간단한 명령어셋(<code class="language-plaintext highlighter-rouge">MIPS</code> - <code class="language-plaintext highlighter-rouge">RISK</code> 방식)을 가지고 있다.</li>
</ul>

<h2 id="instruction-set-architecture-isa">Instruction Set Architecture (ISA)</h2>
<ul>
  <li>하드웨어와 낮은 레벨의 소프트웨어를 연결하는 인터페이스로 시스템 소프트웨어(운영체제)라 할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">ISA</code>가 같으면 같은 소프트웨어를 여러 개의 <code class="language-plaintext highlighter-rouge">CPU</code>에서 실행할 수 있다.</li>
</ul>

<h2 id="abi">ABI</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ISA</code>와 운영체제 인터페이스를 합친 것</li>
  <li><code class="language-plaintext highlighter-rouge">ABI</code>만 같으면 같은 프로그램이 어디에서든 실행될 수 있다.</li>
  <li>윈도우 운영체제를 쓰는 컴퓨터들은 어떤 컴퓨터를 쓰든 같은 프로그램을 실행할 수 있는 것<br /><br /><br /></li>
</ul>

<h1 id="design-principle">Design Principle</h1>
<h2 id="1-정규화규칙화해서-간단하게-만들기">1. 정규화(규칙화)해서 간단하게 만들기</h2>
<ul>
  <li>간단할수록 저비용으로 고성능을 만들기가 쉽다.</li>
</ul>

<h2 id="2-메모리-용량이-작은-것이-빠르다">2. 메모리 용량이 작은 것이 빠르다</h2>
<ul>
  <li>메모리 용량을 작은 레지스터를 최대한 활용하는 것이 성능 향상에 도움이 된다.</li>
</ul>

<h2 id="3-공통-케이스는-빠르게-만들기">3. 공통 케이스는 빠르게 만들기</h2>
<ul>
  <li>자주 사용하고 비중이 높은 연산은 빠르게 처리하도록 만드는 것이 성능 향상에 좋다.</li>
</ul>

<h2 id="4-좋은-디자인을-위해-최대한-통일하기">4. 좋은 디자인을 위해 최대한 통일하기</h2>
<ul>
  <li>명령어의 포맷 가짓수는 최대한 줄이고 통일하는 것이 좋다.</li>
  <li>포맷이 다르면 디코딩 하는 데 복잡해지고 이것은 성능 하락으로 이어지기 때문이다. <br /><br /><br /></li>
</ul>

<h1 id="operations-of-the-computer-hardware">Operations of the Computer Hardware</h1>
<h2 id="arithmetic-operations-산술연산">Arithmetic Operations (산술연산)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">register</code> 간 연산으로 <code class="language-plaintext highlighter-rouge">RISK</code> 프로세서 방식</li>
  <li><code class="language-plaintext highlighter-rouge">add</code>와 <code class="language-plaintext highlighter-rouge">subtract</code>, 더하기와 빼기로 이루어져 있으며 피연산자 3개가 필요하다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add a, b, c
</code></pre></div></div>

<ul>
  <li>위와 같이 쓰면 <code class="language-plaintext highlighter-rouge">b</code>와 <code class="language-plaintext highlighter-rouge">c</code>를 더한 값을 <code class="language-plaintext highlighter-rouge">a</code>에 저장해라는 의미<br /><br /><br /></li>
</ul>

<h1 id="operands-of-the-computer-hardware">Operands of the Computer Hardware</h1>
<h2 id="register-operands">Register Operands</h2>
<ul>
  <li>자주 사용하는 데이터에 빠르게 접근하기 위해서 레지스터를 사용한다.</li>
  <li>32개의 <code class="language-plaintext highlighter-rouge">bit</code>로 이루어져 있으며 <code class="language-plaintext highlighter-rouge">word</code>라 부른다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>는 32개의 <code class="language-plaintext highlighter-rouge">32bit</code> 레지스터 파일을 가지고 있다.</li>
</ul>

<h2 id="byte-addresses">Byte Addresses</h2>
<ul>
  <li>대부분의 아키텍처는 <code class="language-plaintext highlighter-rouge">byte</code> 단위로 메모리를 관리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">word</code>는 <code class="language-plaintext highlighter-rouge">4bytes</code>로 이루어져 있으며 이것은 하나의 명령어 단위가 된다.</li>
  <li>레지스터에 있는 데이터를 메모리에 저장할 때 자리수가 큰 게 최하위 비트(LSB)에 오면 <code class="language-plaintext highlighter-rouge">Big Endian</code>, 자리수가 제일 작은 것이 최하위 비트에 오면 <code class="language-plaintext highlighter-rouge">Little Endian</code>이라 한다.</li>
</ul>

<h2 id="memory-operands">Memory Operands</h2>
<ul>
  <li>메인 메모리는 자료의 집합을 이용한다.</li>
  <li>산술 연산을 하기 위해서 메모리에 접근할 수 있는 명령어가 지정되어 있다.(<code class="language-plaintext highlighter-rouge">Load/Store</code>)</li>
  <li>메모리는 <code class="language-plaintext highlighter-rouge">8bit</code> 크기의 주소로 이루어져 있다.</li>
  <li>모든 명령어의 크기는 <code class="language-plaintext highlighter-rouge">4bytes</code>이기 때문에 메모리 주소 또한 <code class="language-plaintext highlighter-rouge">4bytes</code> 간격으로 나열되어 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>는 빅 엔디안 방식을 사용한다.</li>
</ul>

<h2 id="registers-vs-memory">Registers vs. Memory</h2>
<ul>
  <li>레지스터가 메모리에 접근하는 것 보다 훨씬 빠르다.</li>
  <li>그래서 메모리 접근을 최대한 줄이고 레지스터에서 연산하는 것이 성능 향상에 좋은데 그렇다고 너무 레지스터만 써도 성능이 떨어지니까 자주 쓰지 않는 데이터는 메모리로 내려주는 것이 좋다.</li>
  <li>한 주소는 <code class="language-plaintext highlighter-rouge">32bit</code>로 이루어져 있는데 레지스터 하나는 <code class="language-plaintext highlighter-rouge">5bit</code> 크기이기 때문에 메모리에 접근하는 것 보다는 레지스터를 최대한 사용하는 것이 한 번에 처리할 수 있는 코드가 많아진다.</li>
</ul>

<h2 id="immediate-operands">Immediate Operands</h2>
<ul>
  <li>피연산자 중에 하나가 상수일 때 사용하는 명령어</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addi $s3 , $s3, 4 // 동작은 add와 같음
addi $s2, $s1, -1 // 뺄셈은 -1 사용
</code></pre></div></div>

<ul>
  <li>상수를 레지스터에서 만들어 쓰지 않으면 메모리에 접근해서 가져와야 하는데 이러면 느리다.</li>
  <li>그래서 0 같이 자주 사용되는 상수는 메모리에 접근할 필요 없이 레지스터에서 바로 연산하면 훨씬 빠르다.</li>
</ul>

<h2 id="constant-zero">Constant Zero</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$zero</code>라고 표시하며 <code class="language-plaintext highlighter-rouge">read only</code>로만 사용할 수 있다.</li>
  <li>주로 레지스터간 <code class="language-plaintext highlighter-rouge">move</code>연산을 할 때 사용하는데</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add $t1, $s1, $zero
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">move</code>와 같은 명령어를 따로 만들어서 사용하는 것 보다 <code class="language-plaintext highlighter-rouge">add</code>연산을 하는데 나머지 연산자를 0으로 만들어서 사용하면 <code class="language-plaintext highlighter-rouge">move/copy</code>와 같은 효과를 낼 수 있어서 명령어를 따로 만들지 않고 이렇게 쓴다.</li>
  <li>왜냐면 명령어 셋은 최대한 간단한 것이 성능 향상에 좋기 때문이다.</li>
  <li>어떤 특정 연산 처리만을 위한 명령어를 많이 만들어 쓰다 보면 구현 자체도 쉽지 않지만 구현해도 그 명령어를 처리하는 시간이 다른 쉬운 명령어보다 늘어나는데, 그 늘어난 시간은 다른 간단한 명령어의 실행 시간에도 영향을 미쳐서 다 같이 느려진다.<br /><br /><br /></li>
</ul>

<h1 id="logical-operations">Logical Operations</h1>
<h2 id="시프트-연산자">시프트 연산자</h2>
<ul>
  <li>왼쪽 시프트
    <ul>
      <li>시프트하면서 생기는 빈 비트는 0으로 채운다.</li>
      <li>원래 값에 2^i 을 곱한 효과(음수, 양수 둘 다 적용)</li>
    </ul>
  </li>
  <li>오른쪽 시프트
    <ul>
      <li>시프트하면서 생기는 빈 비트는 0으로 채운다.</li>
      <li>원래 값을 2^i 만큼 나눈 효과(양수에만 적용됨)</li>
    </ul>
  </li>
</ul>

<h2 id="비트-연산자">비트 연산자</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">nor</code> 연산자를 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>에는 NOT 연산자가 없기 때문에 대신 <code class="language-plaintext highlighter-rouge">nor</code> 연산자(a도 아니고 b도 아니다)를 사용해서 NOT 연산자와 같은 효과를 낸다.<br /><br /><br /></li>
</ul>

<h1 id="instructinos-for-making-decisions">Instructinos for Making Decisions</h1>
<h2 id="conditional-operations">Conditional Operations</h2>
<ul>
  <li>어떤 조건이 <code class="language-plaintext highlighter-rouge">true</code>인 경우에 이름지어져 있는 명령어로 분기를 나누고 <code class="language-plaintext highlighter-rouge">false</code>라면 다음 명령어를 계속 실행하는 것 (if ~ else문)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beq rs, rt, L1 // rs와 rt가 같으면 L1에 있는 명령어 실행
bne rs, rt, L2 // rs와 rt가 같지 않으면 L1에 있는 명령어 실행
j L1 // 무조건 L1으로 Jump하는 것
</code></pre></div></div>
<ul>
  <li>어떤 수들의 대소관계 비교도 전용 명령어를 따로 만들지 않고 <code class="language-plaintext highlighter-rouge">beq</code>를 비롯한 여러 명령어들을 조합해서 쓰는 것이 성능 면에서 더 좋기 때문에 조합해서 쓴다.<br /><br /><br /></li>
</ul>

<h1 id="명령-실행-단계">명령 실행 단계</h1>
<p>1) <code class="language-plaintext highlighter-rouge">caller</code>가 <code class="language-plaintext highlighter-rouge">callee</code>에게 파라미터를 넘긴다.
2) <code class="language-plaintext highlighter-rouge">caller</code>가 <code class="language-plaintext highlighter-rouge">callee</code>에게 제어권을 넘긴다.(실행)
3) <code class="language-plaintext highlighter-rouge">callee</code>가 스택에 메모리를 할당한다.
4) <code class="language-plaintext highlighter-rouge">callee</code>가 태스크를 수행한다.
5) <code class="language-plaintext highlighter-rouge">callee</code>가 <code class="language-plaintext highlighter-rouge">caller</code>가 접근할 수 있는 곳에 결과를 둔다.
6) <code class="language-plaintext highlighter-rouge">callee</code>가 <code class="language-plaintext highlighter-rouge">caller</code>에게 제어권을 넘긴다.<br /><br /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Procedure</code> 실행에는 <code class="language-plaintext highlighter-rouge">Leaf</code>와 <code class="language-plaintext highlighter-rouge">Non-Leaf</code> 방식이 있는데 <code class="language-plaintext highlighter-rouge">Leaf</code>는 자기 자신을 포함한 어떤 함수도 호출하지 않는 것이고 <code class="language-plaintext highlighter-rouge">Non-Leaf</code>는 자기 자신을 포함한 함수를 호출하는 것이다.</li>
  <li>프로그래밍 할 때 흔히 작성하는 값 하나를 리턴하고 끝나는 함수는 <code class="language-plaintext highlighter-rouge">Leaf</code> 방식이고 재귀 함수와 같은 형태는 <code class="language-plaintext highlighter-rouge">Non-Leaf</code>로 이루어진다.</li>
</ul>

<h2 id="메모리-영역">메모리 영역</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Text</code> : 프로그램 코드(명령어)가 있는 영역</li>
  <li><code class="language-plaintext highlighter-rouge">Static data</code> : 전역 변수가 있는 영역</li>
  <li><code class="language-plaintext highlighter-rouge">Dynamic data</code> : <code class="language-plaintext highlighter-rouge">heap</code> 영역이라고도 하며 동적으로 할당된 메모리가 있는 영역. 메모리 주소를 가리키는 포인터는 아래에서 위로 이동한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code> : 함수가 호출되면 생기는 지역 변수가 있는 영역. 메모리 주소를 가리키는 포인터는 위에서 아래로 이동한다.<br /><br /><br /></li>
</ul>

<h1 id="코드가-실행되는-과정">코드가 실행되는 과정</h1>
<p>1) 프로그래밍 언어로 프로그램을 작성한다.
2) 컴파일러가 어셈블리어로 번역한다.
3) 어셈블러가 기계어로 번역한다.
4) 기계어로 번역하면서 내가 쓴 코드를 이용해서 만든 기계어 오브젝트와 라이브러리에서 가져오는 코드로 만든 오브젝트가 생기는데 링커가 두 오브젝트 코드들을 합쳐서 실행파일로 만든다.
5) 로더가 실행파일을 메모리에 올려서 실행상태로 만든다.<br /><br /><br /></p>

<h1 id="알고리즘과-수행속도">알고리즘과 수행속도</h1>
<ul>
  <li>명령어 수와 <code class="language-plaintext highlighter-rouge">CPI</code>가 낮은 것이 무조건 성능이 좋은 것은 아니다. 성능에 영향을 미치는 것은 여러가지 요인이 있다.</li>
  <li>컴파일러 최적화는 알고리즘에 영향을 많이 받는다.</li>
  <li>그렇기 때문에 뭐니뭐니해도 알고리즘이 효율적이어야 성능이 좋아진다.<br /><br /><br /></li>
</ul>

<h1 id="배열과-포인터">배열과 포인터</h1>
<ul>
  <li>둘 다 배열을 다룰 때 사용할 수 있지만 배열 인덱스에 접근하려면 내부적으로 인덱스의 주소값을 계산하는 과정이 필요하다. (시작 주소에서부터 몇 칸 떨어져 있는지…)</li>
  <li>하지만 포인터는 그런 연산이 필요없이 그냥 4씩 더해주면서 다음 메모리 주소로 이동하면 된다.</li>
  <li>그렇지만… 최신 컴파일러는 내가 직접 포인터 연산하는 코드를 쓰는 것과 배열 인덱스로 접근하는 코드가 같은 성능을 낼 수 있도록 최적화를 다 해 준다.</li>
  <li>그래서 같은 동작을 수행하는 코드라면 배열 인덱스를 사용하는 코드를 써도 무방하며 포인터를 사용한 코드보다 이해하기도 더 쉽다. 포인터에 비해 버그를 일으키는 코드를 작성할 확률도 줄어드니까 그냥 배열을 쓰자.<br /><br /><br /></li>
</ul>

<h1 id="x86-instructions">x86 Instructions</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>와는 명령어 셋이 다르며 설계 면에서도 차이가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">MIPS</code>에 비해 다소 복잡하게 설계되어 있어 고성능으로 만들기 어려운 <code class="language-plaintext highlighter-rouge">CISK</code> 아키텍처다.</li>
  <li>그래서 고성능을 내기 위해 하드웨어가 내부적으로 복잡한 원래 명령어를 간단한 명령어들로 쪼갠 다음에 실행하는 방식을 쓴다.(결국 <code class="language-plaintext highlighter-rouge">RISC</code>와 같은 매커니즘으로 실행되게 된다고 볼 수 있다)</li>
  <li>이렇게 보면 인텔은 진작에 망했어야 할 거 같지만 시장 점유율을 성공적으로 높이면서 자리잡았기 때문에 인텔 프로세서에서 실행되는 프로그램들이 많다보니 여전히 높은 점유율을 차지하며 지금까지 오고 있는 것이다.<br /><br /><br /></li>
</ul>

<h1 id="결론">결론</h1>
<ul>
  <li>명령어 여러 개를 한꺼번에 처리하면 효율적이겠지만 그만큼 하드웨어 게이트(로직) 수가 많아지면서 실행 속도가 느려진다. 그리고 다른 명령어도 같이 느려진다.</li>
  <li>그래서 간단한 명령어를 여러개 조합해서 쓰는 것이 효율적이다. (<code class="language-plaintext highlighter-rouge">RISK Processor</code> 철학)</li>
  <li>어셈블리 코드를 쓰면 기계어와 가까워서 좋은 성능을 낼 수 있지만 최신 컴파일러는 <code class="language-plaintext highlighter-rouge">C</code> 언어와 같은 고급 언어로 쓴 코드도 어셈블리어와 비슷한 성능을 낼 수 있도록 최적화를 다 해 주기 때문에 그냥 고급 언어를 쓰는 것이 생산성이 더 높고 좋다. (어셈블리어는 생산성이 낮다)<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/cview.do?cid=16bd07027739ad22">컴퓨터구조 - 영남대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><category term="Instruction" /><summary type="html"><![CDATA[Instruction Set 프로세서에서 지원하는 명령어들의 집합 다른 컴퓨터는 다른 명령어셋을 가지고 있지만 기본적으로는 비슷하다. 현대 컴퓨터는 대부분 간단한 명령어셋(MIPS - RISK 방식)을 가지고 있다.]]></summary></entry><entry><title type="html">Java) BOJ 2750. 수 정렬하기</title><link href="http://localhost:4000/boj/boj2750-java/" rel="alternate" type="text/html" title="Java) BOJ 2750. 수 정렬하기" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2750-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2750-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2750">https://www.acmicpc.net/problem/2750</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>제한시간 1초에 N 최대값이 1,000이라 N^2 정렬 알고리즘으로 풀었다.(삽입정렬 사용)<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 188 ms</li>
  <li>메모리 : 16936 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8845c43c6d3be9195cad397c8c3e2984.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2750" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2750 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 2751. 수 정렬하기2</title><link href="http://localhost:4000/boj/boj2751-java/" rel="alternate" type="text/html" title="Java) BOJ 2751. 수 정렬하기2" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2751-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2751-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2751">https://www.acmicpc.net/problem/2751</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>제한시간 2초에 N 최대값이 백만이라 n log n 정렬 알고리즘을 써야 했는데 합병정렬을 쓰면 좋겠지만 구현하기 귀찮기도 하고… 자바에 구현되어 있는 sort 함수 사용법도 익힐겸 저걸 썼다.</li>
  <li>처음에는 Arrays.sort를 썼는데 1700ms 가 나와서 시간복잡도를 알아보니까 평균 n log n이지만 최악의 경우에는 n^2이었다.</li>
  <li>그래서 최악의 경우에도 n log n을 보장한다는 Collections.sort를 써 봤는데 1600ms 정도가 나와서 크게 시간 차이가 나지는 않았다.</li>
  <li>합병정렬 기억을 되살릴 겸 한 번 구현해 보는 것이 좋을 거 같다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 1636 ms</li>
  <li>메모리 : 171216 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/944a523911f3218c3088e59d5a8d6048.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2751" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2751 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Java) BOJ 1436. 영화감독 숌</title><link href="http://localhost:4000/boj/boj1436-java/" rel="alternate" type="text/html" title="Java) BOJ 1436. 영화감독 숌" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1436-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1436-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1436">https://www.acmicpc.net/problem/1436</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>666은 종말을 나타내는 숫자라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.</li>
  <li>조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고,</li>
  <li>
    <p>피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.</p>
  </li>
  <li>
    <p>하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.</p>
  </li>
  <li>
    <p>종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, …. 과 같다.</p>
  </li>
  <li>따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.</li>
  <li>
    <p>일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.</p>
  </li>
  <li>숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>브루트포스로 666부터 하나씩 증가시켜가면서 N번째 수를 구하려 했으나 처음에 생각을 잘못 하는 바람에… 틀려서 구글링 참고해서 풀었다.</li>
  <li>현재 수에 666이 포함되어 있으면 cnt를 증가시키고 cnt가 N과 같다면 현재 수를 리턴하고 그렇지 않다면 현재 수를 증가시키면서 또 666이 포함되어 있는지 확인한다.</li>
  <li>이 때 수를 문자열로 바꿔서 666이 연속되어 있는지 확인해도 되서 처음엔 그렇게 확인하는 함수를 구현했는데 구글링 하니까 자바에는 contains 함수가 있어서 편하게 그걸 썼다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 320 ms</li>
  <li>메모리 : 86524 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/cd9086d9b051383331645a51c0164abb.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1436" /><category term="BruteForce" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1436 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 1427. 소트인사이드</title><link href="http://localhost:4000/boj/boj1427-java/" rel="alternate" type="text/html" title="Java) BOJ 1427. 소트인사이드" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj1427-java</id><content type="html" xml:base="http://localhost:4000/boj/boj1427-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/1427">https://www.acmicpc.net/problem/1427</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력값을 모듈러와 나누기 연산을 하면서 한 자릿수씩 배열에 저장한 다음 Collections의 sort를 사용해 내림차순 정렬했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 124 ms</li>
  <li>메모리 : 14260 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/729070db4256846df492f9c70ff2476b.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No1427" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/1427 제한 시간 제한 : 2 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Java) BOJ 10989. 수 정렬하기3</title><link href="http://localhost:4000/boj/boj10989-java/" rel="alternate" type="text/html" title="Java) BOJ 10989. 수 정렬하기3" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj10989-java</id><content type="html" xml:base="http://localhost:4000/boj/boj10989-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/10989">https://www.acmicpc.net/problem/10989</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 3 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>자바는 제한시간 3초에 메모리 제한은 512라 컬렉션을 쓸 수 없었다.(처음에 컬렉션 sort 써 봤는데 메모리 초과됨 ㅠ)</li>
  <li>int 배열 메모리 계산해 보니까 합병정렬을 할 수 있을 정도가 되어서 합병정렬을 구현했다.</li>
  <li>N의 최대값 10,000,000 * 4byte(int) = 40,000,000byte = 39,062kb = 약 38mb</li>
  <li>합병정렬은 정렬할 배열과 같은 크기의 배열이 하나 더 필요하기 때문에 38 * 2 = 약 76mb</li>
  <li>그래서 자바에서 기본적으로 잡아먹는 메모리를 더해도 통과할 수 있을거 같아서 합병정렬로 풀었는데 시간이 좀 아슬아슬했다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 2948 ms</li>
  <li>메모리 : 383572 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/f9f2c1a27acf0a5bba1e0a65de41e81a.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No10989" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/10989 제한 시간 제한 : 3 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Java) BOJ 2108. 통계학</title><link href="http://localhost:4000/boj/boj2108-java/" rel="alternate" type="text/html" title="Java) BOJ 2108. 통계학" /><published>2022-02-26T00:00:00+09:00</published><updated>2022-02-26T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj2108-java</id><content type="html" xml:base="http://localhost:4000/boj/boj2108-java/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/2108">https://www.acmicpc.net/problem/2108</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 2 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.</p>
  </li>
  <li>산술평균 : N개의 수들의 합을 N으로 나눈 값</li>
  <li>중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값</li>
  <li>최빈값 : N개의 수들 중 가장 많이 나타나는 값</li>
  <li>범위 : N개의 수들 중 최댓값과 최솟값의 차이</li>
  <li>N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>
    <p>첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.</p>
  </li>
  <li>
    <p>둘째 줄에는 중앙값을 출력한다.</p>
  </li>
  <li>
    <p>셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.</p>
  </li>
  <li>
    <p>넷째 줄에는 범위를 출력한다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>각 알고리즘 자체는 어렵지 않았는데 종류가 많아서 그런가 구현에 시간이 걸렸다.</li>
  <li>중앙값 구하는 알고리즘을 더 손에 익히면 좋겠다.</li>
  <li>중앙값은 최대힙과 최소힙을 사용해서 중앙값보다 더 큰 수는 최소힙에 저장하고 작은 수는 최대힙에 저장한 후</li>
  <li>
    <p>최대힙과 최소힙의 길이가 같은 경우 top 평균을 구하고 최대힙이 더 크면 최대힙의 top을 반환하고 최소힙이 더 크면 최소힙의 top을 반환하도록 했다.<br /></p>
  </li>
  <li>최빈값은 배열 인덱스에 1:1로 매핑시켜서 빈도를 구하는 방식은 입력값의 범위가 커서 비효율적일 거 같아서 map을 사용했다.</li>
  <li>입력값을 &lt; 입력값, 빈도 &gt; 로 map에 저장한 후 입력이 끝나면 map을 순회하면서 가장 높은 빈도수를 구한 다음</li>
  <li>
    <p>가장 높은 빈도수와 일치하는 키값이 하나라면 그걸 바로 리턴하고 여러 개라면 그 수를 모두 배열에 저장한 뒤 오름차순으로 정렬해서 두번째로 작은 수를 구해서 리턴했다.<br /></p>
  </li>
  <li>범위는 입력 받으면서 최댓값과 최솟값을 구해서 두 값의 차를 출력하면 되는데 입력값이 음수도 들어오기 때문에 최댓값을 저장하는 변수의 초기값은 0이 아닌 Integer의 가장 작은 value로 설정하면 된다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 1028 ms</li>
  <li>메모리 : 105020 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/a66774c083b6bb3d29c76517e5342bbc.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No2108" /><category term="Sorting" /><category term="Java" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/2108 제한 시간 제한 : 2 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">OS) Process Management</title><link href="http://localhost:4000/operating%20system/OS-04-Process-Management/" rel="alternate" type="text/html" title="OS) Process Management" /><published>2022-02-25T00:00:00+09:00</published><updated>2022-02-25T00:00:00+09:00</updated><id>http://localhost:4000/operating%20system/OS-04-Process-Management</id><content type="html" xml:base="http://localhost:4000/operating%20system/OS-04-Process-Management/"><![CDATA[<h1 id="-프로세스-생성-process-creation">👀 프로세스 생성 (Process Creation)</h1>
<ul>
  <li>부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다.</li>
  <li>복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다.</li>
  <li>프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다.</li>
  <li>프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.</li>
</ul>

<h2 id="자원의-공유">자원의 공유</h2>
<ul>
  <li>부모와 자식이 모든 자원을 공유하는 모델</li>
  <li>일부를 공유하는 모델</li>
  <li>전혀 공유하지 않는 모델 (일반적)</li>
</ul>

<h2 id="수행-execution">수행 (Execution)</h2>
<ul>
  <li>부모와 자식은 공존하며 수행되는 모델</li>
  <li>자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델</li>
</ul>

<h2 id="주소-공간-address-space">주소 공간 (Address space)</h2>
<ul>
  <li>자식은 부모의 공간을 복사함 (binary and OS data)</li>
  <li>자식은 그 공간에 새로운 프로그램을 올린다.(덮어씌움)</li>
</ul>

<h3 id="유닉스의-예">유닉스의 예</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">fork()</code> 시스템 콜이 새로운 프로세스를 생성
    <ul>
      <li>부모를 그대로 복사 후 주소 공간 할당</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fork</code> 다음에 이어지는 <code class="language-plaintext highlighter-rouge">exec()</code> 시스템 콜을 통해 새로운 프로그램을 메모리에 올림 (덮어씌우는 단계)</li>
  <li><code class="language-plaintext highlighter-rouge">fork</code>와 <code class="language-plaintext highlighter-rouge">exec</code>은 독립적으로 이루어지기 때문에 둘 중 하나만 실행될 수 있다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스-종료-process-termination">프로세스 종료 (Process Termination)</h1>
<ul>
  <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.</li>
  <li>그래서 단계적인 종료를 통해 모든 자식 프로세스가 먼저 종료된 후 부모가 종료되어야 한다.</li>
</ul>

<h2 id="system-call을-통해-자발적으로-종료되는-경우">System call을 통해 자발적으로 종료되는 경우</h2>
<ul>
  <li>프로세스가 마지막 명령을 수행한 후 이를 운영체제에게 알려준다.(<code class="language-plaintext highlighter-rouge">exit</code>)</li>
  <li>자식이 부모에게 output data를 보냄 (via <code class="language-plaintext highlighter-rouge">wait</code>)</li>
  <li>프로세스의 각종 자원들이 운영체제에게 반납됨</li>
</ul>

<h2 id="비자발적으로-종료되는-경우">비자발적으로 종료되는 경우</h2>
<ul>
  <li>부모 프로세스가 자식 프로세스의 수행을 강제로 종료시킨다.(<code class="language-plaintext highlighter-rouge">abort</code>)</li>
  <li>자식이 할당 자원의 한계치를 넘어선 경우</li>
  <li>자식에게 할당된 태스크가 더 이상 필요하지 않은 경우</li>
  <li>부모가 종료(exit)하는 경우<br /><br /><br /></li>
</ul>

<h1 id="fork-시스템-콜">fork() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span> <span class="c1">// 부모와 자식을 구분하기 위한 값</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// 새로운 자식 프로세스가 생성되면 여기 다음 줄부터 실행한다.(부모의 문맥을 복사하기 때문)</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a child</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a child!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a parent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>자식 프로세스를 생성하기 위한 시스템 콜로 부모와 자식을 구분하기 위해 부모의 <code class="language-plaintext highlighter-rouge">pid</code>는 0보다 큰 값을 가지고 자식의 <code class="language-plaintext highlighter-rouge">pid</code>는 0을 가진다.<br /><br /><br /></li>
</ul>

<h1 id="exec-시스템-콜">exec() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a child</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a child! Now I'll run date </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">execlp</span><span class="p">(</span><span class="s">"/bin/date"</span><span class="p">,</span> <span class="s">"/bin/date"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">pid</span><span class="p">)</span>   <span class="c1">// this is a parent</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> Hello, I am a parent!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>어떤 프로그램을 새로운 프로세스로 바꿔주기 때문에 <code class="language-plaintext highlighter-rouge">execlp()</code>가 호출되는 순간 이후의 코드들은 실행되지 않는다.<br /><br /><br /></li>
</ul>

<h1 id="wait-시스템-콜">wait() 시스템 콜</h1>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">childPID</span><span class="p">;</span>
    <span class="n">S1</span><span class="p">;</span>
    
    <span class="n">childPID</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">childPID</span><span class="p">)</span>
        <span class="c1">// child 프로세스 코드 실행</span>
    <span class="k">else</span> 
        <span class="n">wait</span><span class="p">();</span>
        
    <span class="n">S2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>프로세스 A가 <code class="language-plaintext highlighter-rouge">wait()</code> 시스템 콜을 호출하면 커널은 <code class="language-plaintext highlighter-rouge">child</code>가 종료될 때까지 프로세스 A를 <code class="language-plaintext highlighter-rouge">sleep</code>시킨다.(block 상태)</li>
  <li>자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다.(ready 상태)<br /><br /><br /></li>
</ul>

<h1 id="exit-시스템-콜">exit() 시스템 콜</h1>
<h2 id="프로세스의-자발적-종료">프로세스의 자발적 종료</h2>
<ul>
  <li>마지막 statement 수행 후 <code class="language-plaintext highlighter-rouge">exit()</code> 시스템 콜을 통해 종료</li>
  <li>프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌</li>
</ul>

<h2 id="프로세스의-비자발적-종료">프로세스의 비자발적 종료</h2>
<ul>
  <li>부모 프로세스가 자식 프로세스를 강제 종료시킴
    <ul>
      <li>자식 프로세스가 한계치를 넘어서는 자원 요청시</li>
      <li>자식에게 할당된 태스크가 더 이상 필요하지 않을 때</li>
    </ul>
  </li>
  <li>키보드로 <code class="language-plaintext highlighter-rouge">kill</code>, <code class="language-plaintext highlighter-rouge">break</code>등을 친 경우</li>
  <li>부모가 종료하는 경우 부모 프로세스가 종료되기 전 자식 프로세스들이 먼저 종료된다.<br /><br /><br /></li>
</ul>

<h1 id="프로세스-간-협력">프로세스 간 협력</h1>
<h2 id="독립적-프로세스-independent-process">독립적 프로세스 (Independent process)</h2>
<ul>
  <li>프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못한다.</li>
</ul>

<h2 id="협력-프로세스-cooperating-process">협력 프로세스 (Cooperating process)</h2>
<ul>
  <li>프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있다.</li>
</ul>

<h2 id="프로세스-간-협력-메커니즘-ipc-interprocess-communication">프로세스 간 협력 메커니즘 (<code class="language-plaintext highlighter-rouge">IPC</code>: Interprocess Communication)</h2>
<h3 id="-메시지를-전달하는-방법">🔸 메시지를 전달하는 방법</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">message passing</code> : 커널을 통해 메시지 전달</li>
</ul>

<h4 id="-주소-공간을-공유하는-방법">🔸 주소 공간을 공유하는 방법</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">shared memory</code> : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음</li>
  <li>물리적 메모리에 매핑할 때 일부 주소공간을 공유하도록 매핑한다.(사전에 시스템 콜을 통해 운영체제에게 보고되어야 한다)</li>
</ul>

<h4 id="-thread">🔸 thread</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">thread</code>는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드들 간에는 주소 공간을 공유하기 때문에 협력이 가능하다. <br /><br /><br /></li>
</ul>

<h1 id="message-passing">Message Passing</h1>
<ul>
  <li>사용자 프로그램끼리는 메시지를 주고받는 것이 불가능하기 때문에 운영체제 커널을 통해서 메시지를 주고받는다.</li>
</ul>

<h2 id="message-system">Message system</h2>
<ul>
  <li>프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템</li>
</ul>

<h2 id="direct-communication">Direct Communication</h2>
<ul>
  <li>통신하려는 프로세스의 이름을 명시적으로 표시해서 메시지를 주고받는 것</li>
</ul>

<h2 id="indirect-communication">Indirect Communication</h2>
<ul>
  <li>mailbox(또는 port)를 통해 메시지를 간접 전달하는 방식<br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="http://www.kocw.net/home/search/kemView.do?kemId=1046323">운영체제 - 이화여자대학교 KOCW 공개강의</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Operating System" /><category term="CS" /><category term="OS" /><category term="Process" /><summary type="html"><![CDATA[👀 프로세스 생성 (Process Creation) 부모 프로세스(Parent process)가 자식 프로세스(Child process) 생성. 복제 생성 하는 것으로 부모 프로세스의 문맥(코드, 데이터, 스택 등)을 모두 복사한다. 복제된 자식 프로세스가 부모 프로세스의 하위 노드로 위치하고 그 자식이 또 자식을 복제하면 또 하위 노드로 위치하고… 를 반복하면서 프로세스의 트리(계층 구조)를 형성한다. 프로세스 혼자서 자식을 생성할 수는 없고 시스템 콜을 통해 운영체제의 서비스를 받아야만 자식 생성이 가능하다. 프로세스는 자원을 필요로 하기 때문에 운영체제로부터 받거나 부모와 공유한다. 기본적으로는 자식이 복제되는 순간 별도의 프로세스가 되기 때문에 그 순간부터 부모와 자원을 얻기 위해 경쟁하는 관계가 된다.]]></summary></entry></feed>