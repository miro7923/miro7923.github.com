<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-30T23:00:25+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">깃허브 블로그(Github Blog)를 만들기 위한 여정</title><link href="http://localhost:4000/story/making-github-blog/" rel="alternate" type="text/html" title="깃허브 블로그(Github Blog)를 만들기 위한 여정" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/story/making-github-blog</id><content type="html" xml:base="http://localhost:4000/story/making-github-blog/"><![CDATA[<h1 id="-시작">🎬 시작<br /></h1>
<p>개발 공부를 시작하고 기존에 쓰던 티스토리 블로그가 있긴 했는데 뭔가 깃헙을 이용해서 블로그를 꾸미고 여기에 공부한 내용을 올리고 싶어졌습니다. 다른 개발자 분들이 쓰시는 걸 보니까 되게 있어보이기도 하고 만들어져 있는 큰 회사(?)의 블로그를 쓰는 것 보다는 내가 직접 만들어 보면 뭔가 더 공부가 되지 않을까… 하는 생각으로 깃헙 블로그 만들기에 호기롭게 도전하게 되었습니다. <br />
 그리고 그것은 엄청난 고생길의 시작이었습니다….ㅎ<br /><br /></p>

<h1 id="0-시작-전에-ruby">0. 시작 전에… Ruby<br /></h1>
<p>깃헙 블로그는 보통 jekyll(지킬)이라는 것을 사용해서 꾸미더라고요. 근데 저건 ruby 기반으로 만들어져 있어서 깃헙 블로그를 시작하려면 ruby를 깔아야 합니다. 전 처음에 이것도 모르고 시작했기 때문에 블로그 글을 똑같이 따라해도 안 되었던 것들이 참 많았기 때문에…ㅎ 이 글을 보시는 분들은 시작 전에 꼭 ruby를 깔고 시작하세요!<br /><br />
ruby 설치 관련글은 아래 글과 같이 구글에 검색하시면 많이 보실 수 있을 것입니다.<br />
<a href="https://ogaeng.com/jekyll-blog-install/">https://ogaeng.com/jekyll-blog-install/</a><br /><br />
부디 고통받지 마시고 사전에 루비 설치하고 진행하세요…<br /><br /></p>

<h2 id="-그리고">+) 그리고…<br /></h2>
<p>시작 전에 깃헙 블로그는 터미널에서 명령어를 입력하는 것을 이용해서 만들 것인데 처음 하면 이것도 뭔가 싶으실 수 있습니다.<br />
모든 블로그 글들을 따라하다 보면 터미널에서 무슨 명령어를 입력해라고 할텐데 그냥 터미널을 켜고 명령어를 입력하면 전혀 작동하지 않고 명령어로 실행하고자 하는 파일이 들어있는 위치로 이동한 다음에 해당 명령어를 입력해야 합니다.<br /><br /></p>

<p><img src="../../assets/images/terminal01.png" alt="terminal01" /><br /><br />
그렇기 때문에 블로그 repository가 있는 폴더에서 마우스 우클릭해서 나오는 메뉴에서 <strong>‘폴더에서 새로운 터미널 열기’</strong> 를 선택해서 터미널을 실행하거나 <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /폴더경로
</code></pre></div></div>
<p>cd 명령어를 이용해 해당 파일이 있는 폴더로 이동해 모든 명령어를 입력해 주어야 합니다.<br /><br /></p>

<h1 id="1-참고했던-글">1. 참고했던 글<br /></h1>
<p><a href="https://zeddios.tistory.com/1222">https://zeddios.tistory.com/1222</a><br /><br />
맨 처음에는 이 블로그 글을 참고해서 만들었었습니다. <br />
그런데 똑같이 따라하고 심지어 테마도 똑같은 걸로 받아 썼지만 안 되더라고요… 제 repo에 push도 잘 되는데 정작 제 블로그 페이지에 들어가보면 맨 처음에 기본으로 주는 테마에서 변경이 안 되었습니다. .gitignore 설정이 잘못 되어있나 싶어서 아예 지워도보고 기타등등 별 짓을 다 해봤지만 되질 않아서… 이 글을 따라하며 만들었던 repo를 삭제하고 다시 만들기로 다짐하면서 다른 블로그 글을 찾아 떠나게 됩니다.<br /><br />
만약 이 글대로 하셔서 잘 되시면 거기서 스톱하고 나만의 블로그를 꾸미시면 됩니다. 전 되질 않아서 더 많은 시간을 소비해야만 했거든요…ㅠ <br /><br />
! 그리고 테마를 설치하다 보면 거의 99% 확률로<br /> 
<strong>`require’: cannot load such file – webrick (LoadError)</strong> <br />
이런 메세지를 보게 됩니다. 근데 다른 블로거분들은 이런걸 보신 적이 없는지 이것에 대한 언급이 아무도 없으심 ㅠ.ㅠ<br />
<a href="https://junho85.pe.kr/1850">https://junho85.pe.kr/1850</a><br /><br />
만약 저런 오류 메세지를 보시면 이 글을 참고하여 해결하시면 됩니다.<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle add webrick
</code></pre></div></div>
<p>무엇보다도 중요한 명령어… 전 테마를 설치할 때마다 webric을 꼭 추가해 주어야 했습니다.<br /><br /></p>

<p><a href="https://honbabzone.com/jekyll/start-gitHubBlog/">https://honbabzone.com/jekyll/start-gitHubBlog/</a><br /><br />
그리고 두번째로 찾은 글<br />
새로운 마음으로 다시 repo를 만들고 테마도 똑같은 걸로 다운받아서 진행했습니다. <br />
이번엔 다행히 잘 되었습니다. 😄👏👏👏<br /><br />
하지만 댓글 기능을 추가하려고 disqus에 들어가 보니까 <br /><br />
<img src="../../assets/images/disqus01.png" alt="disqus01" /><br /><br />
기본적으로 유료 서비스더라고요… 무료 서비스도 있긴 한데 무겁고 광고가 붙는다고 해서 disqus는 쓰지 않고 오픈소스에다 가벼운 utterances를 쓰기로 했습니다.<br /><br /></p>

<h1 id="2-utterances로-댓글-기능-만들기">2. utterances로 댓글 기능 만들기<br /></h1>
<p>사실 영어를 그닥 좋아하지 않아서(^^;) 최대한 한국인이 쓴 글을 구글링 해서 찾는 편이지만 제가 쓰는 테마는 영어를 쓰는 사람이 만들었기 때문에 영어로 된 설명서를 봐야만 했습니다.<br /><br />
<a href="https://github.com/apps/utterances">https://github.com/apps/utterances</a><br /><br />
일단 여기로 이동하셔서 utterances를 repo에 설치합니다. <br /><br /></p>

<p><img src="../../assets/images/utterances01.png" alt="utterances01" /><br /><br />
인스톨 버튼을 누르시면 <br /><br /></p>

<p><img src="../../assets/images/utterances02.png" alt="utterances02" /><br /><br />
이런 화면을 보실 수 있는데 제가 가진 모든 repo에 댓글 기능을 추가할 필요는 없기 때문에 블로그용으로 쓰는 repo만 선택했습니다. 여기까지 하셨으면 Install을 눌러서 다음으로 진행하시면 됩니다.<br /><br /></p>

<p><img src="../../assets/images/utterances03.png" alt="utterances03" /><br /><br />
다음으로 넘어가면 이런 화면을 보실 수 있는데 configuration 아래 repo를 설정하는 란에 나의 깃헙 블로그 파일들을 저장하는 repository의 경로를 적어주시면 됩니다. 깃헙아이디/깃헙아이디.github.com 혹은 깃헙아이디/깃헙아이디.githun.io 이런 식으로 보통 적으실 것입니다.<br /><br /></p>

<p><img src="../../assets/images/utterances04.png" alt="utterances04" /><br /><br />
밑으로 내려보시면 이런 선택란이 있을텐데 댓글이 작성되는 루트를 어디로 설정해주느냐 선택하는 것이라고 합니다. pathname은 블로그에 올릴 포스트의 파일명으로 깃헙 블로그에 올릴 포스트의 파일 이름 형식은 정해져 있어서(ex. 2022-01-30-title.md) 바꿀 일이 거의 없다고 봐도 되기 때문에 맨 첫번째 것으로 선택했습니다. 다른 분들도 많이 선택하시는 옵션이었습니다.<br /><br /></p>

<p><img src="../../assets/images/utterances05.png" alt="utterances05" /><br /><br />
그리고 또 밑으로 내려보시면 이런 태그를 보실 수 있는데 본인이 쓰시는 테마의 레이아웃에 이걸 설정하는 란이 따로 있다면 저 태그를 복사해서 넣어주시면 되는데 제가 쓰는 테마엔 따로 없어서 저 태그는 필요가 없었습니다. <br />
Theme 아래 화살표가 있는 박스를 눌러보시면 댓글창의 테마를 선택할 수 있으니 맘에 드는 것을 고르시면 되겠습니다. <br /><br /></p>

<p><img src="../../assets/images/utterances06.png" alt="utterances06" /><br /><br />
대신 위 설명처럼 _config.yml 파일에서만 설정해주면 되었습니다.<br /><br /></p>

<p><img src="../../assets/images/utterances07.png" alt="utterances07" /><br /><br />
이런 식으로 provider 이름만 설정해주고 아래 utterances 정보 입력란에서 입력만 해 주니까<br /><br /></p>

<p><img src="../../assets/images/utterances08.png" alt="utterances08" /><br /><br />
짜잔! 댓글창이 생겼습니다!! 😘👏👏<br />
아 행복해… 이거 만든다고 또 한시간 썼었거든요…ㅠ <br />
댓글창 색이 테마랑 좀 안맞는 감이 있지만 이건 천천히 수정하기로 하고.. 여기까지 해서 제 첫 깃헙 블로그를 만들기 위한 여정이 마무리 되었습니다. <br /><br />
혹시 제 블로그 설정 파일이 궁금하시면 <br /> 
<a href="https://github.com/miro7923/miro7923.github.com">https://github.com/miro7923/miro7923.github.com</a><br />
 여기를 참고하세요. <br /><br />
<a href="https://github.com/miro7923/miro7923.github.com/blob/main/_config.yml">https://github.com/miro7923/miro7923.github.com/blob/main/_config.yml</a><br />
그 중에서도 _config.yml 파일 내용이 궁금하시면 여기를 참고하시면 됩니다. <br /><br /></p>

<h1 id="3-그런데-열심히-쓴-글이-포스팅-되지-않는다">3. 그런데.. 열심히 쓴 글이 포스팅 되지 않는다.<br /></h1>
<p>드디어 블로그 세팅을 완료하고 설레는 마음으로 첫 글을 썼는데 로컬 서버로 띄워 보면 잘 보이는데 암만 push를 해도 실제 제 블로그에서는 보이질 않는 것이었습니다…! 머선일이고 이게 ㅠㅠ<br /><br />
약 한시간동안 헤멘 끝에<br />
 <a href="https://devyuseon.github.io//github%20blog/githubblog-post-not-shown/">https://devyuseon.github.io//github%20blog/githubblog-post-not-shown/</a><br />
이 글을 보고 해결할 수 있었습니다.<br /><br /></p>

<p><img src="../../assets/images/published.png" alt="published" /><br /><br />
저는 _config.yml에 future: true 추가하고 게시글 마크다운 파일의 상단 타이틀 쓰는 란에 published: true 를 추가해 주었더니 해결되었습니다.<br /><br />
그리고 네이버나 티스토리처럼 큰 회사 블로그처럼 push 하자마자 블로그가 업데이트 되는 것은 아니고 몇 분 정도 기다려야 변경내용이 완전히 반영이 되더라고요. 외국 회사라 그런가?<br /><br /></p>

<p>그럼 오늘은 여기까지… 다음 글에서 만나요!!<br /></p>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Story" /><category term="story" /><summary type="html"><![CDATA[🎬 시작 개발 공부를 시작하고 기존에 쓰던 티스토리 블로그가 있긴 했는데 뭔가 깃헙을 이용해서 블로그를 꾸미고 여기에 공부한 내용을 올리고 싶어졌습니다. 다른 개발자 분들이 쓰시는 걸 보니까 되게 있어보이기도 하고 만들어져 있는 큰 회사(?)의 블로그를 쓰는 것 보다는 내가 직접 만들어 보면 뭔가 더 공부가 되지 않을까… 하는 생각으로 깃헙 블로그 만들기에 호기롭게 도전하게 되었습니다. 그리고 그것은 엄청난 고생길의 시작이었습니다….ㅎ]]></summary></entry><entry><title type="html">컴퓨터는 무엇일까?</title><link href="http://localhost:4000/computer%20science/CS02/" rel="alternate" type="text/html" title="컴퓨터는 무엇일까?" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS02</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS02/"><![CDATA[<h1 id="컴퓨터는-무엇일까">컴퓨터는 무엇일까?</h1>
<h2 id="컴퓨터의-정의">컴퓨터의 정의<br /></h2>
<ul>
  <li>컴퓨터(Computer)란 지금까지 사람이 해 왔던 기억과 계산 등의 일을 빠르고 정확하게 처리해 주는 기계이며, 사람의 지시에 따라 여러 가지 일을 자동적으로 처리해주는 전자 장치이다.<br /></li>
  <li>컴퓨터라는 명칭 자체가 계산하다 라는 뜻인 compute에서 확장된, 계산해주는 사람(혹은 장치)이라는 뜻의 computer에서 유래되었다.<br /></li>
  <li>초기의 컴퓨터는 단순 수치 계산을 목적으로 만들어졌지만 오늘날의 컴퓨터는 수치 계산 뿐만 아니라 기억, 분류, 비교하는 것과 같은 여러 가지 일들을 한꺼번에 처리할 수 있다. <br /></li>
  <li>외부로부터 입력된 자료를 정의된 방법에 따라 자료를 처리하여 정보를 생성하고, 사용자에게 생성된 정보를 출력해 주는 기능을 가지고 있다.<br /><br /></li>
</ul>

<h2 id="컴퓨터의-기능">컴퓨터의 기능<br /></h2>
<h3 id="1-입력-기능">1. 입력 기능<br /></h3>
<ul>
  <li><strong>처리할 데이터</strong>와 <strong>처리 방법</strong> 그리고 <strong>절차</strong>를 지시하는 프로그램을 <strong>외부로부터 읽어</strong>들여 기억 장치로 전달해 주는 기능<br /><br /></li>
</ul>

<h3 id="2-기억-기능">2. 기억 기능<br /></h3>
<ul>
  <li><strong>읽어 들인 데이터</strong>와 <strong>절차를 지시하는 프로그램</strong>들과 <strong>처리된 결과</strong> 등을 기억 장치에 <strong>기억</strong>시키는 기능<br /><br /></li>
</ul>

<h3 id="3-연산-기능">3. 연산 기능<br /></h3>
<ul>
  <li>데이터를 기억 장치에 기억된 프로그램을 통해서 <strong>산술 연산과 논리 연산을 하여 결과를 만들어 내는</strong> 기능<br /><br /></li>
</ul>

<h3 id="4-제어-기능">4. 제어 기능<br /></h3>
<ul>
  <li>기억된 프로그램들의 명령을 하나씩 읽고 해석하여 컴퓨터 각각의 기능이 유기적으로 동작하도록 <strong>장치들을 제어하고 지시</strong>하는 기능<br /><br /></li>
</ul>

<h3 id="5-출력-기능">5. 출력 기능<br /></h3>
<ul>
  <li>컴퓨터 내에 기억된 내용과 처리된 결과를 문자, 도형, 음성 등의 형태로 외부에 보여주는 기능<br /></li>
  <li>컴퓨터의 기능 중에서 <strong>기억</strong>과 <strong>제어</strong> 그리고 <strong>연산</strong> 기능은 가장 핵심적인 것으로서 <strong>주기억장치(Main Memory)</strong>와 <strong>중앙처리 장치(Central Processing Unit : CPU)</strong>에서 이루어진다.<br /><br /><br /></li>
</ul>

<h2 id="컴퓨터의-특징">컴퓨터의 특징<br /></h2>
<h3 id="1-신속성">1. 신속성<br /></h3>
<ul>
  <li>자료를 주어진 시간 내에 빠르고 신속하게 처리한다.<br /><br /></li>
</ul>

<h3 id="2-정확성">2. 정확성<br /></h3>
<ul>
  <li>계산 시에 에러나 오차를 최소화하고 정확하게 계산하고 판단한다.<br /><br /></li>
</ul>

<h3 id="3-자동성">3. 자동성<br /></h3>
<ul>
  <li>입출력을 비롯한 전체 처리 과정을 자동적으로(프로그램 된 대로) 처리한다.<br /><br /></li>
</ul>

<h3 id="4-대량성">4. 대량성<br /></h3>
<ul>
  <li>대량 데이터의 처리가 가능하고 대량 데이터의 저장이 가능하다.<br /><br /><br /></li>
</ul>

<h2 id="컴퓨터의-필요성">컴퓨터의 필요성<br /></h2>
<ol>
  <li>과학 기술의 발달과 산업 사회의 급격한 변화로 새로운 정보를 신속하게 수집, 분석, 활용할 필요성이 생겼다.<br /></li>
  <li>사회 현상이 복잡하고 다양해짐에 따라 처리할 데이터 양이 기하급수적으로 증가하였다.<br /></li>
  <li>가상 현실이나 모의 실험을 활용하여 위험 부담을 줄일 수 있기 때문이다.<br /></li>
  <li>편리한 생활을 위한 기계 및 전자 장치들을 제어하기 위해 컴퓨터가 필요하게 되었다.<br /><br /></li>
</ol>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터는 무엇일까? 컴퓨터의 정의 컴퓨터(Computer)란 지금까지 사람이 해 왔던 기억과 계산 등의 일을 빠르고 정확하게 처리해 주는 기계이며, 사람의 지시에 따라 여러 가지 일을 자동적으로 처리해주는 전자 장치이다. 컴퓨터라는 명칭 자체가 계산하다 라는 뜻인 compute에서 확장된, 계산해주는 사람(혹은 장치)이라는 뜻의 computer에서 유래되었다. 초기의 컴퓨터는 단순 수치 계산을 목적으로 만들어졌지만 오늘날의 컴퓨터는 수치 계산 뿐만 아니라 기억, 분류, 비교하는 것과 같은 여러 가지 일들을 한꺼번에 처리할 수 있다. 외부로부터 입력된 자료를 정의된 방법에 따라 자료를 처리하여 정보를 생성하고, 사용자에게 생성된 정보를 출력해 주는 기능을 가지고 있다.]]></summary></entry><entry><title type="html">컴퓨터의 역사</title><link href="http://localhost:4000/computer%20science/CS03/" rel="alternate" type="text/html" title="컴퓨터의 역사" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS03</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS03/"><![CDATA[<h1 id="컴퓨터의-역사">컴퓨터의 역사<br /></h1>
<h2 id="1-초창기-계산기">1. 초창기 계산기<br /></h2>
<ul>
  <li>학교 다닐 때 배웠던 근대 문학에서 흔히 등장하는 주판이 있다. 주판은 지금 쓰는 전자식 계산기가 보급되기 전 계산을 할 때 쓰던 도구이다.<br /></li>
  <li>주판이 규칙에 따라 문제를 풀 수 있는 장치인 것을 알고 있는 중세와 근대의 유럽인들은 이러한 규칙을 기계 장치에 집어넣으면 계산을 자동화할 수 있지 않을까 하는 발상에서 톱니 계산기를 발명하게 된다.<br /></li>
  <li>최초의 기계식 계산기는 1642년에 파스칼이 고안한 장치였다. 이 장치는 손잡이와 이에 딸린 톱니바퀴가 일정한 비율로 배열되어 손잡이를 좌우로 돌리는데에 따라 덧셈과 뺄셈이 자동으로 수행되는 장치였다. <br /></li>
  <li>이후 라이프니츠가 만든 계산기는 덧셈과 뺄셈 이외에도 곱셈과 나눗셈, 간단한 제곱근까지도 계산이 가능했다고 한다.<br /><br /></li>
</ul>

<h2 id="2-근대-계산기">2. 근대 계산기<br /></h2>
<ul>
  <li>초창기 계산기들은 손으로 수치를 일일이 입력해야 하는 것이 큰 단점이었다. 그래서 19세기 들어 입력 방식을 보완한 근대적 계산기가 탄생하게 된다.<br /></li>
  <li>구멍이 뚫려 있는 천공 카드(punched card)를 이용해서 카드에 뚫린 구멍의 순서에 따라 톱니가 물려 입력 순서를 정하게 되는 방식을 이용해 입력 방식을 보완한다. <br /></li>
  <li>찰스 바베지는 증기 기관으로 작동되는 수식 계산 기계인 차분 엔진(difference engine)과 업그레이드 판인 해석 엔진(analytical engine)을 설계한다. 하지만 완성하지는 못했다.<br /></li>
  <li>찰스 바베지와 함께 프로젝트를 진행했었던 에이다는 세계 최초의 여성 컴퓨터 과학자로 기록되었으며, 병렬 처리 프로그래밍 언어로 유명한 Ada는 그녀의 이름을 딴 것이다.<br /><br /></li>
</ul>

<h2 id="3-현대식-컴퓨터">3. 현대식 컴퓨터<br /></h2>
<ul>
  <li>현대식 전자 컴퓨터는 국방 분야에서 자동화를 위해 많은 인력과 자본을 투입해 개발한 것에서 시작되었다. <br /></li>
  <li>최초의 전자식 계산기의 토대는 2차 세계대전 기간에 만들어져, 2차 세계대전이 끝나고 1950년대 말부터 일반 사무용으로 보급된다. <br /><br /></li>
</ul>

<h3 id="1-0세대">1) 0세대<br /></h3>
<ul>
  <li>최초의 컴퓨터라 할 수 있는 ENIAC(Electronic Nemerical Integrator And Computer)이 개발되었다.</li>
  <li>초당 5번의 곱셈이 가능했지만 지금의 컴퓨터와는 다르게 설계에 따라 한 문제만 풀 수 있었고 다른 문제를 풀게 하려면 진공관 회로의 배치를 바꿔줘야 했다.</li>
  <li>당시 컴퓨터는 덩치가 아주 크고 진공관 수는 약 2만여개였기 때문에 배치를 바꾸는 데에 몇 주가 소요되었다. 그리고 전력도 많이 들고 진공관 고장도 잦고 효율적이지 않았기 때문에 현대 컴퓨터의 아버지라 불리는 존 폰 노이만이 새로운 방식을 고안해 낸다. <br /></li>
  <li>이 방식이 지금 우리에게 익숙한 소프트웨어 방식이다. 저장 프로그램 개념으로 컴퓨터 프로그램을 처리해야 할 데이터의 일부로 규정하여 이를 기억 장치에 저장해 놓고 반복적으로 이용 가능하도록 한 방식이다.<br /></li>
  <li>이 시기에는 0과 1로 이루어진 기계어가 프로그래밍 언어로 사용되었다.<br /><br /></li>
</ul>

<h3 id="2-1세대-컴퓨터1950년대">2) 1세대 컴퓨터(1950년대)<br /></h3>
<ul>
  <li>0세대 컴퓨터는 연구와 국방 목적으로 이용되었지만 이것을 상업적으로 판매할 수 있을거라 생각한 사람들에게서 1세대 컴퓨터가 시작된다.</li>
  <li>최초의 1세대 컴퓨터는 UNIVAC(Universal Automatic Computer)으로 입력 장치로 천공 카드를 이용하고 내부 계산 장치로 진공관을 이용하도록 설계되었다.<br /></li>
  <li>하지만 진공관 컴퓨터는 전력을 많이 소모하면서 속도가 느리고 가격이 비쌌다. 그리고 작동시키려면 0과 1로 이루어진 이진법 기계어에 익숙한 전문가가 필요했기 때문에 여전히 대중화되지는 못했다.<br /></li>
  <li>이 시기에 들어서면서 기계어를 인간이 인식할 수 있는 문자로 대치해서 쓰는 어셈블리어가 개발되었다.<br /><br /></li>
</ul>

<h3 id="3-2세대-컴퓨터1959년대-말--1960년대-초">3) 2세대 컴퓨터(1959년대 말 ~ 1960년대 초)<br /></h3>
<ul>
  <li>진공관의 단점인 크기, 전력 소모, 열 발생의 문제들이 해결된 트랜지스터가 개발된다.</li>
  <li>트랜지스터를 이용해서 진공관 컴퓨터와 같은 원리로 동작하는 컴퓨터를 만드는 것이 가능했기 때문에 트랜지스터 컴퓨터가 개발되면서 컴퓨터의 처리 속도가 획기적으로 빨라지게 된다. 하지만 여전히 입력 수단으로는 천공 카드를 사용하고 있었는데 천공 카드의 입력 속도가 처리 속도에 비해 느려서 컴퓨터가 벌써 일을 다 끝내고 입력을 하염없이 기다리고 있게 된다.<br /></li>
  <li>이를 해결하기 위해
    <ul>
      <li><u>**병렬 처리(parallel processing) 기법**</u> : 여러 개의 프로세서가 입력과 출력 및 연산을 독자적으로 수행하는 것<br /></li>
      <li><u>**멀티프로그래밍(multi-programming) 기법**</u> : 한 개의 프로세서가 서로 다른 여러 개의 프로그램을 번갈아 가면서 처리하는 것<br />
  들이 개발되었다.<br /></li>
    </ul>
  </li>
  <li>이 시기에 들어서서 인간이 인식하기 쉬운 언어로 작성한 프로그램을 기계어나 어셈블리어로 번역하는 컴파일러(compiler) 기술이 개발된다. 이에 따라 프로그램을 보다 체계적으로 구성할 필요가 생기면서 구조적 프로그래밍 언어 기법이 도입되었다. 이를 이용해서 우리가 코딩할 때 쓰는 라이브러리 개념이 생긴다.<br /><br /></li>
</ul>

<h3 id="4-3세대-컴퓨터1960년대-중반--1960년대-말">4) 3세대 컴퓨터(1960년대 중반 ~ 1960년대 말)<br /></h3>
<ul>
  <li>3세대 컴퓨터 시기에 들어오면서 트랜지스터와 동일한 원리로 작동되지만 하나의 작은 실리콘 조각 위에 여러 개의 트랜지스터와 전자회로를 포함한 <u>**집적회로(IC : Integrated Circuit) **</u>가 개발된다.</li>
  <li>집적회로는 비용을 크게 줄였기 때문에 보다 저렴하면서 강력한 성능을 가진 컴퓨터의 제작이 가능해졌다.<br /></li>
  <li>다중 처리와 다중 프로그래밍이 중요해졌으며 시분할 처리 시스템(Time Sharing System)이 생겨난다.<br /><br /></li>
</ul>

<h3 id="5-4세대-컴퓨터1970년대-초--1980년대-말">5) 4세대 컴퓨터(1970년대 초 ~ 1980년대 말)<br /></h3>
<ul>
  <li>집적회로가 더욱 발전되어 하나의 집적회로에서 연산, 제어, 기억 등의 프로세서의 모든 기능을 단순하게나마 수행할 수 있는 <u>**마이크로프로세서**</u>가 개발된다.</li>
  <li>마이크로프로세서를 이용해 만든 개인용 마이크로 컴퓨터가 폭발적인 인기를 끌면서 컴퓨터의 설계는 마이크로프로세서 중심으로 개편된다.<br /></li>
  <li>이 시기부터 GUI(Graphical User Interface)가 개발되어 컴퓨터에 대한 지식이 없어도 쉽게 사용할 수 있게 된다.<br /><br /></li>
</ul>

<h3 id="6-5세대-컴퓨터1990년--현재">6) 5세대 컴퓨터(1990년 ~ 현재)<br /></h3>
<ul>
  <li>데스크톱 말고도 랩탑과 팜탑 컴퓨터의 출현과 보조 기억 장치(CD-ROM, DVD 등)의 개선과 멀티미디어의 사용, 가상현실 등이 주요 특징이다.<br /></li>
  <li>객체지향언어와 프로그래밍이 각광받기 시작했으며 인터넷이 등장했다.<br /><br /></li>
</ul>

<h3 id="7-미래의-컴퓨터-기술">7) 미래의 컴퓨터 기술<br /></h3>
<ul>
  <li>병렬 처리 기술이 더욱 두드러지고 대용량의 주변기기들과의 접목을 통해 컴퓨터의 멀티미디어화가 더욱 가속화 될 것이다.<br /></li>
  <li>착용식 컴퓨터, 광 컴퓨터, 양자 컴퓨터, 바이오 컴퓨터 등과 같은 새로운 형태의 컴퓨터들이 출현할 것으로 기대된다.<br /></li>
  <li>인공지능(AI)이 더욱 발전되어 사람처럼 생각하고 행동하는 소프트웨어가 개발될 것으로 예상된다.<br /></li>
  <li>유비쿼터스 컴퓨팅이 보편화 되어 사용자가 네트워크나 컴퓨터를 의식하지 않고 장소에 상관없이 자유롭게 네트워크에 접속할 수 있는 정보통신 환경이 형성됨으로써 컴퓨팅의 사용성을 극대화한 사용자 중심의 중단없는 컴퓨팅 환경이 제공될 것으로 예상된다.<br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터의 역사 1. 초창기 계산기 학교 다닐 때 배웠던 근대 문학에서 흔히 등장하는 주판이 있다. 주판은 지금 쓰는 전자식 계산기가 보급되기 전 계산을 할 때 쓰던 도구이다. 주판이 규칙에 따라 문제를 풀 수 있는 장치인 것을 알고 있는 중세와 근대의 유럽인들은 이러한 규칙을 기계 장치에 집어넣으면 계산을 자동화할 수 있지 않을까 하는 발상에서 톱니 계산기를 발명하게 된다. 최초의 기계식 계산기는 1642년에 파스칼이 고안한 장치였다. 이 장치는 손잡이와 이에 딸린 톱니바퀴가 일정한 비율로 배열되어 손잡이를 좌우로 돌리는데에 따라 덧셈과 뺄셈이 자동으로 수행되는 장치였다. 이후 라이프니츠가 만든 계산기는 덧셈과 뺄셈 이외에도 곱셈과 나눗셈, 간단한 제곱근까지도 계산이 가능했다고 한다.]]></summary></entry><entry><title type="html">컴퓨터의 분류</title><link href="http://localhost:4000/computer%20science/CS04/" rel="alternate" type="text/html" title="컴퓨터의 분류" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS04</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS04/"><![CDATA[<h1 id="컴퓨터의-분류">컴퓨터의 분류<br /></h1>

<h2 id="1-사용-목적에-따른-분류">1. 사용 목적에 따른 분류<br /></h2>
<h3 id="1-특수용-컴퓨터">1) 특수용 컴퓨터<br /></h3>
<ul>
  <li>한 가지 작업만을 처리할 수 있도록 설계되고 만들어진 컴퓨터<br /><br /></li>
</ul>

<h3 id="2-범용-컴퓨터">2) 범용 컴퓨터<br /></h3>
<ul>
  <li>여러 분야에서 다양한 일을 할 수 있도록 설계된 컴퓨터<br /></li>
  <li>일반적인 자료 처리는 물론이고 프로그램을 교체하여 다른 작업에 이용할 수 있다.<br /></li>
  <li>연구, 기업업무용으로 주로 사용되어 우리가 흔히 아는 개인용 컴퓨터와는 약간 다르다.<br /><br /></li>
</ul>

<h3 id="3-개인용-컴퓨터">3) 개인용 컴퓨터<br /></h3>
<ul>
  <li>개인의 업무를 처리하도록 설계된 컴퓨터<br /></li>
  <li>우리가 흔히 볼 수 있는 컴퓨터로 교육용, 가정용, 기업용 등으로 널리 보급되어 있다.<br /><br /><br /></li>
</ul>

<h2 id="2-데이터-표현-방식에-따른-분류">2. 데이터 표현 방식에 따른 분류<br /></h2>
<h3 id="1-디지털-컴퓨터">1) 디지털 컴퓨터<br /></h3>
<ul>
  <li>일반적으로 생각하는 컴퓨터<br /></li>
  <li>이산적(discrete, 연속적이지 않다)인 형태로 이용한다.<br /></li>
  <li>시간에 따른 연속적인 변화량을 정해진 시간에 측정된 수치로 기억한다. 연결된 것처럼 보일만큼 작은 단위로 쪼개서 기억한다고 볼 수 있다.<br /><br /></li>
</ul>

<h3 id="2-아날로그-컴퓨터">2) 아날로그 컴퓨터<br /></h3>
<ul>
  <li>연속적인 자료를 이용하여 물리적인 유사성으로 변수나 양을 표현하고 이를 수학적으로 분석한 물리적 상태를 흉내 내는 방식으로 작동한다.<br /></li>
  <li>거리, 속도, 가속도, 온도, 압력 등의 물리량을 전압이나 전류의 양으로 대치하고 기계적 또는 전자적으로 동등한 회로에서 작동시킨 결과를 이용하는 방식이다.<br /><br /></li>
</ul>

<h3 id="3-하이브리드-컴퓨터">3) 하이브리드 컴퓨터<br /></h3>
<ul>
  <li>변환기를 통해 아날로그 형태로 입력된 데이터를 디지털 형태로 변환하여 처리한 후 결과를 디지털 형태나 다시 아날로그 형태로 변환하여 출력할 수 있다.<br /><br /><br /></li>
</ul>

<h2 id="3-처리-용량에-따른-분류">3. 처리 용량에 따른 분류<br /></h2>
<ul>
  <li>현재는 크기와는 별도로 컴퓨터의 처리 속도에 따른 분류를 주로 사용한다.<br /><br /></li>
</ul>

<h3 id="1-슈퍼-컴퓨터">1) 슈퍼 컴퓨터<br /></h3>
<ul>
  <li>가장 빠르고 가장 가격이 비싼 컴퓨터를 총칭하는 용어이다.<br /></li>
  <li>항공 우주, 입자물리와 화학, 전자, 자동차 및 석유 탐사 분야와 기상 예측, 지진 분석, 유전자 분석 등 시간이 오래 걸리는 복잡한 수학 공식을 반복적으로 방대한 분량을 계산하는 과학 기술 분야에서 주로 사용된다.<br /></li>
  <li>10기가 플롭스 이상의 속도를 가지고 있는 컴퓨터가 슈퍼 컴퓨터의 범주에 포함된다.<br /><br /></li>
</ul>

<h3 id="2-메인프레임-컴퓨터">2) 메인프레임 컴퓨터<br /></h3>
<ul>
  <li>대규모 회사에서 주로 사용하는 컴퓨터<br /></li>
  <li>계산의 양보다는 입력과 출력되는 데이터의 양이 많은 경우에서 주로 사용된다.<br /></li>
  <li>다중 사용자(multi-user) 시스템<br /><br /></li>
</ul>

<h3 id="3-미니-컴퓨터">3) 미니 컴퓨터<br /></h3>
<ul>
  <li>메인프레임 컴퓨터보다 저렴하면서 메인프레임 컴퓨터와 유사한 기능을 이용할 수 있는 컴퓨터<br /></li>
  <li>약 200명 정도의 동시 사용자를 지원해주는 시스템을 가지고 있다.<br /></li>
  <li>메인프레임 컴퓨터의 하위 호완버전이라고 생각하면 된다.<br /></li>
  <li>다중 사용자(multi-user) 시스템<br /><br /></li>
</ul>

<h3 id="4-워크스테이션과-마이크로-컴퓨터">4) 워크스테이션과 마이크로 컴퓨터<br /></h3>
<ul>
  <li>단일 사용자(single-user) 시스템<br /><br /></li>
</ul>

<p>4-1) 워크스테이션<br />
    * 강력한 계산, 고성능의 그래픽 디스플레이를 필요로 하는 공학자와 건축가, 그 외의 여러 분야의 전문가들의 작업에 적합하도록 설계된 데스크탑 컴퓨터<br /><br /></p>

<p>4-2) 마이크로 컴퓨터<br />
    * 우리가 흔히 볼 수 있는 데스크탑 컴퓨터<br />
    * 현재 많은 사람들이 사용하는 개인용 컴퓨터(PC)는 마이크로프로세서를 이용한 마이크로 컴퓨터를 뜻한다.<br /><br /></p>

<h3 id="5-휴대형-컴퓨터">5) 휴대형 컴퓨터<br /></h3>
<p>5-1) 랩탑 컴퓨터<br />
    * 3~4kg 정도의 무게에 무릎 위에 올려놓고 사용할 수 있는 컴퓨터<br /><br /></p>

<p>5-2) 노트북 컴퓨터<br />
    * 우리가 흔히 사용하는 노트북<br /><br /></p>

<p>5-3) 팜탑 컴퓨터<br />
    * 처리해야 할 작업의 종류가 다양하지 않고 노트북을 휴대하는 것조차 부담스러운 이용자들을 위해 개발된 컴퓨터<br />
    * 대표적인 것이 PDA로 약속 시간 관리 및 전화 번호부, 메모장 등의 용도로 한정되어 있다. 최근에는 무선 및 유선 통신 기능을 추가하여 근로용 단말기로도 이용되고 있다.<br /><br /></p>

<p>5-4) 스마트폰<br />
    * 우리가 흔히 사용하는 스마트폰<br />
    * 다양한 기능 수용을 위해서 iOS, 안드로이드와 같은 표준화된 전용 운영체제를 갖추고 있다.<br /><br /></p>

<p>5-5) 태플릿 PC<br />
    * 아이패드와 같은 태블릿<br />
    * 일반 업무용과 개인 멀티미디어 기기로 활용하며, 프레젠테이션, 교육, 모바일 네트워크 기기로 활용<br /><br /></p>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터의 분류]]></summary></entry><entry><title type="html">데이터의 표현과 연산</title><link href="http://localhost:4000/computer%20science/CS05/" rel="alternate" type="text/html" title="데이터의 표현과 연산" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS05</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS05/"><![CDATA[<h1 id="데이터의-표현과-연산">데이터의 표현과 연산<br /></h1>

<h2 id="1-컴퓨터의-수-체계">1. 컴퓨터의 수 체계<br /></h2>
<ul>
  <li>우리는 10진수를 사용하지만 컴퓨터는 0과 1로 모든 것을 판단하기 때문에 2진수를 사용한다.<br /></li>
  <li>컴퓨터의 연산과 제어의 기본은 부울대수이며, 컴퓨터가 다루는 데이터를 2진 숫자(Binary digIT)라고 하며 약자로 비트(BIT)라고 한다.<br /></li>
  <li>8개의 비트를 한 단위로 하여 1바이트(byte)로 사용한다.<br /></li>
  <li>2진수의 최상위 비트를 MSB(most significant bit)라 하고 최하위 비트를 LSB(least significant bit)라 한다.<br /><br /></li>
</ul>

<h2 id="2-데이터의-표현">2. 데이터의 표현<br /></h2>
<p>1) BCD 코드<br /></p>
<ul>
  <li>Binary Coded Decimal의 약자로 8421 코드라고도 한다.<br /></li>
  <li>BCD 코드는 각 비트 자리가 자리값을 갖는데 1010이라는 4자리 비트가 있다고 했을 때 왼쪽(10진수로 생각할 때 1000의 자리)부터 <br /></li>
  <li>2^3 = 8<br /></li>
  <li>2^2 = 4<br /></li>
  <li>2^1 = 2<br /></li>
  <li>2^0 = 1<br /></li>
  <li>의 값을 가지므로 8421코드라 부른다. <br /></li>
  <li>일반적으로 10진수를 2진수로 표현하는 것과 비슷하지만 10이 넘어가면 2진수는 1010이라고 표현하지만 BCD 코드는 0001 0000, 11은 0001 0001 … 와 같은 방식으로 표현한다.<br /><br /></li>
</ul>

<p>2) 문자 데이터<br /></p>
<ul>
  <li>문자 데이터는 1바이트의 데이터이다. 아스키코드의 문자 ABC를 2진법과 16진법으로 나타낸다면 다음과 같이 된다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>문자</th>
      <th>2진법</th>
      <th>16진법</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>0100 0001</td>
      <td>41H</td>
      <td> </td>
    </tr>
    <tr>
      <td>B</td>
      <td>0100 0010</td>
      <td>42H</td>
      <td> </td>
    </tr>
    <tr>
      <td>C</td>
      <td>0100 0011</td>
      <td>43H</td>
      <td><br /><br /></td>
    </tr>
  </tbody>
</table>

<p>3) 존(Zone) 형식<br /></p>
<ul>
  <li>언팩(unpack) 형식이라고도 하며, 1바이트에 한 개의 10진수가 저장된다. 1바이트의 왼쪽 4비트를 존(zone) 비트라고 하며 항상 F(16진수)가 들어 있다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>1111</th>
      <th>0111</th>
      <th>1111</th>
      <th>0001</th>
      <th>1100</th>
      <th>0010</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>F</td>
      <td>7</td>
      <td>F</td>
      <td>1</td>
      <td>C(양수)</td>
      <td>2</td>
      <td><br /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>10진수를 712로 표현한다면 위와 같이 표현되는데 마지막 바이트의 왼쪽 4비트를 이용해서 부호를 나타낸다. 위와 같은 경우처럼 마지막 바이트의 왼쪽 4비트가 C라면 양수고<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>1111</th>
      <th>0111</th>
      <th>1111</th>
      <th>0001</th>
      <th>1101</th>
      <th>0010</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>F</td>
      <td>7</td>
      <td>F</td>
      <td>1</td>
      <td>D(음수)</td>
      <td>2</td>
      <td><br /></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>위처럼 D라면 음수로 -712가 된다.<br /><br /></li>
</ul>

<p>4) 팩(Pack) 형식<br /></p>
<ul>
  <li>수치를 표현하는 4비트의 BCD를 1바이트에 2개를 나타내며 10진수 숫자 2개를 표시한다. 존 형식이 절반으로 줄어든 형태라고 보면 된다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>0111</th>
      <th>0001</th>
      <th>0010</th>
      <th>1100</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>C(양수)</td>
      <td><br /></td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>2진수</th>
      <th>0111</th>
      <th>0001</th>
      <th>0010</th>
      <th>1101</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16진수</td>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>D(음수)</td>
      <td><br /><br /></td>
    </tr>
  </tbody>
</table>

<p>5) 고정 소수점 형식<br /></p>
<ul>
  <li>고정 소수점 형식은 소수점 위치가 가장 오른쪽 끝에 고정되어 있다고 가정하는 것으로 전체의 수를 정수로 표현한다. 가장 왼쪽의 비트는 부호를 표시하며 0이면 +양수, 1이면 -음수를 나타낸다. 데이터 길이를 n이라고 했을 때 -(2^n-1 - 1) ~ (2^n-1 - 1)의 범위를 나타낼 수 있다.<br /></li>
  <li>고정 소수점은 BCD 코드에 비해서 명령 속도가 빠르다.<br /><br /></li>
</ul>

<p>6) 부동 소수점 표현<br /></p>
<ul>
  <li>아주 큰 수나 아주 작은 수를 표현한다든지 아니면 높은 정도(precision)로 취급할 때 많이 쓰인다. 유효숫자만을 나타내는 소수부(fraction part)와 소수점의 위치를 나타내는 지수부(exponent part)로 구분한다. 10^-78 ~ 10^74의 범위까지를 나타낼 수 있다.<br /><br /><br /></li>
</ul>

<h2 id="3-보수-연산">3. 보수 연산<br /></h2>
<ul>
  <li>보수(complement)란 어떤 기준이 되는 수를 설정했을 때 그 수에 모자라는 수를 말한다. x에 대한 9의 보수는 9로부터 x를 뺀 것인데, 6에 대한 9의 보수는 3이고 2에 대한 10의 보수는 8이다.<br /></li>
  <li>보수 연산은 뺄셈을 할 때 9의 보수를 사용하는 방법과 1의 보수와 2의 보수를 사용하는 방법 등이 있다.<br /><br /><br /></li>
</ul>

<h2 id="4-정보-교환용-코드">4. 정보 교환용 코드<br /></h2>
<ul>
  <li>정보 교환용 코드는 국제표준화기구(ISO)에 의해 정해지고 이것에 준해서 각국에서 정하여 사용하고 있다. 컴퓨터 대 컴퓨터시스템간의 통신을 단순화하고 표준화하기 위해 만들어졌다. <br /></li>
  <li>대표적인 것으로 프로그래밍을 할 때 자주 쓰는 아스키(ASCII)코드가 있다.</li>
  <li>산업 표준으로 전세계 모든 문자들을 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 유니코드(Unicode)가 제정되어 사용되고 있다.<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[데이터의 표현과 연산]]></summary></entry><entry><title type="html">부울대수</title><link href="http://localhost:4000/computer%20science/CS06/" rel="alternate" type="text/html" title="부울대수" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS06</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS06/"><![CDATA[<h1 id="부울대수">부울대수<br /></h1>

<h2 id="1-부울대수의-개요">1. 부울대수의 개요<br /></h2>
<ul>
  <li>부울대수(Boolean algebra)는 논리적 관계의 문제를 다룰 때 대수 형식으로 표시하며, 여러가지 논리회로를 설계하거나 같은 기능을 갖는 논리 회로를 간략화하는 데 사용된다.</li>
  <li>인간의 지식이나 사고를 참, 거짓으로 공식화하고 이를 수학적으로 해석하기 위한 것으로 논리대수라고도 한다.<br /></li>
  <li>주로 컴퓨터의 회로 설계 등에 이용되고 있으며 “0”과 “1”의 두 개의 수치만을 사용하여, 연산의 결과는 언제나 0 또는 1로 표한된다.<br /><br /><br /></li>
</ul>

<h2 id="2-논리회로">2. 논리회로<br /></h2>
<ul>
  <li>논리회로는 2가지 상태를 다루는 방법으로 컴퓨터에서 사용되는 방법이다. NOT, AND, OR 3가지의 기본논리회로의 조합으로 구성된다. <br /><br /></li>
</ul>

<p>1) NOT 회로<br /></p>
<ul>
  <li>인버터(inverter)라고도 한다. 입력이 1개로 구성된 것으로 입력신호와 반대되는 출력을 내놓는다.<br /></li>
  <li>입력신호가 1이면 출력은 0, 입력신호가 0이면 출력은 1<br /><br /></li>
</ul>

<p>2) AND 게이트<br /></p>
<ul>
  <li>두 입력이 모두 1일 때 출력이 1이 되고 그 외에는 모두 0이 출력된다.<br /><br /></li>
</ul>

<p>3) OR 게이트<br /></p>
<ul>
  <li>입력신호 중 어느 하나 또는 두 개가 모두 1일 때 1이 출력된다.<br /><br /></li>
</ul>

<p>4) 부정논리곱<br /></p>
<ul>
  <li>AND와 NOT 회로를 결합한 것으로 AND의 결과를 반전한 결과를 얻는다.<br /></li>
  <li>두 입력이 모두 1일 때에만 0을 출력하고 나머지는 모두 1 출력<br /><br /></li>
</ul>

<p>5) 부정논리합<br /></p>
<ul>
  <li>OR와 NOT 회로를 결합한 것으로 OR의 출력이 반전된 결과를 얻는다. <br /></li>
  <li>두 입력이 모두 0이면 1을 출력하고 나머지는 모두 0 출력<br /><br /></li>
</ul>

<p>6) 베타논리합(XOR : exclusive-OR)<br /></p>
<ul>
  <li>두 개의 입력조건이 서로 다르면 1이고, 조건이 같으면 0이 된다.<br /><br /></li>
</ul>

<h2 id="3-조합-논리-회로">3. 조합 논리 회로<br /></h2>
<ul>
  <li>입력 논리치가 정해지면 출력 논리치가 결정되는 논리회로, AND, OR, XOR 등의 논리가 해당된다.<br /><br /></li>
</ul>

<p>1) 반 가산기(half adder)<br /></p>
<ul>
  <li>1비트의 2진수 2개를 합하여 그 결과를 한 비트의 합과 한 비트의 올림수로 발생시키는 논리회로<br /><br /></li>
</ul>

<p>2) 전 가산기(full adder)<br /></p>
<ul>
  <li>반 가산기는 자리 올림수를 더해줄 수 없기 때문에 이것을 보완하여 만든 회로<br /></li>
  <li>두 개의 입력과 전 단계에서 발생한 자리 올림수를 더할 수 있도록 구성된 회로<br /></li>
  <li>여러 자리의 2진수 덧셈을 위해서는 첫 자리의 덧셈은 반 가산기를 이용하고, 다음 단계부터는 자리 올림수를 더해줘야 하기 때문에 전 가산기를 사용한다.<br /><br /></li>
</ul>

<p>3) 인코더(encoder)<br /></p>
<ul>
  <li>1게의 입력을 다수의 신호로 변환하여 출력을 얻는 회로로 부호기라고도 한다.<br /></li>
  <li>0, 1, 2, … 와 같은 하나의 십진수를 4개의 비트를 이용한 2진수 코드로 변환할 때 사용할 수 있다.<br /><br /></li>
</ul>

<p>4) 디코더(decoder)<br /></p>
<ul>
  <li>인코더와 반대로 다수의 입력신호로서 1개의 출력신호를 얻는 회로이다.<br /></li>
  <li>2진수 코드의 정보를 다른 부호로 바꾸어야 할 때 사용하는 회로로 해독기라고도 한다.<br /><br /></li>
</ul>

<p>5) 멀티플렉서(multiplexer)<br /></p>
<ul>
  <li>n개의 선택입력에 따라 2^n 개의 입력 중 하나를 선택하여 출력하는 회로로 다중기라고도 한다.<br /></li>
  <li>데이터통신 장치에 많이 사용된다.<br /><br /><br /></li>
</ul>

<h1 id="4-순서-논리-회로">4. 순서 논리 회로<br /></h1>
<ul>
  <li>조합 논리 회로가 입력신호의 조합에 따라 출력값이 결정되었다면 순서 논리 회로는 입력신호의 조합뿐만 아니라 논리회로의 내부 상태에 따라 다르게 출력이 나타난다. <br /></li>
  <li>입력 신호에 의하여 상태를 바꾸도록 지시할 때까지 계속적으로 컴퓨터 내부에서 0, 1의 값을 가지는 bit을 기억하고 유지하기 위하여 사용된다.<br /></li>
  <li>이런 소자를 플립플롭(Flip-Flop)이라 하며, 정보를 기억하는 레지스터 및 카운터 등의 구성소자에서 사용된다.<br /></li>
</ul>

<h2 id="레지스터register">@레지스터(register)<br /></h2>
<ul>
  <li>CPU의 연산장치와 기억장치 중에서 기억장치에서 읽어내는 정보와 연산결과 등을 일시 기억하는 데 사용된다.<br /></li>
  <li>1개의 플립플롭은 1비트의 정보가 기억되기 때문에 n개의 플립플롭을 사용하면 n비트의 정보를 기억하는 레지스터가 된다.<br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[부울대수]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 구성</title><link href="http://localhost:4000/computer%20science/CS07/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 구성" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS07</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS07/"><![CDATA[<h1 id="컴퓨터-하드웨어-구성">컴퓨터 하드웨어 구성<br /></h1>
<ul>
  <li>컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다.<br /></li>
  <li>하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다.<br /></li>
  <li>중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다.<br /></li>
  <li>소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.<br /><br /></li>
</ul>

<h2 id="컴퓨터-하드웨어의-구성">컴퓨터 하드웨어의 구성<br /></h2>
<h3 id="1-입력-장치">1) 입력 장치<br /></h3>
<ul>
  <li>자료를 컴퓨터에 읽어 들이는 기능을 가지고 있다.<br /></li>
  <li>디스크 장치, 테이프 장치, 단말기, 카드 판독기 등이 있다.<br /><br /></li>
</ul>

<h3 id="2-기억-장치">2) 기억 장치<br /></h3>
<ul>
  <li>주기억 장치와 보조 기억 장치로 나누며, 입력된 자료가 처리될 때까지 일시적으로 기억하거나 연산 결과와 출력할 내용 등을 기억한다.<br /><br /></li>
</ul>

<h3 id="3-연산-장치">3) 연산 장치<br /></h3>
<ul>
  <li>산술 논리 연산 장치(ALU : Arithmetic and Logic Unit)라고도 한다.<br /></li>
  <li>제어 장치의 지시에 따라 전송된 자료를 처리하기 위하여 사칙 연산, 논리 연산, 자리 이동 등의 연산을 수행하는 장치이다.<br /><br /></li>
</ul>

<h3 id="4-제어-장치">4) 제어 장치<br /></h3>
<ul>
  <li>자료를 처리하는 순서를 저장한 프로그램의 명령어를 해독하여 입력 장치, 기억 장치, 연산 장치, 출력 장치 등을 제어한다.<br /><br /></li>
</ul>

<h3 id="5-출력-장치">5) 출력 장치<br /></h3>
<ul>
  <li>CPU로부터 출력 결과를 받아서 사람이 알 수 있는 형태로 변환하거나 다른 기억 장치(자기 테이프, 자기 디스크 장치 등)로 전송한다.<br /></li>
</ul>

<table>
  <thead>
    <tr>
      <th>중앙 처리 장치(CPU)</th>
      <th>주변 장치</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제어 장치</td>
      <td>보조 기억 장치</td>
    </tr>
    <tr>
      <td>주기억 장치</td>
      <td>입력 장치</td>
    </tr>
    <tr>
      <td>연산 장치</td>
      <td>출력 장치</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터 하드웨어 구성 컴퓨터 시스템은 크게 하드웨어(hardware)와 소프트웨어(software)로 이루어져 있다. 하드웨어는 눈으로 볼 수 있는 기계의 본체로 중앙처리장치(CPU), 보조기억장치, 입출력장치로 구성되어 있다. 중앙처리장치는 주기억장치, 연산장치, 제어장치로 나눌 수 있다. 소프트웨어는 컴퓨터를 이용하는 기술을 말하는 것으로 시스템 프로그램과 응용 프로그램으로 분류된다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 기억장치</title><link href="http://localhost:4000/computer%20science/CS08/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 기억장치" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS08</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS08/"><![CDATA[<h1 id="컴퓨터-하드웨어-기억장치">컴퓨터 하드웨어 기억장치<br /></h1>

<h2 id="기억-장치">기억 장치<br /></h2>
<ul>
  <li>입력 장치에서 읽어 들인 숫자, 문자, 각종 기호 등의 자료들을 저장하는 장치로 주기억 장치와 보조 기억 장치로 나누어진다.<br /><br /></li>
</ul>

<h3 id="1-주기억-장치main-memory-unit">1) 주기억 장치(main memory unit)<br /></h3>
<ul>
  <li>컴퓨터 중앙 처리 장치(CPU)에 위치하며 실행하고자 하는 프로그램이나 자료를 기억시키는 장치<br /><br /></li>
</ul>

<h3 id="2-보조-기억-장치auxiliary-storage-unit">2) 보조 기억 장치(auxiliary storage unit)<br /></h3>
<ul>
  <li>주변 장치로서(CPU에 속하지 않음!) 주기억 장치에 필요한 프로그램이나 자료를 보낼 수 있고, 처리된 자료 또는 개발된 프로그램 등을 저장할 수 있다.<br /><br /></li>
</ul>

<h3 id="3-기억-장치에서-사용되는-단위">3) 기억 장치에서 사용되는 단위<br /></h3>
<ul>
  <li>최소 단위는 비트(bit : binary digit)이다. <br /></li>
  <li>8개의 비트가 모이면 1바이트가 된다.<br /></li>
  <li>1바이트는 영문자 1개를 기억하며 한글 1문자를 저장하는 데엔 2바이트가 필요하다.<br /></li>
  <li>
    <p>1킬로 바이트(KB)는 1,024바이트로 구성되며, 1메가 바이트(MB)는 1,024킬로 바이트이고, 1기가 바이트(GB)는 1,024메가 바이트가 된다.<br /><br /></p>
  </li>
  <li>메모리 셀(memory cell)<br />
    <ul>
      <li><u>**한 소자나 전기회로가 하나의 비트를 저장**</u>하는 데 사용된다.<br /></li>
      <li>(0 또는 1) 플립플롭, 충전된 커패시터, 자기테이프 또는 디스크 등을 예로 들 수 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 워드(memory word)<br />
    <ul>
      <li>메모리에 있는 비트는 몇 가지 형태의 명령이나 데이터로 표현된다.<br /></li>
      <li>예를 들면, 8개의 플립플롭으로 구성된 레지스터는 8비트 워드로 저장되는 메모리로 생각할 수 있다.<br /></li>
      <li>워드의 용량은 보통 4~8바이트 사이이다.<br /><br /></li>
    </ul>
  </li>
  <li>바이트(byte)<br />
    <ul>
      <li>8비트 워드에 대해 사용되는 용어이다.<br /></li>
      <li>항상 8비트로 구성된다.<br /></li>
      <li>마이크로컴퓨터에서 가장 일반적인 워드 크기이다.<br /><br /></li>
    </ul>
  </li>
  <li>용량(capacity)<br />
    <ul>
      <li>비트들을 저장할 수 있는 공간<br /></li>
      <li>메모리에 있어 워드수는 대개 1024의 곱이다.<br /></li>
      <li>우리가 흔히 보는 하드 용량 몇 GB는 2^10(1,024), 2^20(1,048), … 와 같이 딱 나눠 떨어지는 10의 배수가 아닌 2의 거듭제곱들이다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="주기억-장치">주기억 장치<br /></h2>
<h3 id="1-주기억-장치의-구성">1) 주기억 장치의 구성<br /></h3>
<ul>
  <li>주기억 장치는 수많은 바이트로 구성된다.</li>
  <li>입력 장치를 통하여 읽어 들은 자료는 1과 0의 상태가 모아져 바이트 단위로 구성되며 순서에 따라 특정한 장소에 저장된다.<br /></li>
  <li>
    <p>자료를 저장하거나 저장된 자료를 읽기 위하여 각 기억 장소는 고유한 주소를 갖는다.<br />
<img src="../img/main_memory_unit.jpeg" alt="main_memory_unit" /><br /></p>
  </li>
  <li>기억부<br />
    <ul>
      <li>주어진 프로그램이나 데이터를 기억해 두는 2진 기억 소자(memory cell)들이 2차원 행렬(matrix)로 구성되어 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 주소 레지스터(MAR : Memory Address Register)<br />
    <ul>
      <li>프로그램이나 데이터를 입출력하기 위한 번지를 가지고 있다.<br /><br /></li>
    </ul>
  </li>
  <li>메모리 버퍼 레지스터(MBR : Memory Buffer Register)<br />
    <ul>
      <li>입출력하고자 하는 프로그램이나 데이터를 임시 보관하는 레지스터<br /><br /></li>
    </ul>
  </li>
  <li>번지 선택 회로<br />
    <ul>
      <li>MAR(메모리 주소 레지스터)에 의하여 기억 장소를 선택하는 회로<br /><br /></li>
    </ul>
  </li>
  <li>제어 회로<br />
    <ul>
      <li>기억 장치에 저장하라는 Write 신호와 기억 장치로부터 읽어내리는 Read 신호를 발생시키는 회로<br /></li>
      <li>칩이나 모듈 개념으로 여러개로 나누어 구성될 경우 칩 선택 신호나 메모리 모듈 선택 신호가 필요하다.<br /><br /></li>
    </ul>
  </li>
</ul>

<h3 id="2-기억-장치에-저장하는-외부-동작의-순서">2) 기억 장치에 저장하는 외부 동작의 순서<br /></h3>
<ol>
  <li>기억 장치의 위치(번지)를 MAR(메모리 주소 레지스터)에 넣는다.<br /></li>
  <li>프로그램이나 데이터의 비트를 MBR(메모리 버퍼 레지스터)에 넣는다.<br /></li>
  <li>입력 신호로 MBR(메모리 버퍼 레지스터)의 내용이 메모리에 저장된다.<br /><br /></li>
</ol>

<h3 id="3-기억-장치로부터-읽어낼-때-외부-동작-순서">3) 기억 장치로부터 읽어낼 때 외부 동작 순서<br /></h3>
<ol>
  <li>읽어내려는 프로그램이나 데이터 번지를 MAR에 넣은 후 출력신호를 준다.<br /></li>
  <li>메모리의 해당 내용이 MBR로 옮겨져 외부로 출력하게 된다.<br /><br /></li>
</ol>

<h3 id="4-어드레스address">4) 어드레스(Address)<br /></h3>
<ul>
  <li>메모리에서 한 워드의 위치를 식별하는 주소(숫자)<br /></li>
  <li>메모리소자 또는 시스템에 저장된 각 워드는 고유의 주소를 갖는다.<br /></li>
  <li>주소는 보통 2진수, 8진수, 16진수로 표현되고, 편의를 위해 10진수로 표현되기도 한다.<br /></li>
  <li>메모리에 있는 특정 워드의 위치를 언급할 때마다 그것을 식별하기 위해서 그 위치의 주소코드를 사용한다.<br /></li>
</ul>

<h1 id="모든-프로그램은-주기억-장치에서만-실행된다">!모든 프로그램은 주기억 장치에서만 실행된다!</h1>
<ul>
  <li>그래서 주기억 장치(RAM)의 용량이 클수록 더 많은 정보를 기억하고 실행할 수 있기 때문에 비싸다.<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[컴퓨터 하드웨어 기억장치]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 주기억 장치의 종류</title><link href="http://localhost:4000/computer%20science/CS09/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 주기억 장치의 종류" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS09</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS09/"><![CDATA[<h1 id="주기억-장치의-종류">주기억 장치의 종류<br /></h1>
<ul>
  <li>컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다.<br /><br /></li>
</ul>

<h2 id="1-과거의-주기억-장치">1. 과거의 주기억 장치</h2>
<ul>
  <li>초기</li>
  <li>
    <p>처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다.<br /><br /></p>
  </li>
  <li>1960년대 초반 ~ 1970년대 중반</li>
  <li>
    <p>자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.<br /><br /></p>
  </li>
  <li>기억 원리
    <ul>
      <li>코어의 링을 통과하는 도선에 전류를 흘려 ‘플레밍의 오른손 법칙’에 따라 <strong>자화</strong>의 방향을 바꾸어 준다.</li>
      <li>자기 코어는 한 번 1 또는 0의 상태가 되면 어떠한 변화를 주지 않는 한 계속 자화 상태를 유지하여 정보를 기억하게 되고, 여러 개의 코어를 코어판(core plane)의 형태로 묶어서 사용하게 된다.<br /><br /></li>
    </ul>
  </li>
  <li>자화(magnetization)
    <ul>
      <li>물질을 자기장 속에 놓았을 때 그 물질 전체가 갖는 거시적인 자기(磁氣)모멘트</li>
      <li>물질의 자기적 성질은 주로 전자의 자기모멘트에 연유하는데, 전자가 가진 극히 작은 미시적인 자기모멘트가 많이 모여, 그 총합으로 거시적으로 물질이 나타내는 자기모멘트를 <strong>자화</strong>라고 한다.<br /><br /></li>
    </ul>
  </li>
  <li>플레밍의 오른손 법칙<br /><br />
<img src="../img/rightHand.png" alt="rightHand" /><br />
    <ul>
      <li>N극에서 S극 방향으로 자기장이 형성되었을 때 그림처럼 자기장의 방향과 수직으로 도체(금속 막대 등)가 움직이고 있다면 전류는 가운데 손가락 방향으로 흐른다.</li>
      <li>엄지손가락 방향 : 도체를 움직이는 힘(속도)의 방향</li>
      <li>두번째 손가락 방향 : 자기장의 방향</li>
      <li>가운데 손가락 방향 : 전류가 흐르는 방향</li>
    </ul>
  </li>
</ul>

<h2 id="2-현재의-주기억-장치">2. 현재의 주기억 장치</h2>
<ul>
  <li>1960년대 후반부터 반도체 집적 회로(IC : Integrated Circuit) 기술의 개발과 함께 기억 소자로의 적용이 추진된 후, 1968년에는 주기억 장치의 버퍼 메모리로 사용되기 시작했다.</li>
  <li>집적 회로는 집적도, 소비 전력, 소형성, 경제성 등으로 코어 메모리를 대체하여 널리 이용되고 있다.<br /><br /></li>
</ul>

<h2 id="3-미래의-주기억-장치">3. 미래의 주기억 장치</h2>
<ul>
  <li>현재보다 크기가 작고, 대용량, 고속의 기억 소자가 사용될 것이라 예상된다.</li>
  <li>그 중 하나가 조셉슨 소자(Josephson device)인데, 현재의 기억 소자보다 10배 이상 빠르게 나타나고 있으며 대량 생산과 가격 등의 문제점을 해결하고 있다.<br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[주기억 장치의 종류 컴퓨터 하드웨어 기술의 발전은 기억 용량의 급속한 증가와 함께 기억 소자 크기의 감소, 그리고 가격면에서 급격한 하락을 가져왔다. 1. 과거의 주기억 장치 초기 처음엔 진공관을 사용했다. 진공관 한 개는 1비트의 정보를 나타내는데, 그 크기와 전력 소모, 열 발생 등으로 문제점이 많았다. 이후 적은 전력 소모와 신뢰성을 가진 트랜지스터(transistor)가 사용된다. 1960년대 초반 ~ 1970년대 중반 자기 코어(magnetic core)가 기억 소자로 사용되었다. 매우 작은 링(ring) 형태로 되어 있으며, 페라이트(ferrite)라는 자기 재료를 사용해서 페라이트 코어 메모리라고도 한다.]]></summary></entry><entry><title type="html">컴퓨터 하드웨어 - 반도체 메모리</title><link href="http://localhost:4000/computer%20science/CS10/" rel="alternate" type="text/html" title="컴퓨터 하드웨어 - 반도체 메모리" /><published>2022-01-30T00:00:00+09:00</published><updated>2022-01-30T00:00:00+09:00</updated><id>http://localhost:4000/computer%20science/CS10</id><content type="html" xml:base="http://localhost:4000/computer%20science/CS10/"><![CDATA[<h1 id="반도체-메모리">반도체 메모리</h1>
<ul>
  <li>현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.<br /><br /></li>
</ul>

<h2 id="메모리의-제조기술적인-분류에-따른-특성">메모리의 제조기술적인 분류에 따른 특성<br /></h2>
<p>1) 밀도(chip당 bit 용량)<br />
2) 속도<br />
3) 소비전력(bit당 mW)<br />
4) bit당 cost(반도체 제조가격 측면)<br />
5) Noise 면역성<br /><br /></p>

<h2 id="읽기동작read-operation과-쓰기동작">읽기동작(read operation)과 쓰기동작</h2>
<ul>
  <li>특별한 메모리위치(주소)에 저장되어 있는 2진 워드가 감지되어 다른 소자에 전달되는 동작</li>
  <li>만약 100번 주소에 있는 메모리에서 워드 4를 사용하려 한다면 주소 100번에서 읽기동작을 실행해야 한다.</li>
  <li>한 워드를 메모리부터 가져오기 때문에 패치(fetch)동작이라고도 한다.<br /><br /></li>
</ul>

<h2 id="접근-시간access-time">접근 시간(access time)</h2>
<ul>
  <li>기억 장치가 출력 신호를 받은 시간부터 데이터가 출력된 때까지의 시간</li>
  <li>자기 코어 기억 장치에서는 접근 시간과 복원 시간을 합해서 사이클(cycle) 시간이라 하며, IC 메모리에서는 사이클 시간이 접근 시간과 같다.</li>
  <li>메모리소자 동작속도의 측정치로 읽기동작하는 데 필요한 시간이라고도 할 수 있으며, 이는 주소입력 순간으로부터 메모리 내용의 출력순간까지의 시간이다.<br /><br /></li>
</ul>

<h2 id="랜덤-액세스메모리ram">랜덤 액세스메모리(RAM)</h2>
<ul>
  <li>한 메모리 워드의 실제 물리적 위치가 그 위치로부터 읽거나 쓰는 데 걸리는 시간이 얼마나 걸리는가에는 영향을 받지 않는 메모리이다. 즉 액세스시간이 메모리의 모든 주소에 대해서 같은 메모리이다.</li>
  <li>대부분의 반도체메모리와 코어메모리는 RAM이다.
    <ul>
      <li>사용 예 : CDP(컴팩트 디스크 플레이어)는 적당한 코드를 입력함으로써 어떤 한 노래를 선택하든간에 같은 시간을 갖는다.<br /><br /><br /></li>
    </ul>
  </li>
</ul>

<h1 id="순차-액세스-메모리sam">순차 액세스 메모리(SAM)</h1>
<ul>
  <li>액세스시간이 일정하지 않고 주소위치에 따라 변하는 메모리의 한 형태이다.</li>
  <li>원하는 주소에 도달할 때까지 모든 주소위치를 통하여 저장된 워드를 순차적으로 찾기 때문에 랜덤 액세스메모리보다 더 긴 액세스시간을 갖는다.
    <ul>
      <li>사용 예 : 자기테이프, 디스크, 자기버블메모리<br /><br /></li>
    </ul>
  </li>
</ul>

<h2 id="읽기전용메모리rom">읽기전용메모리(ROM)</h2>
<ul>
  <li>읽기동작이 쓰기동작보다 매우 많은 응용분야를 위해 설계된 반도체메모리의 종류</li>
  <li>기술적으로 (주로 제작자에 의해)단 한 번만 프로그래밍되어 쓸 수 있으며, 이후로는 내용을 수정할 수 없으며 읽기만 가능하다.</li>
  <li>모든 ROM은 비휘발성이며 전원이 제거되어도 데이터는 그대로 저장된다.</li>
  <li>한 번 이상 쓰기동작을 할 수 있는 메모리 RMM(Read Mostly Memory)도 있는데 읽기동작보다 쓰기동작이 훨씬 복잡하기 때문에 자주 사용되지는 않는다.<br /><br />
<img src="../img/rom.png" alt="rom" /><br />
    <blockquote>
      <p>ROM의 구성도<br /></p>
    </blockquote>
  </li>
  <li>ROM은 읽어내기만 하기 때문에 기억부와 번지 해독기, 출력 버퍼만으로 구성된다.<br /><br /></li>
</ul>

<h3 id="프로그램이나-자료-저장-방법에-따른-rom-분류">프로그램이나 자료 저장 방법에 따른 ROM 분류</h3>
<ul>
  <li>마스크(Mask) ROM : 사용자의 요구에 따라 제작사가 자료를 넣기 때문에 내용을 바꿀 수는 없지만 대량 생산에 적합</li>
  <li>PROM(Programmable ROM) : 제작시에 아무런 내용을 넣지 않은 상태로 만들어져서 사용자가 원하는 내용을 저장할 수 있다. 하지만 한 번 기억되면 그 내용을 변경할 수 없다.</li>
  <li>EPROM(Erasable ROM) : ROM의 내용을 자외선 삭제 장치로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능</li>
  <li>EEPROM(Electrically Erasable PROM) : ROM의 내용을 전기신호로 지울 수 있다. 지운 후에 새로운 내용을 써 넣는 것도 가능<br /><br /></li>
</ul>

<h2 id="정적-램static-ram-device-sram">정적 램(static RAM device, SRAM)</h2>
<ul>
  <li>전원이 인가되는 동안은 저장된 데이터가 영원히 저장되고, 주기적으로 데이터를 다시 쓸 필요가 없는 반도체 메모리장치</li>
  <li>플립플롭 조합으로 구성되어 있다.<br /><br /></li>
</ul>

<h2 id="동적-램dynamic-ram-device-dram">동적 램(dynamic RAM device, DRAM)</h2>
<ul>
  <li>전원이 인가되어도 저장된 데이터가 영원히 유지되지 못하며, 데이터가 메모리에 주기적으로 다시 쓰여져야 저장된 데이터가 계속 저장되는 반도체메모리</li>
  <li>이러한 주기적 동작을 리플레시(refresh)동작이라 한다.<br /><br /></li>
</ul>

<h2 id="휘발성-메모리volatile-memory">휘발성 메모리(volatile memory)</h2>
<ul>
  <li>전원이 제거되면 메모리에 있는 모든 정보가 소실된다.</li>
  <li>반도체메모리가 휘발성 메모리에 해당한다.<br /><br /></li>
</ul>

<h2 id="캐시-메모리cache-memory">캐시 메모리(cache memory)</h2>
<ul>
  <li>SRAM과 구성이 동일하다.</li>
  <li>기억 용량은 작으나 속도가 매우 빠른 버퍼(buffer) 메모리로 주기억 장치와 CPU와의 속도 차이를 줄여서 처리의 효율을 높이기 위해서 사용된다.</li>
  <li>캐시 기억 장치의 호출 시간은 주기억 장치의 호출 시간보다 5~10배 정도 빠르다.</li>
  <li>전체 기억 장치 시스템의 총 소요 시간을 최소화하면서 가능한 하 높은 평균 액세스 속도를 얻기 위해서 사용한다.<br /><br /><br /></li>
</ul>

<h1 id="메모리의-연결">메모리의 연결</h1>
<ul>
  <li>컴퓨터 내부메모리는 어드레스(Address) 버스, 데이터(Data) 버스, 제어(Control) 버스라는 세 종류의 버스로 CPU에 연결되는 신호선이 구성된다.<br /><br /></li>
</ul>

<h2 id="버스">버스<br /></h2>
<p>1) 어드레스 버스 : CPU에서 메모리 IC까지 2진 어드레스 출력을 전달하는 단방향 버스<br />
2) 데이터 버스 : CPU와 메모리 IC 사이에 데이터를 옮기는 양방향 버스<br />
3) 제어 버스 : CPU에서 메모리 IC까지 제어신호들 전달<br /><br /></p>

<h2 id="cpu의-쓰기동작-순서">CPU의 쓰기동작 순서<br /></h2>
<p>1) CPU가 데이터가 저장될 메모리 위치에 2진 어드레스 공급. 어드레스 버스선에서 이 어드레스를 인가한다.<br />
2) CPU가 데이터 버스선에 저장될 데이터 인가<br />
3) CPU가 메모리 쓰기 동작을 위해 제어신호선 동작시킴<br />
4) 메모리 IC들은 저장될 위치를 선택하기 위해 2진 어드레스 해독<br />
5) 데이터 버스에 있는 데이터가 선택된 메모리 위치로 전송됨<br /><br /></p>

<h2 id="cpu의-읽기동작-순서">CPU의 읽기동작 순서<br /></h2>
<p>1) 어드레스 버스선에 이 어드레스 인가. CPU가 데이터의 메모리 위치의 2진 어드레스 공급<br />
2) CPU가 메모리 읽기동작을 위해 제어신호선 활성화 시킴<br />
3) 메모리 IC중에서 읽기동작이 실행되는 위치를 선택하기 위해, 2진 어드레스를 해독한다.<br />
4) 메모리 IC들은 선택된 메모리 위치로부터 데이터 버스에 데이터 인가. 데이터가 전송되는 곳으로부터 CPU로 데이터 인가<br /><br /></p>

<h1 id="메모리-맵memory-map">메모리 맵(Memory Map)</h1>
<ul>
  <li>원하는 용량 및 워드사이즈에 알맞게 응용하기 위해 메모리칩을 조합하거나 큰 용량을 나누어 쓰는 것<br /><br /><br /></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Computer Science" /><category term="CS" /><summary type="html"><![CDATA[반도체 메모리 현재 주기억 장치로 사용되고 있는 반도체 메모리는 하나의 칩(chip)상에 수메가 비트를 저장할 수 있다. 반도체 제조공법상 쌍극성(bipolar type)과 모스형(mos type)의 두 가지로 구분된다.]]></summary></entry></feed>