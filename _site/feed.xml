<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-21T11:19:54+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yujin Dev Log</title><subtitle>개발 공부 기록하는 블로그</subtitle><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><entry><title type="html">Python) 프로그래머스. 외벽 점검</title><link href="http://localhost:4000/programmers/programmers-maintenance-wall/" rel="alternate" type="text/html" title="Python) 프로그래머스. 외벽 점검" /><published>2022-04-21T00:00:00+09:00</published><updated>2022-04-21T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-maintenance-wall</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-maintenance-wall/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://programmers.co.kr/learn/courses/30/lessons/60062">https://programmers.co.kr/learn/courses/30/lessons/60062</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>레스토랑을 운영하고 있는 “스카피”는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.</p>
  </li>
  <li>
    <p>레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.</p>
  </li>
  <li>
    <p>외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.<br /><br /></p>
  </li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>n은 1 이상 200 이하인 자연수입니다.</li>
  <li>weak의 길이는 1 이상 15 이하입니다.</li>
  <li>서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.</li>
  <li>취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.</li>
  <li>weak의 원소는 0 이상 n - 1 이하인 정수입니다.</li>
  <li>dist의 길이는 1 이상 8 이하입니다.</li>
  <li>dist의 원소는 1 이상 100 이하인 자연수입니다.</li>
  <li>친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 수리지점 한 군데에서 시계방향과 반시계방향으로 돌았을 때 더 짧은 거리를 찾아서 거리배열에서 그 거리와 합이 같거나 커지는 원소들의 개수를 찾으려 했다. 하지만 2번 예제에서만 통하고 1번 예제에서는 통하지 않았음…</li>
  <li>그리하여 참고한 해설은 일단 외벽 배열을 원형탐색할 수 있게 확장한 다음 거리배열의 순열을 구해서 각 경우마다 몇 명을 보내면 외벽 수리를 마칠 수 있는지 확인하는 것이다. 원형배열로 확장하는 부분에 대한 아이디어가 없어서 헤멨는데 이걸 알고 나니까 조금 이해가 수월했다.</li>
  <li>순열을 구하는 함수는 재귀로 직접 구현한 함수와 <code class="language-plaintext highlighter-rouge">itertools</code>에서 제공되는 함수 둘 다 써 봤는데 이 문제에서는 재귀로 직접 구현한 함수가 더 빨랐다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<h2 id="재귀로-순열-함수-구현한-코드">재귀로 순열 함수 구현한 코드</h2>

<script src="https://gist.github.com/miro7923/3dbb17400670abbf4d9e50fd8677bd44.js"></script>

<h2 id="itertools의-순열-함수-사용한-코드">itertools의 순열 함수 사용한 코드</h2>

<script src="https://gist.github.com/miro7923/31c1614750fc4544770808bd672fa477.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60062]]></summary></entry><entry><title type="html">JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 2 - Spring Legacy 프로젝트를 위한 .gitignore 설정</title><link href="http://localhost:4000/uno%20mas/uno-mas-dev-log-02/" rel="alternate" type="text/html" title="JAVA Spring) 1인가구를 위한 쇼핑몰 Uno más 개발일지 2 - Spring Legacy 프로젝트를 위한 .gitignore 설정" /><published>2022-04-20T00:00:00+09:00</published><updated>2022-04-20T00:00:00+09:00</updated><id>http://localhost:4000/uno%20mas/uno-mas-dev-log-02</id><content type="html" xml:base="http://localhost:4000/uno%20mas/uno-mas-dev-log-02/"><![CDATA[<ul>
  <li>작성일 : 2022.04.20</li>
  <li>작성자 : 황유진</li>
  <li>팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진</li>
  <li>GitHub Repository : <a href="https://github.com/miro7923/Uno-Mas">https://github.com/miro7923/Uno-Mas</a><br /><br /><br /></li>
</ul>

<h1 id="개발환경">개발환경</h1>
<ul>
  <li>MacBook Air (M1, 2020)</li>
  <li>OpenJDK 8</li>
  <li>Spring Tool Suite 4.14.0</li>
  <li>Spring framework 4.3.1.RELEASE</li>
  <li>Tomcat 8.5</li>
  <li>MySQL Workbench 8.0.19<br /><br /><br /></li>
</ul>

<h1 id="기간">기간</h1>
<ul>
  <li>2022.4.13 ~ 2022.5.20<br /><br /><br /></li>
</ul>

<h1 id="주제">주제</h1>
<ul>
  <li>웹 백엔드 수업 중 마지막 과제로 팀 프로젝트를 진행하게 되었다.</li>
  <li>조건은 <code class="language-plaintext highlighter-rouge">Spring</code> 기반으로 웹 사이트를 제작하는 것이다.</li>
  <li>총 팀원은 7명이며, 우리 팀은 <code class="language-plaintext highlighter-rouge">1인 가구를 위한 쇼핑몰</code>을 주제로 정했다.<br /><br /><br /></li>
</ul>

<h1 id="진행상황">진행상황</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Spring Legacy Project</code>로 프로젝트를 진행하게 됨에 따라 <code class="language-plaintext highlighter-rouge">GitHub</code> 원격저장소에서 파일을 공유할 때 시스템 환경설정 파일은 함께 공유 되지 않아야 할 필요가 있었다.</li>
  <li>하지만 아무 처리를 하지 않으면 각종 시스템 환경설정파일이 함께 업로드 되기 때문에 <code class="language-plaintext highlighter-rouge">.gitignore</code> 설정을 해줘야 했는데 유명한 <code class="language-plaintext highlighter-rouge">.gitignore</code>를 만들어주는 사이트에서 만드는 버전으로는 좀 한계가 있었다. <code class="language-plaintext highlighter-rouge">STS</code>에서 커밋을 하려고 할 때 <code class="language-plaintext highlighter-rouge">.classpath</code>같은 파일들이 제외되지 않았기 때문이다.</li>
</ul>

<h2 id="gitignore-1차-설정">.gitignore 1차 설정</h2>
<ul>
  <li><a href="https://lsjsj92.tistory.com/566">https://lsjsj92.tistory.com/566</a></li>
  <li>처음엔 위 글을 참고하여 <a href="https://www.toptal.com/developers/gitignore">https://www.toptal.com/developers/gitignore</a> 이 사이트에서 만들었는데 좀 부족했다.</li>
  <li><code class="language-plaintext highlighter-rouge">STS</code>에서 커밋을 하려고 하니 <code class="language-plaintext highlighter-rouge">.classpath</code>, <code class="language-plaintext highlighter-rouge">MINIFEST.MF</code>와 같은 파일들이 제외되지 않았기 때문이다. 나 혼자 하는 프로젝트면 알아서 걸러내고 하면 되겠지만 팀으로 하는 프로젝트이기 때문에 누군가는 저 파일들을 실수로 업로드를 할 것이다. 그렇기 때문에 저것들이 처음부터 제외되도록 <code class="language-plaintext highlighter-rouge">.gitignore</code>를 수정해야 했다.</li>
</ul>

<h2 id="gitignore-2차-설정">.gitignore 2차 설정</h2>
<ul>
  <li><a href="https://jazzodevlab.tistory.com/50">Spring Legacy 프로젝트에서 사용한 .gitignore 파일</a></li>
  <li>위 글을 참고하여 <code class="language-plaintext highlighter-rouge">gitignore</code>를 다시 한 번 설정했다.</li>
  <li>나는 맥 OS를 쓰지만 나머지 팀원들은 모두 윈도우 OS를 사용하기 때문에 각각 운영체제의 환경설정 파일도 제외하는 코드를 추가했다.</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Created by https://www.toptal.com/developers/gitignore/api/windows,macos,eclipse,java
# Edit at https://www.toptal.com/developers/gitignore?templates=windows,macos,eclipse,java

mybatis-config.xml
log4j.xml

lecture
target
pom.properties
.classpath
MANIFEST.MF

### Eclipse ###
.metadata
bin/
tmp/
*.tmp
*.bak
*.swp
*~.nib
local.properties
.settings/
.loadpath
.recommenders

# External tool builders
.externalToolBuilders/

# Locally stored "Eclipse launch configurations"
*.launch

# PyDev specific (Python IDE for Eclipse)
*.pydevproject

# CDT-specific (C/C++ Development Tooling)
.cproject

# CDT- autotools
.autotools

# Java annotation processor (APT)
.factorypath

# PDT-specific (PHP Development Tools)
.buildpath

# sbteclipse plugin
.target

# Tern plugin
.tern-project

# TeXlipse plugin
.texlipse

# STS (Spring Tool Suite)
.springBeans

# Code Recommenders
.recommenders/

# Annotation Processing
.apt_generated/
.apt_generated_test/

# Scala IDE specific (Scala <span class="err">&amp;</span> Java development for Eclipse)
.cache-main
.scala_dependencies
.worksheet

# Uncomment this line if you wish to ignore the project description file.
# Typically, this file would be tracked if it contains build/dependency configurations:
#.project

### Eclipse Patch ###
# Spring Boot Tooling
.sts4-cache/

# Eclipse Core
.project

# IDT-specific (Eclipse Java Development Tools)
.classpath

### Java ###
# Compiled class file
*.class

# Log file
*.log

# BlueJ files
*.ctxt

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
replay_pid*

### macOS ###
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

### macOS Patch ###
# iCloud generated files
*.icloud

### Windows ###
# Windows thumbnail cache files
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# End of https://www.toptal.com/developers/gitignore/api/windows,macos,eclipse,java
</code></pre></div></div>

<ul>
  <li>이렇게 수정하고 <code class="language-plaintext highlighter-rouge">STS</code>에서 다시 커밋을 시도해 보니까 소스파일만 깔끔하게 <code class="language-plaintext highlighter-rouge">Staging</code> 목록에 나타난다. <br /><br /><br /></li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="https://lsjsj92.tistory.com/566">https://lsjsj92.tistory.com/566</a></li>
  <li><a href="https://jazzodevlab.tistory.com/50">Spring Legacy 프로젝트에서 사용한 .gitignore 파일</a><br /><br /><br /></li>
</ul>

<h1 id="마감까지">마감까지</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">D-30</code></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Uno mas" /><category term="Project" /><category term="UnoMas" /><category term="Log" /><summary type="html"><![CDATA[작성일 : 2022.04.20 작성자 : 황유진 팀원 : 김진영, 박승지, 반현빈, 오성은, 오은현, 윤정환, 황유진 GitHub Repository : https://github.com/miro7923/Uno-Mas]]></summary></entry><entry><title type="html">Python) BOJ 15686. 치킨 배달</title><link href="http://localhost:4000/boj/boj15686-py/" rel="alternate" type="text/html" title="Python) BOJ 15686. 치킨 배달" /><published>2022-04-19T00:00:00+09:00</published><updated>2022-04-19T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj15686-py</id><content type="html" xml:base="http://localhost:4000/boj/boj15686-py/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/15686">https://www.acmicpc.net/problem/15686</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 512 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.</p>
  </li>
  <li>
    <p>이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 “치킨 거리”라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는</td>
          <td>r1-r2</td>
          <td>+</td>
          <td>c1-c2</td>
          <td>로 구한다.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.</p>
  </li>
  <li>0 2 0 1 0</li>
  <li>1 0 1 0 0</li>
  <li>0 0 0 0 0</li>
  <li>0 0 0 1 1</li>
  <li>0 0 0 1 2</li>
  <li>
    <p>0은 빈 칸, 1은 집, 2는 치킨집이다.</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는</td>
          <td>2-1</td>
          <td>+</td>
          <td>1-2</td>
          <td>= 2, (5, 5)에 있는 치킨집과의 거리는</td>
          <td>2-5</td>
          <td>+</td>
          <td>1-5</td>
          <td>= 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는</td>
          <td>5-1</td>
          <td>+</td>
          <td>4-2</td>
          <td>= 6, (5, 5)에 있는 치킨집과의 거리는</td>
          <td>5-5</td>
          <td>+</td>
          <td>4-5</td>
          <td>= 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.</p>
  </li>
  <li>도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>
    <p>첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.</p>
  </li>
  <li>
    <p>둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.</p>
  </li>
  <li>
    <p>도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.<br /><br /></p>
  </li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>치킨집을 최대 M개를 선택하다는 말 때문에 1개 이상 M개까지 선택할 수 있다는 말인 줄 알고(최종적으로 선택 가능한 치킨집의 개수가 변하는 것…) 그걸 다 어떻게 처리하느냐는 고민에 빠졌었다. 알고보니 쓸데 없는 고민이었다…</li>
  <li>전체 치킨집 중에서 그냥 M개를 선택하는 것으로 X개의 치킨집 중에서 M개의 치킨을 고르는 경우의 수를 구하는 것이었다. 즉 xCr 조합을 구하면 되는 것이었다.</li>
  <li>그 다음엔 조합들을 대상으로 각 집들의 치킨거리를 구해 치킨거리의 합을 구한다. 그 중에서 최솟값을 출력하면 정답이다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 440 ms</li>
  <li>메모리 : 30840 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/8a6a9b16d3b5de4b28503903d89e3c38.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No15686" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/15686 제한 시간 제한 : 1 초 메모리 제한 : 512 MB]]></summary></entry><entry><title type="html">Python) 프로그래머스. 기둥과 보 설치</title><link href="http://localhost:4000/programmers/programmers-pillar-and-plate-py/" rel="alternate" type="text/html" title="Python) 프로그래머스. 기둥과 보 설치" /><published>2022-04-18T00:00:00+09:00</published><updated>2022-04-18T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-pillar-and-plate-py</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-pillar-and-plate-py/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://programmers.co.kr/learn/courses/30/lessons/60061">https://programmers.co.kr/learn/courses/30/lessons/60061</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>빙하가 깨지면서 스노우타운에 떠내려 온 “죠르디”는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. “죠르디”는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다.</li>
  <li>
    <p>프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다.</p>
  </li>
  <li>기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.</li>
  <li>보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.</li>
  <li>
    <p>단, 바닥은 벽면의 맨 아래 지면을 말합니다.</p>
  </li>
  <li>2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다.</li>
</ul>

<p align="center"><img src="https://grepp-programmers.s3.amazonaws.com/files/production/c453630fa0/834b86e5-6fd0-4d3c-8023-7f853ea4301f.jpg" width="400" /></p>

<ul>
  <li>
    <p>예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다.</p>
  </li>
  <li>(1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다.</li>
  <li>(2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다.</li>
  <li>(5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다.</li>
  <li>(4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다.</li>
  <li>
    <p>만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다.</p>
  </li>
  <li>벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>n은 5 이상 100 이하인 자연수입니다.</li>
  <li>build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.</li>
  <li>build_frame의 가로(열) 길이는 4입니다.</li>
  <li>build_frame의 원소는 [x, y, a, b]형태입니다.</li>
  <li>x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.</li>
  <li>a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.</li>
  <li>b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.</li>
  <li>벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.</li>
  <li>바닥에 보를 설치 하는 경우는 없습니다.</li>
  <li>구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.</li>
  <li>구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.</li>
  <li>최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.</li>
  <li>return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.</li>
  <li>return 하는 배열의 원소는 [x, y, a] 형식입니다.</li>
  <li>x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.</li>
  <li>기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.</li>
  <li>a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.</li>
  <li>return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.</li>
  <li>x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>처음엔 설치와 삭제를 할 때 주변 상황이 조건에 맞는지 확인한 후 동작을 수행하려 했다. 그런데 그렇게 하니까 코드 작성이 까다로워지고 내가 헷갈렸다. 그래서 해설을 참고했다.</li>
  <li>풀이는 의외로 아주 간단했는데 입력의 수가 1,000개로 비교적 적고 시간 제한이 5초로 넉넉한 편이라 O(M^3) 알고리즘으로도 풀이가 가능했다. 바로 설치와 삭제를 할 때마다 일단 동작을 수행한 후에 전체 구조물을 검사해서 가능한 구조물이면 넘어가고 그렇지 않으면 수행했던 동작을 취소하는 것이다. 이걸 어렵게 생각하다니…🥲<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/3a36205058914a5909126f931eb32ea5.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60061]]></summary></entry><entry><title type="html">GitHub로 팀 프로젝트 관리하는 방법</title><link href="http://localhost:4000/uno%20mas/teamwork-by-github/" rel="alternate" type="text/html" title="GitHub로 팀 프로젝트 관리하는 방법" /><published>2022-04-18T00:00:00+09:00</published><updated>2022-04-18T00:00:00+09:00</updated><id>http://localhost:4000/uno%20mas/teamwork-by-github</id><content type="html" xml:base="http://localhost:4000/uno%20mas/teamwork-by-github/"><![CDATA[<ul>
  <li>작성자 : 황유진</li>
  <li>
    <p>글 작성 도움 : 오은현</p>
  </li>
  <li>GitHub로 팀 프로젝트를 처음 진행할 때의 막막함을 덜고 나 스스로도 사용법을 정리하기 위해 작성한 글이다.</li>
  <li>함께 참고하면 좋은 글</li>
  <li><a href="https://gmlwjd9405.github.io/2017/10/27/how-to-collaborate-on-GitHub-1.html">Feature Branch Workflow</a><br /><br /></li>
</ul>

<h1 id="-시작-전에-팀장이-할-일">🎬 시작 전에 팀장이 할 일</h1>
<p align="center"><img src="../../assets/images/gitCollaborators.png" /></p>
<ul>
  <li>새 프로젝트용 레포지토리 생성 후 함께 할 팀원들의 GitHub 메일 주소를 <code class="language-plaintext highlighter-rouge">Collaborator</code>에 추가한다.<br /><br /></li>
</ul>

<h1 id="팀원들이-팀-레포지토리에-참여하기">팀원들이 팀 레포지토리에 참여하기</h1>
<ul>
  <li>메일로 <code class="language-plaintext highlighter-rouge">Collaborator</code> 초대를 받은 뒤 <code class="language-plaintext highlighter-rouge">Accept invitation</code>을 눌러 수락하면 내 레포지토리 목록에 자동으로 추가된다.</li>
  <li><a href="https://hyoje420.tistory.com/41">[Git]GitHub Collaborator 추가하기</a></li>
  <li>
    <p>그림과 함께 보고 싶으면 위 링크 참고</p>
  </li>
  <li>❗️ 참고로 <code class="language-plaintext highlighter-rouge">Collaborator</code>로 참여하면 내 레포지토리 목록에는 보이지 않는다.</li>
</ul>

<p align="center"><img src="../../assets/images/gitPin.png" /></p>

<ul>
  <li>팀장의 레포지토리 상단에서 <code class="language-plaintext highlighter-rouge">pin</code>을 클릭하면 즐겨찾기에 추가된다.</li>
</ul>

<p align="center"><img src="../../assets/images/gitPinned.png" width="700" /></p>

<ul>
  <li>내 GitHub 프로필 메인으로 가면 아까 <code class="language-plaintext highlighter-rouge">pin</code>했던 레포지토리 목록을 볼 수 있다. 이걸로 원격저장소에 찾아오면 된다.</li>
  <li>원격저장소는 하나만 존재하고 이걸 내 컴퓨터로 다운받아서 로컬저장소에서 각자 작업한 후에 원격저장소로 합치는 개념이다.</li>
</ul>

<p align="center"><img src="../../assets/images/gitClone3.png" width="500" /></p>
<ul>
  <li>[맥 OS 기준] 레포지토리를 다운받을 폴더를 선택한 뒤 <code class="language-plaintext highlighter-rouge">폴더에서 새로운 터미널 열기</code>를 선택하거나</li>
  <li>[윈도우 OS 기준] 윈도우 탐색기를 열어서 다운받을 폴더로 이동한 뒤 해당 폴더의 주소를 복사한다. 그 다음 <code class="language-plaintext highlighter-rouge">cmd(명령 프롬프트)</code>를 켜서</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd 아까 복사한 폴더 경로
</code></pre></div></div>

<ul>
  <li>위 명령어를 입력한 후 엔터를 누르면 해당 폴더로 이동할 수 있다.</li>
  <li>이제 아까전에 자동으로 복사되었던 레포지토리로 다시 돌아간다.</li>
</ul>

<p align="center"><img src="../../assets/images/gitClone1.png" width="600" /></p>
<ul>
  <li>원격저장소에 있는 레포지토리를 내 로컬 컴퓨터로 다운받아야 한다.</li>
  <li>초록색 <code class="language-plaintext highlighter-rouge">Code</code> 버튼을 클릭하면 이 레포지토리의 주소를 볼 수 있다.</li>
</ul>

<p align="center"><img src="../../assets/images/gitClone2.png" width="500" /></p>
<ul>
  <li>주소를 복사한다.</li>
</ul>

<p align="center"><img src="../../assets/images/gitClone4.png" width="700" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone 복사한 레포지토리 주소
</code></pre></div></div>
<ul>
  <li>위 사진처럼 명령어를 입력하고 복사한 주소를 붙여넣은 뒤 엔터를 누르면 내 컴퓨터로 레포지토리가 다운로드 된다.</li>
  <li>이제 내 컴퓨터에서 작업한 파일을 레포지토리 폴더에 넣은 다음 명령어 몇 가지만 입력하면 GitHub 사이트에 있는 레포지토리(원격 저장소)로 업로드 할 수 있다.<br /><br /></li>
</ul>

<h1 id="나의-작업물을-원격-저장소에-업로드-하기">나의 작업물을 원격 저장소에 업로드 하기</h1>
<ul>
  <li>작업이 끝나고 나면 결과물을 합쳐야 한다.</li>
</ul>

<p align="center"><img src="../../assets/images/mainBranch.png" width="500" /></p>
<ul>
  <li>브랜치는 같은 저장소에서 만들어진 소규모 공간이라고 생각하면 편하다. 그 중에서 대표 공간이 <code class="language-plaintext highlighter-rouge">main</code> 브랜치이다. 우리의 완성물은 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에만 존재하게 할 것이다.</li>
  <li>내 작업물을 내 컴퓨터에 있는 레포지토리 폴더(로컬저장소)에 넣은 다음 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 <code class="language-plaintext highlighter-rouge">push</code>하면 내 작업물을 합칠 수 있는데 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에는 완성물만 있어야 하기 때문에 그냥 합치면 안 되고 작업물에 문제가 없다는 것이 확인되었을 때 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 합쳐야 한다.</li>
  <li>그런데 그 전까지 각자 컴퓨터에 작업물을 가지고 있으면 다른 팀원과 함께 확인하는 것이 굉장히 불편하다. 내가 쓴 코드를 카톡이나 메일로 공유하지 않고 편할 때 접속할 수 있는 GitHub의 원격 저장소에서 확인할 수 있으면 훨씬 편할 것이다. 이 때 새로운 브랜치를 하나 만들어서 거기에다 <code class="language-plaintext highlighter-rouge">push</code>하는 것이다.(줌에서 소회의실 만들어서 몇 명씩 모여 회의하는 느낌으로…)</li>
  <li>
    <p>그러면 다른 사람들도 새로 생긴 브랜치에 <code class="language-plaintext highlighter-rouge">push</code>된 내용을 GitHub의 원격 저장소에서 확인하고 코드에 댓글도 달 수 있다. 여기서 문제가 없는 것이 확인되면 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 <code class="language-plaintext highlighter-rouge">merge</code> 요청을 하면 된다. 팀장이 승낙하면 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 합쳐진다.</p>
  </li>
  <li>이걸 하려면 먼저 내 로컬저장소가 <code class="language-plaintext highlighter-rouge">main</code> 브랜치의 최신 버전과 동기화가 되어 있어야 한다.</li>
</ul>

<h2 id="내-로컬저장소-최신버전으로-업데이트">내 로컬저장소 최신버전으로 업데이트</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout main   // main branch로 이동
git pull            // 내 로컬저장소의 main 브랜치를 최신버전으로 업데이트
</code></pre></div></div>

<ul>
  <li>원격 저장소에 업로드하기 전에 꼭 이 과정을 먼저 거친 후에 다음 과정을 진행해야 한다.</li>
  <li>안 그러면 과거 버전과 충돌해서 업로드가 제대로 되지 않을 수 있다. 이렇게 되면 고치기 좀 복잡해지니까… 꼭 <code class="language-plaintext highlighter-rouge">main</code> 브랜치 최신버전 업데이트부터 하고 시작하자!</li>
</ul>

<h2 id="개인용-브랜치-생성">개인용 브랜치 생성</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout main             // main 브랜치로 이동
git checkout -b 새 브랜치 이름    // 새 브랜치 생성 후 그 브랜치로 이동
</code></pre></div></div>

<p align="center"><img src="../../assets/images/createBranch.png" width="700" /></p>

<ul>
  <li>새 브랜치가 생성되고 바꿨다고 하는데 터미널 환경이라 이게 제대로 된건지 아닌지 알쏭달쏭할 수 있다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch -a   // 로컬저장소(내 컴퓨터)에 생성되어 있는 브랜치 확인
</code></pre></div></div>

<p align="center"><img src="../../assets/images/checkBranch.png" width="700" /></p>

<ul>
  <li>위 명령어를 입력해 보면 현재 내 로컬저장소에 생성된 브랜치들을 확인할 수 있다.</li>
  <li>초록색 별 표시된 것이 현재 사용 중인 브랜치라는 뜻</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch -r   // 원격저장소(GitHub)에 생성되어 있는 브랜치 확인
</code></pre></div></div>

<p align="center"><img src="../../assets/images/checkGithubBranch.png" width="700" /></p>

<ul>
  <li>원격저장소에 생성되어 있는 브랜치를 확인하고 싶으면 위 명령어를 입력하면 된다.</li>
  <li>아직 <code class="language-plaintext highlighter-rouge">commit</code>과 <code class="language-plaintext highlighter-rouge">push</code>를 진행하지 않았기 때문에 원격저장소에는 아까 만든 브랜치가 없다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch --set-upstream-to origin/main
</code></pre></div></div>

<p align="center"><img src="../../assets/images/gitBranchUpStream.png" width="700" /></p>

<ul>
  <li>새 브랜치를 만들었으면 이걸 사용해서 원격저장소에 업로드를 하겠다고 알려줘야 한다. 위 명령어를 입력하면 GitHub이 OK 하고 새 브랜치를 등록시켜 준다.</li>
  <li>새 브랜치를 만들었을 때 한 번만 하면 된다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout 내 브랜치 이름
</code></pre></div></div>

<ul>
  <li>다음부터는 위 명령어만 입력해서 내 개인 브랜치로 바꾸면 된다.</li>
</ul>

<h2 id="작업물-업로드하기">작업물 업로드하기</h2>
<ul>
  <li>작업물 업로드 전에</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout 내 브랜치 이름
</code></pre></div></div>

<ul>
  <li>이걸 입력해서 꼭 개인 브랜치로 바꾼 후에 업로드 하자!!!</li>
</ul>

<p align="center"><img src="../../assets/images/modifyTask.png" width="700" /></p>

<ul>
  <li>이런 식으로 로컬저장소에 들어있는 파일을 수정하거나 새로 생성하면 내 로컬저장소에 있는 GitHub 폴더가 자동으로 알아차린다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git status  // 현재 로컬저장소 상태 보기
</code></pre></div></div>

<p align="center"><img src="../../assets/images/gitStatus.png" width="700" /></p>

<ul>
  <li>위 명령어를 입력하면 새롭게 추가되거나 변경된 파일 목록을 보여준다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git add .   // 로컬저장소에 있는 모든 파일 추가
git commit -m "[yujin] README 수정"  // 방금 추가한 파일들 업로드 준비 - 누가 어떤 내용을 수정/추가해서 올리는지 작성
</code></pre></div></div>

<p align="center"><img src="../../assets/images/gitAddCommit.png" width="700" /></p>

<ul>
  <li>위 명령어들을 입력하면 원격저장소에 업로드 될 준비가 완료된다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push origin 내 브랜치 이름
</code></pre></div></div>

<p align="center"><img src="../../assets/images/gitPushOriginUserBranch.png" width="700" /></p>

<ul>
  <li>위 명령어를 입력하면 드디어 원격저장소에 업로드가 된다!</li>
</ul>

<p align="center"><img src="../../assets/images/newBranchOnRemoteRepo.png" width="400" /></p>

<ul>
  <li>원격저장소로 와서 보면 아깐 없었던 브랜치가 생긴 것을 볼 수 있다. 그리고 아까 수정했던 리드미 파일의 변경사항도 적용되지 않았다.</li>
</ul>

<p align="center"><img src="../../assets/images/newBranchOnRemoteRepo2.png" width="400" /></p>

<ul>
  <li>새로 만든 브랜치로 와 보면 아까 수정했던 내용이 적용된 것을 볼 수 있다. 브랜치를 이용하면 이런 식으로 같은 공간에서 버전을 나누어서 관리할 수 있다. <br /><br /></li>
</ul>

<h1 id="다른-팀원-코드-확인하고-피드백-댓글달기">다른 팀원 코드 확인하고 피드백 댓글달기</h1>
<ul>
  <li>팀원이 어떤 코드를 추가하고 삭제했는지 확인하고 거기에 댓글을 달 수 있다.</li>
  <li>댓글을 작성하면 해당 팀원에게 댓글이 달렸다는 알림 메일이 발송된다.</li>
</ul>

<p align="center"><img src="../../assets/images/viewCommit.png" width="400" /></p>

<ul>
  <li>작업물을 확인할 팀원의 브랜치로 이동한 후 <code class="language-plaintext highlighter-rouge">commit</code> 메세지를 클릭하면 가장 최근 <code class="language-plaintext highlighter-rouge">commit</code> 내역으로 이동할 수 있다.</li>
</ul>

<p align="center"><img src="../../assets/images/showCommentBtn.png" width="700" /></p>

<ul>
  <li>파란색 +가 보이는 자리에 마우스 오버하면 저 버튼이 생긴다. 클릭하면 댓글창이 나온다.</li>
</ul>

<p align="center"><img src="../../assets/images/addCommentUI.png" width="700" /></p>

<ul>
  <li>혹은 맨 아래에 있는 댓글창을 이용해서 댓글을 작성할 수도 있다.</li>
  <li>각 작업물에 이렇게 피드백을 해 주자.</li>
  <li>여기서 이상 없는 것이 확인 되었으면 <code class="language-plaintext highlighter-rouge">main</code> 브랜치로 합치면 된다.<br /><br /></li>
</ul>

<h1 id="main-브랜치로-작업물-합치기">main 브랜치로 작업물 합치기</h1>

<p align="center"><img src="../../assets/images/pullReq1.png" width="700" /></p>

<ul>
  <li>내 개인 브랜치로 <code class="language-plaintext highlighter-rouge">push</code>를 하고 나면 상단에 <code class="language-plaintext highlighter-rouge">Compare &amp; pull request</code> 버튼이 생긴 것을 볼 수 있다.</li>
</ul>

<p align="center"><img src="../../assets/images/pullReq2.png" width="700" /></p>

<ul>
  <li>브랜치 화살표 방향 잘 확인한 다음 <code class="language-plaintext highlighter-rouge">Create pull request</code> 버튼을 클릭한다. 추가로 작성할 메시지가 있다면 작성하면 된다.</li>
</ul>

<p align="center"><img src="../../assets/images/pullReq3.png" width="700" /></p>

<ul>
  <li>그러면 이렇게 <code class="language-plaintext highlighter-rouge">pull request</code>가 작성된다. 팀장이 확인 후 <code class="language-plaintext highlighter-rouge">merge</code>를 최종 수락하면 합치는 것이 완료된다.</li>
</ul>

<p align="center"><img src="../../assets/images/pullReqComplete1.png" width="700" /></p>

<p><br /></p>

<p align="center"><img src="../../assets/images/pullReqComplete2.png" width="400" /></p>

<ul>
  <li>
    <p>짠! <code class="language-plaintext highlighter-rouge">merge</code> 후 <code class="language-plaintext highlighter-rouge">main</code> 브랜치에 최종 반영된 것을 볼 수 있다.</p>
  </li>
  <li>
    <p>이후에 또 새로운 작업물을 업로드 해야 하면 <strong>내 로컬저장소 최신버전으로 업데이트</strong>부터 반복하면 된다.<br /><br /><br /></p>
  </li>
</ul>

<h1 id="출처">출처</h1>
<ul>
  <li><a href="https://jalynne-kim.medium.com/%EA%B9%83-%ED%9D%90%EB%A6%84-%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EC%97%85%EB%A1%9C%EB%93%9C-%ED%95%98%EA%B8%B0-d12bda2f7ff5">[ 깃허브 ] github 브랜치 만들고 업로드 하기</a></li>
  <li><a href="https://velog.io/@johnny/pintOS-github">[pintOS] github으로 팀프로젝트 관리하기 (pintOS 팀플 맞춤)</a></li>
  <li><a href="https://hyoje420.tistory.com/41">[Git]GitHub Collaborator 추가하기</a></li>
  <li><a href="https://gmlwjd9405.github.io/2017/10/27/how-to-collaborate-on-GitHub-1.html">Feature Branch Workflow</a></li>
</ul>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Uno mas" /><category term="Log" /><category term="Project" /><category term="UnoMas" /><summary type="html"><![CDATA[작성자 : 황유진 글 작성 도움 : 오은현]]></summary></entry><entry><title type="html">Python) 프로그래머스. 자물쇠와 열쇠</title><link href="http://localhost:4000/programmers/programmers-lock-and-key-py/" rel="alternate" type="text/html" title="Python) 프로그래머스. 자물쇠와 열쇠" /><published>2022-04-17T00:00:00+09:00</published><updated>2022-04-17T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-lock-and-key-py</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-lock-and-key-py/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://programmers.co.kr/learn/courses/30/lessons/60059">https://programmers.co.kr/learn/courses/30/lessons/60059</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>고고학자인 “튜브”는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다.</p>
  </li>
  <li>
    <p>잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다.</p>
  </li>
  <li>
    <p>자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.</p>
  </li>
  <li>
    <p>열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.<br /><br /></p>
  </li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.</li>
  <li>lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.</li>
  <li>M은 항상 N 이하입니다.</li>
  <li>key와 lock의 원소는 0 또는 1로 이루어져 있습니다.</li>
  <li>0은 홈 부분, 1은 돌기 부분을 나타냅니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력 배열의 크기가 작아서 완전탐색으로 찾으면 될 거 같은데 구체적인 방법이 떠오르지 않아서 책(이것이 취업을 위한 코딩테스트다)에 있는 해설을 봤다.</li>
  <li>내가 고민했던 것은 열쇠를 회전만 하는 것이 아니라 상하좌우로 움직일 수 있는 것을 어떻게 구현하느냐 였다.</li>
  <li>답은 간단했는데 자물쇠 배열을 3배로 확장한 후 반복문으로 열쇠를 확장한 배열의 처음부터 끝까지 한 칸씩 이동시키면서 자물쇠가 채워지는지 보는 것이었다. 이렇게 하면 회전시키는 것 뿐만 아니라 상하좌우로 이동시키는 것도 간단하게 구현할 수 있다.</li>
  <li>자물쇠와 열쇠에서 채워진 곳은 1, 빈 곳은 0으로 표시되기 때문에 자물쇠 영역이 모두 1로만 채워진다면 <code class="language-plaintext highlighter-rouge">True</code>를 반환하고 하나라도 0이 있거나 2가 있으면 풀 수 없는 자물쇠이기 때문에 <code class="language-plaintext highlighter-rouge">False</code>를 반환하면 된다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/c6577a09219c576654cac03a746fd1c7.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60059]]></summary></entry><entry><title type="html">Python) BOJ 3190. 뱀</title><link href="http://localhost:4000/boj/boj3190-py/" rel="alternate" type="text/html" title="Python) BOJ 3190. 뱀" /><published>2022-04-17T00:00:00+09:00</published><updated>2022-04-17T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj3190-py</id><content type="html" xml:base="http://localhost:4000/boj/boj3190-py/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/3190">https://www.acmicpc.net/problem/3190</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.</p>
  </li>
  <li>
    <p>게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.</p>
  </li>
  <li>
    <p>뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.</p>
  </li>
  <li>먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.</li>
  <li>만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.</li>
  <li>만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.</li>
  <li>사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>
    <p>첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)</p>
  </li>
  <li>
    <p>다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.</p>
  </li>
  <li>
    <p>다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)</p>
  </li>
  <li>
    <p>다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 ‘L’) 또는 오른쪽(C가 ‘D’)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.<br /><br /></p>
  </li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 게임이 몇 초에 끝나는지 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>풀이 과정에서 여러 시행착오를 겪었는데, 가장 큰 것은 문제 이해를 잘못 한 것이었다.</li>
  <li>게임은 뱀이 벽에 부딪힐 때나 몸에 부딪혔을 때 끝나고 입력으로 주어지는 방향 정보는 방향을 전환한 시간과 방향값만 주어지지 언제 벽에 부딪혔다는 정보는 주지 않는다. 즉 방향 정보가 끝나도 뱀은 계속 이동하고 있어야 한다. 하지만 처음에는 방향 정보 개수 L만큼만 반복문을 돌렸기 때문에 항상 방향 정보로 주어지는 시간의 최대값 안에서 끝이 났다. 이것 때문에 시간을 많이 썼다.🥲</li>
  <li>그렇기 때문에 뱀은 무한루프 속에서 이동해야 하며 종료 조건일 때에만 반복문을 탈출하도록 해야 한다.</li>
  <li>플레이 중에는 방향을 전환하는 시간 전 까지는 같은 방향으로 이동하면서 뱀을 이동시켜 주고 방향을 전환하는 시간이 되면 방향을 바꾼 후 이동을 반복한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 76 ms</li>
  <li>메모리 : 30840 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/aa45bd78334e8ccf535592895bad133a.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No3190" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/3190 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry><entry><title type="html">Python) 프로그래머스. 문자열 압축</title><link href="http://localhost:4000/programmers/programmers-compress-str-py/" rel="alternate" type="text/html" title="Python) 프로그래머스. 문자열 압축" /><published>2022-04-16T00:00:00+09:00</published><updated>2022-04-16T00:00:00+09:00</updated><id>http://localhost:4000/programmers/programmers-compress-str-py</id><content type="html" xml:base="http://localhost:4000/programmers/programmers-compress-str-py/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://programmers.co.kr/learn/courses/30/lessons/60057">https://programmers.co.kr/learn/courses/30/lessons/60057</a><br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.</li>
  <li>
    <p>간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.</p>
  </li>
  <li>
    <p>예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.</p>
  </li>
  <li>
    <p>다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.</p>
  </li>
  <li>압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>s의 길이는 1 이상 1,000 이하입니다.</li>
  <li>s는 알파벳 소문자로만 이루어져 있습니다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>옛날에 <code class="language-plaintext highlighter-rouge">C++</code>로 풀었던 문제인데 풀이가 기억나지 않아서… 옛날 코드를 참고했다.</li>
  <li>1) 문자열의 처음부터 한 글자씩 늘려가면서 비교 대상이 될 부분 문자열을 구한다.</li>
  <li>2) 위에서 구한 문자열의 다음 문자부터 위의 문자열과 같은 길이만큼 부분 문자열을 구한 다음에 둘을 비교한다.</li>
  <li>둘이 같다면 카운트를 증가시키고 아니라면 현재까지 증가된 카운트를 압축된 문자열에 더한다. 그 뒤에 1)에서 구한 부분 문자열을 더한다. 그 다음엔 1)에서 구한 비교 대상 부분 문자열을 2)에서 구한 부분 문자열로 교체한다. 카운트를 1로 초기화 시킨다.</li>
  <li>마지막 문자까지 비교가 끝나면 최종적으로 압축된 문자열을 구할 수 있다. 원래 문자열 길이와 최종 압축된 문자열의 길이 중 더 짧은 것을 정답으로 저장한다.</li>
  <li>이 과정을 1)의 부분 문자열의 길이가 원본의 절반이 될 때까지 반복한다.</li>
  <li>절반까지만 반복하는 이유는 1)의 부분 문자열의 길이가 절반을 넘어가면 어차피 압축할 수 없기 때문이다. 그래서 절반을 초과해서 반복문을 돌리는 것은 의미가 없다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/1fb70e08a6ba383889b62b2137bcfa98.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="Programmers" /><category term="Algorithm" /><category term="Programmers" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60057]]></summary></entry><entry><title type="html">Python) BOJ 18406. 럭키 스트레이트</title><link href="http://localhost:4000/boj/boj18406-py/" rel="alternate" type="text/html" title="Python) BOJ 18406. 럭키 스트레이트" /><published>2022-04-16T00:00:00+09:00</published><updated>2022-04-16T00:00:00+09:00</updated><id>http://localhost:4000/boj/boj18406-py</id><content type="html" xml:base="http://localhost:4000/boj/boj18406-py/"><![CDATA[<h1 id="문제-링크">문제 링크</h1>
<hr />

<ul>
  <li><a href="https://www.acmicpc.net/problem/18406">https://www.acmicpc.net/problem/18406</a><br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 256 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>
    <p>어떤 게임의 아웃복서 캐릭터에게는 럭키 스트레이트라는 기술이 존재한다. 이 기술은 매우 강력한 대신에 항상 사용할 수는 없으며, 현재 게임 내에서 점수가 특정 조건을 만족할 때만 사용할 수 있다.</p>
  </li>
  <li>
    <p>특정 조건이란 현재 캐릭터의 점수를 N이라고 할 때 점수 N을 자릿수를 기준으로 반으로 나누어 왼쪽 부분의 각 자릿수의 합과 오른쪽 부분의 각 자릿수의 합을 더한 값이 동일한 상황을 의미한다. 예를 들어 현재 점수가 123,402라면 왼쪽 부분의 각 자릿수의 합은 1+2+3, 오른쪽 부분의 각 자릿수의 합은 4+0+2이므로 두 합이 6으로 동일하여 럭키 스트레이트를 사용할 수 있다.</p>
  </li>
  <li>
    <p>현재 점수 N이 주어졌을 때, 럭키 스트레이트를 사용할 수 있는 상태인지 아닌지를 알려주는 프로그램을 작성하시오. 럭키 스트레이트를 사용할 수 있다면 “LUCKY”를, 사용할 수 없다면 “READY”라는 단어를 출력한다. 또한 점수 N의 자릿수는 항상 짝수 형태로만 주어진다. 예를 들어 자릿수가 5인 12,345와 같은 수는 입력으로 들어오지 않는다.<br /><br /></p>
  </li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 점수 N이 정수로 주어진다. (10 ≤ N ≤ 99,999,999) 단, 점수 N의 자릿수는 항상 짝수 형태로만 주어진다.<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 럭키 스트레이트를 사용할 수 있다면 “LUCKY”를, 사용할 수 없다면 “READY”라는 단어를 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>점수를 문자열로 입력받아서 앞부분과 뒷부분을 나눠서 따로 계산한 다음 변수에 각각 저장했다. 두 변수의 값이 같으면 <code class="language-plaintext highlighter-rouge">LUCKY</code>를 출력하고 아니라면 <code class="language-plaintext highlighter-rouge">READY</code>를 출력한다.<br /><br /></li>
</ul>

<h1 id="결과">결과</h1>
<hr />

<ul>
  <li>시간 : 72 ms</li>
  <li>메모리 : 30840 KB<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/63d9087e23d9ac0eb589b70e103611d1.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="BOJ" /><category term="Algorithm" /><category term="BOJ" /><category term="No18406" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 링크 https://www.acmicpc.net/problem/18406 제한 시간 제한 : 1 초 메모리 제한 : 256 MB]]></summary></entry><entry><title type="html">Python) 이것이 취업을 위한 코딩테스트다 12 구현문제 8. 문자열 재정렬</title><link href="http://localhost:4000/algorithmstudy/CodingTestBook-12-08-py/" rel="alternate" type="text/html" title="Python) 이것이 취업을 위한 코딩테스트다 12 구현문제 8. 문자열 재정렬" /><published>2022-04-16T00:00:00+09:00</published><updated>2022-04-16T00:00:00+09:00</updated><id>http://localhost:4000/algorithmstudy/CodingTestBook-12-08-py</id><content type="html" xml:base="http://localhost:4000/algorithmstudy/CodingTestBook-12-08-py/"><![CDATA[<h1 id="문제-출처">문제 출처</h1>
<hr />

<ul>
  <li>이것이 취업을 위한 코딩테스트다 with 파이썬</li>
  <li>Chapter 12 - 구현문제 8. 문자열 재정렬<br /><br /></li>
</ul>

<h1 id="제한">제한</h1>
<hr />

<ul>
  <li>시간 제한 : 1 초</li>
  <li>메모리 제한 : 128 MB<br /><br /></li>
</ul>

<h1 id="문제">문제</h1>
<hr />

<ul>
  <li>알파벳 대문자와 숫자(0 ~ 9)로만 구성된 문자열이 입력으로 주어진다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력한다.<br /><br /></li>
</ul>

<h1 id="입력">입력</h1>
<hr />

<ul>
  <li>첫째 줄에 하나의 문자열 S가 주어진다. (1 &lt;= S의 길이 &lt;= 10,000)<br /><br /></li>
</ul>

<h1 id="출력">출력</h1>
<hr />

<ul>
  <li>첫째 줄에 문제에서 요구하는 정답을 출력한다.<br /><br /><br /></li>
</ul>

<h1 id="-풀이">👀 풀이</h1>
<hr />

<ul>
  <li>입력받은 문자열을 순회하면서 숫자와 문자를 따로 저장한다.</li>
  <li>문자를 따로 저장한 문자열 뒤에 숫자들의 합을 더해서 출력하면 정답을 만들 수 있다.<br /><br /></li>
</ul>

<h1 id="코드">코드</h1>
<hr />

<script src="https://gist.github.com/miro7923/fe56f87d393663b2c29bc35f8973d7b1.js"></script>]]></content><author><name>Yujin Hwang</name><email>miro7923@gmail.com</email></author><category term="AlgorithmStudy" /><category term="Algorithm" /><category term="Implementation" /><category term="Python" /><summary type="html"><![CDATA[문제 출처 이것이 취업을 위한 코딩테스트다 with 파이썬 Chapter 12 - 구현문제 8. 문자열 재정렬 제한 시간 제한 : 1 초 메모리 제한 : 128 MB]]></summary></entry></feed>